import * as i0 from '@angular/core';
import { Pipe, Injectable, Component, ChangeDetectionStrategy, Input, Directive, EventEmitter, Output, forwardRef, NgModule } from '@angular/core';
import * as i5 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1 from '@angular/forms';
import { NG_VALUE_ACCESSOR, FormControl, ReactiveFormsModule, FormsModule } from '@angular/forms';
import { __rest } from 'tslib';
import { of, throwError, Subject, BehaviorSubject, combineLatest } from 'rxjs';
import { map, switchMap, takeUntil, filter, tap, distinctUntilChanged, withLatestFrom } from 'rxjs/operators';
import * as i1$1 from '@backbase/data-ang/actions';
import * as i6$1 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import * as i2$1 from '@backbase/ui-ang/collapsible';
import { CollapsibleModule } from '@backbase/ui-ang/collapsible';
import * as i3$1 from '@backbase/ui-ang/header';
import { HeaderModule } from '@backbase/ui-ang/header';
import * as i2 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import * as i3 from '@backbase/ui-ang/input-checkbox';
import { InputCheckboxModule } from '@backbase/ui-ang/input-checkbox';
import * as i6 from '@backbase/ui-ang/input-inline-edit';
import { InputInlineEditModule } from '@backbase/ui-ang/input-inline-edit';
import { ModalModule } from '@backbase/ui-ang/modal';
import * as i1$2 from '@backbase/ui-ang/switch';
import { SwitchModule } from '@backbase/ui-ang/switch';
import * as i5$1 from '@backbase/ui-ang/tooltip-directive';
import { TooltipModule } from '@backbase/ui-ang/tooltip-directive';
import * as i5$2 from '@backbase/ui-ang/amount';
import { AmountModule } from '@backbase/ui-ang/amount';
import { BbTemplate } from '@backbase/foundation-ang/core';
import * as i2$2 from '@backbase/ui-ang/dropdown-single-select';
import { DropdownSingleSelectModule } from '@backbase/ui-ang/dropdown-single-select';
import * as i1$3 from '@backbase/data-ang/engagement';

class NoFractionDigitsPipe {
    transform(val) {
        return val ? val.replace(/\..*/, '') : '';
    }
}
NoFractionDigitsPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: NoFractionDigitsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
NoFractionDigitsPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: NoFractionDigitsPipe, name: "noFractionDigits" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: NoFractionDigitsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'noFractionDigits',
                    pure: true,
                }]
        }] });

const AM_PM = ['AM', 'PM'];
const DAYS_OF_WEEK = ['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'];
function getTimeOptions(startTime, minutesStep, excludedOptions, amPmFormat) {
    const timeOptions = [];
    let index = 0;
    while (startTime < 24 * 60) {
        const hh = Math.floor(startTime / 60);
        const mm = startTime % 60;
        if (!excludedOptions.includes(startTime)) {
            timeOptions[index] = {
                label: getOptionLabel(hh, mm, amPmFormat),
                time: startTime,
            };
            index++;
        }
        startTime = startTime + minutesStep;
    }
    return timeOptions;
}
function getHoursOfDay(scheduleTime = []) {
    const list = scheduleTime.map(time => String(time / 60));
    if (!list.length) {
        for (let i = 0; i < 24; i++) {
            list.push(`${i}`);
        }
    }
    return list;
}
function hoursToMinutesArray(hours) {
    return (hours === null || hours === void 0 ? void 0 : hours.map(hour => Number(hour) * 60)) || [];
}
function getOptionLabel(hh, mm, amPmFormat) {
    const getFormattedTime = (hours = hh, suffix = '') => ('0' + hours).slice(-2) + '.' + ('0' + mm).slice(-2) + suffix;
    return amPmFormat ? getFormattedTime(hh % 12, AM_PM[Math.floor(hh / 12)]) : getFormattedTime();
}

const firstNonEmptyString = (...args) => args.find(item => !!item) || '';
const filterObjectByPropNames = (obj, keysToExclude) => {
    const resultObj = Object.assign({}, obj);
    keysToExclude.forEach((id) => delete resultObj[id]);
    return resultObj;
};
const isEqualNumberArrays = (arr1, arr2) => {
    if (arr1.length !== arr2.length) {
        return false;
    }
    const sortedArr1 = sortNumberArray(arr1);
    const sortedArr2 = sortNumberArray(arr2);
    return sortedArr1.every((v, i) => v === sortedArr2[i]);
};
const sortNumberArray = (arr, asc = true) => arr.slice(0).sort((a, b) => (asc ? a - b : b - a));

const fromHttpResponse = (body) => {
    if (body === null) {
        throw new Error('Response body not set');
    }
    return body;
};
const secondsToMilliseconds = (seconds) => seconds * 1000;
const actionRecipeFormItemToRequest = (_a) => {
    var { id, name, amount, actions, recurrence } = _a, restActionRecipe = __rest(_a, ["id", "name", "amount", "actions", "recurrence"]);
    return (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, restActionRecipe), (id && { id })), (name && { name })), { amount: (amount === null || amount === void 0 ? void 0 : amount.amount) || '0' }), (Object.keys(notificationRecurrenceFormValueToRequest(recurrence)).length && {
        recurrence: notificationRecurrenceFormValueToRequest(recurrence),
    })), { actions: notificationChannelsFormValueToRequest(actions) }));
};
const parseActionRecipeFormItem = (_a) => {
    var { id, name, amount, actions, recurrence } = _a, restActionRecipe = __rest(_a, ["id", "name", "amount", "actions", "recurrence"]);
    return (Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, restActionRecipe), (id && { id })), (name && { name })), { amount: amount.amount || '0', actions: parseNotificationChannelsFormValue(actions) }), (Object.keys(notificationRecurrenceFormValueToRequest(recurrence)).length && {
        recurrence: notificationRecurrenceFormValueToRequest(recurrence),
    })));
};
const arrangementActionRecipeToRequest = (arrangementId) => (actionRecipeFormItemValue) => (Object.assign({ arrangementId }, actionRecipeFormItemToRequest(actionRecipeFormItemValue)));
const mergeNotificationChannels = (channels, defaultChannels) => channels
    ? channels.map(channel => (Object.assign(Object.assign({}, channel), { enabled: defaultChannels.some(({ type }) => type === channel.type) })))
    : [];
const mergeSpecificationsWithActionRecipes = (specs, recipes) => specs.reduce((prev, specification) => (Object.assign(Object.assign({}, prev), { [specification.id]: {
        specification,
        actionRecipe: recipes.find(({ specificationId }) => specificationId === specification.id),
    } })), {});
const getMappedRecurrenceResponse = (responseRecurrence, { recurrence: cachedRecurrence }) => (Object.assign(Object.assign({}, responseRecurrence), { hoursOfDay: getCachedHoursOfDay(responseRecurrence, cachedRecurrence) }));
const notificationChannelsFormValueToRequest = (channels) => Object.keys(channels)
    .filter(key => channels[key])
    .map(type => ({ type }));
const notificationRecurrenceFormValueToRequest = (rec) => (Object.assign(Object.assign({}, (((rec === null || rec === void 0 ? void 0 : rec.scheduleTime.length) || 0) !== 0 && { hoursOfDay: getHoursOfDay(rec === null || rec === void 0 ? void 0 : rec.scheduleTime) })), (((rec === null || rec === void 0 ? void 0 : rec.scheduleTime.length) || 0) !== 0 && { daysOfWeek: (rec === null || rec === void 0 ? void 0 : rec.daysOfWeek) || DAYS_OF_WEEK })));
const parseNotificationChannelsFormValue = (channels) => Object.keys(channels).map(type => ({
    type,
    enabled: channels[type],
}));
const getCachedHoursOfDay = (responseRecurrence, cachedRecurrence) => {
    if (!(cachedRecurrence === null || cachedRecurrence === void 0 ? void 0 : cachedRecurrence.scheduleTime)) {
        return responseRecurrence.hoursOfDay;
    }
    if (!isEqualNumberArrays(cachedRecurrence.scheduleTime.slice(0), hoursToMinutesArray(responseRecurrence.hoursOfDay))) {
        return responseRecurrence.hoursOfDay;
    }
    return cachedRecurrence.scheduleTime.map(minutes => String(minutes / 60));
};

class ActionsFormBuilderService {
    constructor(fb) {
        this.fb = fb;
    }
    /**
     * Method to build action recipe form group.
     *
     * @param specification - acton recipe specification
     * @param actionRecipe - action recipe
     * @param account - account data
     * @returns prefilled form object
     */
    buildActionRecipeFormGroup(specification, actionRecipe, account) {
        const actionRecipeFormValue = this.buildActionRecipeFormValue(specification, actionRecipe, account);
        return this.fb.group(Object.assign(Object.assign({}, actionRecipeFormValue), { actions: this.fb.group(actionRecipeFormValue.actions), recurrence: this.buildScheduleNotificationsFormGroup(actionRecipe) }));
    }
    /**
     * Method to build action recipe form value.
     *
     * @param specification - acton recipe specification
     * @param actionRecipe - action recipe
     * @param account - account data
     * @returns action recipe form value object
     */
    buildActionRecipeFormValue(specification, actionRecipe, account) {
        var _a, _b;
        const { actions, amount, active, recurrence, id, specificationId, name } = actionRecipe || this.getDefaultActionRecipe(specification);
        return Object.assign({ id, 
            // tslint:disable-next-line:no-null-keyword
            name: name || null, specificationId,
            active, recurrence: this.buildRecurrenceFormItem(recurrence), amount: {
                amount,
                currency: account ? account.currency : {},
            }, actions: this.buildChannelsFormValue(actions) }, (((_a = specification.recipeDefaults) === null || _a === void 0 ? void 0 : _a.additions) && { additions: Object.assign({}, (_b = specification.recipeDefaults) === null || _b === void 0 ? void 0 : _b.additions) }));
    }
    /**
     * Method to build schedule notificatons form group.
     *
     * @param actionRecipe - action recipe
     * @returns prefilled form object
     */
    buildScheduleNotificationsFormGroup(actionRecipe) {
        return this.fb.group({
            scheduleTime: this.getTimeOptions(actionRecipe),
        });
    }
    getDefaultActionRecipe(specification) {
        return {
            // tslint:disable-next-line:no-null-keyword
            id: null,
            // tslint:disable-next-line:no-null-keyword
            name: specification.name || null,
            specificationId: specification.id,
            amount: (specification.recipeDefaults && specification.recipeDefaults.amount) || '0',
            active: false,
            actions: mergeNotificationChannels(specification.actions, (specification.recipeDefaults && specification.recipeDefaults.actions) || []),
        };
    }
    buildChannelsFormValue(channels) {
        return channels.reduce((previous, current) => (Object.assign(Object.assign({}, previous), { [current.type]: current.enabled })), {});
    }
    buildRecurrenceFormItem(recurrence) {
        return Object.assign({ scheduleTime: hoursToMinutesArray(recurrence === null || recurrence === void 0 ? void 0 : recurrence.hoursOfDay) }, ((recurrence === null || recurrence === void 0 ? void 0 : recurrence.daysOfWeek) && { daysOfWeek: recurrence === null || recurrence === void 0 ? void 0 : recurrence.daysOfWeek }));
    }
    getTimeOptions(recipe) {
        var _a, _b;
        const mappedHours = ((_b = (_a = recipe === null || recipe === void 0 ? void 0 : recipe.recurrence) === null || _a === void 0 ? void 0 : _a.hoursOfDay) === null || _b === void 0 ? void 0 : _b.map(option => this.fb.control(Number(option) * 60))) || [];
        return this.fb.array((mappedHours === null || mappedHours === void 0 ? void 0 : mappedHours.length) !== 24 ? mappedHours : []);
    }
}
ActionsFormBuilderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsFormBuilderService, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Injectable });
ActionsFormBuilderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsFormBuilderService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsFormBuilderService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.FormBuilder }]; } });

const EMPTY_RESPONSE_ERROR = new Error('Response data is empty');

const ACTION_RECIPES_LIMIT = 999999;
class ActionsNotificationsSettingsDataService {
    constructor(dataHttpService, actionSpecificationsService) {
        this.dataHttpService = dataHttpService;
        this.actionSpecificationsService = actionSpecificationsService;
    }
    /**
     * Method to get action recipes.
     *
     * @param params - params object
     * @returns action recipe array
     */
    getActionRecipes(params = {}) {
        const requestParams = Object.assign({ limit: ACTION_RECIPES_LIMIT }, params);
        return this.dataHttpService.getActionRecipes(requestParams).pipe(map(fromHttpResponse), map(response => response.actionRecipes));
    }
    /**
     * Method to get action recipe specifications.
     *
     * @returns action recipe specifications
     */
    getSpecifications() {
        return this.actionSpecificationsService.getActionRecipeSpecifications({}).pipe(map(fromHttpResponse), map(response => response.actionRecipeSpecifications || []));
    }
    /**
     * Method to save action recipe.
     *
     * @param action - recipe form value
     * @param arrangementId - arrangement ID
     * @returns batch processing response
     */
    saveActionRecipe(actionRecipeFormItem, arrangementId) {
        const recipeToRequest = arrangementId
            ? arrangementActionRecipeToRequest(arrangementId)
            : actionRecipeFormItemToRequest;
        const batchProcessingPutRequestBody = { actionRecipes: [recipeToRequest(actionRecipeFormItem)] };
        return this.dataHttpService
            .putBatchProcessing({ batchProcessingPutRequestBody })
            .pipe(switchMap(body => (body ? of(body) : throwError(EMPTY_RESPONSE_ERROR))));
    }
}
ActionsNotificationsSettingsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationsSettingsDataService, deps: [{ token: i1$1.ActionRecipesHttpService }, { token: i1$1.ActionRecipeSpecificationsHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
ActionsNotificationsSettingsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationsSettingsDataService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationsSettingsDataService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.ActionRecipesHttpService }, { type: i1$1.ActionRecipeSpecificationsHttpService }]; } });

class ActionsNotificationChannelsComponent {
    constructor(controlContainer) {
        this.controlContainer = controlContainer;
        /**
         * Action notification channels IDs.
         */
        this.id = `bb-actions-notification-channels-${ActionsNotificationChannelsComponent.idCounter++}`;
        /**
         * Actions map.
         */
        this.actionsMap = new Map();
    }
    /**
     * Actions map setter.
     */
    set actions(value) {
        this.actionsMap = new Map(value.map(action => [action.type, action]));
    }
    ngAfterContentInit() {
        this.formGroup = this.controlContainer.control;
    }
}
ActionsNotificationChannelsComponent.idCounter = 0;
ActionsNotificationChannelsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationChannelsComponent, deps: [{ token: i1.ControlContainer }], target: i0.ɵɵFactoryTarget.Component });
ActionsNotificationChannelsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: ActionsNotificationChannelsComponent, selector: "bb-actions-notification-channels", inputs: { actions: "actions" }, ngImport: i0, template: "<ng-container\n  bbActionsNotificationChannelsCustomizableDirective\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    actionsMap: actionsMap\n  }\"\n></ng-container>\n\n<ng-template bbActionsNotificationChannelsCustomizableDirective let-hostRef let-actionsMap=\"context.actionsMap\">\n  <label class=\"bb-label bb-stack\" *ngIf=\"actionsMap.has('sms') || actionsMap.has('email')\">\n    <span\n      class=\"bb-stack__item bb-stack__item--spacing-sm\"\n      i18n=\"Title for notification channels@@actions-common.notification-channels.title\"\n      data-role=\"channel-title\"\n      >Additional channels</span\n    >\n    <bb-icon-ui\n      class=\"bb-stack__item\"\n      tabindex=\"0\"\n      name=\"info\"\n      size=\"sm\"\n      data-role=\"channel-title-icon\"\n      triggers=\"hover focus\"\n      aria-label=\"Other channels that you would like to receive notifications through, additionally to the ones in-app\"\n      i18n-aria-label=\"\n        Channels that you would like to receive notifications through@@actions-common.notification-channels.others\"\n      bbTooltip=\"Other channels that you would like to receive notifications through, additionally to the ones in-app\"\n      i18n-bbTooltip=\"@@actions-common.notification-channels.others\"\n    ></bb-icon-ui>\n  </label>\n  <div [formGroup]=\"hostRef.formGroup\">\n    <div *ngIf=\"actionsMap.has('sms')\" class=\"bb-block bb-block--sm\">\n      <bb-input-checkbox-ui\n        label=\"SMS\"\n        i18n-label=\"Label for sms channel checkbox@@actions-common.notification-channels.sms.label\"\n        formControlName=\"sms\"\n        data-role=\"sms-checkbox\"\n      ></bb-input-checkbox-ui>\n    </div>\n\n    <div *ngIf=\"actionsMap.has('email')\" class=\"bb-block bb-block--sm\">\n      <bb-input-checkbox-ui\n        label=\"Email\"\n        i18n-label=\"Label for email channel checkbox@@actions-common.notification-channels.email.label\"\n        formControlName=\"email\"\n        data-role=\"email-checkbox\"\n      ></bb-input-checkbox-ui>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return i3.InputCheckboxComponent; }), selector: "bb-input-checkbox-ui", inputs: ["indeterminate"], outputs: ["indeterminateChange"] }], directives: [{ type: i0.forwardRef(function () { return ActionsNotificationChannelsCustomizableDirective; }), selector: "[bbActionsNotificationChannelsCustomizableDirective]" }, { type: i0.forwardRef(function () { return i5.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i5$1.TooltipDirective; }), selector: "[bbTooltip]", inputs: ["bbTooltip", "triggers"] }, { type: i0.forwardRef(function () { return i1.NgControlStatusGroup; }), selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i0.forwardRef(function () { return i1.FormGroupDirective; }), selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i0.forwardRef(function () { return i1.NgControlStatus; }), selector: "[formControlName],[ngModel],[formControl]" }, { type: i0.forwardRef(function () { return i1.FormControlName; }), selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationChannelsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-actions-notification-channels',
                    templateUrl: './actions-notification-channels.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.ControlContainer }]; }, propDecorators: { actions: [{
                type: Input
            }] } });
class ActionsNotificationChannelsCustomizableDirective extends BbTemplate {
}
ActionsNotificationChannelsCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationChannelsCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ActionsNotificationChannelsCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: ActionsNotificationChannelsCustomizableDirective, selector: "[bbActionsNotificationChannelsCustomizableDirective]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationChannelsCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbActionsNotificationChannelsCustomizableDirective]',
                }]
        }] });

// tslint:disable-next-line:directive-class-suffix
class ArrangementBasedRecipeModel {
    constructor(actionsFormBuilderService) {
        this.actionsFormBuilderService = actionsFormBuilderService;
        /**
         * On submit event emitter.
         */
        this.submit = new EventEmitter();
        /**
         * Specifications with actions.
         */
        this.specificationActions = [];
        /**
         * Loading flag.
         */
        this.isLoading = false;
        this.destroy$ = new Subject();
    }
    /**
     * Specification setter.
     */
    set specification(specification) {
        this.specificationValue = specification;
        this.specificationActions = specification.actions || [];
    }
    /**
     * Specification getter.
     */
    get specification() {
        return this.specificationValue;
    }
    /**
     * Method to check if card form control is expanded.
     *
     * @returns boolean value
     */
    get isCardExpanded() {
        const activeControl = this.formGroup && this.formGroup.get('active');
        return activeControl && activeControl.value && !this.isLoading;
    }
    ngOnInit() {
        this.formGroup = this.actionsFormBuilderService.buildActionRecipeFormGroup(this.specification, this.actionRecipe, this.account);
        this.formGroup.valueChanges.pipe(takeUntil(this.destroy$)).subscribe(value => {
            this.onSubmit(value);
        });
    }
    ngOnChanges(changes) {
        const { actionRecipe } = changes;
        if (this.formGroup && actionRecipe && actionRecipe.previousValue !== actionRecipe.currentValue) {
            this.formGroup.patchValue(this.actionsFormBuilderService.buildActionRecipeFormValue(this.specification, this.actionRecipe, this.account), {
                emitEvent: false,
            });
            this.isLoading = false;
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * Method to submit action recipe form.
     *
     * @param formValue - action recipe form value
     */
    onSubmit(formValue) {
        this.submit.emit(formValue);
    }
    /**
     * Method to set loading flag to true.
     */
    onActiveLoadingChange() {
        this.isLoading = true;
    }
}
ArrangementBasedRecipeModel.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ArrangementBasedRecipeModel, deps: [{ token: ActionsFormBuilderService }], target: i0.ɵɵFactoryTarget.Directive });
ArrangementBasedRecipeModel.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: ArrangementBasedRecipeModel, inputs: { account: "account", actionRecipe: "actionRecipe", specification: "specification" }, outputs: { submit: "submit" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ArrangementBasedRecipeModel, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: ActionsFormBuilderService }]; }, propDecorators: { account: [{
                type: Input
            }], actionRecipe: [{
                type: Input
            }], specification: [{
                type: Input
            }], submit: [{
                type: Output
            }] } });

class SwitchWithLoadingComponent {
    constructor() {
        /**
         * Loading indicator presentation marker.
         */
        this.isLoading = false;
        /**
         * ControlValueAccessor on change handler.
         */
        this.onChange = () => { };
        /**
         * ControlValueAccessor on touch handler.
         */
        this.onTouch = () => { };
    }
    /**
     * ControlValueAccessor value setter.
     */
    set value(val) {
        this._value = val;
        this.onChange(val);
        this.onTouch(val);
    }
    /**
     * ControlValueAccessor value getter.
     */
    get value() {
        return this._value;
    }
    /**
     * Method from ControlValueAccessor to write a new value to the element.
     *
     * @param value - new value
     */
    writeValue(value) {
        this._value = value;
    }
    /**
     * Method from ControlValueAccessor to register on change handler.
     *
     * @param fn - on change handler function
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Method from ControlValueAccessor to register on touched handler.
     *
     * @param fn - on touched handler function
     */
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
}
SwitchWithLoadingComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: SwitchWithLoadingComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SwitchWithLoadingComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: SwitchWithLoadingComponent, selector: "bb-switch-with-loading", inputs: { isLoading: "isLoading", ariaLabel: ["aria-label", "ariaLabel"] }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => SwitchWithLoadingComponent),
            multi: true,
        },
    ], ngImport: i0, template: "<bb-switch-ui\n  [aria-label]=\"ariaLabel\"\n  [(ngModel)]=\"value\"\n  (blur)=\"onTouch()\"\n  *ngIf=\"!isLoading; else loadingIndicator\"\n></bb-switch-ui>\n<ng-template #loadingIndicator>\n  <div class=\"bb-loading-indicator bb-loading-indicator--sm\" data-role=\"loading-indicator\">\n    <svg aria-label=\"Loading indicator\" class=\"bb-loading-indicator__circle\" preserveAspectRatio=\"xMinYMin meet\">\n      <circle class=\"bb-loading-indicator__path\" cx=\"50%\" cy=\"50%\" fill=\"none\" r=\"40%\" stroke=\"currentColor\"></circle>\n    </svg>\n  </div>\n</ng-template>\n", components: [{ type: i1$2.SwitchComponent, selector: "bb-switch-ui", inputs: ["labelPosition"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: SwitchWithLoadingComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-switch-with-loading',
                    templateUrl: './switch-with-loading.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => SwitchWithLoadingComponent),
                            multi: true,
                        },
                    ],
                }]
        }], propDecorators: { isLoading: [{
                type: Input
            }], ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }] } });

class ActionsAccountBalanceRecipeFormComponent extends ArrangementBasedRecipeModel {
    constructor(actionsFormBuilderService) {
        super(actionsFormBuilderService);
        /**
         * Account balance action recipe ID.
         */
        this.id = `bb-actions-account-balance-recipe-form-${ActionsAccountBalanceRecipeFormComponent.idCounter++}`;
    }
    /**
     * Method to patch the form with the amount and currency.
     *
     * @param amount - amount input value
     */
    onInlineEditAccept(amount) {
        if (this.formGroup) {
            const amountControl = this.formGroup.get('amount');
            if (amountControl) {
                amountControl.patchValue({
                    amount: amount || '0',
                    currency: amountControl.value.currency,
                });
            }
        }
    }
}
ActionsAccountBalanceRecipeFormComponent.idCounter = 0;
ActionsAccountBalanceRecipeFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsAccountBalanceRecipeFormComponent, deps: [{ token: ActionsFormBuilderService }], target: i0.ɵɵFactoryTarget.Component });
ActionsAccountBalanceRecipeFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: ActionsAccountBalanceRecipeFormComponent, selector: "bb-actions-account-balance-recipe-form", usesInheritance: true, ngImport: i0, template: "<ng-container\n  bbActionsAccountBalanceRecipeCustomizableDirective\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    formGroup: formGroup,\n    isLoading: isLoading\n  }\"\n></ng-container>\n\n<ng-template\n  bbActionsAccountBalanceRecipeCustomizableDirective\n  let-hostRef\n  let-formGroup=\"context.formGroup\"\n  let-isLoading=\"context.isLoading\"\n>\n  <form [formGroup]=\"formGroup\">\n    <bb-collapsible-ui class=\"card\" [isOpen]=\"hostRef.isCardExpanded\">\n      <ng-template bbCollapsibleHeader>\n        <div [ngClass]=\"hostRef.isCardExpanded ? 'card-header' : 'card-body'\">\n          <div class=\"bb-stack\">\n            <bb-header-ui\n              class=\"bb-stack__item\"\n              headingType=\"h5\"\n              heading=\"Balance\"\n              i18n-heading=\"Account balance recipe heading@@actions-common.account-balance-recipe.heading\"\n              data-role=\"balance-header\"\n            ></bb-header-ui>\n            <bb-switch-with-loading\n              [isLoading]=\"isLoading\"\n              (change)=\"hostRef.onActiveLoadingChange()\"\n              formControlName=\"active\"\n              class=\"bb-stack__item bb-stack__item--push-right\"\n              aria-label=\"Enable and expand account balance notifications\"\n              i18n-aria-label=\"\n                Account balance switcher aria label@@actions-common.account-balance-recipe.switcher.aria-label\"\n              data-role=\"balance-switcher\"\n            ></bb-switch-with-loading>\n          </div>\n          <div\n            class=\"bb-text-support\"\n            i18n=\"Account balance subheading@@actions-common.account-balance-recipe.subheading\"\n            data-role=\"balance-sub-header\"\n          >\n            Receive notifications when your balance is lower than a selected amount\n          </div>\n        </div>\n      </ng-template>\n      <ng-template bbCollapsibleBody>\n        <div class=\"card-body\">\n          <label\n            id=\"currency-input-label\"\n            class=\"bb-label\"\n            i18n=\"Lower than input label@@actions-common.account-balance-recipe.lower-than-input\"\n            >Lower than\n          </label>\n          <div class=\"row\">\n            <div class=\"col-sm-6 col-12 bb-block bb-block--md\">\n              <ng-template #amountTemplate>\n                <bb-amount-ui\n                  class=\"bb-highlight\"\n                  [amount]=\"formGroup.get('amount').value.amount\"\n                  [currency]=\"account?.currency\"\n                ></bb-amount-ui>\n              </ng-template>\n              <bb-input-inline-edit-ui\n                pattern=\"-?\\d{1,18}\"\n                (accept)=\"hostRef.onInlineEditAccept($event)\"\n                [inputText]=\"formGroup.get('amount').value.amount | noFractionDigits\"\n                [inputInlineTemplate]=\"amountTemplate\"\n                data-role=\"balance-input\"\n                i18n-ariaLabelEdit=\"\n                  Edit amount without\n                  fractions@@actions-common.account-balance-recipe.edit-amount-without-fractions-button\"\n                ariaLabelEdit=\"Edit amount without fractions\"\n              ></bb-input-inline-edit-ui>\n            </div>\n          </div>\n          <bb-actions-notification-channels\n            formGroupName=\"actions\"\n            [actions]=\"hostRef.specificationActions\"\n          ></bb-actions-notification-channels>\n        </div>\n      </ng-template>\n    </bb-collapsible-ui>\n  </form>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.CollapsibleComponent; }), selector: "bb-collapsible-ui", inputs: ["recreateBodyContent", "hasChevron", "isOpen"], outputs: ["isOpenChange"] }, { type: i0.forwardRef(function () { return i3$1.HeaderComponent; }), selector: "bb-header-ui", inputs: ["headingClasses", "headingType", "heading"] }, { type: i0.forwardRef(function () { return SwitchWithLoadingComponent; }), selector: "bb-switch-with-loading", inputs: ["isLoading", "aria-label"] }, { type: i0.forwardRef(function () { return i5$2.AmountComponent; }), selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }, { type: i0.forwardRef(function () { return i6.InputInlineEditComponent; }), selector: "bb-input-inline-edit-ui", inputs: ["state", "canEdit", "hasLoadingState", "inputInlineTemplate", "inputText", "maxLength", "minLength", "maxValue", "minValue", "autofocus", "ariaLabelAccept", "ariaLabelCancel", "ariaLabelEdit", "tooltipAccept", "tooltipCancel", "tooltipEdit", "autocomplete", "pattern", "hint"], outputs: ["stateChange", "cancel", "accept"] }, { type: i0.forwardRef(function () { return ActionsNotificationChannelsComponent; }), selector: "bb-actions-notification-channels", inputs: ["actions"] }], directives: [{ type: i0.forwardRef(function () { return ActionsAccountBalanceRecipeCustomizableDirective; }), selector: "[bbActionsAccountBalanceRecipeCustomizableDirective]" }, { type: i0.forwardRef(function () { return i1.ɵNgNoValidate; }), selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i0.forwardRef(function () { return i1.NgControlStatusGroup; }), selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i0.forwardRef(function () { return i1.FormGroupDirective; }), selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i0.forwardRef(function () { return i2$1.CollapsibleHeaderDirective; }), selector: "ng-template[bbCollapsibleHeader]" }, { type: i0.forwardRef(function () { return i5.NgClass; }), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i0.forwardRef(function () { return i1.NgControlStatus; }), selector: "[formControlName],[ngModel],[formControl]" }, { type: i0.forwardRef(function () { return i1.FormControlName; }), selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i0.forwardRef(function () { return i2$1.CollapsibleBodyDirective; }), selector: "ng-template[bbCollapsibleBody]" }, { type: i0.forwardRef(function () { return i1.FormGroupName; }), selector: "[formGroupName]", inputs: ["formGroupName"] }], pipes: { "noFractionDigits": i0.forwardRef(function () { return NoFractionDigitsPipe; }) }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsAccountBalanceRecipeFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-actions-account-balance-recipe-form',
                    templateUrl: './actions-account-balance-recipe-form.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ActionsFormBuilderService }]; } });
class ActionsAccountBalanceRecipeCustomizableDirective extends BbTemplate {
}
ActionsAccountBalanceRecipeCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsAccountBalanceRecipeCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ActionsAccountBalanceRecipeCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: ActionsAccountBalanceRecipeCustomizableDirective, selector: "[bbActionsAccountBalanceRecipeCustomizableDirective]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsAccountBalanceRecipeCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbActionsAccountBalanceRecipeCustomizableDirective]',
                }]
        }] });

class ActionsTransactionsRecipeFormComponent extends ArrangementBasedRecipeModel {
    constructor(actionsFormBuilderService) {
        super(actionsFormBuilderService);
    }
}
ActionsTransactionsRecipeFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsTransactionsRecipeFormComponent, deps: [{ token: ActionsFormBuilderService }], target: i0.ɵɵFactoryTarget.Component });
ActionsTransactionsRecipeFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: ActionsTransactionsRecipeFormComponent, selector: "bb-actions-transactions-recipe-form", usesInheritance: true, ngImport: i0, template: "<ng-container\n  bbActionsTransactionsRecipeCustomizableDirective\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    formGroup: formGroup,\n    isLoading: isLoading\n  }\"\n></ng-container>\n\n<ng-template\n  bbActionsTransactionsRecipeCustomizableDirective\n  let-hostRef\n  let-formGroup=\"context.formGroup\"\n  let-isLoading=\"context.isLoading\"\n>\n  <form [formGroup]=\"formGroup\">\n    <bb-collapsible-ui class=\"card\" [isOpen]=\"hostRef.isCardExpanded\">\n      <ng-template bbCollapsibleHeader>\n        <div [ngClass]=\"hostRef.isCardExpanded ? 'card-header' : 'card-body'\" data-role=\"collapsible-header\">\n          <div class=\"bb-stack\">\n            <bb-header-ui\n              class=\"bb-stack__item\"\n              headingType=\"h5\"\n              heading=\"Debits and credits\"\n              i18n-heading=\"Debits and credits recipe heading@@actions-common.transactions-recipe.heading\"\n              data-role=\"transactions-recipe-header\"\n            ></bb-header-ui>\n            <bb-switch-with-loading\n              [isLoading]=\"isLoading\"\n              (change)=\"hostRef.onActiveLoadingChange()\"\n              formControlName=\"active\"\n              class=\"bb-stack__item bb-stack__item--push-right\"\n              aria-label=\"Enable and expand debits and credits notifications\"\n              i18n-aria-label=\"\n                Debits and credits switcher aria label@@actions-common.transactions-recipe.switcher.aria-label\"\n              data-role=\"transactions-recipe-switcher\"\n            ></bb-switch-with-loading>\n          </div>\n          <div\n            class=\"bb-text-support\"\n            i18n=\"Debits and credits subheading@@actions-common.transactions-recipe.subheading\"\n            data-role=\"transactions-recipe-sub-header\"\n          >\n            Receive notification when an amount is debited or credited from your account\n          </div>\n        </div>\n      </ng-template>\n      <ng-template bbCollapsibleBody>\n        <div class=\"card-body\">\n          <bb-actions-notification-channels\n            formGroupName=\"actions\"\n            [actions]=\"hostRef.specificationActions\"\n          ></bb-actions-notification-channels>\n        </div>\n      </ng-template>\n    </bb-collapsible-ui>\n  </form>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.CollapsibleComponent; }), selector: "bb-collapsible-ui", inputs: ["recreateBodyContent", "hasChevron", "isOpen"], outputs: ["isOpenChange"] }, { type: i0.forwardRef(function () { return i3$1.HeaderComponent; }), selector: "bb-header-ui", inputs: ["headingClasses", "headingType", "heading"] }, { type: i0.forwardRef(function () { return SwitchWithLoadingComponent; }), selector: "bb-switch-with-loading", inputs: ["isLoading", "aria-label"] }, { type: i0.forwardRef(function () { return ActionsNotificationChannelsComponent; }), selector: "bb-actions-notification-channels", inputs: ["actions"] }], directives: [{ type: i0.forwardRef(function () { return ActionsTransactionsRecipeCustomizableDirective; }), selector: "[bbActionsTransactionsRecipeCustomizableDirective]" }, { type: i0.forwardRef(function () { return i1.ɵNgNoValidate; }), selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i0.forwardRef(function () { return i1.NgControlStatusGroup; }), selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i0.forwardRef(function () { return i1.FormGroupDirective; }), selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i0.forwardRef(function () { return i2$1.CollapsibleHeaderDirective; }), selector: "ng-template[bbCollapsibleHeader]" }, { type: i0.forwardRef(function () { return i5.NgClass; }), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i0.forwardRef(function () { return i1.NgControlStatus; }), selector: "[formControlName],[ngModel],[formControl]" }, { type: i0.forwardRef(function () { return i1.FormControlName; }), selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i0.forwardRef(function () { return i2$1.CollapsibleBodyDirective; }), selector: "ng-template[bbCollapsibleBody]" }, { type: i0.forwardRef(function () { return i1.FormGroupName; }), selector: "[formGroupName]", inputs: ["formGroupName"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsTransactionsRecipeFormComponent, decorators: [{
            type: Component,
            args: [{
                    //TODO: remove first selector in 3.8.0
                    selector: 'bb-actions-transactions-recipe-form',
                    templateUrl: './actions-transactions-recipe-form.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ActionsFormBuilderService }]; } });
class ActionsTransactionsRecipeCustomizableDirective extends BbTemplate {
}
ActionsTransactionsRecipeCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsTransactionsRecipeCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ActionsTransactionsRecipeCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: ActionsTransactionsRecipeCustomizableDirective, selector: "[bbActionsTransactionsRecipeCustomizableDirective]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsTransactionsRecipeCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbActionsTransactionsRecipeCustomizableDirective]',
                }]
        }] });

const MinutesInDay = 1440;
var ScheduleType;
(function (ScheduleType) {
    ScheduleType["RightAway"] = "RightAway";
    ScheduleType["Custom"] = "Custom";
})(ScheduleType || (ScheduleType = {}));
const ScheduleDescriptionText = {
    // TODO: use in component template once localize pipe will be available
    RightAway: 'Notifications will be sent immediately.',
    Custom: 'Notifications will be grouped and sent at specified time.',
};
const DefaultTime = 480;
const MaxOptionsQuantity = 4;

class TimePickerComponent {
    constructor() {
        this.timeOptions = [];
        this.excludedOptions$$ = new BehaviorSubject([]);
        this.componentDestroyed$ = new Subject();
        /**
         * Start time
         */
        this.startTime = 0;
        /**
         * Step on minutes for time options
         */
        this.minutesStep = 60;
        /**
         * Time form control
         */
        this.timeControl = new FormControl();
        /**
         * Change event handler
         */
        this.onChange = (_time) => { }; // NOSONAR
        /**
         * Touched event handler
         */
        this.onTouched = () => { }; // NOSONAR
    }
    /**
     * Options to exclude
     */
    set excludedOptions(options) {
        this.excludedOptions$$.next(options || []);
    }
    ngOnInit() {
        this.onExcludedOptionsChange();
        this.onFormValueChange();
    }
    onExcludedOptionsChange() {
        this.excludedOptions$$.pipe(takeUntil(this.componentDestroyed$)).subscribe(options => {
            var _a, _b;
            const timeControlValue = ((_a = this.timeControl.value) === null || _a === void 0 ? void 0 : _a.time) || ((_b = this.controlRef) === null || _b === void 0 ? void 0 : _b.value);
            const excludedOptions = timeControlValue || timeControlValue === 0 ? options.filter(option => option !== timeControlValue) : [];
            this.timeOptions = getTimeOptions(this.startTime, this.minutesStep, excludedOptions, this.amPmFormat);
            const selection = this.timeOptions.find(option => option.time === timeControlValue);
            this.timeControl.setValue(selection);
        });
    }
    onFormValueChange() {
        this.timeControl.valueChanges.pipe(takeUntil(this.componentDestroyed$)).subscribe(value => {
            if (value) {
                this.onChange(value.time);
            }
        });
    }
    /**
     * Method to register change event handler
     *
     * @param fn
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Method to register touched event handler
     *
     * @param fn
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Method to write initial value to the input
     *
     * @param time
     */
    writeValue(time) {
        this.timeControl.setValue(this.timeOptions.find(ts => ts.time === time));
    }
    markAsTouched(event) {
        const target = event.target;
        target.blur();
        this.onTouched();
    }
    ngOnDestroy() {
        this.componentDestroyed$.next(true);
    }
}
TimePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: TimePickerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TimePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: TimePickerComponent, selector: "bb-time-picker", inputs: { startTime: "startTime", minutesStep: "minutesStep", amPmFormat: "amPmFormat", excludedOptions: "excludedOptions", controlRef: "controlRef", label: "label" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => TimePickerComponent),
            multi: true,
        },
    ], ngImport: i0, template: "<bb-dropdown-single-select-ui\n  iconName=\"caret-down\"\n  [options]=\"timeOptions\"\n  [label]=\"label\"\n  (change)=\"markAsTouched($event)\"\n  [formControl]=\"timeControl\"\n  displayAttributePath=\"label\"\n  data-role=\"time-picker-dropdown\"\n>\n</bb-dropdown-single-select-ui>\n", components: [{ type: i2$2.DropdownSingleSelectComponent, selector: "bb-dropdown-single-select-ui", inputs: ["placeholder", "defaultOptionAsPlaceholder", "options", "displayAttributePath", "iconName", "compareWithFn"] }], directives: [{ type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i1.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: TimePickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-time-picker',
                    templateUrl: './time-picker.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => TimePickerComponent),
                            multi: true,
                        },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { startTime: [{
                type: Input
            }], minutesStep: [{
                type: Input
            }], amPmFormat: [{
                type: Input
            }], excludedOptions: [{
                type: Input
            }], controlRef: [{
                type: Input
            }], label: [{
                type: Input
            }] } });

class ActionsScheduleNotificationsComponent {
    constructor(fb) {
        this.fb = fb;
        /**
         * Schedule type enum
         */
        this.ScheduleType = ScheduleType;
        /**
         * Maximum options quantity
         */
        this.MaxOptionsQuantity = MaxOptionsQuantity;
        /**
         * Stream of selected options
         */
        this.selectedTimeOptions$ = of([]);
        this.selectedTimeOptions = [];
        this.destroy$ = new Subject();
        /**
         * Minutes step in time options list.
         */
        this.minutesStep = 60;
        /**
         * Schedule form submit output.
         */
        this.submit = new EventEmitter();
    }
    ngOnInit() {
        this.scheduleType = this.getScheduleType(this.actionRecipe);
        this.onScheduleFormChange();
    }
    onScheduleTypeChange(event) {
        const target = event.target;
        if (this.scheduleType === this.ScheduleType.RightAway) {
            this.resetScheduleForm();
        }
        else if (this.scheduleType === this.ScheduleType.Custom) {
            this.addTimeOption();
        }
        target.blur();
    }
    addTimeOption() {
        this.scheduleTime.push(this.fb.control(this.defaultTime));
        this.submitScheduleForm();
    }
    deleteTimeOption(index) {
        this.scheduleTime.removeAt(index);
        this.submitScheduleForm();
    }
    timeControlChange() {
        this.submitScheduleForm();
    }
    onScheduleFormChange() {
        this.selectedTimeOptions$ = this.scheduleForm.controls.scheduleTime.valueChanges.pipe(filter(val => val), tap(val => (this.selectedTimeOptions = val)), distinctUntilChanged(), takeUntil(this.destroy$));
    }
    submitScheduleForm() {
        this.submit.emit(this.scheduleForm);
    }
    getScheduleType(recipe) {
        var _a, _b;
        const hoursOfDayQuantity = ((_b = (_a = recipe.recurrence) === null || _a === void 0 ? void 0 : _a.hoursOfDay) === null || _b === void 0 ? void 0 : _b.length) || 0;
        const hoursScheduleApplied = hoursOfDayQuantity !== 0 && hoursOfDayQuantity !== 24;
        if (!hoursScheduleApplied) {
            return ScheduleType.RightAway;
        }
        return ScheduleType.Custom;
    }
    resetScheduleForm() {
        this.scheduleTime.clear();
        this.submitScheduleForm();
    }
    /**
     * Getter for repeat count control
     */
    get scheduleTime() {
        return this.scheduleForm.get('scheduleTime');
    }
    /**
     * Getter for default time which returns 08:00 for the first option and +1 hour for subsequent
     */
    get defaultTime() {
        const lastSelectedTimeOption = this.lastSelectedTimeOption;
        let defaultTime = lastSelectedTimeOption + this.minutesStep;
        if (!lastSelectedTimeOption && lastSelectedTimeOption !== 0) {
            return DefaultTime;
        }
        if (defaultTime === MinutesInDay) {
            defaultTime = 0;
        }
        while (this.selectedTimeOptions.includes(defaultTime)) {
            if (defaultTime === MinutesInDay) {
                defaultTime = 0;
            }
            else {
                defaultTime = defaultTime + 60;
            }
        }
        return defaultTime;
    }
    /**
     * Getter for last added time option
     */
    get lastSelectedTimeOption() {
        var _a;
        return (_a = this.scheduleTime.controls[this.scheduleTime.controls.length - 1]) === null || _a === void 0 ? void 0 : _a.value;
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
ActionsScheduleNotificationsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsScheduleNotificationsComponent, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });
ActionsScheduleNotificationsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: ActionsScheduleNotificationsComponent, selector: "bb-actions-schedule-notifications", inputs: { actionRecipe: "actionRecipe", scheduleForm: "scheduleForm", minutesStep: "minutesStep" }, outputs: { submit: "submit" }, ngImport: i0, template: "<ng-container bbActionsScheduleNotificationsComponentCustomizableDirective [bbHostRef]=\"this\"> </ng-container>\n<ng-template bbActionsScheduleNotificationsComponentCustomizableDirective let-hostRef>\n  <div class=\"row bb-block bb-block--md bb-stack bb-stack--align-baseline\">\n    <div class=\"col-3\">\n      <span i18n=\"Notify me label@@actions-common.actions-schedule-notifications.title\"> Notify me </span>\n    </div>\n    <div class=\"col-3\">\n      <bb-dropdown-single-select-ui\n        iconName=\"caret-down\"\n        [required]=\"true\"\n        [(ngModel)]=\"hostRef.scheduleType\"\n        (change)=\"hostRef.onScheduleTypeChange($event)\"\n        aria-label=\"Schedule type\"\n        i18n-aria-label=\"\n          Schedule type dropdown@@actions-common.actions-schedule-notifications.schedule-type-dropdown.aria-label\"\n        data-role=\"notifications-schedule-type\"\n      >\n        <bb-dropdown-single-select-option-ui\n          i18n-label=\"\n            Schedule type dropdown right away\n            option@@actions-common.actions-schedule-notifications.schedule-type-right-away-option.label\"\n          label=\"Right away\"\n          [value]=\"hostRef.ScheduleType.RightAway\"\n        ></bb-dropdown-single-select-option-ui>\n        <bb-dropdown-single-select-option-ui\n          i18n-label=\"\n            Schedule type dropdown custom\n            option@@actions-common.actions-schedule-notifications.schedule-type-custom-option.label\"\n          label=\"Custom\"\n          [value]=\"hostRef.ScheduleType.Custom\"\n        ></bb-dropdown-single-select-option-ui>\n      </bb-dropdown-single-select-ui>\n    </div>\n    <div\n      class=\"col-6 row bb-stack bb-stack--align-baseline no-gutters\"\n      *ngIf=\"hostRef.scheduleType === hostRef.ScheduleType.Custom\"\n    >\n      <span\n        class=\"col-1\"\n        i18n=\"Schedule time picker title @@actions-common.actions-schedule-notifications.schedule-time-picker.title\"\n        >At</span\n      >\n      <form class=\"col-11\" [formGroup]=\"hostRef.scheduleForm\">\n        <div\n          class=\"row no-gutters bb-block bb-block--md\"\n          formArrayName=\"scheduleTime\"\n          *ngFor=\"let ref of hostRef.scheduleTime.controls; let i = index; let last = last\"\n        >\n          <bb-time-picker\n            class=\"col-6 actions-schedule-time-picker__dropdown\"\n            [formControlName]=\"i\"\n            [excludedOptions]=\"hostRef.selectedTimeOptions$ | async\"\n            [controlRef]=\"ref\"\n            [minutesStep]=\"hostRef.minutesStep\"\n            (change)=\"hostRef.timeControlChange()\"\n            data-role=\"schedule-time-picker\"\n            i18n-aria-label=\"\n              Schedule time picker label @@actions-common.actions-schedule-notifications.schedule-time-picker.aria-label\"\n            aria-label=\"actions-schedule-notifications-time-picker\"\n          ></bb-time-picker>\n          <button\n            bbButton\n            circle=\"true\"\n            *ngIf=\"last && i !== 0\"\n            (click)=\"hostRef.deleteTimeOption(i)\"\n            color=\"link\"\n            aria-label=\"Delete time option\"\n            i18n-aria-label=\"\n              Schedule delete time option\n              @@actions-common.actions-schedule-notifications.schedule-delete-time-option.aria-label\"\n            data-role=\"delete-time-option\"\n          >\n            <bb-icon-ui name=\"delete\" class=\"text-muted\"></bb-icon-ui>\n          </button>\n        </div>\n        <button\n          bbButton\n          class=\"bb-stack__item\"\n          color=\"primary\"\n          circle=\"true\"\n          buttonSize=\"sm\"\n          type=\"button\"\n          *ngIf=\"hostRef.scheduleTime.controls.length < hostRef.MaxOptionsQuantity\"\n          (click)=\"hostRef.addTimeOption()\"\n          aria-label=\"Add time option\"\n          i18n-aria-label=\"\n            Schedule add time option @@actions-common.actions-schedule-notifications.schedule-time-add-option.aria-label\"\n          data-role=\"add-time-option\"\n        >\n          <bb-icon-ui name=\"add\" size=\"sm\"></bb-icon-ui>\n        </button>\n      </form>\n    </div>\n  </div>\n  <div class=\"bb-block bb-block--md text-center bb-text-support\" data-role=\"schedule-description\">\n    <em i18n=\"Schedule description@@actions-common.actions-schedule-notifications.schedule-description\">\n      Notifications will be {hostRef.scheduleType, select, Custom {grouped and sent at specified time.} RightAway {sent\n      immediately.}}\n    </em>\n    <hr />\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$2.DropdownSingleSelectComponent; }), selector: "bb-dropdown-single-select-ui", inputs: ["placeholder", "defaultOptionAsPlaceholder", "options", "displayAttributePath", "iconName", "compareWithFn"] }, { type: i0.forwardRef(function () { return i2$2.DropdownSingleSelectOptionComponent; }), selector: "bb-dropdown-single-select-option-ui", inputs: ["value", "label"] }, { type: i0.forwardRef(function () { return TimePickerComponent; }), selector: "bb-time-picker", inputs: ["startTime", "minutesStep", "amPmFormat", "excludedOptions", "controlRef", "label"] }, { type: i0.forwardRef(function () { return i2.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i0.forwardRef(function () { return ActionsScheduleNotificationsComponentCustomizableDirective; }), selector: "[bbActionsScheduleNotificationsComponentCustomizableDirective]" }, { type: i0.forwardRef(function () { return i1.RequiredValidator; }), selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i0.forwardRef(function () { return i1.NgControlStatus; }), selector: "[formControlName],[ngModel],[formControl]" }, { type: i0.forwardRef(function () { return i1.NgModel; }), selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i0.forwardRef(function () { return i5.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i1.ɵNgNoValidate; }), selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i0.forwardRef(function () { return i1.NgControlStatusGroup; }), selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i0.forwardRef(function () { return i1.FormGroupDirective; }), selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i0.forwardRef(function () { return i5.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i0.forwardRef(function () { return i1.FormArrayName; }), selector: "[formArrayName]", inputs: ["formArrayName"] }, { type: i0.forwardRef(function () { return i1.FormControlName; }), selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i0.forwardRef(function () { return i6$1.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], pipes: { "async": i0.forwardRef(function () { return i5.AsyncPipe; }) }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsScheduleNotificationsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-actions-schedule-notifications',
                    templateUrl: './actions-schedule-notifications.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.FormBuilder }]; }, propDecorators: { actionRecipe: [{
                type: Input
            }], scheduleForm: [{
                type: Input
            }], minutesStep: [{
                type: Input
            }], submit: [{
                type: Output
            }] } });
class ActionsScheduleNotificationsComponentCustomizableDirective extends BbTemplate {
}
ActionsScheduleNotificationsComponentCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsScheduleNotificationsComponentCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ActionsScheduleNotificationsComponentCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: ActionsScheduleNotificationsComponentCustomizableDirective, selector: "[bbActionsScheduleNotificationsComponentCustomizableDirective]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsScheduleNotificationsComponentCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbActionsScheduleNotificationsComponentCustomizableDirective]',
                }]
        }] });

class ActionsToggleRecipeFormComponent {
    constructor(actionsFormBuilderService) {
        this.actionsFormBuilderService = actionsFormBuilderService;
        /**
         * Flag to control if schedule notifications is enabled
         */
        this.scheduleEnabled = false;
        /**
         * On form submit output.
         */
        this.submit = new EventEmitter();
        /**
         * Loading state flag.
         */
        this.isLoading = false;
    }
    ngOnInit() {
        this.formGroup = this.actionsFormBuilderService.buildActionRecipeFormGroup(this.specification, this.actionRecipe);
    }
    ngOnChanges(changes) {
        const { actionRecipe } = changes;
        if (this.formGroup && actionRecipe && actionRecipe.previousValue !== actionRecipe.currentValue) {
            this.isLoading = false;
            this.formGroup.patchValue(this.actionsFormBuilderService.buildActionRecipeFormValue(this.specification, this.actionRecipe));
        }
    }
    /**
     * Method to handle schedule form change and trigger submit action.
     *
     * @param value - action recipe form value
     */
    onScheduleChange(value) {
        var _a, _b;
        (_a = this.formGroup) === null || _a === void 0 ? void 0 : _a.patchValue(value);
        this.submit.emit((_b = this.formGroup) === null || _b === void 0 ? void 0 : _b.value);
    }
    /**
     * Method to submit action recipe form.
     *
     * @param formValue - action recipe form value
     */
    onSubmit(formValue) {
        this.isLoading = true;
        this.submit.emit(formValue);
    }
}
ActionsToggleRecipeFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsToggleRecipeFormComponent, deps: [{ token: ActionsFormBuilderService }], target: i0.ɵɵFactoryTarget.Component });
ActionsToggleRecipeFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: ActionsToggleRecipeFormComponent, selector: "bb-actions-toggle-recipe-form", inputs: { actionRecipe: "actionRecipe", specification: "specification", label: "label", scheduleEnabled: "scheduleEnabled" }, outputs: { submit: "submit" }, usesOnChanges: true, ngImport: i0, template: "<ng-container bbActionsToggleRecipeFormCustomizableDirective [bbHostRef]=\"this\"></ng-container>\n\n<ng-template bbActionsToggleRecipeFormCustomizableDirective let-hostRef>\n  <ng-container *ngIf=\"hostRef.formGroup\">\n    <form [formGroup]=\"hostRef.formGroup\">\n      <div class=\"bb-block bb-block--md bb-stack\">\n        <div\n          class=\"bb-stack__item bb-text-support bb-text-bold\"\n          [attr.data-role]=\"'toggle-recipe-label-' + hostRef.specification.id\"\n        >\n          {{ hostRef.label }}\n        </div>\n        <bb-switch-with-loading\n          [isLoading]=\"hostRef.isLoading\"\n          class=\"bb-stack__item bb-stack__item--push-right\"\n          formControlName=\"active\"\n          (change)=\"hostRef.onSubmit(hostRef.formGroup.value)\"\n          aria-label=\"{{ 'Switch on/off ' + hostRef.label }}\"\n          i18n-aria-label=\"Toggle recipe aria label@@actions-common.actions-toggle-recipe-form.switcher.aria-label\"\n          [attr.data-role]=\"'toggle-recipe-' + hostRef.specification.id\"\n        ></bb-switch-with-loading>\n      </div>\n      <bb-actions-schedule-notifications\n        class=\"bb-stack__item\"\n        *ngIf=\"hostRef.scheduleEnabled && hostRef.formGroup.value?.active && hostRef.actionRecipe\"\n        [scheduleForm]=\"hostRef.formGroup.get('recurrence')\"\n        [actionRecipe]=\"hostRef.actionRecipe\"\n        (submit)=\"hostRef.onScheduleChange($event)\"\n      ></bb-actions-schedule-notifications>\n    </form>\n  </ng-container>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return SwitchWithLoadingComponent; }), selector: "bb-switch-with-loading", inputs: ["isLoading", "aria-label"] }, { type: i0.forwardRef(function () { return ActionsScheduleNotificationsComponent; }), selector: "bb-actions-schedule-notifications", inputs: ["actionRecipe", "scheduleForm", "minutesStep"], outputs: ["submit"] }], directives: [{ type: i0.forwardRef(function () { return ActionsToggleRecipeFormCustomizableDirective; }), selector: "[bbActionsToggleRecipeFormCustomizableDirective]" }, { type: i0.forwardRef(function () { return i5.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i1.ɵNgNoValidate; }), selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i0.forwardRef(function () { return i1.NgControlStatusGroup; }), selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i0.forwardRef(function () { return i1.FormGroupDirective; }), selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i0.forwardRef(function () { return i1.NgControlStatus; }), selector: "[formControlName],[ngModel],[formControl]" }, { type: i0.forwardRef(function () { return i1.FormControlName; }), selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsToggleRecipeFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-actions-toggle-recipe-form',
                    templateUrl: './actions-toggle-recipe-form.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: ActionsFormBuilderService }]; }, propDecorators: { actionRecipe: [{
                type: Input
            }], specification: [{
                type: Input
            }], label: [{
                type: Input
            }], scheduleEnabled: [{
                type: Input
            }], submit: [{
                type: Output
            }] } });
class ActionsToggleRecipeFormCustomizableDirective extends BbTemplate {
}
ActionsToggleRecipeFormCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsToggleRecipeFormCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
ActionsToggleRecipeFormCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: ActionsToggleRecipeFormCustomizableDirective, selector: "[bbActionsToggleRecipeFormCustomizableDirective]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsToggleRecipeFormCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbActionsToggleRecipeFormCustomizableDirective]',
                }]
        }] });

class TimePickerModule {
}
TimePickerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: TimePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TimePickerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: TimePickerModule, declarations: [TimePickerComponent], imports: [CommonModule, DropdownSingleSelectModule, ReactiveFormsModule], exports: [TimePickerComponent, DropdownSingleSelectModule, ReactiveFormsModule] });
TimePickerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: TimePickerModule, imports: [[CommonModule, DropdownSingleSelectModule, ReactiveFormsModule], DropdownSingleSelectModule, ReactiveFormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: TimePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, DropdownSingleSelectModule, ReactiveFormsModule],
                    declarations: [TimePickerComponent],
                    exports: [TimePickerComponent, DropdownSingleSelectModule, ReactiveFormsModule],
                }]
        }] });

const PreferenceDataMap = {
    '1': {
        generalNotificationId: 'new-transaction-occurred',
        preferenceName: 'Transactions',
        preferenceLabel: 'Transactions',
        specificationId: '1',
    },
    '4': {
        generalNotificationId: 'account-balance-low',
        preferenceName: 'AccountBalance',
        preferenceLabel: 'Account Balance',
        specificationId: '4',
    },
};

class ActionsNotificationsPreferencesDataService {
    constructor(dataHttpService) {
        this.dataHttpService = dataHttpService;
        this.cachedNotificationPreferences$$ = new BehaviorSubject([]);
        this.mapSavePreferenceResponce = () => (preference) => preference.pipe(withLatestFrom(this.cachedNotificationPreferences$$), switchMap(([pref, preferences]) => {
            this.updatePreferencesCache(preferences, pref);
            return of({
                actionRecipes: [this.preferenceToRecipe(pref)],
            });
        }));
        this.preferenceToSpecification = ({ userConditions, channels, generalNotificationId, }) => {
            var _a, _b, _c;
            return ({
                actions: channels.map(channel => ({ type: channel.channel })),
                recipeDefaults: Object.assign({}, (((_a = userConditions === null || userConditions === void 0 ? void 0 : userConditions.conditions) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('amount')) && {
                    amount: `${(_b = userConditions === null || userConditions === void 0 ? void 0 : userConditions.conditions) === null || _b === void 0 ? void 0 : _b.amount}`,
                })),
                id: (_c = Object.values(PreferenceDataMap).find(pref => pref.generalNotificationId === generalNotificationId)) === null || _c === void 0 ? void 0 : _c.specificationId,
            });
        };
        this.preferenceToRecipe = ({ channels, userConditions, createdOn, generalNotificationId, active, id, }) => {
            var _a, _b, _c;
            return (Object.assign(Object.assign({ specificationId: (_a = Object.values(PreferenceDataMap).find(pref => pref.generalNotificationId === generalNotificationId)) === null || _a === void 0 ? void 0 : _a.specificationId, active, actions: channels.map(channel => ({
                    type: channel.channel,
                    enabled: channel.enabled,
                })), createdOn }, (((_b = userConditions === null || userConditions === void 0 ? void 0 : userConditions.conditions) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('amount')) && {
                amount: `${(_c = userConditions === null || userConditions === void 0 ? void 0 : userConditions.conditions) === null || _c === void 0 ? void 0 : _c.amount}`,
            })), { id: id || '' }));
        };
    }
    /**
     * Method to get action recipes.
     *
     * @param arrangementId
     * @returns action recipe array
     */
    getActionRecipes(arrangementId) {
        const requestParams = {
            entityId: arrangementId,
            entityType: 'arrangement',
        };
        return this.dataHttpService.getNotificationPreferences(requestParams).pipe(map(fromHttpResponse), map(({ notificationPreferences }) => {
            this.cachedNotificationPreferences$$.next(notificationPreferences);
            return notificationPreferences.map(pref => this.preferenceToRecipe(pref));
        }));
    }
    /**
     * Method to get action recipe specifications.
     *
     * @returns action recipe specifications
     */
    getSpecifications() {
        return this.cachedNotificationPreferences$$.pipe(map(fromHttpResponse), map(notificationPreferences => notificationPreferences.map(pref => this.preferenceToSpecification(pref))));
    }
    /**
     * Method to save action recipe.
     *
     * @param action - recipe form value
     * @param arrangementId - arrangement ID
     * @returns batch processing response
     */
    saveActionRecipe(actionRecipeFormItem, arrangementId) {
        const notificationPreferences = this.cachedNotificationPreferences$$.getValue();
        const preferenceToUpdate = notificationPreferences.find(pref => pref.generalNotificationId === PreferenceDataMap[actionRecipeFormItem.specificationId].generalNotificationId);
        if (preferenceToUpdate.id) {
            return this.updateNotificationPreference(preferenceToUpdate, actionRecipeFormItem);
        }
        else {
            return this.createNotificationPreference(preferenceToUpdate, actionRecipeFormItem, arrangementId);
        }
    }
    updateNotificationPreference(preferenceToUpdate, actionRecipeFormItem) {
        const notificationPreferencePutRequest = this.getNotificationPreferencePutRequest(preferenceToUpdate, actionRecipeFormItem);
        return this.dataHttpService
            .updateNotificationPreference({ id: preferenceToUpdate.id || '', notificationPreferencePutRequest })
            .pipe(this.mapSavePreferenceResponce());
    }
    createNotificationPreference(preferenceToUpdate, actionRecipeFormItem, arrangementId) {
        const notificationPreferencePostRequest = this.getNotificationPreferencePostRequest(preferenceToUpdate, actionRecipeFormItem, arrangementId);
        return this.dataHttpService
            .createNotificationPreference({ notificationPreferencePostRequest })
            .pipe(this.mapSavePreferenceResponce());
    }
    getNotificationPreferencePutRequest(preference, actionRecipeFormItem) {
        return {
            active: actionRecipeFormItem.active,
            channels: preference.channels.map(channel => (Object.assign(Object.assign({}, channel), { enabled: !!actionRecipeFormItem.actions[channel.channel] }))),
            conditions: Object.assign({}, (actionRecipeFormItem.amount.amount !== undefined && {
                amount: `${actionRecipeFormItem.amount.amount}`,
            })),
        };
    }
    getNotificationPreferencePostRequest(preference, actionRecipeFormItem, arrangementId) {
        var _a;
        return {
            generalNotificationId: preference.generalNotificationId,
            active: actionRecipeFormItem.active,
            eRef: arrangementId,
            channels: preference.channels.map(channel => (Object.assign(Object.assign({}, channel), { enabled: !!actionRecipeFormItem.actions[channel.channel] }))),
            conditions: Object.assign({}, (_a = preference.userConditions) === null || _a === void 0 ? void 0 : _a.conditions),
        };
    }
    updatePreferencesCache(preferences, updatedPreference) {
        const updatedPreferences = preferences.map(pref => pref.generalNotificationId === updatedPreference.generalNotificationId ? updatedPreference : pref);
        this.cachedNotificationPreferences$$.next(updatedPreferences);
    }
}
ActionsNotificationsPreferencesDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationsPreferencesDataService, deps: [{ token: i1$3.NotificationPreferenceService }], target: i0.ɵɵFactoryTarget.Injectable });
ActionsNotificationsPreferencesDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationsPreferencesDataService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsNotificationsPreferencesDataService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$3.NotificationPreferenceService }]; } });

const components = [
    ActionsNotificationChannelsComponent,
    ActionsAccountBalanceRecipeFormComponent,
    ActionsTransactionsRecipeFormComponent,
    ActionsToggleRecipeFormComponent,
    SwitchWithLoadingComponent,
    ActionsScheduleNotificationsComponent,
];
const directives = [
    ActionsNotificationChannelsCustomizableDirective,
    ActionsAccountBalanceRecipeCustomizableDirective,
    ActionsTransactionsRecipeCustomizableDirective,
    ActionsToggleRecipeFormCustomizableDirective,
    ActionsScheduleNotificationsComponentCustomizableDirective,
];
const pipes = [NoFractionDigitsPipe];
const uiModules = [
    AmountModule,
    ModalModule,
    ButtonModule,
    InputCheckboxModule,
    SwitchModule,
    HeaderModule,
    CollapsibleModule,
    IconModule,
    TooltipModule,
    InputInlineEditModule,
];
class ActionsCommonModule {
}
ActionsCommonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsCommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ActionsCommonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsCommonModule, declarations: [ActionsNotificationChannelsComponent,
        ActionsAccountBalanceRecipeFormComponent,
        ActionsTransactionsRecipeFormComponent,
        ActionsToggleRecipeFormComponent,
        SwitchWithLoadingComponent,
        ActionsScheduleNotificationsComponent, ActionsNotificationChannelsCustomizableDirective,
        ActionsAccountBalanceRecipeCustomizableDirective,
        ActionsTransactionsRecipeCustomizableDirective,
        ActionsToggleRecipeFormCustomizableDirective,
        ActionsScheduleNotificationsComponentCustomizableDirective, NoFractionDigitsPipe], imports: [CommonModule, FormsModule, ReactiveFormsModule, TimePickerModule, AmountModule,
        ModalModule,
        ButtonModule,
        InputCheckboxModule,
        SwitchModule,
        HeaderModule,
        CollapsibleModule,
        IconModule,
        TooltipModule,
        InputInlineEditModule], exports: [ActionsNotificationChannelsComponent,
        ActionsAccountBalanceRecipeFormComponent,
        ActionsTransactionsRecipeFormComponent,
        ActionsToggleRecipeFormComponent,
        SwitchWithLoadingComponent,
        ActionsScheduleNotificationsComponent, AmountModule,
        ModalModule,
        ButtonModule,
        InputCheckboxModule,
        SwitchModule,
        HeaderModule,
        CollapsibleModule,
        IconModule,
        TooltipModule,
        InputInlineEditModule, ActionsNotificationChannelsCustomizableDirective,
        ActionsAccountBalanceRecipeCustomizableDirective,
        ActionsTransactionsRecipeCustomizableDirective,
        ActionsToggleRecipeFormCustomizableDirective,
        ActionsScheduleNotificationsComponentCustomizableDirective, NoFractionDigitsPipe, TimePickerModule] });
ActionsCommonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsCommonModule, providers: [
        ActionsFormBuilderService,
        ActionsNotificationsSettingsDataService,
        ActionsNotificationsPreferencesDataService,
    ], imports: [[CommonModule, FormsModule, ReactiveFormsModule, TimePickerModule, ...uiModules], AmountModule,
        ModalModule,
        ButtonModule,
        InputCheckboxModule,
        SwitchModule,
        HeaderModule,
        CollapsibleModule,
        IconModule,
        TooltipModule,
        InputInlineEditModule, TimePickerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsCommonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, ReactiveFormsModule, TimePickerModule, ...uiModules],
                    providers: [
                        ActionsFormBuilderService,
                        ActionsNotificationsSettingsDataService,
                        ActionsNotificationsPreferencesDataService,
                    ],
                    declarations: [...components, ...directives, ...pipes],
                    exports: [...components, ...uiModules, ...directives, ...pipes, TimePickerModule],
                }]
        }] });

class NotificationsPreferencesBaseDataService {
}

const getPropertyValue = (input, prop) => combineLatest([input, prop]).pipe(map(([inputVal, propVal]) => (inputVal !== undefined ? inputVal : propVal)));

var SpecificationIds;
(function (SpecificationIds) {
    SpecificationIds["Transactions"] = "1";
    SpecificationIds["AccountBalance"] = "4";
    SpecificationIds["Payments"] = "5";
    SpecificationIds["Contacts"] = "6";
    SpecificationIds["PaymentsToApprove"] = "13";
    SpecificationIds["ContactsToApprove"] = "14";
})(SpecificationIds || (SpecificationIds = {}));

const DEFAULT_NOTIFICATION_DISMISS_TIME = 5;
const DEFAULT_SPECIFICATION_IDS = '5, 6, 13, 14';
const DEFAULT_API_MODE = 'actions';
class ActionsBasePropertiesService {
    /**
     * Method to get notification dismiss time preference value.
     *
     * @returns notification dismiss time in seconds
     */
    getNotificationDismissTimeProperty() {
        return of(DEFAULT_NOTIFICATION_DISMISS_TIME).pipe(map(secondsToMilliseconds));
    }
    /**
     * Method to get specification IDs.
     *
     * @returns specification IDs array
     */
    getSpecificationIDs() {
        return of(DEFAULT_SPECIFICATION_IDS).pipe(map(data => data.replace(/\s/g, '').split(',')));
    }
    getApiMode() {
        return DEFAULT_API_MODE;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { ActionsBasePropertiesService, ActionsCommonModule, ActionsNotificationsPreferencesDataService, ActionsNotificationsSettingsDataService, DAYS_OF_WEEK, DEFAULT_API_MODE, DEFAULT_NOTIFICATION_DISMISS_TIME, DEFAULT_SPECIFICATION_IDS, DefaultTime, EMPTY_RESPONSE_ERROR, MaxOptionsQuantity, MinutesInDay, NotificationsPreferencesBaseDataService, ScheduleDescriptionText, ScheduleType, SpecificationIds, actionRecipeFormItemToRequest, arrangementActionRecipeToRequest, filterObjectByPropNames, firstNonEmptyString, fromHttpResponse, getHoursOfDay, getMappedRecurrenceResponse, getPropertyValue, getTimeOptions, hoursToMinutesArray, isEqualNumberArrays, mergeNotificationChannels, mergeSpecificationsWithActionRecipes, parseActionRecipeFormItem, secondsToMilliseconds, sortNumberArray, ActionsAccountBalanceRecipeCustomizableDirective as ӨActionsAccountBalanceRecipeCustomizableDirective, ActionsAccountBalanceRecipeFormComponent as ӨActionsAccountBalanceRecipeFormComponent, ActionsNotificationChannelsComponent as ӨActionsNotificationChannelsComponent, ActionsNotificationChannelsCustomizableDirective as ӨActionsNotificationChannelsCustomizableDirective, ActionsScheduleNotificationsComponent as ӨActionsScheduleNotificationsComponent, ActionsScheduleNotificationsComponentCustomizableDirective as ӨActionsScheduleNotificationsComponentCustomizableDirective, ActionsToggleRecipeFormComponent as ӨActionsToggleRecipeFormComponent, ActionsToggleRecipeFormCustomizableDirective as ӨActionsToggleRecipeFormCustomizableDirective, ActionsTransactionsRecipeCustomizableDirective as ӨActionsTransactionsRecipeCustomizableDirective, ActionsTransactionsRecipeFormComponent as ӨActionsTransactionsRecipeFormComponent, NoFractionDigitsPipe as ӨNoFractionDigitsPipe, SwitchWithLoadingComponent as ӨSwitchWithLoadingComponent, TimePickerComponent as ӨTimePickerComponent, TimePickerModule as ӨTimePickerModule };
//# sourceMappingURL=backbase-actions-common-ang.js.map
