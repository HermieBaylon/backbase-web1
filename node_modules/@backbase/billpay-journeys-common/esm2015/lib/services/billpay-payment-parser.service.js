import { __rest } from "tslib";
import { Inject, Injectable, LOCALE_ID } from '@angular/core';
import { getLocaleNumberSymbol, NumberSymbol } from '@angular/common';
import { EndTypes, FrequencyKeys, PaymentServicesTypes } from '../model';
import { recurringFrequencies } from '../constants';
import * as i0 from "@angular/core";
export class BillpayPaymentParserService {
    constructor(locale) {
        this.locale = locale;
        this.decimalSeparator = getLocaleNumberSymbol(this.locale, NumberSymbol.CurrencyDecimal);
    }
    paymentRecurringToFormState(payment, payees) {
        const frequency = payment.recurring && recurringFrequencies.find(item => item.value === payment.frequency);
        const endType = payment.numberOfInstances ? EndTypes.After : EndTypes.Never;
        return Object.assign(Object.assign({}, this.parsePaymentCommonResponse(payment, payees)), { schedule: Object.assign({ repeat: payment.numberOfInstances, endType, startDate: payment.paymentDate, alertPendingCheckbox: payment.paymentScheduledAlert || false, alertSentCheckbox: payment.paymentSentAlert || false, alertLastPendingCheckbox: payment.modelExpirationAlert || false }, (frequency && { frequency: frequency.value })) });
    }
    paymentOneOffToFormState(payment, payees) {
        return Object.assign(Object.assign({}, this.parsePaymentCommonResponse(payment, payees)), { schedule: {
                startDate: payment.paymentDate,
                alertPendingCheckbox: false,
                alertSentCheckbox: false,
                alertLastPendingCheckbox: false,
                frequency: FrequencyKeys.Once,
            } });
    }
    paymentFormStateToReview({ accountFrom, payeeTo, amount, memo, schedule, overnightDeliveryAddress, }) {
        return Object.assign(Object.assign(Object.assign(Object.assign({ amount: {
                amount: amount.amount.replace(this.decimalSeparator, '.'),
                currencyCode: amount.currency,
            }, paymentDate: schedule.paymentServiceDate || schedule.startDate, paymentAccount: accountFrom, recurring: schedule.frequency !== FrequencyKeys.Once }, (memo && { paymentMemo: memo })), (overnightDeliveryAddress && { overnightDeliveryAddress })), this.parsePaymentFormPayee(payeeTo)), this.parsePaymentFormSchedule(schedule));
    }
    paymentAndPayeeResponsesToReview(payment, payee) {
        return Object.assign(Object.assign({}, this.paymentResponseToReview(payment)), (payee.address && { address: payee.address }));
    }
    // eslint-disable-next-line no-unused-vars, @typescript-eslint/no-unused-vars
    paymentResponseToReview(_a) {
        var { id, status, ebillID } = _a, rest = __rest(_a, ["id", "status", "ebillID"]);
        return rest;
    }
    parsePaymentFormPayee(payee) {
        return Object.assign(Object.assign({ payeeID: payee.id, payeeName: payee.name }, (payee.accountNumber && { payeeAccountNumber: payee.accountNumber })), (payee.nickName && { payeeNickName: payee.nickName }));
    }
    parsePaymentFormSchedule(schedule) {
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (this.getScheduleFee(schedule) && { fee: this.getScheduleFee(schedule) })), (schedule.repeat && { numberOfInstances: schedule.repeat })), (schedule.frequency !== FrequencyKeys.Once && { frequency: schedule.frequency })), (schedule.alertPendingCheckbox && { paymentScheduledAlert: schedule.alertPendingCheckbox })), (schedule.alertSentCheckbox && { paymentSentAlert: schedule.alertSentCheckbox })), (schedule.alertLastPendingCheckbox && { modelExpirationAlert: schedule.alertLastPendingCheckbox }));
    }
    getScheduleFee(schedule) {
        return ((schedule.paymentService &&
            (schedule.paymentService.index === PaymentServicesTypes.Expedited ||
                schedule.paymentService.index === PaymentServicesTypes.Overnight) &&
            schedule.paymentService.service &&
            schedule.paymentService.service.fee) ||
            undefined);
    }
    parsePaymentCommonResponse(payment, payees) {
        const payeeTo = payees.find(item => item.id === payment.payeeID);
        const amount = payment.amount && {
            currency: payment.amount.currencyCode,
            amount: payment.amount.amount.replace(this.decimalSeparator, '.'),
        };
        return Object.assign(Object.assign(Object.assign(Object.assign({ paymentId: payment.id }, (payment.amount && { amount })), (payeeTo && { payeeTo })), (payment.paymentAccount && { accountFrom: payment.paymentAccount })), (payment.paymentMemo && { memo: payment.paymentMemo }));
    }
}
/** @nocollapse */ BillpayPaymentParserService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BillpayPaymentParserService, deps: [{ token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ BillpayPaymentParserService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BillpayPaymentParserService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BillpayPaymentParserService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });
//# sourceMappingURL=billpay-payment-parser.service.js.map