import * as i0 from '@angular/core';
import { Injectable, Optional, InjectionToken, LOCALE_ID, Inject, Component, ChangeDetectionStrategy, Input, Directive, HostListener, EventEmitter, Output, ViewContainerRef, ViewChild, Pipe, NgModule } from '@angular/core';
import * as i1$1 from '@backbase/data-ang/transactions';
import { combineLatest, defer, of, ReplaySubject, BehaviorSubject, Subject, merge, iif, timer, from, throwError } from 'rxjs';
import { map, switchMap, publishReplay, refCount, catchError, filter, distinctUntilChanged, tap, scan, first, finalize, share, takeUntil, mergeMap, shareReplay, pluck } from 'rxjs/operators';
import * as i1 from '@backbase/data-ang/arrangements';
import * as i3 from '@backbase/foundation-ang/core';
import { BbTemplate } from '@backbase/foundation-ang/core';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1$2 from '@angular/platform-browser';
import * as i1$3 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import * as i2$1 from '@backbase/ui-ang/dropdown-menu';
import { DropdownMenuModule } from '@backbase/ui-ang/dropdown-menu';
import * as i3$1 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import * as i3$2 from '@backbase/ui-ang/loading-indicator';
import { LoadingIndicatorModule } from '@backbase/ui-ang/loading-indicator';
import * as i4 from '@backbase/ui-ang/empty-state';
import { EmptyStateModule } from '@backbase/ui-ang/empty-state';
import * as i5 from '@angular/cdk/a11y';
import { A11yModule } from '@angular/cdk/a11y';
import * as i1$4 from '@angular/forms';
import { ReactiveFormsModule } from '@angular/forms';
import * as i2$2 from '@backbase/ui-ang/input-radio-group';
import { InputRadioGroupModule } from '@backbase/ui-ang/input-radio-group';
import * as i3$3 from '@backbase/ui-ang/input-validation-message';
import { InputValidationMessageModule } from '@backbase/ui-ang/input-validation-message';
import * as i4$1 from '@backbase/ui-ang/rich-text-editor';
import { RichTextEditorModule } from '@backbase/ui-ang/rich-text-editor';
import * as i5$1 from '@backbase/ui-ang/input-file';
import { InputFileModule } from '@backbase/ui-ang/input-file';
import * as i6 from '@backbase/ui-ang/file-attachment';
import { FileAttachmentModule } from '@backbase/ui-ang/file-attachment';
import * as i7 from '@backbase/ui-ang/alert';
import { AlertModule } from '@backbase/ui-ang/alert';
import * as i8 from '@backbase/ui-ang/load-button';
import { LoadButtonModule } from '@backbase/ui-ang/load-button';
import * as i10 from '@backbase/ui-ang/modal';
import { ModalModule } from '@backbase/ui-ang/modal';
import * as i14 from '@backbase/ui-ang/tooltip-directive';
import { TooltipModule } from '@backbase/ui-ang/tooltip-directive';
import * as i1$5 from '@backbase/ui-ang/badge';
import { BadgeModule } from '@backbase/ui-ang/badge';
import { HttpResponse } from '@angular/common/http';
import * as i1$6 from '@backbase/data-ang/payment-batch';
import * as i3$4 from '@backbase/ui-ang/notification';
import * as i1$7 from '@backbase/data-ang/categories-management';
import * as i1$8 from '@backbase/data-ang/messages';
import '@angular/localize/init';
import * as i1$9 from '@angular/router';

var OnLoadAction;
(function (OnLoadAction) {
    OnLoadAction[OnLoadAction["Replace"] = 0] = "Replace";
    OnLoadAction[OnLoadAction["Append"] = 1] = "Append";
    OnLoadAction[OnLoadAction["ReplacePage"] = 2] = "ReplacePage";
})(OnLoadAction || (OnLoadAction = {}));
var TransactionState;
(function (TransactionState) {
    TransactionState["completed"] = "COMPLETED";
    TransactionState["uncompleted"] = "UNCOMPLETED";
})(TransactionState || (TransactionState = {}));
const defaultAccountOptions = {
    account: {},
};
const defaultSearchOptions = {
    search: {},
};
const defaultFilterOptions = {
    filter: {},
};
const defaultSortOptions = {};
const defaultPaginationOptions = {
    pagination: {
        from: 0,
        size: 10,
    },
};
const defaultInitialListOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultAccountOptions), defaultSearchOptions), defaultFilterOptions), defaultSortOptions), defaultPaginationOptions), { onLoad: OnLoadAction.Replace });
const defaultInitialExportOptions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultAccountOptions), defaultSearchOptions), defaultFilterOptions), defaultSortOptions), { exportType: 'csv', locale: 'en-US' });

/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsFilterOptions;
(function (TransactionsFilterOptions) {
    function isEmpty(options) {
        return Object.values(options)
            .filter((value) => typeof value !== 'undefined')
            .every((value) => !value || (typeof value === 'object' && isEmpty(value)));
    }
    TransactionsFilterOptions.isEmpty = isEmpty;
    // converts a Date object to `dddd-MM-yy` string format
    // eslint-disable-next-line complexity
    const formatDate = (date) => {
        const year = date.getFullYear().toString();
        const month = (date.getMonth() + 1).toString();
        const day = date.getDate().toString();
        return `${year}-${month[1] ? month : '0' + month[0]}-${day[1] ? day : '0' + day[0]}`;
    };
    function toHttpGetParams(options = {}) {
        const params = {};
        const setIfExists = (paramName, conditionFn, valueFn) => {
            if (conditionFn(options)) {
                params[paramName] = valueFn(options);
            }
        };
        setIfExists('creditDebitIndicator', (option) => option.creditDebitIndicator !== undefined && option.creditDebitIndicator.value !== undefined, (option) => option.creditDebitIndicator.value);
        setIfExists('types', (option) => option.type !== undefined && option.type.value !== undefined, (option) => (Array.isArray(option.type.value) ? option.type.value : [option.type.value]));
        setIfExists('billingStatus', (option) => option.billingStatus !== undefined && option.billingStatus.value !== undefined, (option) => option.billingStatus.value);
        setIfExists('amountGreaterThan', (option) => option.amount && option.amount.from, (option) => option.amount.from);
        setIfExists('amountLessThan', (option) => option.amount && option.amount.to, (option) => option.amount.to);
        setIfExists('bookingDateGreaterThan', (option) => option.date && option.date.from && Object.keys(option.date.from).length, (option) => formatDate(new Date(option.date.from)));
        setIfExists('bookingDateLessThan', (option) => option.date && option.date.to && Object.keys(option.date.to).length, (option) => formatDate(new Date(option.date.to)));
        setIfExists('fromCheckSerialNumber', (option) => option.checkSerialNumber && option.checkSerialNumber.from, (option) => option.checkSerialNumber.from);
        setIfExists('toCheckSerialNumber', (option) => option.checkSerialNumber && option.checkSerialNumber.to, (option) => option.checkSerialNumber.to);
        return params;
    }
    TransactionsFilterOptions.toHttpGetParams = toHttpGetParams;
    // eslint-disable-next-line complexity
    function fromHttpGetParams(params) {
        const options = {};
        if (params.creditDebitIndicator) {
            options.creditDebitIndicator = { value: params.creditDebitIndicator };
        }
        if (params.type) {
            if (Array.isArray(params.type)) {
                options.types = params.type.map((value) => ({ value }));
            }
            else {
                options.types = { value: params.type };
            }
        }
        if (params.billingStatus) {
            options.billingStatus = { value: params.billingStatus };
        }
        if (params.amountGreaterThan) {
            options.amount = { from: parseInt(params.amountGreaterThan, 10) };
        }
        if (params.amountLessThan) {
            options.amount = Object.assign(Object.assign({}, options.amount), { to: parseInt(params.amountLessThan, 10) });
        }
        if (params.bookingDateGreaterThan) {
            options.date = {
                from: params.bookingDateGreaterThan,
            };
        }
        if (params.bookingDateLessThan) {
            options.date = Object.assign(Object.assign({}, options.date), { to: params.bookingDateLessThan });
        }
        if (params.fromCheckSerialNumber) {
            options.checkSerialNumber = {
                from: parseInt(params.fromCheckSerialNumber, 10),
            };
        }
        if (params.toCheckSerialNumber) {
            options.checkSerialNumber = Object.assign(Object.assign({}, options.checkSerialNumber), { to: parseInt(params.toCheckSerialNumber, 10) });
        }
        return options;
    }
    TransactionsFilterOptions.fromHttpGetParams = fromHttpGetParams;
})(TransactionsFilterOptions || (TransactionsFilterOptions = {}));
/* eslint-enable no-redeclare*/

var AvailableFilterEnum;
(function (AvailableFilterEnum) {
    AvailableFilterEnum["CreditDebitIndicator"] = "creditDebitIndicator";
    AvailableFilterEnum["Types"] = "types";
    AvailableFilterEnum["BillingStatus"] = "billingStatus";
    AvailableFilterEnum["Amount"] = "amount";
    AvailableFilterEnum["Date"] = "date";
    AvailableFilterEnum["Categories"] = "categories";
    AvailableFilterEnum["CheckSerialNumber"] = "checkSerialNumber";
})(AvailableFilterEnum || (AvailableFilterEnum = {}));

/**
 * Dropdown values for credit/debit indicator filter.
 */
const creditDebitIndicatorEnumValues = [
    {
        name: 'All',
    },
    {
        value: 'CRDT',
        name: 'Credit',
    },
    {
        value: 'DBIT',
        name: 'Debit',
    },
];
/**
 * Fallback dropdown values for transaction type filter.
 */
const defaultTransactionTypeEnumValues = [
    {
        value: 'ATM',
        name: 'ATM',
    },
    {
        value: 'ACH',
        name: 'Ach',
    },
    {
        value: 'Bill Payment',
        name: 'Bill Payment',
    },
    {
        value: 'Cash',
        name: 'Cash',
    },
    {
        name: 'Cheques',
        value: 'Cheques',
    },
    {
        value: 'CreditDebit Card',
        name: 'Credit/Debit Card',
    },
    {
        value: 'Check',
        name: 'Check',
    },
    {
        value: 'Deposit',
        name: 'Deposit',
    },
    {
        value: 'Fee',
        name: 'Fee',
    },
    {
        value: 'POS',
        name: 'POS',
    },
    {
        value: 'Withdrawal',
        name: 'Withdrawal',
    },
];
/**
 * Fallback dropdown values for billing status filter.
 */
const defaultBillingStatusEnumValues = [
    {
        value: 'PENDING',
        name: 'Pending',
    },
    {
        value: 'BILLED',
        name: 'Billed',
    },
    {
        value: 'UNBILLED',
        name: 'Unbilled',
    },
];
/**
 * Name of different check images status
 */
var CheckImagesAvailability;
(function (CheckImagesAvailability) {
    CheckImagesAvailability["available"] = "AVAILABLE";
    CheckImagesAvailability["unavailable"] = "UNAVAILABLE";
})(CheckImagesAvailability || (CheckImagesAvailability = {}));
var BillingStatusEnum;
(function (BillingStatusEnum) {
    BillingStatusEnum["billed"] = "BILLED";
    BillingStatusEnum["unbilled"] = "UNBILLED";
    BillingStatusEnum["pending"] = "PENDING";
})(BillingStatusEnum || (BillingStatusEnum = {}));
/**
 * Name of response header that contains the total amount of results.
 */
const totalCountHeader = 'X-Total-Count';
/**
 * Name of response header that contains the available export types.
 */
const availableExportTypes = 'X-Available-Export-Types';
const unvailableExportTypesReasons = 'X-Unavailable-Export-Types-Reasons';
/**
 * Name of response header that contains the sort configuration.
 */
const sortFieldsDirectionHeader = 'X-Sort-Fields-Direction';
/**
 * Notification time to live in ms.
 */
const notificationTtl = 5000;
/**
 * Which category level should be retrieved for category change modal list.
 */
const categoryListLevelParam = 'PARENTS';
const defaultAvailableFiltersConfig = {
    'Current Account': [
        AvailableFilterEnum.Date,
        AvailableFilterEnum.CreditDebitIndicator,
        AvailableFilterEnum.Amount,
        AvailableFilterEnum.Types,
        AvailableFilterEnum.BillingStatus,
        AvailableFilterEnum.CheckSerialNumber,
    ],
    'Savings Account': [
        AvailableFilterEnum.Date,
        AvailableFilterEnum.CreditDebitIndicator,
        AvailableFilterEnum.Amount,
        AvailableFilterEnum.Types,
        AvailableFilterEnum.BillingStatus,
        AvailableFilterEnum.CheckSerialNumber,
    ],
    'Credit Card': [
        AvailableFilterEnum.Date,
        AvailableFilterEnum.CreditDebitIndicator,
        AvailableFilterEnum.Amount,
        AvailableFilterEnum.Types,
        AvailableFilterEnum.BillingStatus,
    ],
    Loan: [AvailableFilterEnum.Date, AvailableFilterEnum.CreditDebitIndicator, AvailableFilterEnum.Amount],
    'Term Deposit': [AvailableFilterEnum.Date, AvailableFilterEnum.CreditDebitIndicator, AvailableFilterEnum.Amount],
    'Debit Card': [AvailableFilterEnum.Date, AvailableFilterEnum.CreditDebitIndicator, AvailableFilterEnum.Amount],
    'Investment Account': [
        AvailableFilterEnum.Date,
        AvailableFilterEnum.CreditDebitIndicator,
        AvailableFilterEnum.Amount,
    ],
    defaultFilters: [AvailableFilterEnum.Date, AvailableFilterEnum.CreditDebitIndicator, AvailableFilterEnum.Amount],
};
const deserialize = (propertyValue) => {
    const params = propertyValue.split('&');
    return params.reduce((acc, param) => {
        const [key, val] = param.split('=');
        return Object.assign(Object.assign({}, acc), { [decodeURIComponent(key)]: decodeURIComponent(val) });
    }, {});
};
const parseSortOptions = (propertyValue) => {
    if (!propertyValue.length) {
        return undefined;
    }
    const sortOption = propertyValue
        .split(',')[0]
        .trim()
        .replace(/\s{2,}/g, ' ');
    const [orderBy, direction] = sortOption.split(' ');
    if (!orderBy || (direction !== 'ASC' && direction !== 'DESC')) {
        throw new Error(`Invalid value for "initialSortOptions" property.
      Please use "<orderBy> <direction>" format, e.g., "bookingDate DESC", or leave it empty.`);
    }
    return {
        orderBy,
        direction,
    };
};
const filterInputParameters = (input, prop) => combineLatest([input, prop]).pipe(map(([inputVal, propVal]) => inputVal !== null && inputVal !== void 0 ? inputVal : propVal));
const b64Encode = (str) => btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (_match, p1) {
    return String.fromCharCode(parseInt(p1, 16));
}));
const truncateDate = (date) => new Date(date.getFullYear(), date.getMonth(), date.getDate());
const daysDiff = (date1, date2) => {
    const diff = truncateDate(new Date(date1)).getTime() - truncateDate(new Date(date2)).getTime();
    return Math.ceil(diff / (1000 * 3600 * 24));
};

/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsList;
(function (TransactionsList) {
    // eslint-disable-next-line complexity
    const processTransaction = (transaction) => {
        const amountSign = transaction.creditDebitIndicator === 'DBIT' ? -1 : 1;
        const formattedTransaction = Object.assign(Object.assign(Object.assign({}, transaction), { isPending: (function isPending(data) {
                let result = false;
                if (data && data.billingStatus) {
                    const billingStatus = data.billingStatus.toUpperCase();
                    result = billingStatus === BillingStatusEnum.pending || billingStatus === BillingStatusEnum.unbilled;
                }
                return result;
            })(transaction) }), (transaction.merchant
            ? {
                merchant: Object.assign(Object.assign({ id: transaction.merchant.id, name: transaction.merchant.name }, (transaction.merchant.logo ? { logo: transaction.merchant.logo } : {})), (transaction.merchant.website ? { website: transaction.merchant.website } : {})),
            }
            : {}));
        if (transaction.transactionAmountCurrency) {
            const amountNumber = parseFloat(transaction.transactionAmountCurrency.amount);
            formattedTransaction.transactionAmountCurrency = Object.assign(Object.assign({}, transaction.transactionAmountCurrency), { unsignedAmount: amountNumber, amount: (amountSign * (amountNumber || 0)).toString() });
        }
        if (transaction.instructedAmountCurrency) {
            const amountNumber = parseFloat(transaction.instructedAmountCurrency.amount);
            formattedTransaction.instructedAmountCurrency = Object.assign(Object.assign({}, transaction.instructedAmountCurrency), { unsignedAmount: amountNumber, amount: (amountSign * (amountNumber || 0)).toString() });
        }
        formattedTransaction.currencyExchangeAvailability =
            !!transaction.instructedAmountCurrency &&
                !!transaction.transactionAmountCurrency &&
                !!transaction.currencyExchangeRate;
        return formattedTransaction;
    };
    const processTransactions = (transactionsList) => (Object.assign(Object.assign({}, transactionsList), { items: transactionsList.items.map(processTransaction) }));
    const processTotalCountHeader = (totalCount) => (totalCount ? parseInt(totalCount, 10) : 0);
    const processAvailableExportTypes = (availableExports) => availableExports || '';
    const processUnavailableExportTypesReasons = (unavilableExportTypesReasonsValue) => JSON.parse(unavilableExportTypesReasonsValue || '{}');
    const processSortFieldsDirectionHeader = (sortFieldsDirection) => {
        if (sortFieldsDirection === null || !sortFieldsDirection.length) {
            return undefined;
        }
        const sortOption = sortFieldsDirection
            .split(',')[0]
            .trim()
            .replace(/\s{2,}/g, ' ');
        const [orderBy, direction] = sortOption.split(' ');
        if (!orderBy || (direction !== 'ASC' && direction !== 'DESC')) {
            throw new Error(`Invalid value for "initialSortOptions" property.
        Please use "<orderBy> <direction>" format, e.g., "bookingDate DESC",
        or leave it empty.`);
        }
        return {
            orderBy,
            direction,
        };
    };
    // eslint-disable-next-line no-inner-declarations
    function padValueWithZeros(value, size = 2) {
        return (value + '').padStart(size, '0');
    }
    // eslint-disable-next-line no-inner-declarations
    function formatDate(date) {
        const safeDate = date || '';
        if (/^[0-9]{4}-[0-9]{2}-[0-9]{2}/.exec(safeDate)) {
            const localDate = new Date(safeDate);
            const month = padValueWithZeros(localDate.getMonth() + 1);
            const day = padValueWithZeros(localDate.getDate());
            const year = localDate.getFullYear();
            return `${year}-${month}-${day}`;
        }
        else if (date !== undefined) {
            console.error(`invalid date provided ${date}`);
        }
        return undefined;
    }
    TransactionsList.fromHttpResponse = (response) => {
        const totalCount = processTotalCountHeader(response.headers.get(totalCountHeader));
        const sort = processSortFieldsDirectionHeader(response.headers.get(sortFieldsDirectionHeader));
        const availableExportTypesHeader = processAvailableExportTypes(response.headers.get(availableExportTypes));
        const unavailableExportTypesReasonsHeader = processUnavailableExportTypesReasons(response.headers.get(unvailableExportTypesReasons));
        return processTransactions(Object.assign(Object.assign({ items: response.body || [], totalCount }, (sort ? { sort } : {})), { availableExportTypesHeader,
            unavailableExportTypesReasonsHeader }));
    };
    TransactionsList.concat = (transactionsList1, transactionsList2) => {
        if (transactionsList2.httpResponseError) {
            return Object.assign(Object.assign({}, transactionsList1), { items: [...transactionsList1.items], httpResponseError: transactionsList2.httpResponseError });
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({ items: [...transactionsList1.items, ...transactionsList2.items], totalCount: transactionsList1.totalCount }, (transactionsList2.sort ? { sort: transactionsList2.sort } : {})), (transactionsList2.availableExportTypesHeader
            ? {
                availableExportTypesHeader: transactionsList2.availableExportTypesHeader,
            }
            : {})), (transactionsList2.unavailableExportTypesReasonsHeader
            ? {
                unavailableExportTypesReasonsHeader: transactionsList2.unavailableExportTypesReasonsHeader,
            }
            : {})), { httpResponseError: transactionsList2.httpResponseError });
    };
    TransactionsList.hasLoadedAll = (transactionsList) => transactionsList.items.length === transactionsList.totalCount;
    TransactionsList.toHttpRequest = (listOptions) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
        const turnIntoArrayObject = (value, name, fn) => {
            if (!value) {
                return {};
            }
            return Array.isArray(value) ? { [name]: fn(value) } : { [name]: [fn(value)] };
        };
        const optionalItem = (name, value) => (value !== undefined ? { [name]: value } : {});
        const isTransactionListOption = (data) => Object.prototype.hasOwnProperty.call(data, 'pagination');
        const isTransactionExportOptions = (data) => Object.prototype.hasOwnProperty.call(data, 'exportType');
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, turnIntoArrayObject(listOptions.account.arrangementId, 'arrangementsIds', (value) => value)), optionalItem('query', (_a = listOptions.search) === null || _a === void 0 ? void 0 : _a.query)), optionalItem('amountGreaterThan', (_c = (_b = listOptions.filter) === null || _b === void 0 ? void 0 : _b.amount) === null || _c === void 0 ? void 0 : _c.from)), optionalItem('amountLessThan', (_e = (_d = listOptions.filter) === null || _d === void 0 ? void 0 : _d.amount) === null || _e === void 0 ? void 0 : _e.to)), optionalItem('bookingDateGreaterThan', ((_g = (_f = listOptions.filter) === null || _f === void 0 ? void 0 : _f.date) === null || _g === void 0 ? void 0 : _g.from) === '' ? undefined : formatDate((_j = (_h = listOptions.filter) === null || _h === void 0 ? void 0 : _h.date) === null || _j === void 0 ? void 0 : _j.from))), optionalItem('bookingDateLessThan', ((_l = (_k = listOptions.filter) === null || _k === void 0 ? void 0 : _k.date) === null || _l === void 0 ? void 0 : _l.to) === '' ? undefined : formatDate((_o = (_m = listOptions.filter) === null || _m === void 0 ? void 0 : _m.date) === null || _o === void 0 ? void 0 : _o.to))), optionalItem('categories', (_p = listOptions.filter) === null || _p === void 0 ? void 0 : _p.categories)), optionalItem('fromCheckSerialNumber', (_r = (_q = listOptions.filter) === null || _q === void 0 ? void 0 : _q.checkSerialNumber) === null || _r === void 0 ? void 0 : _r.from)), optionalItem('toCheckSerialNumber', (_t = (_s = listOptions.filter) === null || _s === void 0 ? void 0 : _s.checkSerialNumber) === null || _t === void 0 ? void 0 : _t.to)), optionalItem('orderBy', (_u = listOptions.sort) === null || _u === void 0 ? void 0 : _u.orderBy)), optionalItem('direction', (_v = listOptions.sort) === null || _v === void 0 ? void 0 : _v.direction)), optionalItem('state', isTransactionListOption(listOptions) ? listOptions.state : undefined)), optionalItem('from', isTransactionListOption(listOptions) ? (_w = listOptions.pagination) === null || _w === void 0 ? void 0 : _w.from : undefined)), optionalItem('size', isTransactionListOption(listOptions) ? (_x = listOptions.pagination) === null || _x === void 0 ? void 0 : _x.size : undefined)), optionalItem('billingStatus', (_z = (_y = listOptions.filter) === null || _y === void 0 ? void 0 : _y.billingStatus) === null || _z === void 0 ? void 0 : _z.value)), optionalItem('creditDebitIndicator', (_1 = (_0 = listOptions.filter) === null || _0 === void 0 ? void 0 : _0.creditDebitIndicator) === null || _1 === void 0 ? void 0 : _1.value)), optionalItem('exportType', isTransactionExportOptions(listOptions) ? listOptions.exportType : undefined)), optionalItem('locale', isTransactionExportOptions(listOptions) ? listOptions.locale : undefined)), turnIntoArrayObject((_2 = listOptions.filter) === null || _2 === void 0 ? void 0 : _2.types, 'types', (value) => value.value));
    };
})(TransactionsList || (TransactionsList = {}));
/* eslint-enable no-redeclare*/

function fromArrangementsResponse(response) {
    return (response.body || []).map((item) => ({
        id: item.id,
        name: item.name,
        displayName: item.displayName,
        alias: item.bankAlias,
        IBAN: item.IBAN,
        BBAN: item.BBAN,
        currency: item.currency,
    }));
}

class AccountsService {
    constructor(productSummaryDataHttpService) {
        this.productSummaryDataHttpService = productSummaryDataHttpService;
    }
    getAllArrangements() {
        return this.productSummaryDataHttpService
            .getArrangementsByBusinessFunction({
            businessFunction: 'Product Summary',
            resourceName: 'Product Summary',
            privilege: 'view',
            size: 1000000,
        }, 'response')
            .pipe(map(fromArrangementsResponse));
    }
    getProductSummary() {
        return this.productSummaryDataHttpService.getArrangementsByBusinessFunction({
            businessFunction: 'Product Summary',
            resourceName: 'Product Summary',
            privilege: 'view',
            size: 1000000,
        }, 'body');
    }
}
AccountsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AccountsService, deps: [{ token: i1.ProductSummaryHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
AccountsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AccountsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AccountsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.ProductSummaryHttpService }]; } });

const deepEqual = (x, y) => {
    const ok = Object.keys;
    const tx = typeof x;
    const ty = typeof y;
    return x && y && tx === 'object' && tx === ty
        ? ok(x).length === ok(y).length && ok(x).every((key) => deepEqual(x[key], y[key]))
        : x === y;
};
const cacheRequest = (request) => (source) => source.pipe(switchMap(request), publishReplay(1), refCount());
const multipleAccountsPredicate = (listOptions) => () => Array.isArray(listOptions.account.arrangementId) && listOptions.account.arrangementId.length > 1;
const onLoadTransactions = (acc, curr) => curr.onLoad === OnLoadAction.Append ? TransactionsList.concat(acc, curr.transactionsList) : curr.transactionsList;
const getNameFromContentDispositionHeader = (response) => {
    const contentDisposition = response.headers.get('Content-Disposition');
    let fileName = '';
    if (contentDisposition) {
        const result = /filename[^;=\n]*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/i.exec(contentDisposition);
        fileName = result ? result[2] : '';
    }
    return fileName;
};

const WidgetProperties = {
    pageSize: 'bb.transaction.pageSize',
    maxNavPages: 'bb.transaction.maxNavPages',
    paginationType: 'bb.transaction.paginationType',
    initialFilterOptions: 'bb.transaction.initialFilterOptions',
    initialSortOptions: 'bb.transaction.initialSortOptions',
    showControls: 'bb.transaction.showControls',
    showChangeCategory: 'bb.transaction.showChangeCategory',
    refreshTransactionsListEvents: 'event.refreshTransactionsList',
    showPendingTransactionsOnTop: 'bb.transaction.showPendingTransactionsOnTop',
    showCheckImage: 'bb.transaction.showCheckImage',
    gmapsAPIKey: 'bb.transaction.gmapsAPIKey',
    showManageNotes: 'bb.transaction.showManageNotes',
    getOrPostEndpoints: 'bb.transaction.getOrPostEndpoints',
    disputeByBillingStatus: 'disputeByBillingStatus',
    disputeEligibilityDays: 'disputeEligibilityDays',
    disputeTransactionTypes: 'disputeTransactionTypes',
    enableDisputeAndInquiry: 'enableDisputeAndInquiry',
    inquireTopicId: 'inquireTopicId',
    disputeTopicId: 'disputeTopicId',
};
const defaultPageSize = 10;
const defaultMaxNavPage = 3;
const defaultInitialFilterOptions = '';
const defaultInitialSortOptions = '';
var PaginationType;
(function (PaginationType) {
    PaginationType["LOAD_MORE"] = "load-more";
    PaginationType["PAGINATION"] = "pagination";
    PaginationType["INFINITE_SCROLL"] = "infinite-scroll";
})(PaginationType || (PaginationType = {}));
var EndpointType;
(function (EndpointType) {
    EndpointType["GET_REQUEST"] = "get-request";
    EndpointType["POST_REQUEST"] = "post-request";
})(EndpointType || (EndpointType = {}));
const defaultModelObservable = (value) => defer(() => of(value)).pipe(publishReplay(1), refCount());
class WidgetPropertiesService {
    constructor(itemModel) {
        this.itemModel = itemModel;
    }
    get pageSize() {
        if (!this.itemModel) {
            return defaultModelObservable(defaultPageSize);
        }
        return this.itemModel.property(WidgetProperties.pageSize).pipe(map((propertyValue) => parseInt(propertyValue, 10)), map((pageSize) => (pageSize > 0 ? pageSize : defaultPageSize)));
    }
    get maxNavPages() {
        if (!this.itemModel) {
            return defaultModelObservable(defaultMaxNavPage);
        }
        return this.itemModel
            .property(WidgetProperties.maxNavPages)
            .pipe(map((propertyValue) => parseInt(propertyValue, 10)));
    }
    get paginationType() {
        if (!this.itemModel) {
            return defaultModelObservable(PaginationType.LOAD_MORE);
        }
        return this.itemModel
            .property(WidgetProperties.paginationType)
            .pipe(map((propertyValue) => propertyValue));
    }
    get initialFilterOptions() {
        if (!this.itemModel) {
            return defaultModelObservable({});
        }
        return this.itemModel.property(WidgetProperties.initialFilterOptions, defaultInitialFilterOptions).pipe(map(deserialize), map((params) => TransactionsFilterOptions.fromHttpGetParams(params)));
    }
    get initialSortOptions() {
        if (!this.itemModel) {
            return defaultModelObservable(parseSortOptions(defaultInitialSortOptions));
        }
        return this.itemModel.property(WidgetProperties.initialSortOptions, defaultInitialSortOptions).pipe(map(parseSortOptions), catchError((err) => {
            console.warn(`initialSortOptions property ignored: ${err}`);
            return of(undefined);
        }));
    }
    get showControls() {
        if (!this.itemModel) {
            return defaultModelObservable(true);
        }
        return this.itemModel
            .property(WidgetProperties.showControls)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get showChangeCategory() {
        if (!this.itemModel) {
            return defaultModelObservable(true);
        }
        return this.itemModel
            .property(WidgetProperties.showChangeCategory)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get refreshTransactionsListEvents() {
        if (!this.itemModel) {
            return defaultModelObservable('');
        }
        return this.itemModel
            .property(WidgetProperties.refreshTransactionsListEvents)
            .pipe(map((propertyValue) => propertyValue));
    }
    get showPendingTransactionsOnTop() {
        if (!this.itemModel) {
            return defaultModelObservable(false);
        }
        return this.itemModel
            .property(WidgetProperties.showPendingTransactionsOnTop)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get showCheckImage() {
        if (!this.itemModel) {
            return defaultModelObservable(true);
        }
        return this.itemModel
            .property(WidgetProperties.showCheckImage)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get showManageNotes() {
        if (!this.itemModel) {
            return defaultModelObservable(true);
        }
        return this.itemModel
            .property(WidgetProperties.showManageNotes)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get getOrPostEndpoints() {
        if (!this.itemModel) {
            return defaultModelObservable(EndpointType.POST_REQUEST);
        }
        return this.itemModel
            .property(WidgetProperties.getOrPostEndpoints)
            .pipe(map((propertyValue) => propertyValue));
    }
    get gmapsAPIKey() {
        if (!this.itemModel) {
            return defaultModelObservable('');
        }
        return this.itemModel.property(WidgetProperties.gmapsAPIKey).pipe(map((propertyValue) => propertyValue));
    }
    get disputeByBillingStatus() {
        if (!this.itemModel) {
            return defaultModelObservable(true);
        }
        return this.itemModel
            .property(WidgetProperties.disputeByBillingStatus)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get disputeEligibilityDays() {
        if (!this.itemModel) {
            return defaultModelObservable(120);
        }
        return this.itemModel
            .property(WidgetProperties.disputeEligibilityDays, '120')
            .pipe(map((propertyValue) => parseInt(propertyValue, 10)));
    }
    get disputeTransactionTypes() {
        if (!this.itemModel) {
            return defaultModelObservable(['Credit/Debit Card']);
        }
        return this.itemModel
            .property(WidgetProperties.disputeTransactionTypes, 'Credit/Debit Card')
            .pipe(map((propertyValue) => propertyValue.split(',')));
    }
    get enableDisputeAndInquiry() {
        if (!this.itemModel) {
            return defaultModelObservable(false);
        }
        return this.itemModel
            .property(WidgetProperties.enableDisputeAndInquiry)
            .pipe(map((propertyValue) => (typeof propertyValue === 'boolean' ? propertyValue : propertyValue === 'true')));
    }
    get inquireTopicId() {
        if (!this.itemModel) {
            return defaultModelObservable('');
        }
        return this.itemModel
            .property(WidgetProperties.inquireTopicId)
            .pipe(map((propertyValue) => propertyValue));
    }
    get disputeTopicId() {
        if (!this.itemModel) {
            return defaultModelObservable('');
        }
        return this.itemModel
            .property(WidgetProperties.disputeTopicId)
            .pipe(map((propertyValue) => propertyValue));
    }
}
WidgetPropertiesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService, deps: [{ token: i3.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
WidgetPropertiesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i3.ItemModel, decorators: [{
                    type: Optional
                }] }]; } });

var LoadingState;
(function (LoadingState) {
    LoadingState["NotLoaded"] = "NotLoaded";
    LoadingState["LoadingMore"] = "LoadingMore";
    LoadingState["LoadingPage"] = "LoadingPage";
    LoadingState["Loading"] = "Loading";
    LoadingState["Loaded"] = "Loaded";
})(LoadingState || (LoadingState = {}));
const showDetailsConfigToken = new InjectionToken('shows the transactions details modal');
class TransactionsService {
    constructor(transactionsDataHttpService, accountService, deprecationsService, locale) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.accountService = accountService;
        this.deprecationsService = deprecationsService;
        this.locale = locale;
        this.selectedAccount = new ReplaySubject(1);
        this.pageSize = new ReplaySubject(1);
        this.initialListOptions = new ReplaySubject(1);
        this.options = new BehaviorSubject({});
        this.listRefresh = new Subject();
        this.listOptions = new BehaviorSubject(defaultInitialListOptions);
        this.exportOptions = new BehaviorSubject(defaultInitialExportOptions);
        this.showPendingTransactionsOnTop = new ReplaySubject(1);
        this.getOrPostEndpoint = new BehaviorSubject(EndpointType.GET_REQUEST);
        this.transactionsList = merge(this.listOptions.pipe(filter((listOptions) => typeof listOptions.account.arrangementId !== 'undefined'), distinctUntilChanged(deepEqual)), this.listRefresh).pipe(cacheRequest((listOptions) => {
            this.loadingState.next(listOptions.onLoad === OnLoadAction.Append
                ? LoadingState.LoadingMore
                : listOptions.onLoad === OnLoadAction.ReplacePage
                    ? LoadingState.LoadingPage
                    : LoadingState.Loading);
            return combineLatest([
                this.loadTransactions(listOptions).pipe(tap(() => {
                    this.loadingState.next(LoadingState.Loaded);
                }), map((transactionsList) => ({
                    transactionsList,
                    onLoad: listOptions.onLoad,
                }))),
                iif(multipleAccountsPredicate(listOptions), this.accountService.getAllArrangements().pipe(map((accounts) => {
                    const accountMap = new Map();
                    accounts.forEach((account) => {
                        accountMap.set(account.id, account);
                    });
                    return accountMap;
                })), of(new Map())),
                this.isFilterApplied,
                this.isSearchApplied,
            ]).pipe(map(([transactions, accountMap, isFilterApplied, isSearchApplied]) => {
                transactions.transactionsList.items = transactions.transactionsList.items.map((transaction) => (Object.assign(Object.assign({}, transaction), { account: accountMap.get(transaction.arrangementId || '') })));
                transactions.transactionsList.initialRequest = !(isFilterApplied || isSearchApplied);
                return transactions;
            }));
        }), scan(onLoadTransactions, { items: [], totalCount: 0 }));
        this.loadingState = new BehaviorSubject(LoadingState.NotLoaded);
        this.isFilterApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.filter || {})));
        this.isSearchApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.search || {})));
        // Base this.options on this.selectedAccount, this.pageSize, this.initialListOptions
        combineLatest([this.selectedAccount, this.pageSize, this.initialListOptions, this.showPendingTransactionsOnTop])
            .pipe(map(([selectedAccount, pageSize, initialListOptions, showPendingTransactionsOnTop]) => (Object.assign(Object.assign(Object.assign({}, (showPendingTransactionsOnTop ? { state: TransactionState.completed } : {})), { account: {
                arrangementId: selectedAccount,
            }, pagination: {
                from: 0,
                size: pageSize,
            }, onLoad: OnLoadAction.Replace }), initialListOptions))))
            .subscribe(this.options);
        // Base this.listOptions on this.options
        this.options
            .pipe(scan((acc, curr) => Object.assign({}, acc, curr), defaultInitialListOptions))
            .subscribe(this.listOptions);
        // Base this.exportOptions on this.listOptions
        this.listOptions
            .pipe(filter((listOptions) => typeof listOptions.account.arrangementId !== 'undefined'), map((params) => (Object.assign(Object.assign({}, params), { pagination: undefined, state: undefined, exportType: 'csv', locale: 'en-US' }))))
            .subscribe(this.exportOptions);
    }
    loadTransactions(listOptions) {
        const transactionPayload = TransactionsList.toHttpRequest(listOptions);
        let transactionsResponse;
        if (this.isUsingPostEndpoints) {
            transactionsResponse = this.transactionsDataHttpService.getTransactionsWithPost({
                transactionListRequest: transactionPayload,
            }, 'response');
        }
        else {
            this.deprecationsService.logDeprecatedFeature('[TransactionsService: loadTransactions] GET endpoints deprecated. Please use POST endpoints by changing CXP configuration');
            transactionsResponse = this.transactionsDataHttpService.getTransactions(transactionPayload, 'response');
        }
        return transactionsResponse.pipe(map(TransactionsList.fromHttpResponse), catchError((err) => of({
            items: [],
            totalCount: 0,
            httpResponseError: err,
        })));
    }
    exportTransactions(exportOptions) {
        const exportPayload = TransactionsList.toHttpRequest(Object.assign(Object.assign({}, exportOptions), { locale: this.locale }));
        if (this.isUsingPostEndpoints) {
            return this.transactionsDataHttpService.getTransactionsExportWithPost({
                transactionListRequest: exportPayload,
            }, 'response');
        }
        else {
            this.deprecationsService.logDeprecatedFeature('[TransactionsService: exportTransactions] GET endpoints deprecated. Please use POST endpoints by changing CXP configuration');
            return this.transactionsDataHttpService.getTransactionsExport(exportPayload, 'response');
        }
    }
    search(query) {
        const searchOptions = {
            query,
        };
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions, search: searchOptions, onLoad: OnLoadAction.Replace }));
    }
    clearSearch() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions, onLoad: OnLoadAction.Replace }));
    }
    filter(filterOptions) {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions, filter: Object.assign({}, filterOptions), onLoad: OnLoadAction.Replace }));
    }
    clearFilter() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions, onLoad: OnLoadAction.Replace }));
    }
    exportToType(type) {
        return this.exportOptions.pipe(first(), switchMap((exportOptions) => this.exportTransactions(Object.assign(Object.assign({}, exportOptions), { exportType: type }))));
    }
    loadMore() {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        const paginationOptions = Object.assign(Object.assign({}, currentPaginationOptions), { from: currentPaginationOptions.from + 1 });
        this.options.next({
            pagination: paginationOptions,
            onLoad: OnLoadAction.Append,
        });
    }
    sort(sortOptions) {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        this.options.next({
            sort: Object.assign({}, sortOptions),
            pagination: Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 }),
            onLoad: OnLoadAction.ReplacePage,
        });
    }
    pageChange(page) {
        const paginationOptions = Object.assign(Object.assign(Object.assign({}, defaultPaginationOptions.pagination), this.options.getValue().pagination), { from: page });
        this.options.next({
            pagination: paginationOptions,
            onLoad: OnLoadAction.ReplacePage,
        });
    }
    getTransactionsFrom(selectedAccount, pageSize, initialListOptions = of({}), showPendingTransactionsOnTop = of(false), getOrPostEndpoint = of(EndpointType.GET_REQUEST)) {
        selectedAccount.subscribe(this.selectedAccount);
        pageSize.subscribe(this.pageSize);
        initialListOptions.subscribe(this.initialListOptions);
        showPendingTransactionsOnTop.subscribe(this.showPendingTransactionsOnTop);
        getOrPostEndpoint.subscribe(this.getOrPostEndpoint);
    }
    getCurrentPage() {
        return this.listOptions.pipe(map((options) => (options.pagination || defaultPaginationOptions.pagination).from));
    }
    getTransactionsList() {
        return this.transactionsList;
    }
    retryFiltering() {
        this.listRefresh.next(this.listOptions.getValue());
    }
    refreshTransactions() {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        const paginationOptions = Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 });
        const newOptions = Object.assign(Object.assign({}, this.listOptions.getValue()), { pagination: paginationOptions, onLoad: OnLoadAction.ReplacePage });
        if (deepEqual(newOptions, this.listOptions.getValue())) {
            this.listRefresh.next(this.listOptions.getValue());
        }
        else {
            this.options.next({
                pagination: paginationOptions,
                onLoad: OnLoadAction.ReplacePage,
            });
        }
    }
    get isUsingPostEndpoints() {
        return this.getOrPostEndpoint.getValue() === EndpointType.POST_REQUEST;
    }
    ngOnDestroy() {
        this.listRefresh.complete();
        this.selectedAccount.complete();
        this.pageSize.complete();
        this.initialListOptions.complete();
        this.options.complete();
        this.listOptions.complete();
        this.exportOptions.complete();
        this.showPendingTransactionsOnTop.complete();
        this.loadingState.complete();
        this.getOrPostEndpoint.complete();
    }
}
TransactionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsService, deps: [{ token: i1$1.TransactionClientHttpService }, { token: AccountsService }, { token: i3.DeprecationsService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Injectable });
TransactionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TransactionClientHttpService }, { type: AccountsService }, { type: i3.DeprecationsService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });

class TransactionsNumberOfResultsFoundComponent {
    constructor() {
        /**
         * Reference to instance of customizable component.
         */
        this.hostRef = this;
        /**
         * Number of results found after filtering or searching.
         */
        this.numberOfResultsFound = 0;
        /**
         * The loading state of the transactions list.
         */
        this.loadingState = LoadingState.NotLoaded;
        /**
         * Whether filter is applied or not.
         */
        this.isFilterApplied = false;
        /**
         * Whether search is applied or not.
         */
        this.isSearchApplied = false;
    }
    /**
     * Whether loading has finished or not.
     */
    get isLoaded() {
        return this.loadingState === LoadingState.Loaded;
    }
}
TransactionsNumberOfResultsFoundComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsNumberOfResultsFoundComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionsNumberOfResultsFoundComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsNumberOfResultsFoundComponent, selector: "bb-transactions-number-of-results-found", inputs: { numberOfResultsFound: "numberOfResultsFound", loadingState: "loadingState", isFilterApplied: "isFilterApplied", isSearchApplied: "isSearchApplied" }, ngImport: i0, template: "<ng-container bbTransactionsNumberOfResultsFoundCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n\n<ng-template bbTransactionsNumberOfResultsFoundCustomizable let-hostRef>\n  <div\n    class=\"bb-card__header bb-subtitle\"\n    [ngClass]=\"{ 'sr-only': hostRef.numberOfResultsFound <= 0 }\"\n    i18n=\"Number of results found for the applied filter@@transactions.list.numberOfResultsFound\"\n    *ngIf=\"hostRef.isLoaded && (hostRef.isFilterApplied || hostRef.isSearchApplied)\"\n    aria-live=\"assertive\"\n  >\n    {hostRef.numberOfResultsFound, plural, =0 {No results} =1 {1 result} other\n    {{{ hostRef.numberOfResultsFound }} results}} found\n  </div>\n</ng-template>\n", directives: [{ type: i0.forwardRef(function () { return TransactionsNumberOfResultsFoundCustomizableDirective; }), selector: "[bbTransactionsNumberOfResultsFoundCustomizable]" }, { type: i0.forwardRef(function () { return i2.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i2.NgClass; }), selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsNumberOfResultsFoundComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transactions-number-of-results-found',
                    templateUrl: 'transactions-number-of-results-found.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { numberOfResultsFound: [{
                type: Input
            }], loadingState: [{
                type: Input
            }], isFilterApplied: [{
                type: Input
            }], isSearchApplied: [{
                type: Input
            }] } });
class TransactionsNumberOfResultsFoundCustomizableDirective extends BbTemplate {
}
TransactionsNumberOfResultsFoundCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsNumberOfResultsFoundCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TransactionsNumberOfResultsFoundCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsNumberOfResultsFoundCustomizableDirective, selector: "[bbTransactionsNumberOfResultsFoundCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsNumberOfResultsFoundCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTransactionsNumberOfResultsFoundCustomizable]',
                }]
        }] });

var TransactionsCheckImageType;
(function (TransactionsCheckImageType) {
    TransactionsCheckImageType["PNG"] = "image/png";
    TransactionsCheckImageType["JPEG"] = "image/jpeg";
})(TransactionsCheckImageType || (TransactionsCheckImageType = {}));
var TransactionsCheckImageSide;
(function (TransactionsCheckImageSide) {
    TransactionsCheckImageSide["FRONT"] = "FRONT";
    TransactionsCheckImageSide["BACK"] = "BACK";
})(TransactionsCheckImageSide || (TransactionsCheckImageSide = {}));
//eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsCheckImages;
(function (TransactionsCheckImages) {
    // eslint-disable-next-line no-inner-declarations
    function processImages(imageObject) {
        return {
            side: imageObject.side,
            mimeType: imageObject.mimeType,
            content: imageObject.content,
        };
    }
    function fromHttpResponse(response) {
        const imagesArray = (response.body && response.body.images) || [];
        const mappedImages = imagesArray.map(processImages);
        return {
            images: mappedImages,
        };
    }
    TransactionsCheckImages.fromHttpResponse = fromHttpResponse;
})(TransactionsCheckImages || (TransactionsCheckImages = {}));

var TransactionsDetailsLoadingState;
(function (TransactionsDetailsLoadingState) {
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["error"] = -1] = "error";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["serverError"] = -2] = "serverError";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["badRequestError"] = -3] = "badRequestError";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["notFoundError"] = -4] = "notFoundError";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["loading"] = 0] = "loading";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["done"] = 1] = "done";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["notLoaded"] = 2] = "notLoaded";
    TransactionsDetailsLoadingState[TransactionsDetailsLoadingState["notStarted"] = 3] = "notStarted";
})(TransactionsDetailsLoadingState || (TransactionsDetailsLoadingState = {}));
var DisputeStatusEnum;
(function (DisputeStatusEnum) {
    DisputeStatusEnum["Refunded"] = "REFUNDED";
    DisputeStatusEnum["Undisputed"] = "UNDISPUTED";
    DisputeStatusEnum["Pending"] = "PENDING";
    DisputeStatusEnum["Rejected"] = "REJECTED";
})(DisputeStatusEnum || (DisputeStatusEnum = {}));

class AccessibilityKeyboardDirective {
    constructor(element) {
        this.element = element;
        element.nativeElement.tabIndex = 0;
    }
    // eslint-disable-next-line
    eventListener(event) {
        this.element.nativeElement.click(event);
    }
}
AccessibilityKeyboardDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AccessibilityKeyboardDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AccessibilityKeyboardDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: AccessibilityKeyboardDirective, selector: "[bbAccessibilityKeyboard]", host: { listeners: { "keydown.enter": "eventListener($event)", "keydown.space": "eventListener($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AccessibilityKeyboardDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbAccessibilityKeyboard]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { eventListener: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

class TransactionCheckImageItemComponent {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.sideText = '';
        this.imageAlt = '';
        this.selectImage = new EventEmitter();
    }
    get imageFileName() {
        const fileType = this.image ? this.image.mimeType.replace('image/', '') : '';
        const side = this.image ? this.image.side : '';
        return `${this.imageCheckNumber}-${side}.${fileType}`;
    }
    get formatedImageSource() {
        const mimeType = this.image ? this.image.mimeType : '';
        const content = this.image ? this.image.content : '';
        return `data:${mimeType};base64,${content}`;
    }
    get imageCheckNumber() {
        return this.transaction && this.transaction.checkSerialNumber;
    }
    createImageSource() {
        return this.sanitizer.bypassSecurityTrustResourceUrl(this.formatedImageSource);
    }
    toggleDocumentViewer() {
        this.selectImage.emit();
    }
}
TransactionCheckImageItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCheckImageItemComponent, deps: [{ token: i1$2.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component });
TransactionCheckImageItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionCheckImageItemComponent, selector: "bb-transaction-check-image-item", inputs: { image: "image", transaction: "transaction", sideText: "sideText", imageAlt: "imageAlt" }, outputs: { selectImage: "selectImage" }, ngImport: i0, template: "<ng-container>\n  <span>{{ sideText }}</span>\n  <div\n    role=\"img\"\n    data-role=\"check-image-item\"\n    class=\"bb-check-img-container\"\n    (click)=\"!!image && toggleDocumentViewer()\"\n    attr.aria-label=\"{{ sideText }} image container\"\n    i18n-aria-label=\"\n      Image container for front or back check image@@transaction-check-image-item.aria-label.image-container\"\n    bbAccessibilityKeyboard\n  >\n    <ng-container *ngIf=\"!!image; else noImage\">\n      <div class=\"bb-check-img-container-state\">\n        <div class=\"bb-check-img-container-state__container\">\n          <bb-icon-ui\n            name=\"remove-red-eye\"\n            size=\"lg\"\n            color=\"white\"\n            aria-label=\"Expand Image\"\n            i18n-aria-label=\"Expand image@@transaction-check-image-item.aria-label.expand-icon\"\n          ></bb-icon-ui>\n        </div>\n      </div>\n      <img class=\"bb-check-img-container__img\" alt=\"{{ imageAlt }}\" [src]=\"createImageSource()\" />\n    </ng-container>\n  </div>\n</ng-container>\n\n<ng-template #noImage>\n  <div class=\"bb-check-no-img\">\n    <div class=\"bb-check-no-img__icon\">\n      <bb-icon-ui\n        name=\"broken-image\"\n        size=\"lg\"\n        aria-label=\"No image\"\n        i18n-aria-label=\"No image@@transaction-check-image-item.aria-label.no-image-icon\"\n      ></bb-icon-ui>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i1$3.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: AccessibilityKeyboardDirective, selector: "[bbAccessibilityKeyboard]" }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCheckImageItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transaction-check-image-item',
                    templateUrl: 'transaction-check-image-item.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$2.DomSanitizer }]; }, propDecorators: { image: [{
                type: Input
            }], transaction: [{
                type: Input
            }], sideText: [{
                type: Input
            }], imageAlt: [{
                type: Input
            }], selectImage: [{
                type: Output
            }] } });

const DOCUMENT_LOAD_DELAY_MS = 400;
var DocumentViewerType;
(function (DocumentViewerType) {
    DocumentViewerType["JPEG"] = "image/jpeg";
    DocumentViewerType["JPG"] = "image/jpg";
    DocumentViewerType["PNG"] = "image/png";
    DocumentViewerType["WEBP"] = "image/webp";
    DocumentViewerType["GIF"] = "image/gif";
    DocumentViewerType["BMP"] = "image/bmp";
})(DocumentViewerType || (DocumentViewerType = {}));
const isDocumentViewerType = (type) => Object.values(DocumentViewerType).includes(type);
const downloadFile = (url, fileName) => {
    const link = document.createElement('a');
    link.href = url;
    link.download = `${fileName}`;
    link.click();
};
var KEY_CODES;
(function (KEY_CODES) {
    KEY_CODES["UP"] = "ArrowUp";
    KEY_CODES["DOWN"] = "ArrowDown";
    KEY_CODES["ENTER"] = "Enter";
    KEY_CODES["SPACE"] = " ";
    KEY_CODES["TAB"] = "Tab";
    KEY_CODES["BACKSPACE"] = "Backspace";
    KEY_CODES["DELETE"] = "Delete";
    KEY_CODES["ESCAPE"] = "Escape";
    KEY_CODES["X"] = "x";
    KEY_CODES["V"] = "v";
    KEY_CODES["LEFT"] = "ArrowLeft";
    KEY_CODES["RIGHT"] = "ArrowRight";
})(KEY_CODES || (KEY_CODES = {}));
const KEY_CODE_TO_CODE = {
    9: KEY_CODES.TAB,
    38: KEY_CODES.UP,
    40: KEY_CODES.DOWN,
    32: KEY_CODES.SPACE,
    13: KEY_CODES.ENTER,
    46: KEY_CODES.DELETE,
    8: KEY_CODES.BACKSPACE,
    27: KEY_CODES.ESCAPE,
    88: KEY_CODES.X,
    86: KEY_CODES.V,
};
function browserIsMsie() {
    return navigator.userAgent.indexOf('MSIE') > -1 || navigator.userAgent.indexOf('Trident/') > -1;
}
function getKeyCode(event) {
    // NOTE: detect IE
    if (browserIsMsie()) {
        return KEY_CODE_TO_CODE[event.keyCode];
    }
    return event.code;
}

class DocumentViewerBackdropComponent {
    get containerStyles() {
        var _a, _b;
        return ((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.container) === null || _b === void 0 ? void 0 : _b.styles) || null;
    }
    get hasCustomStyles() {
        var _a, _b;
        return Boolean((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.container) === null || _b === void 0 ? void 0 : _b.styles);
    }
}
DocumentViewerBackdropComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerBackdropComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DocumentViewerBackdropComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DocumentViewerBackdropComponent, selector: "bb-document-viewer-backdrop", inputs: { options: "options" }, ngImport: i0, template: "<div\n  class=\"bb-document-viewer-backdrop modal-backdrop show\"\n  aria-hidden=\"true\"\n  [class.bb-document-viewer-backdrop-default-off]=\"hasCustomStyles\"\n  [ngStyle]=\"containerStyles\"\n></div>\n", directives: [{ type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerBackdropComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-document-viewer-backdrop',
                    templateUrl: './document-viewer-backdrop.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { options: [{
                type: Input
            }] } });

class DocumentViewerHeaderComponent {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.isLoading = false;
        //eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
    }
    set source(src) {
        if (src) {
            this.revokeObjectURL();
            this.documentObjectURL = src;
        }
    }
    ngOnDestroy() {
        this.revokeObjectURL();
    }
    onOpenDocument() {
        if (!this.documentObjectURL) {
            return;
        }
        this.openImage(this.documentObjectURL);
    }
    onPrintDocument() {
        if (!this.documentObjectURL) {
            return;
        }
        this.printWindow(this.openImage(this.documentObjectURL));
    }
    onDownloadDocument() {
        if (!this.documentObjectURL) {
            return;
        }
        downloadFile(this.documentObjectURL, this.filename);
    }
    openImage(documentObjectURL) {
        const image = new Image();
        const newWindow = window.open('about:blank', '_new');
        image.src = documentObjectURL;
        newWindow.document.write(image.outerHTML);
        return newWindow;
    }
    printWindow(window) {
        this.ngZone.runOutsideAngular(() => {
            setTimeout(() => {
                window.focus();
                window.print();
            }, 0);
        });
    }
    revokeObjectURL() {
        if (this.documentObjectURL) {
            window.URL.revokeObjectURL(this.documentObjectURL);
        }
    }
}
DocumentViewerHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerHeaderComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
DocumentViewerHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DocumentViewerHeaderComponent, selector: "bb-document-viewer-header", inputs: { filename: "filename", filetype: "filetype", source: "source", isLoading: "isLoading" }, outputs: { close: "close" }, ngImport: i0, template: "<div class=\"bb-document-viewer-header\">\n  <span class=\"bb-document-viewer-header__title bb-stack\">\n    <bb-icon-ui\n      class=\"bb-stack__item bb-stack__item--spacing-sm\"\n      data-role=\"document-viewer-header-icon\"\n      name=\"description\"\n      size=\"md\"\n    ></bb-icon-ui>\n    <span class=\"bb-stack__item\" data-role=\"document-viewer-header-filename\">{{ filename }}</span>\n  </span>\n  <div class=\"bb-stack\">\n    <!-- web view -->\n    <div\n      class=\"\n        bb-stack__item bb-stack__item--spacing-none bb-stack__item--push-right\n        bb-document-viewer-header-controls__web-view\n      \"\n    >\n      <button\n        bbButton\n        data-role=\"print-document-btn\"\n        class=\"bb-document-viewer-interactor-controls__button bb-document-viewer-header__spacer\"\n        aria-label=\"print\"\n        i18n-aria-label=\"Print document button@@document-viewer-header.aria-label.print-document-btn\"\n        buttonSize=\"sm\"\n        (click)=\"!isLoading && onPrintDocument()\"\n      >\n        <bb-icon-ui name=\"local-printshop\" size=\"md\" color=\"light\"></bb-icon-ui>\n      </button>\n\n      <button\n        bbButton\n        data-role=\"download-document-btn\"\n        class=\"bb-document-viewer-interactor-controls__button bb-document-viewer-header__spacer\"\n        aria-label=\"download\"\n        i18n-aria-label=\"Download document button@document-viewer-header.aria-label.download-document-btn\"\n        buttonSize=\"sm\"\n        (click)=\"!isLoading && onDownloadDocument()\"\n      >\n        <bb-icon-ui name=\"save-alt\" size=\"md\" color=\"light\"></bb-icon-ui>\n      </button>\n\n      <button\n        bbButton\n        data-role=\"open-document-btn\"\n        class=\"bb-document-viewer-interactor-controls__button bb-document-viewer-header__spacer\"\n        aria-label=\"new tab\"\n        i18n-aria-label=\"Open document in new tab button@@document-viewer-header.aria-label.open-document-new-tab-btn\"\n        buttonSize=\"sm\"\n        (click)=\"!isLoading && onOpenDocument()\"\n      >\n        <bb-icon-ui name=\"open-in-new\" size=\"md\" color=\"light\"></bb-icon-ui>\n      </button>\n\n      <button\n        bbButton\n        data-role=\"close-document-btn\"\n        class=\"bb-document-viewer-interactor-controls__button bb-document-viewer-header__spacer\"\n        aria-label=\"close\"\n        i18n-aria-label=\"Close document button@@document-viewer-header.aria-label.close-btn\"\n        buttonSize=\"sm\"\n        (click)=\"close.emit()\"\n      >\n        <bb-icon-ui name=\"times\" size=\"md\" color=\"light\"></bb-icon-ui>\n      </button>\n    </div>\n\n    <!-- mobile view -->\n    <div\n      class=\"\n        bb-stack__item bb-stack__item--spacing-none bb-stack__item--push-right\n        bb-document-viewer-header-controls__mobile-view\n      \"\n    >\n      <div class=\"bb-stack\">\n        <bb-dropdown-menu-ui\n          container=\"body\"\n          data-role=\"options-menu-dropdown\"\n          class=\"bb-stack__item\"\n          icon=\"ellipsis-h\"\n          btnColor=\"muted\"\n          buttonSize=\"sm\"\n          [btnCircle]=\"true\"\n          iconSize=\"md\"\n          iconColor=\"light\"\n          ariaLabel=\"Check image export dropdown menu\"\n          i18n-ariaLabel=\"Check image export dropdown menu@@document-viewer-header.export-dropdown-menu.ariaLabel\"\n        >\n          <ng-template bbDropdownMenuItem>\n            <a\n              role=\"menuitem\"\n              class=\"dropdown-item\"\n              data-role=\"open-document-item\"\n              (click)=\"!isLoading && onOpenDocument()\"\n              href=\"javaScript:void(0);\"\n            >\n              <bb-icon-ui class=\"bb-document-viewer-header__dropdown-icon\" name=\"open-in-new\" size=\"md\"></bb-icon-ui>\n              <span i18n=\"Open image in new tab@@document-viewer-header.controlsList.open-in-new-tab\"\n                >Open in new tab</span\n              >\n            </a>\n            <a\n              role=\"menuitem\"\n              class=\"dropdown-item\"\n              data-role=\"download-document-item\"\n              (click)=\"!isLoading && onDownloadDocument()\"\n              href=\"javaScript:void(0);\"\n            >\n              <bb-icon-ui class=\"bb-document-viewer-header__dropdown-icon\" name=\"save-alt\" size=\"md\"></bb-icon-ui>\n              <span i18n=\"Download image@@document-viewer-header.controlsList.download-image\">Download</span>\n            </a>\n            <a\n              role=\"menuitem\"\n              class=\"dropdown-item\"\n              data-role=\"print-document-item\"\n              (click)=\"!isLoading && onPrintDocument()\"\n              href=\"javaScript:void(0);\"\n            >\n              <bb-icon-ui\n                class=\"bb-document-viewer-header__dropdown-icon\"\n                name=\"local-printshop\"\n                size=\"md\"\n              ></bb-icon-ui>\n              <span i18n=\"Print image@@document-viewer-header.controlsList.print-image\">Print</span>\n            </a>\n          </ng-template>\n        </bb-dropdown-menu-ui>\n        <button\n          bbButton\n          data-role=\"close-document-btn\"\n          class=\"bb-stack__item bb-document-viewer-interactor-controls__button bb-document-viewer-header__spacer\"\n          aria-label=\"close\"\n          i18n-aria-label=\"Close document button@@document-viewer-header.aria-label.close-btn\"\n          buttonSize=\"sm\"\n          (click)=\"close.emit()\"\n        >\n          <bb-icon-ui name=\"times\" size=\"md\" color=\"light\"></bb-icon-ui>\n        </button>\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: i1$3.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i2$1.DropdownMenuComponent, selector: "bb-dropdown-menu-ui", inputs: ["label", "disabled", "options", "icon", "iconSize", "iconColor", "btnColor", "btnCircle", "optionLabelKey", "fullWidth", "autoClose", "container", "position", "ariaLabel", "dropDownMenuRole", "dropDownMenuId", "buttonSize", "dropDownButtonLabel", "visibleElementDependingOnViewport", "role"], outputs: ["select"] }], directives: [{ type: i3$1.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i2$1.DropdownMenuItemDirective, selector: "ng-template[bbDropdownMenuItem]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerHeaderComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-document-viewer-header',
                    templateUrl: './document-viewer-header.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { filename: [{
                type: Input
            }], filetype: [{
                type: Input
            }], source: [{
                type: Input
            }], isLoading: [{
                type: Input
            }], close: [{
                type: Output
            }] } });

class DocumentViewerInteractorComponent {
    constructor() {
        this.navigationState = { currIdx: 0, total: 0 };
        this.canZoomOut = true;
        this.canZoomIn = true;
        this.navigate = new EventEmitter();
        this.zoomIn = new EventEmitter();
        this.zoomOut = new EventEmitter();
    }
    get navigationStatus() {
        return this.navigationState.currIdx + 1 + '/' + this.navigationState.total;
    }
    get hasNextNavigation() {
        return this.navigationState.currIdx + 1 < this.navigationState.total;
    }
    get hasPrevNavigation() {
        return this.navigationState.currIdx > 0;
    }
    prev() {
        this.navigate.emit(this.navigationState.currIdx - 1);
    }
    next() {
        this.navigate.emit(this.navigationState.currIdx + 1);
    }
}
DocumentViewerInteractorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerInteractorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
DocumentViewerInteractorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DocumentViewerInteractorComponent, selector: "bb-document-viewer-interactor", inputs: { navigationState: "navigationState", canZoomOut: "canZoomOut", canZoomIn: "canZoomIn" }, outputs: { navigate: "navigate", zoomIn: "zoomIn", zoomOut: "zoomOut" }, ngImport: i0, template: "<div class=\"bb-document-viewer-interactor\">\n  <div class=\"bb-document-viewer-interactor__container\" (click)=\"$event.stopPropagation()\">\n    <div class=\"bb-document-viewer-interactor-controls\">\n      <button\n        bbButton\n        data-role=\"previous-document-btn\"\n        *ngIf=\"hasPrevNavigation\"\n        class=\"bb-document-viewer-interactor-controls__button bb-document-viewer-interactor-controls__spacer\"\n        buttonSize=\"sm\"\n        (click)=\"prev()\"\n        aria-label=\"previous\"\n        i18n-aria-label=\"Previous document button@@document-viewer-interactor.aria-label.previous-document-button\"\n      >\n        <bb-icon-ui name=\"angle-left\" color=\"light\" size=\"md\"></bb-icon-ui>\n      </button>\n      <span class=\"bb-document-viewer-interactor-controls__spacer\">{{ navigationStatus }}</span>\n      <button\n        bbButton\n        data-role=\"next-document-btn\"\n        *ngIf=\"hasNextNavigation\"\n        class=\"bb-document-viewer-interactor-controls__button\"\n        buttonSize=\"sm\"\n        (click)=\"next()\"\n        aria-label=\"next\"\n        i18n-aria-label=\"Next document button@@document-viewer-interactor.aria-label.next-document-button\"\n      >\n        <bb-icon-ui name=\"angle-right\" color=\"light\" size=\"md\"></bb-icon-ui>\n      </button>\n    </div>\n    <div class=\"bb-document-viewer-interactor-separator\"></div>\n    <div class=\"bb-document-viewer-interactor-controls\">\n      <button\n        bbButton\n        data-role=\"zoom-out-btn\"\n        class=\"bb-document-viewer-interactor-controls__button bb-document-viewer-interactor-controls__spacer\"\n        [disabled]=\"!canZoomOut\"\n        buttonSize=\"sm\"\n        (click)=\"zoomOut.emit()\"\n        aria-label=\"zoom out\"\n        i18n-aria-label=\"Zoom out document button@@document-viewer-interactor.aria-label.zoomOut-document-button\"\n      >\n        <bb-icon-ui name=\"zoom-out\" color=\"light\" size=\"md\"></bb-icon-ui>\n      </button>\n      <button\n        bbButton\n        data-role=\"zoom-in-btn\"\n        class=\"bb-document-viewer-interactor-controls__button\"\n        [disabled]=\"!canZoomIn\"\n        aria-label=\"zoom in\"\n        buttonSize=\"sm\"\n        (click)=\"zoomIn.emit()\"\n        i18n-aria-label=\"Zoom in document button@@document-viewer-interactor.aria-label.zoomIn-document-button\"\n      >\n        <bb-icon-ui name=\"zoom-in\" color=\"light\" size=\"md\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n</div>\n", components: [{ type: i1$3.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3$1.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerInteractorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-document-viewer-interactor',
                    templateUrl: './document-viewer-interactor.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { navigationState: [{
                type: Input
            }], canZoomOut: [{
                type: Input
            }], canZoomIn: [{
                type: Input
            }], navigate: [{
                type: Output
            }], zoomIn: [{
                type: Output
            }], zoomOut: [{
                type: Output
            }] } });

const ZOOM_FACTOR = 1.1;
const ZOOM_IN_THRESHOLD = 4;
const ZOOM_OUT_THRESHOLD = 0.1;
class ImageViewerComponent {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
        this.navigationState = { currIdx: 0, total: 0 };
        this.navigate = new EventEmitter();
        this.imageUiState = { scale: 1 };
    }
    set source(src) {
        if (src) {
            this.revokeObjectURLIfNeeded();
            this.imageObjectUrl = src;
            this.imageObjectTrustedUrl = this.domSanitizer.bypassSecurityTrustResourceUrl(this.imageObjectUrl);
        }
    }
    get canZoomOut() {
        return this.imageUiState.scale >= ZOOM_OUT_THRESHOLD;
    }
    get canZoomIn() {
        return this.imageUiState.scale <= ZOOM_IN_THRESHOLD;
    }
    get scale() {
        return this.domSanitizer.bypassSecurityTrustStyle(`scale(${this.imageUiState.scale})`);
    }
    ngOnDestroy() {
        this.revokeObjectURLIfNeeded();
    }
    zoomIn() {
        if (this.canZoomIn) {
            this.imageUiState.scale *= ZOOM_FACTOR;
        }
    }
    zoomOut() {
        if (this.canZoomOut) {
            this.imageUiState.scale /= ZOOM_FACTOR;
        }
    }
    revokeObjectURLIfNeeded() {
        if (this.imageObjectUrl) {
            window.URL.revokeObjectURL(this.imageObjectUrl);
        }
    }
}
ImageViewerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ImageViewerComponent, deps: [{ token: i1$2.DomSanitizer }], target: i0.ɵɵFactoryTarget.Component });
ImageViewerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: ImageViewerComponent, selector: "bb-image-viewer", inputs: { source: "source", navigationState: "navigationState" }, outputs: { navigate: "navigate" }, ngImport: i0, template: "<div class=\"bb-img-viewer-container bb-stack bb-stack--center\">\n  <img\n    #imgRef\n    class=\"bb-img-viewer-container__img\"\n    [style.transform]=\"scale\"\n    [src]=\"imageObjectTrustedUrl\"\n    alt=\"Transaction check image\"\n    (click)=\"$event.stopPropagation()\"\n  />\n</div>\n<bb-document-viewer-interactor\n  [navigationState]=\"navigationState\"\n  [canZoomOut]=\"canZoomOut\"\n  [canZoomIn]=\"canZoomIn\"\n  (navigate)=\"navigate.emit($event)\"\n  (zoomIn)=\"zoomIn()\"\n  (zoomOut)=\"zoomOut()\"\n></bb-document-viewer-interactor>\n", components: [{ type: DocumentViewerInteractorComponent, selector: "bb-document-viewer-interactor", inputs: ["navigationState", "canZoomOut", "canZoomIn"], outputs: ["navigate", "zoomIn", "zoomOut"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ImageViewerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-image-viewer',
                    templateUrl: './image-viewer.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$2.DomSanitizer }]; }, propDecorators: { source: [{
                type: Input
            }], navigationState: [{
                type: Input
            }], navigate: [{
                type: Output
            }] } });

class DocumentViewerContainerComponent {
    constructor(elemRef) {
        this.elemRef = elemRef;
        this.documentRefSrcs = [];
        // eslint-disable-next-line
        this.close = new EventEmitter();
        this.isLoading$ = new BehaviorSubject(false);
        this.isHttpError$ = new BehaviorSubject(false);
        this.documentType = DocumentViewerType;
        /**
         * Internal
         */
        this.activeDocumentRefIdx$ = new ReplaySubject(1);
        this.destroy$ = new Subject();
    }
    set activeDocumentRefIdx(idx) {
        this.activeDocumentRefIdx$.next(idx);
    }
    get containerStyles() {
        var _a, _b;
        return ((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.container) === null || _b === void 0 ? void 0 : _b.styles) || null;
    }
    get viewerScale() {
        var _a;
        return (_a = this.options) === null || _a === void 0 ? void 0 : _a.scale;
    }
    ngOnInit() {
        this.setDocumentRefChangeSources();
        this.setFocus();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onEscape() {
        this.close.emit();
    }
    closeDialog() {
        this.close.emit();
    }
    onNavigate(idx) {
        this.activeDocumentRefIdx$.next(idx);
    }
    setDocumentRefChangeSources() {
        this.documentSrc$ = this.activeDocumentRefIdx$.pipe(distinctUntilChanged(), tap(() => {
            this.isLoading$.next(true);
            this.isHttpError$.next(false);
        }), switchMap((idx) => combineLatest([this.documentRefSrcs[idx].src, timer(DOCUMENT_LOAD_DELAY_MS)]).pipe(map(([src]) => src), finalize(() => {
            this.isLoading$.next(false);
        }))), catchError((error) => {
            this.isHttpError$.next(true);
            throw error;
        }), share());
        this.documentFilename$ = this.activeDocumentRefIdx$.pipe(map((idx) => this.documentRefSrcs[idx].filename));
        this.documentFiletype$ = this.activeDocumentRefIdx$.pipe(map((idx) => this.documentRefSrcs[idx].filetype));
        this.navigationState$ = this.activeDocumentRefIdx$.pipe(map((idx) => ({ currIdx: idx, total: this.documentRefSrcs.length })));
    }
    setFocus() {
        this.elemRef.nativeElement.focus();
    }
}
DocumentViewerContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerContainerComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
DocumentViewerContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DocumentViewerContainerComponent, selector: "bb-document-viewer-container", inputs: { documentRefSrcs: "documentRefSrcs", activeDocumentRefIdx: "activeDocumentRefIdx", options: "options" }, outputs: { close: "close" }, host: { listeners: { "document:keydown.escape": "onEscape()" } }, viewQueries: [{ propertyName: "viewContainer", first: true, predicate: ["viewerContainer"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: "<div\n  class=\"bb-document-viewer-container show\"\n  role=\"dialog\"\n  aria-modal=\"true\"\n  tabindex=\"-1\"\n  [ngStyle]=\"containerStyles\"\n  cdkTrapFocus\n  cdkTrapFocusAutoCapture=\"true\"\n>\n  <div class=\"bb-document-viewer-container__wrapper\">\n    <bb-document-viewer-header\n      data-role=\"document-viewer-header\"\n      [filename]=\"(documentFilename$ | async)!\"\n      [source]=\"(documentSrc$ | async)!\"\n      [filetype]=\"(documentFiletype$ | async)!\"\n      [isLoading]=\"(isLoading$ | async)!\"\n      (close)=\"close.emit()\"\n    ></bb-document-viewer-header>\n\n    <ng-container *ngIf=\"documentSrc$ | async as source\">\n      <ng-container *ngIf=\"!(isLoading$ | async) && !(isHttpError$ | async)\">\n        <div\n          class=\"bb-document-viewer-container-image\"\n          *ngIf=\"documentFiletype$ | async as documentFiletype\"\n          (click)=\"closeDialog()\"\n        >\n          <bb-image-viewer\n            data-role=\"document-viewer-image\"\n            [source]=\"source\"\n            [navigationState]=\"(navigationState$ | async)!\"\n            (navigate)=\"onNavigate($event)\"\n          ></bb-image-viewer>\n        </div>\n      </ng-container>\n    </ng-container>\n\n    <bb-loading-indicator-ui\n      *ngIf=\"isLoading$ | async\"\n      class=\"bb-document-viewer-container__state\"\n      data-role=\"document-viewer-loading-state\"\n      loaderSize=\"lg\"\n    >\n    </bb-loading-indicator-ui>\n\n    <bb-empty-state-ui\n      *ngIf=\"!(isLoading$ | async) && (isHttpError$ | async)\"\n      data-role=\"document-viewer-error-state\"\n      class=\"bb-document-viewer-container__state\"\n      iconColor=\"white\"\n      iconModifier=\"error-outline\"\n      iconSize=\"xxl\"\n      title=\"Unknown Error\"\n      i18n-title=\"Unknown http error title@@document-viewer-component.uknown-error-title\"\n      subtitle=\"Try to reload the page or contact the system administrator\"\n      i18n-subtitle=\"\n        Try to reload the page or contact the system administrator@@document-viewer-component.uknown-error-subtitle\"\n    ></bb-empty-state-ui>\n  </div>\n</div>\n", components: [{ type: DocumentViewerHeaderComponent, selector: "bb-document-viewer-header", inputs: ["filename", "filetype", "source", "isLoading"], outputs: ["close"] }, { type: ImageViewerComponent, selector: "bb-image-viewer", inputs: ["source", "navigationState"], outputs: ["navigate"] }, { type: i3$2.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i4.EmptyStateComponent, selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }], directives: [{ type: i5.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }, { type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i2.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DocumentViewerContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-document-viewer-container',
                    templateUrl: './document-viewer-container.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { documentRefSrcs: [{
                type: Input
            }], activeDocumentRefIdx: [{
                type: Input
            }], options: [{
                type: Input
            }], close: [{
                type: Output
            }], viewContainer: [{
                type: ViewChild,
                args: ['viewerContainer', { static: true, read: ViewContainerRef }]
            }], onEscape: [{
                type: HostListener,
                args: ['document:keydown.escape']
            }] } });

class TransactionCheckImageDocumentViewerComponent {
    constructor() {
        this.position = 0;
        this.closeViewer = new EventEmitter();
    }
    toDocumentRefSrc(...images) {
        return images
            .filter((item) => !!item)
            .map((image) => {
            const { mimeType, content, side } = image;
            const fileType = image === null || image === void 0 ? void 0 : image.mimeType.replace('image/', '');
            const filename = `${this.imageCheckNumber}-${side}.${fileType}`;
            return {
                filename,
                filetype: image === null || image === void 0 ? void 0 : image.mimeType,
                src: of(`data:${mimeType};base64,${content}`),
            };
        });
    }
    get imagesRefsSrc() {
        return this.toDocumentRefSrc(this.imageFront, this.imageBack);
    }
    closeDocumentViewer() {
        this.closeViewer.emit();
    }
    trapKeyEvent(event) {
        if (getKeyCode(event) !== KEY_CODES.ESCAPE) {
            event.stopPropagation();
        }
    }
}
TransactionCheckImageDocumentViewerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCheckImageDocumentViewerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionCheckImageDocumentViewerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionCheckImageDocumentViewerComponent, selector: "bb-transaction-check-image-document-viewer", inputs: { imageCheckNumber: "imageCheckNumber", imageFront: "imageFront", imageBack: "imageBack", position: "position" }, outputs: { closeViewer: "closeViewer" }, ngImport: i0, template: "<div (keydown)=\"trapKeyEvent($event)\" (keyup)=\"trapKeyEvent($event)\">\n  <bb-document-viewer-backdrop></bb-document-viewer-backdrop>\n  <bb-document-viewer-container\n    [documentRefSrcs]=\"imagesRefsSrc\"\n    [activeDocumentRefIdx]=\"position\"\n    cdkTrapFocus\n    (close)=\"closeDocumentViewer()\"\n  ></bb-document-viewer-container>\n</div>\n", components: [{ type: DocumentViewerBackdropComponent, selector: "bb-document-viewer-backdrop", inputs: ["options"] }, { type: DocumentViewerContainerComponent, selector: "bb-document-viewer-container", inputs: ["documentRefSrcs", "activeDocumentRefIdx", "options"], outputs: ["close"] }], directives: [{ type: i5.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCheckImageDocumentViewerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transaction-check-image-document-viewer',
                    templateUrl: 'transaction-check-image-document-viewer.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { imageCheckNumber: [{
                type: Input
            }], imageFront: [{
                type: Input
            }], imageBack: [{
                type: Input
            }], position: [{
                type: Input
            }], closeViewer: [{
                type: Output
            }] } });

class TransactionCheckImageComponent {
    constructor() {
        this.loadingStateEnum = TransactionsDetailsLoadingState;
        /**
         * Index to display in the document viewer. For the purpose of hidding and showing
         * the viewer this will be base 1
         * when the value is 0 the document viewer will not be visible
         */
        this.index = 0;
    }
    /**
     * The check image object.
     */
    // eslint-disable-next-line
    set checkImagesList(value) {
        this.imageFront = value && value.images.find((data) => data.side === TransactionsCheckImageSide.FRONT);
        this.imageBack = value && value.images.find((data) => data.side === TransactionsCheckImageSide.BACK);
    }
    get hasErrors() {
        return (this.transactionDetailsLoadingStatus &&
            this.transactionDetailsLoadingStatus.checkImages &&
            this.transactionDetailsLoadingStatus.checkImages < 0);
    }
    get isDone() {
        return (this.transactionDetailsLoadingStatus &&
            this.transactionDetailsLoadingStatus.checkImages === TransactionsDetailsLoadingState.done);
    }
    onClose() {
        this.index = 0;
    }
    selectImage(index) {
        this.index = index;
    }
}
TransactionCheckImageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCheckImageComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionCheckImageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionCheckImageComponent, selector: "bb-transaction-check-image", inputs: { transaction: "transaction", checkImagesList: "checkImagesList", transactionDetailsLoadingStatus: "transactionDetailsLoadingStatus" }, ngImport: i0, template: "<ng-container *ngIf=\"isDone || hasErrors; else loadingState\">\n  <div class=\"bb-stack bb-stack--wrap\">\n    <div class=\"bb-stack__item\">\n      <bb-transaction-check-image-item\n        *ngIf=\"!!imageFront || hasErrors\"\n        [image]=\"imageFront\"\n        data-role=\"check-image-item-front\"\n        (selectImage)=\"selectImage(1)\"\n        [transaction]=\"transaction\"\n        sideText=\"Front\"\n        imageAlt=\"Front check image\"\n        i18n-sideText=\"Front side title of check image@@transactions.detail.check-image.front.title\"\n        i18n-imageAlt=\"Front side alt of check image@@transactions.detail.check-image.front.alt-image\"\n      ></bb-transaction-check-image-item>\n    </div>\n\n    <div class=\"bb-stack__item\">\n      <bb-transaction-check-image-item\n        *ngIf=\"!!imageBack || hasErrors\"\n        data-role=\"check-image-item-back\"\n        (selectImage)=\"selectImage(imageFront ? 2 : 1)\"\n        [image]=\"imageBack\"\n        [transaction]=\"transaction\"\n        sideText=\"Back\"\n        imageAlt=\"Back check image\"\n        i18n-sideText=\"Back side title of check image@@transactions.detail.check-image.back.title\"\n        i18n-imageAlt=\"Back side alt of check image@@transactions.detail.check-image.back.alt-image\"\n      ></bb-transaction-check-image-item>\n    </div>\n  </div>\n\n  <bb-transaction-check-image-document-viewer\n    *ngIf=\"index > 0\"\n    data-role=\"check-image-document-viewer\"\n    [imageCheckNumber]=\"transaction?.checkSerialNumber\"\n    [imageFront]=\"imageFront\"\n    [imageBack]=\"imageBack\"\n    [position]=\"index - 1\"\n    (closeViewer)=\"onClose()\"\n  ></bb-transaction-check-image-document-viewer>\n\n  <ng-container *ngIf=\"hasErrors\">\n    <span\n      i18n=\"Something went wrong@@transactions.detail.check-image.server-error\"\n      class=\"bb-input-validation-message\"\n      data-role=\"check-image-server-error-state\"\n      *ngIf=\"transactionDetailsLoadingStatus?.checkImages === loadingStateEnum?.serverError\"\n    >\n      Something went wrong. Please try again later.\n    </span>\n\n    <span\n      i18n=\"Check images cannot be viewed at the moment@@transactions.detail.check-image.bad-request-error\"\n      class=\"bb-input-validation-message\"\n      data-role=\"check-image-bad-request-error-state\"\n      *ngIf=\"transactionDetailsLoadingStatus?.checkImages === loadingStateEnum?.badRequestError\"\n    >\n      Check images cannot be viewed at the moment, please try again later or contact your financial institution.\n    </span>\n\n    <span\n      i18n=\"Check images cannot be viewed at the moment@@transactions.detail.check-image.not-found-error\"\n      class=\"bb-input-validation-message\"\n      data-role=\"check-image-not-found-error-state\"\n      *ngIf=\"transactionDetailsLoadingStatus?.checkImages === loadingStateEnum?.notFoundError\"\n    >\n      Check images cannot be viewed at the moment, please try again later or contact your financial institution.\n    </span>\n  </ng-container>\n</ng-container>\n\n<ng-template #loadingState>\n  <bb-loading-indicator-ui loaderSize=\"lg\"></bb-loading-indicator-ui>\n</ng-template>\n", components: [{ type: TransactionCheckImageItemComponent, selector: "bb-transaction-check-image-item", inputs: ["image", "transaction", "sideText", "imageAlt"], outputs: ["selectImage"] }, { type: TransactionCheckImageDocumentViewerComponent, selector: "bb-transaction-check-image-document-viewer", inputs: ["imageCheckNumber", "imageFront", "imageBack", "position"], outputs: ["closeViewer"] }, { type: i3$2.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCheckImageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transaction-check-image',
                    templateUrl: './transaction-check-image.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { transaction: [{
                type: Input
            }], checkImagesList: [{
                type: Input
            }], transactionDetailsLoadingStatus: [{
                type: Input
            }] } });

class TransactionsInquiryDisputeComponent {
    constructor(fb) {
        this.fb = fb;
        this.enableDispute = false;
        /**
         * Whether the dispute & inquiry form is sending or not.
         */
        this.state = TransactionsDetailsLoadingState.notStarted;
        this.submitReport = new EventEmitter();
        this.cancelReport = new EventEmitter();
        this.messageChange = new EventEmitter();
        this.fileChange = new EventEmitter();
        this.fileRemoved = new EventEmitter();
        this.confirmationDialogActive = false;
        this.labels = {
            inquire: $localize `:Inquire tooltip@@transactions.dispute.inquire.inquireLabel:Inquire for more information`,
            dispute: $localize `:Dispute tooltip@@transactions.dispute.inquire.disputeLabel:Dispute this transaction`,
        };
        this.loadingStateEnum = TransactionsDetailsLoadingState;
        this.unsubscribeSubject = new Subject();
        this.transactionReportForm = this.fb.group({
            topic: [{ value: '' }, this.topicRequired],
            attachment: [undefined],
            subject: [{ name: '' }],
            body: [''],
        });
    }
    topicRequired(control) {
        var _a;
        return ((_a = control.value) === null || _a === void 0 ? void 0 : _a.value) === '' ? { required: 'value is required' } : null;
    }
    getControl(field) {
        return this.transactionReportForm.controls[field];
    }
    setFormValue(values) {
        this.transactionReportForm.patchValue({
            body: values.body,
            attachments: values.attachments,
        }, { emitEvent: false });
    }
    hasError(field, type) {
        const control = this.getControl(field);
        return control && control.errors && control.errors[type];
    }
    isInvalidControl(field) {
        const control = this.getControl(field);
        return !!control && control.touched && control.invalid;
    }
    saveReport() {
        if (this.transactionReportForm.valid) {
            this.submitReport.emit(this.message);
        }
        else {
            this.transactionReportForm.markAllAsTouched();
        }
    }
    closeReportForm() {
        this.cancelReport.emit();
        this.closeConfirmationDialog();
    }
    closeConfirmationDialog() {
        this.confirmationDialogActive = false;
    }
    processLabel(label) {
        const arr = label.split(' ');
        const last = arr.splice(arr.length - 1, 1);
        return [arr.join(' ') + ' ', ...last];
    }
    ngOnInit() {
        if (this.message) {
            this.setFormValue(this.message);
        }
        this.transactionReportForm.valueChanges.pipe(takeUntil(this.unsubscribeSubject)).subscribe({
            next: (formValue) => {
                this.messageChange.emit(Object.assign(Object.assign({}, this.message), formValue));
            },
        });
    }
    uploadFile(input) {
        if (input.files && input.files[0]) {
            const file = input.files[0];
            this.fileChange.emit(file);
            input.value = '';
        }
    }
    removeAttachment(attachment) {
        this.fileRemoved.emit(attachment);
    }
    ngOnDestroy() {
        this.unsubscribeSubject.next();
        this.unsubscribeSubject.complete();
    }
}
TransactionsInquiryDisputeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsInquiryDisputeComponent, deps: [{ token: i1$4.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });
TransactionsInquiryDisputeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsInquiryDisputeComponent, selector: "bb-transactions-inquiry-dispute", inputs: { message: "message", enableDispute: "enableDispute", state: "state", inquireAndDisputeTopics: "inquireAndDisputeTopics" }, outputs: { submitReport: "submitReport", cancelReport: "cancelReport", messageChange: "messageChange", fileChange: "fileChange", fileRemoved: "fileRemoved" }, ngImport: i0, template: "<div class=\"bb-transaction-list-item-detail-additional-info\">\n  <form [formGroup]=\"transactionReportForm\">\n    <div class=\"bb-block bb-block--lg\" bbAccessibilityKeyboard>\n      <h5\n        class=\"bb-transaction-list-item-detail-additional-info__title\"\n        data-role=\"dispute-inquiry-header\"\n        i18n=\"dispute and inquiry form header@@transactions.dispute.inquiry.header\"\n      >\n        Does this transaction seem suspicious or incorrect?\n      </h5>\n      <p\n        class=\"bb-text-support text-small\"\n        data-role=\"dispute-inquiry-subHeader\"\n        i18n=\"dispute and inquiry form subHeader@@transactions.dispute.inquiry.subHeader\"\n      >\n        It\u2019s important to provide as much detail as possible for the bank employee to quickly and accurately review your\n        issue.\n      </p>\n    </div>\n\n    <div class=\"form-group bb-block bb-block--lg\">\n      <bb-input-radio-group-ui\n        aria-labelledby=\"'label-transaction-dispute'\"\n        [horizontal]=\"false\"\n        formControlName=\"topic\"\n        verticalAlign=\"top\"\n      >\n        <bb-input-radio-ui\n          value=\"dispute\"\n          [labelTemplate]=\"optionsLabel\"\n          labelTemplateContext=\"dispute\"\n          [disabled]=\"!enableDispute\"\n        ></bb-input-radio-ui>\n        <bb-input-radio-ui\n          value=\"inquire\"\n          [labelTemplate]=\"optionsLabel\"\n          labelTemplateContext=\"inquire\"\n        ></bb-input-radio-ui>\n      </bb-input-radio-group-ui>\n      <bb-input-validation-message-ui [showErrors]=\"isInvalidControl('topic')\">\n        <span\n          *ngIf=\"hasError('topic', 'required')\"\n          i18n=\"Error message if field is required@@transactions.dispute.errors.operationRequired\"\n        >\n          Required field\n        </span>\n      </bb-input-validation-message-ui>\n    </div>\n\n    <div class=\"form-group bb-block\" [ngClass]=\"{ 'bb-block--sm': isInvalidControl('body') }\">\n      <bb-rich-text-editor-ui\n        aria-label=\"Report body\"\n        formControlName=\"body\"\n        placeholder=\"Please tell us more about this transaction...\"\n        i18n-aria-label=\"label report body body@@transactions.dispute.inquiry.body.label\"\n        i18n-placeholder=\"Place holder for messages body@@transactions.dispute.inquiry.body.message\"\n        [readonly]=\"false\"\n        [required]=\"true\"\n      ></bb-rich-text-editor-ui>\n\n      <bb-input-validation-message-ui [showErrors]=\"isInvalidControl('body')\">\n        <span\n          *ngIf=\"hasError('body', 'required')\"\n          i18n=\"Error message if field is required@@transactions.dispute.errors.bodyRequired\"\n        >\n          Required field\n        </span>\n      </bb-input-validation-message-ui>\n    </div>\n\n    <div class=\"form-group bb-block bb-block--sm\">\n      <bb-input-file-ui\n        label=\"Default file input\"\n        data-role=\"attachment-file-input\"\n        [disabled]=\"state === loadingStateEnum.loading\"\n        (change)=\"uploadFile($any($event.target))\"\n      ></bb-input-file-ui>\n    </div>\n\n    <div class=\"row bb-inquire-dispute-attachments\" *ngIf=\"message?.attachments?.length\">\n      <div *ngFor=\"let attachment of message?.attachments\" class=\"col-md-6 bb-inquire-dispute-attachments__item\">\n        <div class=\"bb-block bb-block--md\">\n          <bb-file-attachment-ui\n            data-role=\"attachment-file\"\n            [name]=\"attachment.name\"\n            [size]=\"attachment.size\"\n            [fileContent]=\"attachment.content\"\n            [block]=\"true\"\n            [loading]=\"attachment.id === undefined\"\n            [deletable]=\"attachment.id !== undefined\"\n            (delete)=\"removeAttachment(attachment)\"\n          ></bb-file-attachment-ui>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"bb-block bb-block--xl bb-text-align-left\">\n      <ng-container *ngIf=\"state === loadingStateEnum.error\">\n        <bb-alert-ui\n          title=\"Couldn\u2019t send your message\"\n          data-role=\"send-report-failed\"\n          message=\"Something went wrong. Please try again.\"\n          i18n-title=\"\n            Send report failed notification|Message for a notification displayed when sending transaction report request\n            has failed@@transactions.notification.error.send.title\"\n          i18n-message=\"Send report failed notification message@@transactions.notification.error.send.message\"\n        ></bb-alert-ui>\n      </ng-container>\n    </div>\n\n    <div class=\"bb-button-bar\">\n      <bb-load-button-ui\n        bbButton\n        color=\"primary\"\n        class=\"bb-button-bar__button\"\n        data-role=\"dispute-inquiry-send-button\"\n        [isLoading]=\"state === loadingStateEnum.loading\"\n        (click)=\"state !== loadingStateEnum.loading && saveReport()\"\n        i18n=\"Send button@@transactions.dispute.inquiry.button.send\"\n      >\n        Send\n      </bb-load-button-ui>\n      <button\n        *ngIf=\"state !== loadingStateEnum.loading\"\n        bbButton\n        type=\"button\"\n        color=\"secondary\"\n        data-role=\"dispute-inquiry-cancel-button\"\n        class=\"bb-button-bar__button\"\n        (click)=\"confirmationDialogActive = true\"\n        i18n=\"Cancel button@@transactions.dispute.inquiry.button.cancel\"\n      >\n        Cancel\n      </button>\n    </div>\n  </form>\n</div>\n\n<ng-template #disputeTipContent>\n  <div class=\"bb-text-align-left\">\n    <span i18n=\"Description inside a tooltip@@transactions.dispute.inquiry.tooltip.description\">\n      If this transaction is incorrect, you can raise a claim for a refund.\n    </span>\n  </div>\n</ng-template>\n\n<ng-template #inqueryTipContent>\n  <div class=\"bb-text-align-left\">\n    <span i18n=\"Description inside inquery tooltip@@transactions.dispute.inquiry.tooltip.description\">\n      If you are suspicious about this transaction, you can ask the bank to gather more information about it.\n    </span>\n  </div>\n</ng-template>\n\n<ng-template #optionsLabel let-context=\"labelTemplateContext\">\n  <ng-container *ngIf=\"context === 'dispute'\">\n    <span class=\"bb-input-radio-group__radio-label\">\n      {{ processLabel(labels.dispute)[0] }}\n    </span>\n    <span class=\"d-inline-block\">\n      <span class=\"bb-input-radio-group__radio-label\">\n        {{ processLabel(labels.dispute)[1] }}\n      </span>\n      <bb-icon-ui\n        class=\"bb-transactions-list-pending-header__tooltip bb-transactions-list-pending-header__tooltip--md-top\"\n        role=\"tooltip\"\n        name=\"info\"\n        size=\"md\"\n        [bbTooltip]=\"disputeTipContent\"\n        triggers=\"hover click\"\n        placement=\"right\"\n        bbAccessibilityKeyboard\n      ></bb-icon-ui>\n      <bb-icon-ui\n        class=\"bb-transactions-list-pending-header__tooltip bb-transactions-list-pending-header__tooltip--sm-bottom\"\n        role=\"tooltip\"\n        name=\"info\"\n        size=\"md\"\n        [bbTooltip]=\"disputeTipContent\"\n        triggers=\"hover click\"\n        placement=\"left\"\n        bbAccessibilityKeyboard\n      ></bb-icon-ui>\n      <span\n        class=\"sr-only\"\n        i18n=\"Description inside a tooltip@@transactions.dispute.inquiry.tooltip.hidden.description\"\n      >\n        If this transaction is incorrect, you can raise a claim for a refund.\n      </span>\n    </span>\n  </ng-container>\n\n  <ng-container *ngIf=\"context === 'inquire'\">\n    <span class=\"bb-input-radio-group__radio-label\">\n      {{ processLabel(labels.inquire)[0] }}\n    </span>\n    <span class=\"d-inline-block\">\n      <span class=\"bb-input-radio-group__radio-label\">\n        {{ processLabel(labels.inquire)[1] }}\n      </span>\n      <bb-icon-ui\n        class=\"bb-transactions-list-pending-header__tooltip bb-transactions-list-pending-header__tooltip--md-top\"\n        role=\"tooltip\"\n        name=\"info\"\n        size=\"md\"\n        [bbTooltip]=\"inqueryTipContent\"\n        triggers=\"hover click\"\n        placement=\"right\"\n        bbAccessibilityKeyboard\n      ></bb-icon-ui>\n      <bb-icon-ui\n        class=\"bb-transactions-list-pending-header__tooltip bb-transactions-list-pending-header__tooltip--sm-bottom\"\n        role=\"tooltip\"\n        name=\"info\"\n        size=\"md\"\n        [bbTooltip]=\"inqueryTipContent\"\n        triggers=\"hover click\"\n        placement=\"top\"\n        bbAccessibilityKeyboard\n      ></bb-icon-ui>\n      <span\n        class=\"sr-only\"\n        i18n=\"Description inside inquery tooltip@@transactions.dispute.inquiry.tooltip.hidden.description\"\n      >\n        If you are suspicious about this transaction, you can ask the bank to gather more information about it.\n      </span>\n    </span>\n  </ng-container>\n</ng-template>\n\n<!-- Cancel Dispute or Inquiry -->\n<bb-modal-ui [isOpen]=\"confirmationDialogActive\" (cancel)=\"closeConfirmationDialog()\">\n  <div class=\"modal-header\">\n    <h2\n      id=\"modal-basic-title\"\n      class=\"modal-title\"\n      data-role=\"discard-report-modal-header\"\n      i18n=\"Discard your report?|Discard report modal title@@transactions.dispute.inquiry.discard.report.modal.title\"\n    >\n      Discard your report?\n    </h2>\n  </div>\n\n  <div class=\"modal-body\">\n    <span\n      data-role=\"discard-report-modal-subHeader\"\n      i18n=\"All entered data will be lost.|Discard report info@@transactions.dispute.inquiry.discard.report.modal.info\"\n    >\n      All entered data will be lost.\n    </span>\n  </div>\n\n  <div class=\"modal-footer\">\n    <div class=\"bb-button-bar\">\n      <button\n        bbButton\n        color=\"danger\"\n        class=\"bb-button-bar__button\"\n        data-role=\"discard-report-modal-discard-button\"\n        (click)=\"closeReportForm()\"\n        i18n=\"Discard|Discard report button label@@transactions.dispute.inquiry.discard.report.modal.discard.button\"\n      >\n        Discard\n      </button>\n\n      <button\n        bbButton\n        color=\"secondary\"\n        class=\"bb-button-bar__button\"\n        data-role=\"discard-report-modal-cancel-button\"\n        (click)=\"closeConfirmationDialog()\"\n        i18n=\"Cancel|Cancel button label@@transactions.dispute.inquiry.discard.report.modal.cancel.button\"\n      >\n        Cancel\n      </button>\n    </div>\n  </div>\n</bb-modal-ui>\n", components: [{ type: i2$2.InputRadioGroupComponent, selector: "bb-input-radio-group-ui", inputs: ["horizontal", "preselect", "name", "verticalAlign"] }, { type: i2$2.InputRadioComponent, selector: "bb-input-radio-ui", inputs: ["labelTemplate", "labelTemplateContext", "value", "label", "aria-label", "aria-labelledby", "aria-describedby", "role", "aria-activedescendant", "aria-expanded", "aria-invalid", "aria-owns", "disabled"] }, { type: i3$3.InputValidationMessageComponent, selector: "bb-input-validation-message-ui", inputs: ["showErrors", "messageId"] }, { type: i4$1.RichTextEditorComponent, selector: "bb-rich-text-editor-ui", inputs: ["maxLength", "minLength", "placeholder", "counter", "readonly", "actionsTooltipPlacement"] }, { type: i5$1.InputFileComponent, selector: "bb-input-file-ui", inputs: ["accept", "maxSizeInMb", "multiple", "color", "autofocus", "buttonText", "buttonSize", "iconName"] }, { type: i6.FileAttachmentComponent, selector: "bb-file-attachment-ui", inputs: ["name", "size", "fileContent", "loading", "deletable", "disabled", "block"], outputs: ["delete"] }, { type: i7.AlertComponent, selector: "bb-alert-ui", inputs: ["modifier", "dismissible", "title", "message"], outputs: ["close"] }, { type: i8.LoadButtonComponent, selector: "bb-load-button-ui", inputs: ["isLoading", "from", "size", "circle", "totalCount"], outputs: ["paramChange"] }, { type: i1$3.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i10.ModalComponent, selector: "bb-modal-ui", inputs: ["isOpen", "aria-labelledby", "aria-describedby", "modalOptions"], outputs: ["confirm", "cancel", "isOpenChange"] }], directives: [{ type: i1$4.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i1$4.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i1$4.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: AccessibilityKeyboardDirective, selector: "[bbAccessibilityKeyboard]" }, { type: i1$4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i1$4.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1$4.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3$1.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i14.TooltipDirective, selector: "[bbTooltip]", inputs: ["bbTooltip", "triggers"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsInquiryDisputeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transactions-inquiry-dispute',
                    templateUrl: 'transactions-inquiry-dispute.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$4.FormBuilder }]; }, propDecorators: { message: [{
                type: Input
            }], enableDispute: [{
                type: Input
            }], state: [{
                type: Input
            }], inquireAndDisputeTopics: [{
                type: Input
            }], submitReport: [{
                type: Output
            }], cancelReport: [{
                type: Output
            }], messageChange: [{
                type: Output
            }], fileChange: [{
                type: Output
            }], fileRemoved: [{
                type: Output
            }] } });

class TransactionsDisputeStatusTagComponent {
}
TransactionsDisputeStatusTagComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsDisputeStatusTagComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionsDisputeStatusTagComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsDisputeStatusTagComponent, selector: "bb-dispute-status-tag", inputs: { status: "status" }, ngImport: i0, template: "<ng-container *ngIf=\"status === 'PENDING'\">\n  <bb-badge-ui\n    text=\"Dispute Pending\"\n    i18n-text=\"Dispute pending|Text for pending disputed transaction label@@transaction.dispute.status.pending\"\n    color=\"warning\"\n    data-role=\"dispute-pending-tag\"\n  ></bb-badge-ui>\n</ng-container>\n\n<ng-container *ngIf=\"status === 'REFUNDED'\">\n  <bb-badge-ui\n    text=\"Refunded\"\n    i18n-text=\"Dispute refunded|Text for refunded disputed transaction label@@transaction.dispute.status.refunded\"\n    color=\"success\"\n    data-role=\"dispute-refunded-tag\"\n  ></bb-badge-ui>\n</ng-container>\n\n<ng-container *ngIf=\"status === 'REJECTED'\">\n  <bb-badge-ui\n    text=\"Dispute Rejected\"\n    i18n-text=\"Dispute rejected|Text for rejected disputed transaction label@@transaction.dispute.status.rejected\"\n    color=\"danger\"\n    data-role=\"dispute-rejected-tag\"\n  ></bb-badge-ui>\n</ng-container>\n", components: [{ type: i1$5.BadgeComponent, selector: "bb-badge-ui", inputs: ["color", "text", "abbr", "circle", "wrap", "ariaLabel"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsDisputeStatusTagComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-dispute-status-tag',
                    templateUrl: 'transaction-dispute-status-tag.component.html',
                }]
        }], propDecorators: { status: [{
                type: Input
            }] } });

class TransactionsDisputeBannerComponent {
    constructor() {
        this.disputeStatus = DisputeStatusEnum;
    }
}
TransactionsDisputeBannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsDisputeBannerComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionsDisputeBannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsDisputeBannerComponent, selector: "bb-dispute-banner", inputs: { transaction: "transaction" }, ngImport: i0, template: "<ng-container>\n  <bb-alert-ui\n    *ngIf=\"transaction?.disputeStatus === disputeStatus.Pending\"\n    modifier=\"info\"\n    data-role=\"dispute-pending-banner\"\n    title=\"You\u2019ve disputed this transaction\"\n    i18n-title=\"\n      Send dispute report success notification|Message for a notification displayed when sending transaction dispute\n      report request has succeed@@transactions.notification.success.send.dispute.title\"\n    message=\"Please go to Messages to view any responses to your request.\"\n    i18n-message=\"\n      Send dispute report success notification message@@transactions.notification.success.send.dispute.message\"\n  ></bb-alert-ui>\n\n  <bb-alert-ui\n    *ngIf=\"transaction?.disputeStatus === disputeStatus.Refunded\"\n    modifier=\"success\"\n    data-role=\"dispute-refunded-banner\"\n    title=\"Your dispute was approved\"\n    i18n-title=\"\n      Dispute report refunded notification|Message for a notification displayed when transaction dispute report request\n      has refunded@@transactions.notification.dispute.refunded.title\"\n    message=\"Please go to Messages to view the process of your refund.\"\n    i18n-message=\"Dispute report reunded notification message@@transactions.notification.dispute.refunded.message\"\n  ></bb-alert-ui>\n\n  <bb-alert-ui\n    *ngIf=\"transaction?.disputeStatus === disputeStatus.Rejected\"\n    modifier=\"error\"\n    data-role=\"dispute-rejected-banner\"\n    title=\"Your dispute was rejected\"\n    i18n-title=\"\n      Dispute report rejected notification|Message for a notification displayed when transaction dispute report request\n      has rejected@@transactions.notification.dispute.rejected.title\"\n    message=\"Please go to Messages to view the reason for this rejection.\"\n    i18n-message=\"Dispute report rejected notification message@@transactions.notification.dispute.rejected.message\"\n  ></bb-alert-ui>\n</ng-container>\n", components: [{ type: i7.AlertComponent, selector: "bb-alert-ui", inputs: ["modifier", "dismissible", "title", "message"], outputs: ["close"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsDisputeBannerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-dispute-banner',
                    templateUrl: 'transaction-dispute-banner.component.html',
                }]
        }], propDecorators: { transaction: [{
                type: Input
            }] } });

/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsBackendError;
(function (TransactionsBackendError) {
    const getMessageFromResponse = (error) => {
        const responseBody = error.error;
        if (Array.isArray(responseBody === null || responseBody === void 0 ? void 0 : responseBody.errors)) {
            return responseBody.errors.map((data) => {
                const { context = {} } = data;
                const message = data.message.replace(/{[_a-zA-Z][_a-zA-Z0-9]*}/g, (match) => {
                    const result = context[match.replace(/[{}']+/g, '')];
                    return result !== undefined ? result : match;
                });
                return `Error ${error.status}: ${message}`;
            });
        }
        else {
            return undefined;
        }
    };
    /* eslint-enable no-redeclare*/
    /**
     * @name fromHttpErrorResponse
     * @param errorResponse The error response
     * @returns An object containing a user-friendly error message
     *
     * @description
     * Parse an HttpErrorResponse and return a TransactionsError object that can be used to display a
     * user-friendly error message.
     */
    TransactionsBackendError.fromHttpErrorResponse = (errorResponse) => {
        if (errorResponse.error instanceof ErrorEvent) {
            // Client-side or network error.
            return {
                message: 'An unexpected error occurred',
            };
        }
        else {
            const error = getMessageFromResponse(errorResponse) || [];
            return {
                message: error[0] || `Error ${errorResponse.status}`,
            };
        }
    };
    TransactionsBackendError.fromHttpErrorsResponse = (errorResponse) => {
        if (errorResponse.error instanceof ErrorEvent || !errorResponse.status) {
            // Client-side or network error.
            return [
                {
                    message: 'An unexpected error occurred',
                },
            ];
        }
        else {
            const errors = getMessageFromResponse(errorResponse) || [`Error ${errorResponse.status}`];
            return errors.map((message) => ({ message }));
        }
    };
})(TransactionsBackendError || (TransactionsBackendError = {}));

var TransactionsExportErrorType;
(function (TransactionsExportErrorType) {
    TransactionsExportErrorType["MIXED_PRODUCT_KINDS"] = "MIXED_PRODUCT_KINDS";
    TransactionsExportErrorType["UNSUPPORTED_PRODUCT_KIND"] = "UNSUPPORTED_PRODUCT_KIND";
    TransactionsExportErrorType["TOO_MANY_ITEMS"] = "TOO_MANY_ITEMS";
    TransactionsExportErrorType["MULTIPLE_PRODUCTS"] = "MULTIPLE_PRODUCTS";
    TransactionsExportErrorType["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
})(TransactionsExportErrorType || (TransactionsExportErrorType = {}));
function combineExportTypesConfig(exportConfig) {
    let exportTypesArr = [];
    const { availableExportTypesHeader = '', unavailableExportTypesReasonsHeader } = exportConfig;
    const availableExportTypesArray = availableExportTypesHeader.split(',');
    const availableTypes = availableExportTypesArray
        .filter((name) => name !== '')
        .map((name) => ({
        name,
        reason: undefined,
        isAvailable: true,
    }));
    if (unavailableExportTypesReasonsHeader) {
        const unavailableTypes = Object.keys(unavailableExportTypesReasonsHeader).map((name) => {
            if (unavailableExportTypesReasonsHeader && Array.isArray(unavailableExportTypesReasonsHeader[name])) {
                return {
                    name,
                    reason: unavailableExportTypesReasonsHeader[name][0],
                    isAvailable: false,
                };
            }
            return {
                name,
                reason: TransactionsExportErrorType.UNKNOWN_ERROR,
                isAvailable: false,
            };
        });
        exportTypesArr = [...availableTypes, ...unavailableTypes];
    }
    else {
        exportTypesArr = [...availableTypes];
    }
    return [...exportTypesArr].sort((left, right) => {
        if (left.name === right.name) {
            return 0;
        }
        return left.name > right.name ? 1 : -1;
    });
}

class PendingTransactionsService {
    constructor(transactionsDataHttpService, accountService, deprecationsService) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.accountService = accountService;
        this.deprecationsService = deprecationsService;
        this.initialListOptions = new ReplaySubject(1);
        this.selectedAccount = new ReplaySubject(1);
        this.options = new BehaviorSubject({});
        this.listOptions = new BehaviorSubject(defaultInitialListOptions);
        this.listRefresh = new Subject();
        this.getOrPostEndpoint = new BehaviorSubject(EndpointType.GET_REQUEST);
        this.transactionsList = merge(this.listOptions.pipe(filter((listOptions) => typeof listOptions.account.arrangementId !== 'undefined'), distinctUntilChanged(deepEqual)), this.listRefresh).pipe(cacheRequest((listOptions) => {
            this.loadingState.next(listOptions.onLoad === OnLoadAction.Append
                ? LoadingState.LoadingMore
                : listOptions.onLoad === OnLoadAction.ReplacePage
                    ? LoadingState.LoadingPage
                    : LoadingState.Loading);
            return combineLatest([
                this.loadTransactions(listOptions).pipe(tap(() => {
                    this.loadingState.next(LoadingState.Loaded);
                }), map((transactionsList) => ({
                    transactionsList,
                    onLoad: OnLoadAction.ReplacePage,
                }))),
                iif(multipleAccountsPredicate(listOptions), this.accountService.getAllArrangements().pipe(map((accounts) => {
                    const accountMap = new Map();
                    accounts.forEach((account) => {
                        accountMap.set(account.id, account);
                    });
                    return accountMap;
                })), of(new Map())),
            ]).pipe(map(([transactions, accountMap]) => {
                transactions.transactionsList.items = transactions.transactionsList.items.map((transaction) => (Object.assign(Object.assign({}, transaction), { account: accountMap.get(transaction.arrangementId || '') })));
                return transactions;
            }));
        }), scan(onLoadTransactions, { items: [], totalCount: 0 }));
        this.loadingState = new BehaviorSubject(LoadingState.NotLoaded);
        this.isFilterApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.filter || {})));
        this.isSearchApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.search || {})));
        combineLatest([this.selectedAccount, this.initialListOptions])
            .pipe(map(([selectedAccount, initialListOptions]) => (Object.assign({ account: {
                arrangementId: selectedAccount,
            }, pagination: {
                from: 0,
                size: 250,
            }, state: TransactionState.uncompleted }, initialListOptions))))
            .subscribe(this.options);
        // Base this.listOptions on this.options
        this.options
            .pipe(scan((acc, curr) => Object.assign({}, acc, curr), defaultInitialListOptions))
            .subscribe(this.listOptions);
    }
    loadTransactions(listOptions) {
        const transactionPayload = TransactionsList.toHttpRequest(listOptions);
        let transactionsResponse;
        if (this.isUsingPostEndpoints) {
            transactionsResponse = this.transactionsDataHttpService.getTransactionsWithPost({
                transactionListRequest: transactionPayload,
            }, 'response');
        }
        else {
            this.deprecationsService.logDeprecatedFeature('[PendingTransactionsService: loadTransactions] GET endpoints are deprecated. Please use POST endpoints by changing CXP configuration');
            transactionsResponse = this.transactionsDataHttpService.getTransactions(transactionPayload, 'response');
        }
        return transactionsResponse.pipe(map(TransactionsList.fromHttpResponse), catchError((err) => of({
            items: [],
            totalCount: 0,
            httpResponseError: err,
        })));
    }
    getTransactionsFrom(selectedAccount, initialListOptions = of({}), getOrPostEndpoint = of(EndpointType.GET_REQUEST)) {
        selectedAccount.subscribe(this.selectedAccount);
        initialListOptions.subscribe(this.initialListOptions);
        getOrPostEndpoint.subscribe(this.getOrPostEndpoint);
    }
    getTransactionsList() {
        return this.transactionsList;
    }
    search(query) {
        const searchOptions = {
            query,
        };
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions, search: searchOptions }));
    }
    clearSearch() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions }));
    }
    filter(filterOptions) {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions, filter: Object.assign({}, filterOptions) }));
    }
    clearFilter() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions }));
    }
    sort(sortOptions) {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        this.options.next({
            sort: Object.assign({}, sortOptions),
            pagination: Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 }),
        });
    }
    retryFiltering() {
        this.listRefresh.next(this.listOptions.getValue());
    }
    refreshTransactions() {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        const paginationOptions = Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 });
        const newOptions = Object.assign(Object.assign({}, this.listOptions.getValue()), { pagination: paginationOptions });
        if (deepEqual(newOptions, this.listOptions.getValue())) {
            this.listRefresh.next(this.listOptions.getValue());
        }
        else {
            this.options.next({
                pagination: paginationOptions,
            });
        }
    }
    get isUsingPostEndpoints() {
        return this.getOrPostEndpoint.getValue() === EndpointType.POST_REQUEST;
    }
    ngOnDestroy() {
        this.listRefresh.complete();
        this.selectedAccount.complete();
        this.initialListOptions.complete();
        this.options.complete();
        this.listOptions.complete();
        this.loadingState.complete();
        this.getOrPostEndpoint.complete();
    }
}
PendingTransactionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PendingTransactionsService, deps: [{ token: i1$1.TransactionClientHttpService }, { token: AccountsService }, { token: i3.DeprecationsService }], target: i0.ɵɵFactoryTarget.Injectable });
PendingTransactionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PendingTransactionsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PendingTransactionsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TransactionClientHttpService }, { type: AccountsService }, { type: i3.DeprecationsService }]; } });

var GoogleMapsScriptProtocol;
(function (GoogleMapsScriptProtocol) {
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
})(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));

class MapAPILoaderService {
    constructor() {
        this.scriptID = 'bbGoogleMapsApiScript';
        this.callbackName = 'bbMapsAPILoader';
        this.apiLoadPromiseName = 'bbMapsAPILoaderPromise';
        this.windowRef = window;
        this.documentRef = document;
        this.configValue = {};
    }
    get config() {
        return this.configValue;
    }
    set config(config) {
        this.configValue = config;
    }
    get loadAPIPromise() {
        return this.windowRef[this.apiLoadPromiseName];
    }
    assignScriptLoadingPromise(scriptElem) {
        this.windowRef[this.apiLoadPromiseName] = new Promise((resolve, reject) => {
            this.windowRef[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    getScriptSrc(callbackName) {
        const protocolType = (this.configValue && this.configValue.protocol) || GoogleMapsScriptProtocol.HTTPS;
        let protocol = '';
        switch (protocolType) {
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this.configValue.hostAndPath || 'maps.googleapis.com/maps/api/js';
        // make sure we have places library for search component
        const libraries = this.configValue.libraries || [];
        if (libraries.indexOf('places') === -1) {
            this.configValue.libraries = [...libraries, 'places'];
        }
        const queryParams = {
            v: this.configValue.apiVersion || 'quarterly',
            callback: callbackName,
            key: this.configValue.apiKey,
            client: this.configValue.clientId,
            channel: this.configValue.channel,
            libraries: this.configValue.libraries,
            region: this.configValue.region,
            language: this.configValue.language,
        };
        const params = Object.keys(queryParams)
            .filter((key) => queryParams[key] !== undefined)
            .filter((key) => 
        // remove empty arrays
        !Array.isArray(queryParams[key]) ||
            (Array.isArray(queryParams[key]) && queryParams[key].length > 0))
            .map((key) => {
            let value = queryParams[key];
            if (Array.isArray(value)) {
                // join arrays as comma seperated strings
                value = value.join(',');
            }
            return `${key}=${value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
    load() {
        const window = this.windowRef;
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this.loadAPIPromise) {
            return this.loadAPIPromise;
        }
        const script = this.documentRef.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this.scriptID;
        script.src = this.getScriptSrc(this.callbackName);
        this.assignScriptLoadingPromise(script);
        this.documentRef.body.appendChild(script);
        return this.loadAPIPromise;
    }
}
MapAPILoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MapAPILoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService, decorators: [{
            type: Injectable
        }] });

class PaymentsBatchService {
    constructor(batchOrdersHttpService) {
        this.batchOrdersHttpService = batchOrdersHttpService;
    }
    getBatch(batchOrderId) {
        return this.batchOrdersHttpService.getBatchOrdersById({ batchOrderId });
    }
}
PaymentsBatchService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentsBatchService, deps: [{ token: i1$6.BatchOrdersHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
PaymentsBatchService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentsBatchService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentsBatchService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$6.BatchOrdersHttpService }]; } });

class ConfigManager {
    constructor(config) {
        this.config = config;
    }
    isDisputable(transaction) {
        return (this.isBillingStatusApproved(transaction) && !this.isOld(transaction) && this.isOfRestrictedType(transaction));
    }
    isBillingStatusApproved(transaction) {
        var _a;
        if (!((_a = this.config) === null || _a === void 0 ? void 0 : _a.byBillingStatus)) {
            return true;
        }
        return !(transaction === null || transaction === void 0 ? void 0 : transaction.isPending);
    }
    isOld(transaction) {
        var _a;
        if (!(transaction === null || transaction === void 0 ? void 0 : transaction.bookingDate)) {
            return false;
        }
        const days = daysDiff(new Date(), transaction.bookingDate);
        const byEligitibilityDays = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.byEligitibilityDays) || 0;
        return days > byEligitibilityDays;
    }
    isOfRestrictedType(transaction) {
        var _a;
        return (transaction === null || transaction === void 0 ? void 0 : transaction.type) ? (((_a = this.config) === null || _a === void 0 ? void 0 : _a.byTransactionTypes) || []).includes(transaction.type) : false;
    }
}
class TransactionDetailsService {
    constructor(transactionsDataHttpService, mapApiLoader, paymentsBatchService) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.mapApiLoader = mapApiLoader;
        this.paymentsBatchService = paymentsBatchService;
        /**
         * watches the transaction that is shown in the details
         */
        this.transactionSelection = new Subject();
        /**
         * watches the configuration from CXP that can disable/enable check images
         */
        this.hasCheckImages = new ReplaySubject();
        /**
         * general status of each feature that runs asynchronously
         */
        this.transactionsDetailsStatus = new ReplaySubject();
        this.mapsApiKey = new ReplaySubject();
        this.batchOrder = this.transactionSelection.pipe(tap(() => {
            this.transactionsDetailsStatus.next({
                batchOrder: TransactionsDetailsLoadingState.loading,
            });
        }), mergeMap((transaction) => {
            if (!transaction.batchOrderId) {
                return of(undefined);
            }
            return this.paymentsBatchService.getBatch(transaction.batchOrderId).pipe(catchError(() => {
                this.transactionsDetailsStatus.next({
                    batchOrder: TransactionsDetailsLoadingState.error,
                });
                return of(undefined);
            }));
        }), map((data) => {
            this.transactionsDetailsStatus.next({
                batchOrder: data ? TransactionsDetailsLoadingState.done : TransactionsDetailsLoadingState.notStarted,
            });
            return data;
        }));
        this.transactionsDetailsStatus.next({
            checkImages: TransactionsDetailsLoadingState.notStarted,
            geolocation: TransactionsDetailsLoadingState.notStarted,
            enableDisputeAndInquiry: TransactionsDetailsLoadingState.notStarted,
            disputeOption: TransactionsDetailsLoadingState.notStarted,
            batchOrder: TransactionsDetailsLoadingState.notStarted,
        });
    }
    set enableDisputeAndInquiry(value) {
        this.transactionsDetailsStatus.next({
            enableDisputeAndInquiry: value ? TransactionsDetailsLoadingState.done : TransactionsDetailsLoadingState.notLoaded,
        });
    }
    fromInquiryAndDispute(enableDisputeAndInquiry, disputeByBillingStatus, disputeEligibilityDays, disputeTransactionTypes) {
        const config = combineLatest([
            enableDisputeAndInquiry,
            disputeByBillingStatus,
            disputeEligibilityDays,
            disputeTransactionTypes,
        ]).pipe(map(([enabled, byBillingStatus, byEligitibilityDays, byTransactionTypes]) => enabled ? { byBillingStatus, byEligitibilityDays, byTransactionTypes } : undefined));
        combineLatest([this.transactionSelection, config]).subscribe({
            next: ([transactionSelection, inquiryAndDispute]) => {
                if (!inquiryAndDispute) {
                    this.transactionsDetailsStatus.next({
                        enableDisputeAndInquiry: TransactionsDetailsLoadingState.notLoaded,
                        disputeOption: TransactionsDetailsLoadingState.notLoaded,
                    });
                }
                else {
                    const configuration = new ConfigManager(inquiryAndDispute);
                    this.transactionsDetailsStatus.next({
                        enableDisputeAndInquiry: TransactionsDetailsLoadingState.done,
                        disputeOption: configuration.isDisputable(transactionSelection)
                            ? TransactionsDetailsLoadingState.done
                            : TransactionsDetailsLoadingState.notLoaded,
                    });
                }
            },
        });
    }
    /**
     *
     * @param transactionId
     * triggers a new action that will cause transcations details reload and change an image
     */
    selectTransaction(transaction) {
        this.transactionSelection.next(transaction);
    }
    /**
     * Key-value pair that controls the loading status in transactions details
     */
    get loadingState() {
        return this.transactionsDetailsStatus.pipe(scan((acc, curr) => (Object.assign(Object.assign({}, acc), curr)), {}));
    }
    /**
     *
     * @param hasCheckImages
     * Configuration for check images reactive functionality
     */
    fromCheckImages(hasCheckImages) {
        hasCheckImages.subscribe(this.hasCheckImages);
        hasCheckImages
            .pipe(map((value) => ({
            checkImages: value ? TransactionsDetailsLoadingState.loading : TransactionsDetailsLoadingState.notLoaded,
        })))
            .subscribe({
            next: (value) => {
                this.transactionsDetailsStatus.next(value);
            },
        });
        return this.setCondition(this.transactionSelection, this.hasCheckImages).pipe(tap(() => {
            this.transactionsDetailsStatus.next({
                checkImages: TransactionsDetailsLoadingState.loading,
            });
        }), filter((transaction) => transaction.checkImageAvailability === CheckImagesAvailability.available), switchMap(({ id: transactionId = '' }) => this.transactionsDataHttpService.getTransactionCheckImages({ transactionId }, 'response').pipe(tap(() => {
            this.transactionsDetailsStatus.next({
                checkImages: TransactionsDetailsLoadingState.done,
            });
        }), catchError((error) => {
            switch (error.status) {
                case 500: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.serverError,
                    });
                    break;
                }
                case 400: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.badRequestError,
                    });
                    break;
                }
                case 404: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.notFoundError,
                    });
                    break;
                }
                default: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.error,
                    });
                }
            }
            return of(new HttpResponse({
                body: {
                    images: [],
                },
            }));
        }), map(TransactionsCheckImages.fromHttpResponse))));
    }
    fromGeolocation(mapsApiKey) {
        mapsApiKey.subscribe(this.mapsApiKey);
        return combineLatest([this.transactionSelection, this.mapsApiKey]).pipe(map(([transaction, apiKey]) => {
            this.mapApiLoader.config = {
                apiKey,
                libraries: ['geometry'],
            };
            this.transactionsDetailsStatus.next({
                geolocation: TransactionsDetailsLoadingState.loading,
            });
            if (!apiKey || !transaction.location || !transaction.location.latitude || !transaction.location.longitude) {
                this.transactionsDetailsStatus.next({
                    geolocation: TransactionsDetailsLoadingState.notLoaded,
                });
                return Promise.resolve(false);
            }
            return this.mapApiLoader.load().then(() => {
                this.transactionsDetailsStatus.next({
                    geolocation: TransactionsDetailsLoadingState.done,
                });
                return true;
            }, () => {
                this.transactionsDetailsStatus.next({
                    geolocation: TransactionsDetailsLoadingState.error,
                });
                return false;
            });
        }), mergeMap((promise) => from(promise)));
    }
    /**
     * destroy lifecycle hook that will release resources
     */
    ngOnDestroy() {
        this.transactionSelection.complete();
        this.transactionsDetailsStatus.complete();
        this.mapsApiKey.complete();
    }
    /**
     *
     * @param feature
     * @param toggle
     *
     * Prevents from emiting values if the cxp configuration is set as disabled
     */
    setCondition(feature, toggle) {
        return combineLatest([feature, toggle]).pipe(filter(([, condition]) => condition), map(([value]) => value));
    }
}
TransactionDetailsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionDetailsService, deps: [{ token: i1$1.TransactionClientHttpService }, { token: MapAPILoaderService }, { token: PaymentsBatchService }], target: i0.ɵɵFactoryTarget.Injectable });
TransactionDetailsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionDetailsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionDetailsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TransactionClientHttpService }, { type: MapAPILoaderService }, { type: PaymentsBatchService }]; } });

class AvailableFiltersConfigService {
    constructor(accountsService) {
        this.accountsService = accountsService;
        this.availableFiltersConfig$ = new ReplaySubject(1);
        this.selectedAccounts$ = new ReplaySubject(1);
        this.productSummary$ = this.getProductSummaryForSelectedAccounts();
        this.availableFilters$ = this.getAvailableFilters();
    }
    setFilterConfigurationAndAccount(availableFiltersConfig, selectedAccounts) {
        availableFiltersConfig.subscribe(this.availableFiltersConfig$);
        selectedAccounts.subscribe(this.selectedAccounts$);
    }
    getProductSummaryForSelectedAccounts() {
        return combineLatest([this.accountsService.getProductSummary(), this.selectedAccounts$]).pipe(map(([productSummaryItems, selectedAccounts]) => productSummaryItems.filter((productSummaryItem) => selectedAccounts === null || selectedAccounts === void 0 ? void 0 : selectedAccounts.includes(productSummaryItem.id))));
    }
    getAvailableFilters() {
        return combineLatest([this.availableFiltersConfig$, this.productSummary$]).pipe(map(([availableFiltersConfig, productSummaryItems]) => {
            const availableFilters = productSummaryItems.reduce((filters, productSummaryItem) => filters.concat(this.getFiltersFromConfigs(productSummaryItem, availableFiltersConfig)), []);
            return Array.from(new Set(availableFilters));
        }));
    }
    getFiltersFromConfigs(productSummaryItem, availableFiltersConfig) {
        var _a;
        const availableFilters = (_a = this.getFiltersFromConfigObject(availableFiltersConfig, productSummaryItem)) !== null && _a !== void 0 ? _a : this.getFiltersFromConfigObject(defaultAvailableFiltersConfig, productSummaryItem);
        return availableFilters !== null && availableFilters !== void 0 ? availableFilters : defaultAvailableFiltersConfig.defaultFilters;
    }
    getFiltersFromConfigObject(config, productSummaryItem) {
        if (productSummaryItem.productKindName !== undefined) {
            const productKind = config[productSummaryItem.productKindName];
            if (productKind === undefined)
                return undefined;
            if (Array.isArray(productKind))
                return productKind;
            if (productSummaryItem.productTypeName === undefined)
                return undefined;
            return productKind[productSummaryItem.productTypeName];
        }
        return undefined;
    }
}
AvailableFiltersConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AvailableFiltersConfigService, deps: [{ token: AccountsService }], target: i0.ɵɵFactoryTarget.Injectable });
AvailableFiltersConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AvailableFiltersConfigService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AvailableFiltersConfigService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: AccountsService }]; } });

// eslint-disable-next-line
class BaseTransactionsContainer {
    constructor(model, widgetProperties, cd, eventBusService, notificationService, pendingTransactionsService, transactionDetailsService, availableFiltersConfigService, showDetailsConfig) {
        this.model = model;
        this.widgetProperties = widgetProperties;
        this.cd = cd;
        this.eventBusService = eventBusService;
        this.notificationService = notificationService;
        this.pendingTransactionsService = pendingTransactionsService;
        this.transactionDetailsService = transactionDetailsService;
        this.availableFiltersConfigService = availableFiltersConfigService;
        this.showDetailsConfig = showDetailsConfig;
        /**
         * Reference to instance of customizable component.
         */
        this.hostRef = this;
        this.apiKeySubject = new BehaviorSubject(undefined);
        /**
         * Observable of options to initialize the filter with.  By default, it is empty.
         */
        this.initialFilterOptions = of({});
        /**
         * Observable of options to initialize the sort options with.  By default, it is empty.
         */
        this.initialSortOptions = of(undefined);
        this.transactionSelected = new EventEmitter();
        this.transactionsLoaded = new EventEmitter();
        this.pageSizeSubject = new BehaviorSubject(undefined);
        this.maxNavPagesSubject = new BehaviorSubject(undefined);
        this.paginationTypeSubject = new BehaviorSubject(undefined);
        this.showControlsSubject = new BehaviorSubject(undefined);
        this.showChangeCategorySubject = new BehaviorSubject(undefined);
        this.showPendingTransactionsOnTopSubject = new BehaviorSubject(undefined);
        this.showCheckImageSubject = new BehaviorSubject(undefined);
        this.showManageNotesSubject = new BehaviorSubject(undefined);
        this.getOrPostEndpointsSubject = new BehaviorSubject(undefined);
        this.disputeByBillingStatusSubject = new BehaviorSubject(undefined);
        this.disputeEligibilityDaysSubject = new BehaviorSubject(undefined);
        this.disputeTransactionTypesSubject = new BehaviorSubject(undefined);
        this.enableDisputeAndInquirySubject = new BehaviorSubject(false);
        this.inquireTopicIdSubject = new BehaviorSubject('');
        this.disputeTopicIdSubject = new BehaviorSubject('');
        /**
         * Events registered to transactions widgets
         */
        this.registeredRefreshTransactionsListEvents = [];
        this.unsubscribeSubject = new Subject();
        /**
         * Subject that listens the transactionsList observable and provides the export types
         */
        this.exportConfig = new BehaviorSubject({});
        this.exportErrorMessagesRef = {};
        this.numberOfResultsFound = new ReplaySubject();
        this.numberOfResultsDisplayed = new ReplaySubject();
        this.availableFiltersConfig = new ReplaySubject(1);
        this.availableFilters = this.availableFiltersConfigService.availableFilters$;
        this.inquireTopicId = filterInputParameters(this.inquireTopicIdSubject.asObservable(), this.widgetProperties.inquireTopicId);
        this.disputeTopicId = filterInputParameters(this.disputeTopicIdSubject.asObservable(), this.widgetProperties.disputeTopicId);
        this.inquireAndDisputeTopics = combineLatest([
            this.inquireTopicId,
            this.disputeTopicId,
        ]).pipe(map(([inquire, dispute]) => ({ inquire, dispute })));
        this.refreshTransactionsListHandler = () => {
            this.model.refreshTransactions();
        };
        /**
         * @deprecated will be removed in 11.0.0
         */
        this.handleError = (errorResponse) => {
            this.errors = TransactionsBackendError.fromHttpErrorsResponse(errorResponse);
            return of({
                items: [],
                totalCount: 0,
            });
        };
    }
    /**
     * API key needed for the google maps to work.
     */
    // eslint-disable-next-line
    set googleAPIKey(key) {
        this.apiKeySubject.next(key);
    }
    /**
     * input parameters that will take the place of model properties--
     */
    set pageSizeValue(value) {
        this.pageSizeSubject.next(value);
    }
    set maxNavPagesValue(value) {
        this.maxNavPagesSubject.next(value);
    }
    set paginationTypeValue(value) {
        this.paginationTypeSubject.next(value);
    }
    set showControlsValue(value) {
        this.showControlsSubject.next(value);
    }
    set showChangeCategoryValue(value) {
        this.showChangeCategorySubject.next(value);
    }
    set showPendingTransactionsOnTopValue(value) {
        this.showPendingTransactionsOnTopSubject.next(value);
    }
    set showCheckImageValue(value) {
        this.showCheckImageSubject.next(value);
    }
    set showManageNotesValue(value) {
        this.showManageNotesSubject.next(value);
    }
    set getOrPostEndpointsValue(value) {
        this.getOrPostEndpointsSubject.next(value);
    }
    set disputeByBillingStatusValue(value) {
        this.disputeByBillingStatusSubject.next(typeof value === 'boolean' ? value : value === 'true');
    }
    set disputeEligibilityDaysValue(value) {
        this.disputeEligibilityDaysSubject.next(value);
    }
    set disputeTransactionTypesValue(value) {
        this.disputeTransactionTypesSubject.next((value || '').split(','));
    }
    set enableDisputeAndInquiryValue(value) {
        this.enableDisputeAndInquirySubject.next(typeof value === 'boolean' ? value : value === 'true');
    }
    set availableFiltersValue(availableFiltersConfig) {
        this.availableFiltersConfig.next(availableFiltersConfig);
    }
    /** end input parameters--- */
    /**
     * Information about the backend error, if it occurs.
     */
    /**
     * @deprecated will be removed in 11.0.0
     */
    get error() {
        return this.errors && this.errors[0];
    }
    clearRefreshTransactionsListEvents() {
        this.registeredRefreshTransactionsListEvents.forEach((eventName) => {
            this.eventBusService.unsubscribe(eventName, this.refreshTransactionsListHandler);
        });
        this.registeredRefreshTransactionsListEvents = [];
    }
    retry() {
        this.model.retryFiltering();
        this.pendingTransactionsService.retryFiltering();
    }
    ngOnDestroy() {
        this.clearRefreshTransactionsListEvents();
        this.unsubscribeSubject.next();
        this.unsubscribeSubject.complete();
    }
    get pageSize() {
        return filterInputParameters(this.pageSizeSubject.asObservable(), this.widgetProperties.pageSize);
    }
    get maxNavPages() {
        return filterInputParameters(this.maxNavPagesSubject.asObservable(), this.widgetProperties.maxNavPages);
    }
    get showControls() {
        return filterInputParameters(this.showControlsSubject.asObservable(), this.widgetProperties.showControls);
    }
    get isFilterApplied() {
        return this.model.isFilterApplied;
    }
    get isSearchApplied() {
        return this.model.isSearchApplied;
    }
    get paginationType() {
        return filterInputParameters(this.paginationTypeSubject.asObservable(), this.widgetProperties.paginationType);
    }
    get showPendingTransactionsOnTop() {
        return filterInputParameters(this.showPendingTransactionsOnTopSubject.asObservable(), this.widgetProperties.showPendingTransactionsOnTop);
    }
    get showChangeCategory() {
        return filterInputParameters(this.showChangeCategorySubject.asObservable(), this.widgetProperties.showChangeCategory);
    }
    get showCheckImage() {
        return filterInputParameters(this.showCheckImageSubject.asObservable(), this.widgetProperties.showCheckImage);
    }
    get showManageNotes() {
        return filterInputParameters(this.showManageNotesSubject, this.widgetProperties.showManageNotes);
    }
    get getOrPostEndpoint() {
        return filterInputParameters(this.getOrPostEndpointsSubject.asObservable(), this.widgetProperties.getOrPostEndpoints);
    }
    get gmapsAPIKey() {
        return combineLatest([this.apiKeySubject.asObservable(), this.widgetProperties.gmapsAPIKey]).pipe(map(([inputVal, propVal]) => inputVal || propVal));
    }
    get enableDisputeAndInquiry() {
        return filterInputParameters(this.enableDisputeAndInquirySubject.asObservable(), this.widgetProperties.enableDisputeAndInquiry);
    }
    get disputeByBillingStatus() {
        return filterInputParameters(this.disputeByBillingStatusSubject.asObservable(), this.widgetProperties.disputeByBillingStatus);
    }
    get disputeEligibilityDays() {
        return filterInputParameters(this.disputeEligibilityDaysSubject.asObservable(), this.widgetProperties.disputeEligibilityDays);
    }
    get disputeTransactionTypes() {
        return filterInputParameters(this.disputeTransactionTypesSubject.asObservable(), this.widgetProperties.disputeTransactionTypes);
    }
    onLoadMore() {
        this.model.loadMore();
    }
    ngOnInit() {
        if (typeof this.selectedAccount === 'undefined') {
            throw new Error(`"selectedAccount" input is required in "${this.constructor.name}"`);
        }
        const initialListOptions = combineLatest([
            this.initialFilterOptions,
            this.initialSortOptions,
        ]).pipe(map(([initialFilterOptions, initialSortOptions]) => ({
            filter: initialFilterOptions,
            sort: initialSortOptions,
        })));
        this.model.getTransactionsFrom(this.selectedAccount.pipe(map((value) => value !== null && value !== void 0 ? value : [])), this.pageSize, initialListOptions, this.showPendingTransactionsOnTop, this.getOrPostEndpoint);
        if (this.showDetailsConfig) {
            this.checkImagesList = this.transactionDetailsService.fromCheckImages(this.showCheckImage);
            this.transactionDetailsLoadingStatus = this.transactionDetailsService.loadingState;
            this.transactionDetailsService
                .fromGeolocation(this.gmapsAPIKey)
                .pipe(takeUntil(this.unsubscribeSubject))
                .subscribe();
        }
        this.transactionsList = this.model.getTransactionsList().pipe(publishReplay(1), refCount(), tap((data) => {
            this.errors = data.httpResponseError
                ? TransactionsBackendError.fromHttpErrorsResponse(data.httpResponseError)
                : undefined;
            this.cd.markForCheck();
        }));
        this.pendingTransactionsService.getTransactionsFrom(this.selectedAccount.pipe(map((value) => value !== null && value !== void 0 ? value : [])), initialListOptions, this.getOrPostEndpoint);
        this.pendingTransactionsList = this.pendingTransactionsService.getTransactionsList().pipe(publishReplay(1), refCount(), tap((data) => {
            this.errors = data.httpResponseError
                ? TransactionsBackendError.fromHttpErrorsResponse(data.httpResponseError)
                : undefined;
            this.cd.markForCheck();
        }));
        this.transactionsList
            .pipe(takeUntil(this.unsubscribeSubject), map((transactionsList) => {
            if (!transactionsList) {
                return {};
            }
            const { availableExportTypesHeader, unavailableExportTypesReasonsHeader } = transactionsList;
            return combineExportTypesConfig({
                availableExportTypesHeader,
                unavailableExportTypesReasonsHeader,
            });
        }))
            .subscribe(this.exportConfig);
        const transactionsListCount = this.transactionsList.pipe(map((trans) => ({ history: trans ? trans.totalCount : 0 })));
        const pendingTransactionsListCount = this.pendingTransactionsList.pipe(map((trans) => ({ pending: trans ? trans.totalCount : 0 })));
        const transactionsListItemsToDisplay = this.transactionsList.pipe(map((trans) => ({ history: trans ? trans.items.length : 0 })));
        const pendingTransactionsListItemsToDisplay = this.pendingTransactionsList.pipe(map((trans) => ({ pending: trans ? trans.items.length : 0 })));
        this.sumTransactionsResults(transactionsListCount, pendingTransactionsListCount)
            .pipe(takeUntil(this.unsubscribeSubject))
            .subscribe(this.numberOfResultsFound);
        this.sumTransactionsResults(transactionsListItemsToDisplay, pendingTransactionsListItemsToDisplay)
            .pipe(takeUntil(this.unsubscribeSubject))
            .subscribe(this.numberOfResultsDisplayed);
        this.currentPage = this.model.getCurrentPage();
        this.loadingState = this.model.loadingState;
        this.loadingPendingState = this.pendingTransactionsService.loadingState;
        this.widgetProperties.refreshTransactionsListEvents.pipe(takeUntil(this.unsubscribeSubject)).subscribe((events) => {
            this.clearRefreshTransactionsListEvents();
            if (events) {
                this.registeredRefreshTransactionsListEvents = events.split(',');
                this.registeredRefreshTransactionsListEvents.forEach((eventName) => {
                    this.eventBusService.subscribe(eventName, this.refreshTransactionsListHandler);
                });
            }
        });
        this.configureTransctionsDetailsOutputBehaviour();
        this.transactionDetailsService.fromInquiryAndDispute(this.enableDisputeAndInquiry, this.disputeByBillingStatus, this.disputeEligibilityDays, this.disputeTransactionTypes);
        this.availableFiltersConfigService.setFilterConfigurationAndAccount(this.availableFiltersConfig.asObservable(), this.selectedAccount.pipe(map((value) => value !== null && value !== void 0 ? value : [])));
    }
    configureTransctionsDetailsOutputBehaviour() {
        if (this.transactionsList && this.pendingTransactionsList && !this.showDetailsConfig) {
            const pending = this.showPendingTransactionsOnTop.pipe(mergeMap((cond) => iif(() => cond, this.pendingTransactionsList, of({ items: [], totalCount: 0 }))));
            combineLatest([pending, this.transactionsList])
                .pipe(takeUntil(this.unsubscribeSubject), map(([pendingTransactionsList, transactionsList]) => {
                const pendingTransactions = pendingTransactionsList ? pendingTransactionsList.items : [];
                const transactions = transactionsList ? transactionsList.items : [];
                const mixed = {
                    items: [...pendingTransactions, ...transactions],
                    totalCount: ((pendingTransactionsList === null || pendingTransactionsList === void 0 ? void 0 : pendingTransactionsList.totalCount) || 0) + ((transactionsList === null || transactionsList === void 0 ? void 0 : transactionsList.totalCount) || 0),
                };
                return mixed;
            }))
                .subscribe((data) => {
                this.transactionsLoaded.emit(data);
            });
        }
    }
    sumTransactionsResults(historyCount, pendingCount) {
        return this.showPendingTransactionsOnTop.pipe(mergeMap((showPendingTransactionsOnTop) => iif(() => showPendingTransactionsOnTop, merge(historyCount, pendingCount), historyCount)), scan((acc, curr) => (Object.assign(Object.assign({}, acc), curr)), { history: 0, pending: 0 }), map(({ history = 0, pending = 0 }) => history + pending));
    }
    onPageChange(page) {
        this.model.pageChange(page);
    }
    onSearch(query) {
        // search ui component sends an unexpected event
        // that is type Event. To avoid calling backend with that event
        // it has to be string
        if (typeof query === 'string') {
            this.model.search(query);
            this.pendingTransactionsService.search(query);
        }
    }
    onFilter(filterOptions) {
        this.model.filter(filterOptions);
        this.pendingTransactionsService.filter(filterOptions);
    }
    onSort(sortOptions) {
        this.model.sort(sortOptions);
    }
    onPrint() {
        window.print();
    }
    onExport(exportType) {
        this.storedExportType = Object.assign({}, exportType);
        if (exportType.isAvailable) {
            this.model
                .exportToType(exportType.name)
                .pipe(takeUntil(this.unsubscribeSubject))
                .subscribe((response) => {
                const anchorTag = document.createElement('a');
                anchorTag.href = URL.createObjectURL(response.body);
                const fileName = getNameFromContentDispositionHeader(response);
                const defaultName = exportType.name.toLowerCase() === 'pdf' ? 'Account Activities' : 'transactions';
                anchorTag.download = fileName !== '' ? fileName : defaultName;
                anchorTag.click();
            }, () => {
                this.notificationService.showNotification({
                    header: this.notificationServerErrorHeader,
                    message: this.notificationServerErrorMessage || '',
                    modifier: 'error',
                });
            });
        }
        else {
            this.pushNotification({
                header: this.notificationErrorUpdateHeaderTemplate,
                message: this.notificationErrorUpdateMessageTemplate,
                modifier: 'error',
            });
        }
    }
    onDetailOpen(transaction) {
        if (!this.showDetailsConfig) {
            this.transactionSelected.emit(transaction);
        }
        else {
            this.transactionDetailsService.selectTransaction(transaction);
        }
    }
    pushNotification(notificationMessage) {
        this.notificationService.showNotification(Object.assign({ dismissible: true, ttl: notificationTtl }, notificationMessage));
    }
}
BaseTransactionsContainer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseTransactionsContainer, deps: "invalid", target: i0.ɵɵFactoryTarget.Directive });
BaseTransactionsContainer.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: BaseTransactionsContainer, inputs: { googleAPIKey: "googleAPIKey", selectedAccount: "selectedAccount", initialFilterOptions: "initialFilterOptions", initialSortOptions: "initialSortOptions", pageSizeValue: ["pageSize", "pageSizeValue"], maxNavPagesValue: ["maxNavPages", "maxNavPagesValue"], paginationTypeValue: ["paginationType", "paginationTypeValue"], showControlsValue: ["showControls", "showControlsValue"], showChangeCategoryValue: ["showChangeCategory", "showChangeCategoryValue"], showPendingTransactionsOnTopValue: ["showPendingTransactionsOnTop", "showPendingTransactionsOnTopValue"], showCheckImageValue: ["showCheckImage", "showCheckImageValue"], showManageNotesValue: ["showManageNotes", "showManageNotesValue"], getOrPostEndpointsValue: ["getOrPostEndpoints", "getOrPostEndpointsValue"], disputeByBillingStatusValue: ["disputeByBillingStatus", "disputeByBillingStatusValue"], disputeEligibilityDaysValue: ["disputeEligibilityDays", "disputeEligibilityDaysValue"], disputeTransactionTypesValue: ["disputeTransactionTypes", "disputeTransactionTypesValue"], enableDisputeAndInquiryValue: ["enableDisputeAndInquiry", "enableDisputeAndInquiryValue"], availableFiltersValue: ["availableFiltersConfig", "availableFiltersValue"], inquireTopicIdValue: ["inquireTopicId", "inquireTopicIdValue"], disputeTopicIdValue: ["disputeTopicId", "disputeTopicIdValue"] }, outputs: { transactionSelected: "transactionSelected", transactionsLoaded: "transactionsLoaded" }, viewQueries: [{ propertyName: "notificationErrorUpdateHeaderTemplate", first: true, predicate: ["notificationErrorUpdateHeader"], descendants: true }, { propertyName: "notificationErrorUpdateMessageTemplate", first: true, predicate: ["notificationErrorUpdateMessage"], descendants: true }, { propertyName: "notificationServerErrorHeader", first: true, predicate: ["notificationServerErrorHeader"], descendants: true }, { propertyName: "notificationServerErrorMessage", first: true, predicate: ["notificationServerErrorMessage"], descendants: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseTransactionsContainer, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: TransactionsService }, { type: WidgetPropertiesService }, { type: i0.ChangeDetectorRef }, { type: undefined }, { type: i3$4.NotificationService }, { type: PendingTransactionsService }, { type: TransactionDetailsService }, { type: AvailableFiltersConfigService }, { type: undefined }]; }, propDecorators: { notificationErrorUpdateHeaderTemplate: [{
                type: ViewChild,
                args: ['notificationErrorUpdateHeader']
            }], notificationErrorUpdateMessageTemplate: [{
                type: ViewChild,
                args: ['notificationErrorUpdateMessage']
            }], notificationServerErrorHeader: [{
                type: ViewChild,
                args: ['notificationServerErrorHeader', { static: false }]
            }], notificationServerErrorMessage: [{
                type: ViewChild,
                args: ['notificationServerErrorMessage', { static: false }]
            }], googleAPIKey: [{
                type: Input
            }], selectedAccount: [{
                type: Input
            }], initialFilterOptions: [{
                type: Input
            }], initialSortOptions: [{
                type: Input
            }], pageSizeValue: [{
                type: Input,
                args: ['pageSize']
            }], maxNavPagesValue: [{
                type: Input,
                args: ['maxNavPages']
            }], paginationTypeValue: [{
                type: Input,
                args: ['paginationType']
            }], showControlsValue: [{
                type: Input,
                args: ['showControls']
            }], showChangeCategoryValue: [{
                type: Input,
                args: ['showChangeCategory']
            }], showPendingTransactionsOnTopValue: [{
                type: Input,
                args: ['showPendingTransactionsOnTop']
            }], showCheckImageValue: [{
                type: Input,
                args: ['showCheckImage']
            }], showManageNotesValue: [{
                type: Input,
                args: ['showManageNotes']
            }], getOrPostEndpointsValue: [{
                type: Input,
                args: ['getOrPostEndpoints']
            }], disputeByBillingStatusValue: [{
                type: Input,
                args: ['disputeByBillingStatus']
            }], disputeEligibilityDaysValue: [{
                type: Input,
                args: ['disputeEligibilityDays']
            }], disputeTransactionTypesValue: [{
                type: Input,
                args: ['disputeTransactionTypes']
            }], enableDisputeAndInquiryValue: [{
                type: Input,
                args: ['enableDisputeAndInquiry']
            }], availableFiltersValue: [{
                type: Input,
                args: ['availableFiltersConfig']
            }], inquireTopicIdValue: [{
                type: Input,
                args: ['inquireTopicId']
            }], disputeTopicIdValue: [{
                type: Input,
                args: ['disputeTopicId']
            }], transactionSelected: [{
                type: Output
            }], transactionsLoaded: [{
                type: Output
            }] } });
class TransactionsNoAccountSelectedStateCustomizableDirective extends BbTemplate {
}
TransactionsNoAccountSelectedStateCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsNoAccountSelectedStateCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TransactionsNoAccountSelectedStateCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsNoAccountSelectedStateCustomizableDirective, selector: "[bbTransactionsNoAccountSelectedStateCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsNoAccountSelectedStateCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTransactionsNoAccountSelectedStateCustomizable]',
                }]
        }] });
class TransactionsErrorStateCustomizableDirective extends BbTemplate {
}
TransactionsErrorStateCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsErrorStateCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TransactionsErrorStateCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsErrorStateCustomizableDirective, selector: "[bbTransactionsErrorStateCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsErrorStateCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTransactionsErrorStateCustomizable]',
                }]
        }] });

class CapitalizePipe {
    transform(value) {
        return value[0].toUpperCase() + value.substr(1).toLowerCase();
    }
}
CapitalizePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CapitalizePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
CapitalizePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CapitalizePipe, name: "bbCapitalizePipe" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CapitalizePipe, decorators: [{
            type: Pipe,
            args: [{ name: 'bbCapitalizePipe' }]
        }] });

var TransactionIconType;
(function (TransactionIconType) {
    TransactionIconType[TransactionIconType["category"] = 1] = "category";
    TransactionIconType[TransactionIconType["type"] = 2] = "type";
    TransactionIconType[TransactionIconType["creditDebit"] = 3] = "creditDebit";
})(TransactionIconType || (TransactionIconType = {}));
class BaseTransactionIcon {
    cleanClassName(text) {
        const result = text.toLowerCase().replace(/\W/g, '-').replace(/-{2,}/g, '-');
        if (result.endsWith('-')) {
            return result.slice(0, -1);
        }
        else {
            return result;
        }
    }
    throwIfIncorrect() {
        if (!this.isValid) {
            throw new Error(`Invalid transaction provided to ${this.constructor.name}`);
        }
    }
    constructor() {
        this.throwIfIncorrect();
    }
}
class TransactionCategoryIcon extends BaseTransactionIcon {
    constructor(transaction) {
        super();
        this.transaction = transaction;
    }
    get title() {
        return !this.transaction.isPending ? this.transaction.category || '' : 'pending';
    }
    get type() {
        return TransactionIconType.category;
    }
    isValid() {
        return this.transaction.isPending || (this.transaction !== undefined && this.transaction.category !== undefined);
    }
    formatClassName() {
        return `bb-transaction-category-${this.cleanClassName(this.transaction.category || 'pending')}`;
    }
}
class TransactionTypeIcon extends BaseTransactionIcon {
    constructor(transaction) {
        super();
        this.transaction = transaction;
    }
    get title() {
        return this.transaction.type || '';
    }
    get type() {
        return TransactionIconType.type;
    }
    isValid() {
        return !!this.transaction && !!this.transaction.type;
    }
    formatClassName() {
        return this.transaction.type ? `bb-icon-transaction-type-${this.cleanClassName(this.transaction.type)}` : '';
    }
}
class TransactionCreditDebitIcon extends BaseTransactionIcon {
    constructor(transaction) {
        super();
        this.transaction = transaction;
    }
    get title() {
        return this.indicator;
    }
    get type() {
        return TransactionIconType.creditDebit;
    }
    formatClassName() {
        return this.transaction.transactionAmountCurrency
            ? `bb-icon-credit-debit-indicator-${this.cleanClassName(this.indicator)}`
            : '';
    }
    get indicator() {
        if (this.transaction.transactionAmountCurrency) {
            return parseInt(this.transaction.transactionAmountCurrency.amount, 10) > 0 ? 'incoming' : 'outgoing';
        }
        return '';
    }
    isValid() {
        return this.transaction !== undefined && this.transaction.transactionAmountCurrency !== undefined;
    }
}

class TransactionsIconCategoriesFactoryService {
    create(transaction) {
        if (transaction.category || transaction.isPending) {
            return new TransactionCategoryIcon(transaction);
        }
        else if (transaction.type) {
            return new TransactionTypeIcon(transaction);
        }
        else {
            return new TransactionCreditDebitIcon(transaction);
        }
    }
}
TransactionsIconCategoriesFactoryService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsIconCategoriesFactoryService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TransactionsIconCategoriesFactoryService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsIconCategoriesFactoryService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsIconCategoriesFactoryService, decorators: [{
            type: Injectable
        }] });

class TransactionCategoryIconComponent {
    constructor(transactionsIconCategoriesFactory, cd) {
        this.transactionsIconCategoriesFactory = transactionsIconCategoriesFactory;
        this.cd = cd;
        /**
         * Whether to show the icon in a circle.
         */
        this.circle = false;
        /* eslint-enable */
        /**
         * Determines if the image is done loading.
         */
        this.hasImageLoaded = false;
    }
    ngOnInit() {
        if (this.transaction === undefined) {
            throw new Error(`"transaction" input is required in "${this.constructor.name}"`);
        }
        this.transactionIcon = this.transactionsIconCategoriesFactory.create(this.transaction);
    }
    ngAfterViewInit() {
        if (this.categoryImage) {
            this.categoryImage.nativeElement.onload = () => {
                this.hasImageLoaded = true;
                this.cd.markForCheck();
            };
        }
    }
}
TransactionCategoryIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCategoryIconComponent, deps: [{ token: TransactionsIconCategoriesFactoryService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
TransactionCategoryIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionCategoryIconComponent, selector: "bb-transaction-category-icon", inputs: { transaction: "transaction", circle: "circle", size: "size" }, viewQueries: [{ propertyName: "categoryImage", first: true, predicate: ["categoryImage"], descendants: true }], ngImport: i0, template: "<div\n  aria-hidden=\"true\"\n  class=\"bb-transaction-category bb-transaction-category--enriched\"\n  title=\"{{ transaction?.merchant ? transaction?.merchant?.name : transactionIcon?.title }}\"\n  [ngClass]=\"[\n    circle ? 'bb-transaction-category-icon-circle' : 'bb-transaction-category-icon',\n    size ? 'bb-transaction-category--' + size : '',\n    !transaction?.merchant?.logo || !hasImageLoaded ? transactionIcon?.formatClassName() : ''\n  ]\"\n>\n  <img\n    class=\"bb-transaction-category__image\"\n    *ngIf=\"transaction?.merchant?.logo\"\n    [hidden]=\"!hasImageLoaded\"\n    [src]=\"transaction?.merchant?.logo\"\n    #categoryImage\n  />\n</div>\n", directives: [{ type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionCategoryIconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transaction-category-icon',
                    templateUrl: './transaction-category-icon.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: TransactionsIconCategoriesFactoryService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { transaction: [{
                type: Input
            }], circle: [{
                type: Input
            }], size: [{
                type: Input
            }], categoryImage: [{
                type: ViewChild,
                args: ['categoryImage']
            }] } });

class TransactionUpdateService {
    constructor(transactionsDataHttpService) {
        this.transactionsDataHttpService = transactionsDataHttpService;
    }
    handleError(error) {
        if (error.error instanceof ErrorEvent) {
            // A client-side or network error occurred.  Handle it accordingly.
            console.error('An error occurred:', error.error.message);
        }
        else {
            // The backend returned an unsuccessful response code.
            // The response body may contain clues as to what went wrong.
            console.error(`Backend returned code ${error.status}, ` + `body was: ${error.error}`);
        }
        // Return an observable with a user-facing error message.
        return throwError('Something bad happened; please try again later.');
    }
    update(transaction, update) {
        if (typeof transaction.id === 'undefined' || typeof transaction.arrangementId === 'undefined') {
            return throwError('updateNotes: invalid transaction');
        }
        return this.transactionsDataHttpService
            .patchTransactions({
            transactionsClientPatchRequestBody: [
                {
                    id: transaction.id,
                    arrangementId: transaction.arrangementId,
                    notes: update.notes,
                    disputeStatus: update.disputeStatus,
                    category: update.category,
                },
            ],
        }, 'response')
            .pipe(catchError(this.handleError));
    }
    setDisputeStatus(transaction, disputeStatus) {
        return this.update(transaction, { disputeStatus });
    }
    updateNotes(transaction, notes) {
        return this.update(transaction, { notes });
    }
}
TransactionUpdateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionUpdateService, deps: [{ token: i1$1.TransactionClientHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
TransactionUpdateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionUpdateService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionUpdateService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TransactionClientHttpService }]; } });

/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsEnumValue;
(function (TransactionsEnumValue) {
    // eslint-disable-next-line no-inner-declarations
    function toTitleCase(text) {
        if (!text) {
            return '';
        }
        return `${text.charAt(0).toUpperCase()}${text.substr(1).toLowerCase()}`;
    }
    // Until Angular supports i18n in typescript, this is the way to go
    // eslint-disable-next-line no-inner-declarations
    function processEnumValue(enumValue) {
        switch (enumValue.value) {
            case 'CRDT':
                return Object.assign(Object.assign({}, enumValue), { name: 'Credit' });
            case 'DBIT':
                return Object.assign(Object.assign({}, enumValue), { name: 'Debit' });
            case 'BILLED':
            case 'UNBILLED':
            case 'PENDING':
                return Object.assign(Object.assign({}, enumValue), { name: enumValue.name || toTitleCase(enumValue.value) });
            default:
                return Object.assign(Object.assign({}, enumValue), { name: enumValue.name || enumValue.value });
        }
    }
    // eslint-disable-next-line no-inner-declarations
    function processEnumValues(enumValues) {
        return enumValues.map(processEnumValue);
    }
    function fromHttpResponse(response) {
        return processEnumValues(response.body || []);
    }
    TransactionsEnumValue.fromHttpResponse = fromHttpResponse;
})(TransactionsEnumValue || (TransactionsEnumValue = {}));
/* eslint-enable no-redeclare*/

class EnumValuesService {
    constructor(transactionsDataHttpService) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.enumValues = {};
    }
    handleError(error) {
        if (error.error instanceof ErrorEvent) {
            // A client-side or network error occurred.  Handle it accordingly.
            console.error('An error occurred:', error.error.message);
        }
        else {
            // The backend returned an unsuccessful response code.
            // The response body may contain clues as to what went wrong.
            console.error(`Backend returned code ${error.status}, ` + `body was: ${error.error}`);
        }
        // Return an observable with a user-facing error message.
        return throwError('Something bad happened; please try again later.');
    }
    loadEnumValues(attributeName) {
        return this.transactionsDataHttpService
            .getEnumValuesByAttributeName({ attributeName }, 'response')
            .pipe(map(TransactionsEnumValue.fromHttpResponse), catchError(this.handleError));
    }
    getEnumValues(attributeName) {
        if (typeof this.enumValues[attributeName] === 'undefined') {
            this.enumValues[attributeName] = this.loadEnumValues(attributeName);
        }
        return this.enumValues[attributeName];
    }
}
EnumValuesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EnumValuesService, deps: [{ token: i1$1.TransactionClientHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
EnumValuesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EnumValuesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: EnumValuesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.TransactionClientHttpService }]; } });

function categoriesManagementMap(item) {
    return Object.assign({}, item);
}
function fromCategoriesManagementResponse(response) {
    return (response.body || []).map(categoriesManagementMap);
}

class CategoriesService {
    constructor(categoriesManagementDataHttpService) {
        this.categoriesManagementDataHttpService = categoriesManagementDataHttpService;
    }
    getCategories() {
        return this.categoriesManagementDataHttpService
            .getCategories({
            level: categoryListLevelParam,
        }, 'response')
            .pipe(shareReplay(), map(fromCategoriesManagementResponse));
    }
}
CategoriesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CategoriesService, deps: [{ token: i1$7.CategoriesHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
CategoriesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CategoriesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CategoriesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$7.CategoriesHttpService }]; } });

class TransactionsMapUiComponent {
    buildMapOptions(location) {
        if (location.latitude && location.longitude) {
            return {
                center: {
                    lat: location.latitude,
                    lng: location.longitude,
                },
                zoom: 10,
                disableDefaultUI: true,
                zoomControl: false,
                styles: [
                    {
                        featureType: 'poi',
                        stylers: [{ visibility: 'off' }],
                    },
                ],
            };
        }
        return undefined;
    }
    getFullAddress(location) {
        return encodeURI(`${location.latitude}, ${location.longitude}`);
    }
    ngAfterViewInit() {
        if (this.location && this.mapContainer) {
            const options = this.buildMapOptions(this.location);
            const map = new google.maps.Map(this.mapContainer.nativeElement, options);
            if (this.location && this.location.latitude && this.location.longitude) {
                const mapUrl = this.getFullAddress(this.location);
                const marker = new google.maps.Marker({
                    position: {
                        lat: this.location.latitude,
                        lng: this.location.longitude,
                    },
                    map,
                });
                marker.addListener('click', () => {
                    window.open('https://www.google.com/maps/dir//' + mapUrl, '_blank');
                });
            }
        }
    }
}
TransactionsMapUiComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsMapUiComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionsMapUiComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionsMapUiComponent, selector: "bb-transactions-map-ui", inputs: { location: "location" }, viewQueries: [{ propertyName: "mapContainer", first: true, predicate: ["bbMapContainer"], descendants: true }], ngImport: i0, template: "<div class=\"bb-transcations-geolocation-map\" #bbMapContainer></div>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsMapUiComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transactions-map-ui',
                    templateUrl: 'transactions-map-ui.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { mapContainer: [{
                type: ViewChild,
                args: ['bbMapContainer']
            }], location: [{
                type: Input
            }] } });

class TransactionGeoLocationMapComponent {
    constructor() {
        this.loadingStateEnum = TransactionsDetailsLoadingState;
    }
}
TransactionGeoLocationMapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionGeoLocationMapComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TransactionGeoLocationMapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TransactionGeoLocationMapComponent, selector: "bb-transaction-geo-location-map", inputs: { transaction: "transaction", loadingStatus: "loadingStatus" }, ngImport: i0, template: "<div class=\"bb-transactions-geolocation\">\n  <span class=\"bb-inline-stack bb-block bb-block--sm\" *ngIf=\"transaction?.location?.address\">\n    <bb-icon-ui class=\"bb-inline-stack__item\" name=\"location-on\" size=\"md\"></bb-icon-ui>\n    <span class=\"bb-inline-stack__item bb-transactions-geolocation__address\">{{ transaction?.location?.address }}</span>\n  </span>\n  <ng-container *ngIf=\"loadingStatus !== loadingStateEnum.notStarted\">\n    <ng-container *ngIf=\"loadingStatus !== loadingStateEnum.notLoaded\">\n      <ng-container *ngIf=\"loadingStatus !== loadingStateEnum.error; else errorState\">\n        <ng-container *ngIf=\"loadingStatus !== loadingStateEnum.loading; else loadingState\">\n          <bb-transactions-map-ui [location]=\"transaction?.location\"></bb-transactions-map-ui>\n        </ng-container>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n</div>\n\n<ng-template #loadingState>\n  <bb-loading-indicator-ui loaderSize=\"lg\"></bb-loading-indicator-ui>\n</ng-template>\n\n<ng-template #errorState>\n  <!-- Error state is not defined yet -->\n</ng-template>\n", components: [{ type: i1$3.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: TransactionsMapUiComponent, selector: "bb-transactions-map-ui", inputs: ["location"] }, { type: i3$2.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionGeoLocationMapComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transaction-geo-location-map',
                    templateUrl: './transaction-geo-location-map.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { transaction: [{
                type: Input
            }], loadingStatus: [{
                type: Input
            }] } });

/**
 * Utility service for DOM manipulations
 */
class DomAttributesService {
    constructor() {
        this.basePrefix = 'bb_transactions';
        this.idCounter = 0;
    }
    nextId(prefix) {
        return `${this.basePrefix}-${prefix ? prefix : 'default'}-${Date.now()}-${this.idCounter++}`;
    }
}
DomAttributesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DomAttributesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DomAttributesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DomAttributesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DomAttributesService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class DynamicIdDirective {
    constructor(_elRef, _renderer, domAttributesService, cd) {
        this._elRef = _elRef;
        this._renderer = _renderer;
        this.domAttributesService = domAttributesService;
        this.cd = cd;
    }
    ngAfterContentInit() {
        setTimeout(() => {
            this._renderer.setAttribute(this._elRef.nativeElement, 'id', this.domAttributesService.nextId(this.bbDynamicId));
            this.cd.markForCheck();
        });
    }
}
DynamicIdDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DynamicIdDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: DomAttributesService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
DynamicIdDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: DynamicIdDirective, selector: "[bbDynamicId]", inputs: { bbDynamicId: "bbDynamicId" }, exportAs: ["bbDynamicId"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DynamicIdDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbDynamicId]',
                    exportAs: 'bbDynamicId',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: DomAttributesService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { bbDynamicId: [{
                type: Input
            }] } });

class MessagesService {
    constructor(messageCenterHttpService) {
        this.messageCenterHttpService = messageCenterHttpService;
        // TODO: default message is out of scope
        this.defaultMessage = of({
            body: b64Encode('test message'),
            subject: 'no subject',
            topic: 'no topic',
            sender: {
                name: 'test sender',
            },
        });
    }
    saveMessages(message) {
        return this.messageCenterHttpService.postMessages({
            presentationMessagePostRequestBody: message,
        });
    }
    saveAttachment(attachment) {
        return this.messageCenterHttpService.postMessageAttachments({ attachment }).pipe(map((data) => data.id));
    }
    deleteAttachments(attachmentIds) {
        return this.messageCenterHttpService
            .deleteMessageAttachments({ ids: attachmentIds })
            .pipe(map((data) => data.deleted));
    }
    createDefaultBody(transaction) {
        var _a, _b;
        return `transactionID: ${transaction.id}
referenceNumber: ${transaction.reference}
arranagementID: ${transaction.arrangementId}
bookingDate: ${transaction.bookingDate}
amount: ${(_a = transaction.transactionAmountCurrency) === null || _a === void 0 ? void 0 : _a.amount}
merchantName: ${(_b = transaction.merchant) === null || _b === void 0 ? void 0 : _b.name}
counterpartyName: ${transaction.counterPartyName}
description: ${transaction.description}
type: ${transaction.type}`;
    }
}
MessagesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MessagesService, deps: [{ token: i1$8.MessagecenterHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
MessagesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MessagesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MessagesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$8.MessagecenterHttpService }]; } });

/* eslint-disable  @typescript-eslint/no-non-null-assertion */
class TransactionsInquireAndDisputeUIService {
    constructor(messagesService) {
        this.messagesService = messagesService;
        this.showReportSubject = new Subject();
        this.DEFAULT_MESSAGE = {
            attachments: [],
            body: '',
            topic: 'inquire',
        };
        this.showReport = this.showReportSubject.asObservable();
        this.message = Object.assign({}, this.DEFAULT_MESSAGE);
        this.reportState = TransactionsDetailsLoadingState.notStarted;
        this.subjectReportMap = {
            dispute: $localize `:Dispute subject@@transactions.dispute.subject:Transaction dispute raised on`,
            inquire: $localize `:Inquiry subject@@transactions.inquire.subject:Transaction inquiry raised on`,
        };
    }
    formatMessage(messageForm, defaultBody, inquireAndDisputeTopics, transaction) {
        const { topic = 'inquire', body = '', attachments = [] } = messageForm;
        return {
            body: b64Encode([defaultBody, body].join('\n')),
            topic: inquireAndDisputeTopics[topic],
            attachments: attachments.map((data) => data.id || ''),
            subject: `${this.subjectReportMap[topic]} ${transaction === null || transaction === void 0 ? void 0 : transaction.arrangementId}`,
        };
    }
    // TODO: Add unit tests when the functionality is complete
    saveReport(message) {
        this.reportState = TransactionsDetailsLoadingState.loading;
        return this.messagesService.saveMessages(message).pipe(map(() => {
            this.message = this.DEFAULT_MESSAGE;
            this.showReportForm(false);
            this.reportState = TransactionsDetailsLoadingState.done;
            return message;
        }), catchError(() => {
            this.reportState = TransactionsDetailsLoadingState.error;
            return of(undefined);
        }));
    }
    showReportForm(display) {
        this.showReportSubject.next(display);
    }
    cancelReport() {
        this.removeAllFiles();
        this.reportState = TransactionsDetailsLoadingState.notStarted;
        this.message = this.DEFAULT_MESSAGE;
        this.showReportForm(false);
    }
    fileChange(file) {
        let attachment = {
            name: file.name,
            size: file.size,
            content: from(file.arrayBuffer()),
        };
        const currentAttachments = this.message.attachments || [];
        this.message.attachments = [...currentAttachments, attachment];
        const state = this.reportState;
        this.reportState = TransactionsDetailsLoadingState.loading;
        return this.messagesService.saveAttachment(file).pipe(map((id) => {
            attachment = Object.assign({ id }, attachment);
            this.reportState = TransactionsDetailsLoadingState.notStarted;
            this.message.attachments = [...currentAttachments, attachment];
            return id;
        }), catchError(() => {
            this.reportState = state;
            this.message.attachments = [...currentAttachments];
            return of('');
            //TODO: add error message
        }));
    }
    deleteReportForm() {
        //TODO: this is just a placeholder for now
    }
    fileRemoved(attachment) {
        const { id = '' } = attachment;
        return this.messagesService.deleteAttachments([id]).pipe(tap(() => {
            this.message.attachments = this.message.attachments.filter((item) => item.id !== id);
        }));
    }
    removeAllFiles() {
        if (this.message.attachments.length > 0) {
            const files = this.message.attachments.map((item) => item.id || '');
            this.messagesService.deleteAttachments(files).subscribe({
                next: () => {
                    this.message.attachments = [];
                },
            });
        }
    }
}
TransactionsInquireAndDisputeUIService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsInquireAndDisputeUIService, deps: [{ token: MessagesService }], target: i0.ɵɵFactoryTarget.Injectable });
TransactionsInquireAndDisputeUIService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsInquireAndDisputeUIService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsInquireAndDisputeUIService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: MessagesService }]; } });

class TransactionsCommonModule {
}
TransactionsCommonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsCommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TransactionsCommonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsCommonModule, declarations: [TransactionsNumberOfResultsFoundComponent,
        TransactionCheckImageComponent,
        TransactionGeoLocationMapComponent,
        TransactionsErrorStateCustomizableDirective,
        TransactionsNoAccountSelectedStateCustomizableDirective,
        AccessibilityKeyboardDirective,
        TransactionsNumberOfResultsFoundCustomizableDirective,
        TransactionsMapUiComponent,
        TransactionCategoryIconComponent,
        TransactionCheckImageItemComponent,
        CapitalizePipe,
        DocumentViewerBackdropComponent,
        DocumentViewerContainerComponent,
        DocumentViewerHeaderComponent,
        DocumentViewerInteractorComponent,
        ImageViewerComponent,
        TransactionCheckImageDocumentViewerComponent,
        DynamicIdDirective,
        TransactionsInquiryDisputeComponent,
        TransactionsDisputeStatusTagComponent,
        TransactionsDisputeBannerComponent], imports: [CommonModule,
        IconModule,
        ButtonModule,
        LoadButtonModule,
        InputRadioGroupModule,
        TooltipModule,
        ReactiveFormsModule,
        LoadingIndicatorModule,
        EmptyStateModule,
        DropdownMenuModule,
        A11yModule,
        RichTextEditorModule,
        InputValidationMessageModule,
        InputFileModule,
        FileAttachmentModule,
        AlertModule,
        ModalModule,
        BadgeModule], exports: [TransactionsNumberOfResultsFoundComponent,
        TransactionsErrorStateCustomizableDirective,
        TransactionsNoAccountSelectedStateCustomizableDirective,
        AccessibilityKeyboardDirective,
        TransactionCheckImageComponent,
        TransactionCheckImageItemComponent,
        TransactionGeoLocationMapComponent,
        TransactionsNumberOfResultsFoundCustomizableDirective,
        IconModule,
        A11yModule,
        TransactionsMapUiComponent,
        TransactionCategoryIconComponent,
        CapitalizePipe,
        DocumentViewerBackdropComponent,
        DocumentViewerContainerComponent,
        DocumentViewerHeaderComponent,
        DocumentViewerInteractorComponent,
        ImageViewerComponent,
        TransactionCheckImageDocumentViewerComponent,
        EmptyStateModule,
        LoadingIndicatorModule,
        DropdownMenuModule,
        DynamicIdDirective,
        TransactionsInquiryDisputeComponent,
        TransactionsDisputeStatusTagComponent,
        TransactionsDisputeBannerComponent] });
TransactionsCommonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsCommonModule, providers: [
        TransactionUpdateService,
        EnumValuesService,
        CategoriesService,
        AccountsService,
        TransactionsIconCategoriesFactoryService,
        MapAPILoaderService,
        DomAttributesService,
        MessagesService,
        TransactionsInquireAndDisputeUIService,
        PaymentsBatchService,
        AvailableFiltersConfigService,
    ], imports: [[
            CommonModule,
            IconModule,
            ButtonModule,
            LoadButtonModule,
            InputRadioGroupModule,
            TooltipModule,
            ReactiveFormsModule,
            LoadingIndicatorModule,
            EmptyStateModule,
            DropdownMenuModule,
            A11yModule,
            RichTextEditorModule,
            InputValidationMessageModule,
            InputFileModule,
            FileAttachmentModule,
            AlertModule,
            ModalModule,
            BadgeModule,
        ], IconModule,
        A11yModule,
        EmptyStateModule,
        LoadingIndicatorModule,
        DropdownMenuModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsCommonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        IconModule,
                        ButtonModule,
                        LoadButtonModule,
                        InputRadioGroupModule,
                        TooltipModule,
                        ReactiveFormsModule,
                        LoadingIndicatorModule,
                        EmptyStateModule,
                        DropdownMenuModule,
                        A11yModule,
                        RichTextEditorModule,
                        InputValidationMessageModule,
                        InputFileModule,
                        FileAttachmentModule,
                        AlertModule,
                        ModalModule,
                        BadgeModule,
                    ],
                    providers: [
                        TransactionUpdateService,
                        EnumValuesService,
                        CategoriesService,
                        AccountsService,
                        TransactionsIconCategoriesFactoryService,
                        MapAPILoaderService,
                        DomAttributesService,
                        MessagesService,
                        TransactionsInquireAndDisputeUIService,
                        PaymentsBatchService,
                        AvailableFiltersConfigService,
                    ],
                    declarations: [
                        TransactionsNumberOfResultsFoundComponent,
                        TransactionCheckImageComponent,
                        TransactionGeoLocationMapComponent,
                        TransactionsErrorStateCustomizableDirective,
                        TransactionsNoAccountSelectedStateCustomizableDirective,
                        AccessibilityKeyboardDirective,
                        TransactionsNumberOfResultsFoundCustomizableDirective,
                        TransactionsMapUiComponent,
                        TransactionCategoryIconComponent,
                        TransactionCheckImageItemComponent,
                        CapitalizePipe,
                        DocumentViewerBackdropComponent,
                        DocumentViewerContainerComponent,
                        DocumentViewerHeaderComponent,
                        DocumentViewerInteractorComponent,
                        ImageViewerComponent,
                        TransactionCheckImageDocumentViewerComponent,
                        DynamicIdDirective,
                        TransactionsInquiryDisputeComponent,
                        TransactionsDisputeStatusTagComponent,
                        TransactionsDisputeBannerComponent,
                    ],
                    exports: [
                        TransactionsNumberOfResultsFoundComponent,
                        TransactionsErrorStateCustomizableDirective,
                        TransactionsNoAccountSelectedStateCustomizableDirective,
                        AccessibilityKeyboardDirective,
                        TransactionCheckImageComponent,
                        TransactionCheckImageItemComponent,
                        TransactionGeoLocationMapComponent,
                        TransactionsNumberOfResultsFoundCustomizableDirective,
                        IconModule,
                        A11yModule,
                        TransactionsMapUiComponent,
                        TransactionCategoryIconComponent,
                        CapitalizePipe,
                        DocumentViewerBackdropComponent,
                        DocumentViewerContainerComponent,
                        DocumentViewerHeaderComponent,
                        DocumentViewerInteractorComponent,
                        ImageViewerComponent,
                        TransactionCheckImageDocumentViewerComponent,
                        EmptyStateModule,
                        LoadingIndicatorModule,
                        DropdownMenuModule,
                        DynamicIdDirective,
                        TransactionsInquiryDisputeComponent,
                        TransactionsDisputeStatusTagComponent,
                        TransactionsDisputeBannerComponent,
                    ],
                }]
        }] });

class NavigationService {
    constructor(routerService) {
        this.routerService = routerService;
    }
    view(arrangementId) {
        return this.routerService.navigate(['/', arrangementId]);
    }
}
NavigationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NavigationService, deps: [{ token: i3.RouterService }], target: i0.ɵɵFactoryTarget.Injectable });
NavigationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NavigationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i3.RouterService }]; } });

/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsGetParams;
(function (TransactionsGetParams) {
    // eslint-disable-next-line complexity
    TransactionsGetParams.toHttpGetParams = (getParams) => {
        const params = Object.assign({}, TransactionsFilterOptions.toHttpGetParams(getParams.filter));
        if (getParams.account && getParams.account.arrangementId) {
            params['arrangementsIds'] = Array.isArray(getParams.account.arrangementId)
                ? getParams.account.arrangementId
                : [getParams.account.arrangementId];
        }
        if (getParams.search && getParams.search.query) {
            params['query'] = getParams.search.query;
        }
        if (getParams.pagination) {
            params['from'] = getParams.pagination.from;
            params['size'] = getParams.pagination.size;
        }
        if (getParams.sort) {
            params['orderBy'] = getParams.sort.orderBy.toString();
            params['direction'] = getParams.sort.direction.toString();
        }
        if (getParams.exportType) {
            params['exportType'] = getParams.exportType;
        }
        if (getParams.locale) {
            params['locale'] = getParams.locale;
        }
        if (getParams.state) {
            params['state'] = getParams.state;
        }
        return params;
    };
})(TransactionsGetParams || (TransactionsGetParams = {}));
/* eslint-enable no-redeclare*/

/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
var TransactionsGroupedByDate;
(function (TransactionsGroupedByDate) {
    // eslint-disable-next-line no-inner-declarations
    function getDate(transaction) {
        const date = transaction.bookingDate ? new Date(transaction.bookingDate) : new Date();
        return date.toISOString().slice(0, 10);
    }
    function groupByDate(transactionsList) {
        const transactions = transactionsList && transactionsList.items !== null ? transactionsList.items : [];
        return transactions.reduce((transactionsGroupedByDate, transaction) => {
            const transactionDate = getDate(transaction);
            if (transactionsGroupedByDate[transactionDate]) {
                transactionsGroupedByDate[transactionDate].push(transaction);
            }
            else {
                transactionsGroupedByDate[transactionDate] = [transaction];
            }
            return transactionsGroupedByDate;
        }, {});
    }
    TransactionsGroupedByDate.groupByDate = groupByDate;
})(TransactionsGroupedByDate || (TransactionsGroupedByDate = {}));
/* eslint-enable no-redeclare*/

/* eslint-disable */
class BaseTransactionsWidget {
    constructor(route, widgetProperties) {
        this.route = route;
        this.widgetProperties = widgetProperties;
        this.enableDisputeAndInquiry = false;
        this.availableFiltersConfig = defaultAvailableFiltersConfig;
        this.transactionSelected = new EventEmitter();
        this.transactionsLoaded = new EventEmitter();
        this.initialFilterOptionsSubject = new BehaviorSubject(undefined);
        this.initialSortOptionsSubject = new BehaviorSubject(undefined);
        this.selectedAccount = this.getRouteParam(this.route, 'selectedAccount').pipe(map((selectedAccount) => selectedAccount), map((selectedAccount) => typeof selectedAccount !== 'undefined' && selectedAccount.includes(',')
            ? selectedAccount.split(',')
            : selectedAccount !== undefined
                ? [selectedAccount]
                : undefined));
    }
    set initialFilterOptionsValue(value) {
        const deseralizedValue = deserialize(value);
        this.initialFilterOptionsSubject.next(TransactionsFilterOptions.fromHttpGetParams(deseralizedValue));
    }
    set initialSortOptionsValue(value) {
        const options = parseSortOptions(value);
        this.initialSortOptionsSubject.next(options);
    }
    getRouteParam(route, param) {
        const paramValue = route.paramMap.pipe(pluck('params', param));
        if (!route.parent) {
            return paramValue;
        }
        // Ensure that level that has actual value keeps it from being cleared.
        return combineLatest([paramValue, this.getRouteParam(route.parent, param)]).pipe(map((params) => params[0] || params[1]));
    }
    get initialFilterOptions() {
        return filterInputParameters(this.initialFilterOptionsSubject.asObservable(), this.widgetProperties.initialFilterOptions);
    }
    get initialSortOptions() {
        return filterInputParameters(this.initialSortOptionsSubject.asObservable(), this.widgetProperties.initialSortOptions);
    }
    onDetailOpen(transaction) {
        this.transactionSelected.emit(transaction);
    }
    onTransactionsLoaded(transactionsList) {
        this.transactionsLoaded.emit(transactionsList);
    }
}
BaseTransactionsWidget.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseTransactionsWidget, deps: [{ token: i1$9.ActivatedRoute }, { token: WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Directive });
BaseTransactionsWidget.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: BaseTransactionsWidget, inputs: { googleAPIKey: "googleAPIKey", initialFilterOptionsValue: ["initialFilterOptions", "initialFilterOptionsValue"], initialSortOptionsValue: ["initialSortOptions", "initialSortOptionsValue"], pageSize: "pageSize", maxNavPages: "maxNavPages", paginationType: "paginationType", showControls: "showControls", showChangeCategory: "showChangeCategory", showPendingTransactionsOnTop: "showPendingTransactionsOnTop", showCheckImage: "showCheckImage", showManageNotes: "showManageNotes", getOrPostEndpoints: "getOrPostEndpoints", enableDisputeAndInquiry: "enableDisputeAndInquiry", disputeByBillingStatus: "disputeByBillingStatus", disputeEligibilityDays: "disputeEligibilityDays", disputeTransactionTypes: "disputeTransactionTypes", inquireTopicId: "inquireTopicId", disputeTopicId: "disputeTopicId", availableFiltersConfig: "availableFiltersConfig" }, outputs: { transactionSelected: "transactionSelected", transactionsLoaded: "transactionsLoaded" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseTransactionsWidget, decorators: [{
            type: Directive
        }], ctorParameters: function () { return [{ type: i1$9.ActivatedRoute }, { type: WidgetPropertiesService }]; }, propDecorators: { googleAPIKey: [{
                type: Input
            }], initialFilterOptionsValue: [{
                type: Input,
                args: ['initialFilterOptions']
            }], initialSortOptionsValue: [{
                type: Input,
                args: ['initialSortOptions']
            }], pageSize: [{
                type: Input
            }], maxNavPages: [{
                type: Input
            }], paginationType: [{
                type: Input
            }], showControls: [{
                type: Input
            }], showChangeCategory: [{
                type: Input
            }], showPendingTransactionsOnTop: [{
                type: Input
            }], showCheckImage: [{
                type: Input
            }], showManageNotes: [{
                type: Input
            }], getOrPostEndpoints: [{
                type: Input
            }], enableDisputeAndInquiry: [{
                type: Input
            }], disputeByBillingStatus: [{
                type: Input
            }], disputeEligibilityDays: [{
                type: Input
            }], disputeTransactionTypes: [{
                type: Input
            }], inquireTopicId: [{
                type: Input
            }], disputeTopicId: [{
                type: Input
            }], availableFiltersConfig: [{
                type: Input
            }], transactionSelected: [{
                type: Output
            }], transactionsLoaded: [{
                type: Output
            }] } });

// eslint-disable-next-line
class BaseTransactionsControls {
    constructor() {
        /**
         * Whether a filter is applied on the transactions.
         */
        this.isFilterApplied = false;
        /**
         * Configurations for exporting transactions.
         */
        // eslint-disable-next-line
        this.exportConfig = [
            {
                name: 'CSV',
                isAvailable: true,
            },
            {
                name: 'OFX',
                isAvailable: true,
            },
        ];
        /**
         * Configuration parameter to show/hide filters
         */
        this.availableFilters = [];
        /**
         * EventEmitter for triggering a filter action.
         */
        this.filter = new EventEmitter();
        /**
         * EventEmitter for triggering a search action.
         */
        this.search = new EventEmitter();
        /**
         * EventEmitter for triggering an export action.
         */
        this.export = new EventEmitter();
        /**
         * Whether the filter form is shown.
         */
        this.isFilterOpen = false;
    }
    /**
     * Search event callback
     */
    onSearch(searchParam) {
        this.search.emit(searchParam);
    }
    /**
     * Filter event callback
     */
    onFilter(filterParams) {
        this.filter.emit(filterParams);
    }
    /**
     * Export event callback
     */
    onExport(type) {
        this.export.emit(type);
    }
    /**
     * Close event callback to hide the filters controls
     */
    onClose() {
        this.isFilterOpen = false;
    }
    /**
     * Toogle method to hide or show the filter form
     */
    toggleFilter() {
        this.isFilterOpen = !this.isFilterOpen;
    }
    ngOnInit() {
        if (typeof this.exportConfig === 'undefined') {
            throw new Error(`"exportConfig" input is required in "${this.constructor.name}"`);
        }
    }
}
BaseTransactionsControls.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseTransactionsControls, deps: [], target: i0.ɵɵFactoryTarget.Directive });
BaseTransactionsControls.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: BaseTransactionsControls, inputs: { isFilterApplied: "isFilterApplied", exportConfig: "exportConfig", availableFilters: "availableFilters" }, outputs: { filter: "filter", search: "search", export: "export" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseTransactionsControls, decorators: [{
            type: Directive
        }], propDecorators: { isFilterApplied: [{
                type: Input
            }], exportConfig: [{
                type: Input
            }], availableFilters: [{
                type: Input
            }], filter: [{
                type: Output
            }], search: [{
                type: Output
            }], export: [{
                type: Output
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { AccessibilityKeyboardDirective, AccountsService, AvailableFilterEnum, AvailableFiltersConfigService, BaseTransactionIcon, BaseTransactionsContainer, BaseTransactionsControls, BaseTransactionsWidget, BillingStatusEnum, CapitalizePipe, CategoriesService, CheckImagesAvailability, DisputeStatusEnum, DocumentViewerBackdropComponent, DocumentViewerContainerComponent, DocumentViewerHeaderComponent, DocumentViewerInteractorComponent, DomAttributesService, DynamicIdDirective, EndpointType, EnumValuesService, ImageViewerComponent, LoadingState, MapAPILoaderService, MessagesService, NavigationService, OnLoadAction, PaginationType, PaymentsBatchService, PendingTransactionsService, TransactionCategoryIcon, TransactionCategoryIconComponent, TransactionCheckImageComponent, TransactionCheckImageDocumentViewerComponent, TransactionCheckImageItemComponent, TransactionCreditDebitIcon, TransactionDetailsService, TransactionGeoLocationMapComponent, TransactionIconType, TransactionState, TransactionTypeIcon, TransactionUpdateService, TransactionsBackendError, TransactionsCheckImageSide, TransactionsCheckImageType, TransactionsCheckImages, TransactionsCommonModule, TransactionsDetailsLoadingState, TransactionsDisputeBannerComponent, TransactionsDisputeStatusTagComponent, TransactionsEnumValue, TransactionsErrorStateCustomizableDirective, TransactionsExportErrorType, TransactionsFilterOptions, TransactionsGetParams, TransactionsGroupedByDate, TransactionsIconCategoriesFactoryService, TransactionsInquireAndDisputeUIService, TransactionsInquiryDisputeComponent, TransactionsList, TransactionsMapUiComponent, TransactionsNoAccountSelectedStateCustomizableDirective, TransactionsNumberOfResultsFoundComponent, TransactionsNumberOfResultsFoundCustomizableDirective, TransactionsService, WidgetPropertiesService, availableExportTypes, categoriesManagementMap, categoryListLevelParam, combineExportTypesConfig, creditDebitIndicatorEnumValues, defaultAccountOptions, defaultBillingStatusEnumValues, defaultFilterOptions, defaultInitialExportOptions, defaultInitialFilterOptions, defaultInitialListOptions, defaultInitialSortOptions, defaultMaxNavPage, defaultPageSize, defaultPaginationOptions, defaultSearchOptions, defaultSortOptions, defaultTransactionTypeEnumValues, deserialize, filterInputParameters, fromCategoriesManagementResponse, notificationTtl, parseSortOptions, showDetailsConfigToken, sortFieldsDirectionHeader, totalCountHeader, unvailableExportTypesReasons };
//# sourceMappingURL=backbase-transactions-common-ang.js.map
