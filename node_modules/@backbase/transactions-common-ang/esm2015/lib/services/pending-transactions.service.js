import { Injectable } from '@angular/core';
import { TransactionClientHttpService, } from '@backbase/data-ang/transactions';
import { AccountsService } from './accounts.service';
import { ReplaySubject, BehaviorSubject, combineLatest, of, merge, Subject, iif } from 'rxjs';
import { defaultInitialListOptions, defaultPaginationOptions, defaultSearchOptions, defaultFilterOptions, OnLoadAction, TransactionState, } from '../model/transactions-list-options.model';
import { map, scan, filter, distinctUntilChanged, tap, catchError } from 'rxjs/operators';
import { TransactionsList } from '../model/transactions-list.model';
import { TransactionsFilterOptions } from '../model/transactions-filter-options.model';
import { deepEqual, cacheRequest, multipleAccountsPredicate, onLoadTransactions, } from '../model/transactions-list-utils.model';
import { LoadingState } from './transactions.service';
import { EndpointType } from './widget-properties.service';
import { DeprecationsService } from '@backbase/foundation-ang/core';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/transactions";
import * as i2 from "./accounts.service";
import * as i3 from "@backbase/foundation-ang/core";
export class PendingTransactionsService {
    constructor(transactionsDataHttpService, accountService, deprecationsService) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.accountService = accountService;
        this.deprecationsService = deprecationsService;
        this.initialListOptions = new ReplaySubject(1);
        this.selectedAccount = new ReplaySubject(1);
        this.options = new BehaviorSubject({});
        this.listOptions = new BehaviorSubject(defaultInitialListOptions);
        this.listRefresh = new Subject();
        this.getOrPostEndpoint = new BehaviorSubject(EndpointType.GET_REQUEST);
        this.transactionsList = merge(this.listOptions.pipe(filter((listOptions) => typeof listOptions.account.arrangementId !== 'undefined'), distinctUntilChanged(deepEqual)), this.listRefresh).pipe(cacheRequest((listOptions) => {
            this.loadingState.next(listOptions.onLoad === OnLoadAction.Append
                ? LoadingState.LoadingMore
                : listOptions.onLoad === OnLoadAction.ReplacePage
                    ? LoadingState.LoadingPage
                    : LoadingState.Loading);
            return combineLatest([
                this.loadTransactions(listOptions).pipe(tap(() => {
                    this.loadingState.next(LoadingState.Loaded);
                }), map((transactionsList) => ({
                    transactionsList,
                    onLoad: OnLoadAction.ReplacePage,
                }))),
                iif(multipleAccountsPredicate(listOptions), this.accountService.getAllArrangements().pipe(map((accounts) => {
                    const accountMap = new Map();
                    accounts.forEach((account) => {
                        accountMap.set(account.id, account);
                    });
                    return accountMap;
                })), of(new Map())),
            ]).pipe(map(([transactions, accountMap]) => {
                transactions.transactionsList.items = transactions.transactionsList.items.map((transaction) => (Object.assign(Object.assign({}, transaction), { account: accountMap.get(transaction.arrangementId || '') })));
                return transactions;
            }));
        }), scan(onLoadTransactions, { items: [], totalCount: 0 }));
        this.loadingState = new BehaviorSubject(LoadingState.NotLoaded);
        this.isFilterApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.filter || {})));
        this.isSearchApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.search || {})));
        combineLatest([this.selectedAccount, this.initialListOptions])
            .pipe(map(([selectedAccount, initialListOptions]) => (Object.assign({ account: {
                arrangementId: selectedAccount,
            }, pagination: {
                from: 0,
                size: 250,
            }, state: TransactionState.uncompleted }, initialListOptions))))
            .subscribe(this.options);
        // Base this.listOptions on this.options
        this.options
            .pipe(scan((acc, curr) => Object.assign({}, acc, curr), defaultInitialListOptions))
            .subscribe(this.listOptions);
    }
    loadTransactions(listOptions) {
        const transactionPayload = TransactionsList.toHttpRequest(listOptions);
        let transactionsResponse;
        if (this.isUsingPostEndpoints) {
            transactionsResponse = this.transactionsDataHttpService.getTransactionsWithPost({
                transactionListRequest: transactionPayload,
            }, 'response');
        }
        else {
            this.deprecationsService.logDeprecatedFeature('[PendingTransactionsService: loadTransactions] GET endpoints are deprecated. Please use POST endpoints by changing CXP configuration');
            transactionsResponse = this.transactionsDataHttpService.getTransactions(transactionPayload, 'response');
        }
        return transactionsResponse.pipe(map(TransactionsList.fromHttpResponse), catchError((err) => of({
            items: [],
            totalCount: 0,
            httpResponseError: err,
        })));
    }
    getTransactionsFrom(selectedAccount, initialListOptions = of({}), getOrPostEndpoint = of(EndpointType.GET_REQUEST)) {
        selectedAccount.subscribe(this.selectedAccount);
        initialListOptions.subscribe(this.initialListOptions);
        getOrPostEndpoint.subscribe(this.getOrPostEndpoint);
    }
    getTransactionsList() {
        return this.transactionsList;
    }
    search(query) {
        const searchOptions = {
            query,
        };
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions, search: searchOptions }));
    }
    clearSearch() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions }));
    }
    filter(filterOptions) {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions, filter: Object.assign({}, filterOptions) }));
    }
    clearFilter() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions }));
    }
    sort(sortOptions) {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        this.options.next({
            sort: Object.assign({}, sortOptions),
            pagination: Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 }),
        });
    }
    retryFiltering() {
        this.listRefresh.next(this.listOptions.getValue());
    }
    refreshTransactions() {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        const paginationOptions = Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 });
        const newOptions = Object.assign(Object.assign({}, this.listOptions.getValue()), { pagination: paginationOptions });
        if (deepEqual(newOptions, this.listOptions.getValue())) {
            this.listRefresh.next(this.listOptions.getValue());
        }
        else {
            this.options.next({
                pagination: paginationOptions,
            });
        }
    }
    get isUsingPostEndpoints() {
        return this.getOrPostEndpoint.getValue() === EndpointType.POST_REQUEST;
    }
    ngOnDestroy() {
        this.listRefresh.complete();
        this.selectedAccount.complete();
        this.initialListOptions.complete();
        this.options.complete();
        this.listOptions.complete();
        this.loadingState.complete();
        this.getOrPostEndpoint.complete();
    }
}
PendingTransactionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PendingTransactionsService, deps: [{ token: i1.TransactionClientHttpService }, { token: i2.AccountsService }, { token: i3.DeprecationsService }], target: i0.ɵɵFactoryTarget.Injectable });
PendingTransactionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PendingTransactionsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PendingTransactionsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.TransactionClientHttpService }, { type: i2.AccountsService }, { type: i3.DeprecationsService }]; } });
//# sourceMappingURL=pending-transactions.service.js.map