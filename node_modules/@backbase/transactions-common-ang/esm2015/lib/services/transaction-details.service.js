import { Injectable } from '@angular/core';
import { TransactionClientHttpService } from '@backbase/data-ang/transactions';
import { Subject, of, ReplaySubject, combineLatest, from } from 'rxjs';
import { TransactionsCheckImages } from '../model/transactions-check-images.model';
import { switchMap, map, tap, scan, catchError, filter, mergeMap } from 'rxjs/operators';
import { TransactionsDetailsLoadingState } from '../model/transactions-details.model';
import { HttpResponse } from '@angular/common/http';
import { CheckImagesAvailability, daysDiff } from '../constants';
import { MapAPILoaderService } from './map-api-loader.service';
import { PaymentsBatchService } from './payments-batch.service';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/transactions";
import * as i2 from "./map-api-loader.service";
import * as i3 from "./payments-batch.service";
class ConfigManager {
    constructor(config) {
        this.config = config;
    }
    isDisputable(transaction) {
        return (this.isBillingStatusApproved(transaction) && !this.isOld(transaction) && this.isOfRestrictedType(transaction));
    }
    isBillingStatusApproved(transaction) {
        var _a;
        if (!((_a = this.config) === null || _a === void 0 ? void 0 : _a.byBillingStatus)) {
            return true;
        }
        return !(transaction === null || transaction === void 0 ? void 0 : transaction.isPending);
    }
    isOld(transaction) {
        var _a;
        if (!(transaction === null || transaction === void 0 ? void 0 : transaction.bookingDate)) {
            return false;
        }
        const days = daysDiff(new Date(), transaction.bookingDate);
        const byEligitibilityDays = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.byEligitibilityDays) || 0;
        return days > byEligitibilityDays;
    }
    isOfRestrictedType(transaction) {
        var _a;
        return (transaction === null || transaction === void 0 ? void 0 : transaction.type) ? (((_a = this.config) === null || _a === void 0 ? void 0 : _a.byTransactionTypes) || []).includes(transaction.type) : false;
    }
}
export class TransactionDetailsService {
    constructor(transactionsDataHttpService, mapApiLoader, paymentsBatchService) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.mapApiLoader = mapApiLoader;
        this.paymentsBatchService = paymentsBatchService;
        /**
         * watches the transaction that is shown in the details
         */
        this.transactionSelection = new Subject();
        /**
         * watches the configuration from CXP that can disable/enable check images
         */
        this.hasCheckImages = new ReplaySubject();
        /**
         * general status of each feature that runs asynchronously
         */
        this.transactionsDetailsStatus = new ReplaySubject();
        this.mapsApiKey = new ReplaySubject();
        this.batchOrder = this.transactionSelection.pipe(tap(() => {
            this.transactionsDetailsStatus.next({
                batchOrder: TransactionsDetailsLoadingState.loading,
            });
        }), mergeMap((transaction) => {
            if (!transaction.batchOrderId) {
                return of(undefined);
            }
            return this.paymentsBatchService.getBatch(transaction.batchOrderId).pipe(catchError(() => {
                this.transactionsDetailsStatus.next({
                    batchOrder: TransactionsDetailsLoadingState.error,
                });
                return of(undefined);
            }));
        }), map((data) => {
            this.transactionsDetailsStatus.next({
                batchOrder: data ? TransactionsDetailsLoadingState.done : TransactionsDetailsLoadingState.notStarted,
            });
            return data;
        }));
        this.transactionsDetailsStatus.next({
            checkImages: TransactionsDetailsLoadingState.notStarted,
            geolocation: TransactionsDetailsLoadingState.notStarted,
            enableDisputeAndInquiry: TransactionsDetailsLoadingState.notStarted,
            disputeOption: TransactionsDetailsLoadingState.notStarted,
            batchOrder: TransactionsDetailsLoadingState.notStarted,
        });
    }
    set enableDisputeAndInquiry(value) {
        this.transactionsDetailsStatus.next({
            enableDisputeAndInquiry: value ? TransactionsDetailsLoadingState.done : TransactionsDetailsLoadingState.notLoaded,
        });
    }
    fromInquiryAndDispute(enableDisputeAndInquiry, disputeByBillingStatus, disputeEligibilityDays, disputeTransactionTypes) {
        const config = combineLatest([
            enableDisputeAndInquiry,
            disputeByBillingStatus,
            disputeEligibilityDays,
            disputeTransactionTypes,
        ]).pipe(map(([enabled, byBillingStatus, byEligitibilityDays, byTransactionTypes]) => enabled ? { byBillingStatus, byEligitibilityDays, byTransactionTypes } : undefined));
        combineLatest([this.transactionSelection, config]).subscribe({
            next: ([transactionSelection, inquiryAndDispute]) => {
                if (!inquiryAndDispute) {
                    this.transactionsDetailsStatus.next({
                        enableDisputeAndInquiry: TransactionsDetailsLoadingState.notLoaded,
                        disputeOption: TransactionsDetailsLoadingState.notLoaded,
                    });
                }
                else {
                    const configuration = new ConfigManager(inquiryAndDispute);
                    this.transactionsDetailsStatus.next({
                        enableDisputeAndInquiry: TransactionsDetailsLoadingState.done,
                        disputeOption: configuration.isDisputable(transactionSelection)
                            ? TransactionsDetailsLoadingState.done
                            : TransactionsDetailsLoadingState.notLoaded,
                    });
                }
            },
        });
    }
    /**
     *
     * @param transactionId
     * triggers a new action that will cause transcations details reload and change an image
     */
    selectTransaction(transaction) {
        this.transactionSelection.next(transaction);
    }
    /**
     * Key-value pair that controls the loading status in transactions details
     */
    get loadingState() {
        return this.transactionsDetailsStatus.pipe(scan((acc, curr) => (Object.assign(Object.assign({}, acc), curr)), {}));
    }
    /**
     *
     * @param hasCheckImages
     * Configuration for check images reactive functionality
     */
    fromCheckImages(hasCheckImages) {
        hasCheckImages.subscribe(this.hasCheckImages);
        hasCheckImages
            .pipe(map((value) => ({
            checkImages: value ? TransactionsDetailsLoadingState.loading : TransactionsDetailsLoadingState.notLoaded,
        })))
            .subscribe({
            next: (value) => {
                this.transactionsDetailsStatus.next(value);
            },
        });
        return this.setCondition(this.transactionSelection, this.hasCheckImages).pipe(tap(() => {
            this.transactionsDetailsStatus.next({
                checkImages: TransactionsDetailsLoadingState.loading,
            });
        }), filter((transaction) => transaction.checkImageAvailability === CheckImagesAvailability.available), switchMap(({ id: transactionId = '' }) => this.transactionsDataHttpService.getTransactionCheckImages({ transactionId }, 'response').pipe(tap(() => {
            this.transactionsDetailsStatus.next({
                checkImages: TransactionsDetailsLoadingState.done,
            });
        }), catchError((error) => {
            switch (error.status) {
                case 500: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.serverError,
                    });
                    break;
                }
                case 400: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.badRequestError,
                    });
                    break;
                }
                case 404: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.notFoundError,
                    });
                    break;
                }
                default: {
                    this.transactionsDetailsStatus.next({
                        checkImages: TransactionsDetailsLoadingState.error,
                    });
                }
            }
            return of(new HttpResponse({
                body: {
                    images: [],
                },
            }));
        }), map(TransactionsCheckImages.fromHttpResponse))));
    }
    fromGeolocation(mapsApiKey) {
        mapsApiKey.subscribe(this.mapsApiKey);
        return combineLatest([this.transactionSelection, this.mapsApiKey]).pipe(map(([transaction, apiKey]) => {
            this.mapApiLoader.config = {
                apiKey,
                libraries: ['geometry'],
            };
            this.transactionsDetailsStatus.next({
                geolocation: TransactionsDetailsLoadingState.loading,
            });
            if (!apiKey || !transaction.location || !transaction.location.latitude || !transaction.location.longitude) {
                this.transactionsDetailsStatus.next({
                    geolocation: TransactionsDetailsLoadingState.notLoaded,
                });
                return Promise.resolve(false);
            }
            return this.mapApiLoader.load().then(() => {
                this.transactionsDetailsStatus.next({
                    geolocation: TransactionsDetailsLoadingState.done,
                });
                return true;
            }, () => {
                this.transactionsDetailsStatus.next({
                    geolocation: TransactionsDetailsLoadingState.error,
                });
                return false;
            });
        }), mergeMap((promise) => from(promise)));
    }
    /**
     * destroy lifecycle hook that will release resources
     */
    ngOnDestroy() {
        this.transactionSelection.complete();
        this.transactionsDetailsStatus.complete();
        this.mapsApiKey.complete();
    }
    /**
     *
     * @param feature
     * @param toggle
     *
     * Prevents from emiting values if the cxp configuration is set as disabled
     */
    setCondition(feature, toggle) {
        return combineLatest([feature, toggle]).pipe(filter(([, condition]) => condition), map(([value]) => value));
    }
}
TransactionDetailsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionDetailsService, deps: [{ token: i1.TransactionClientHttpService }, { token: i2.MapAPILoaderService }, { token: i3.PaymentsBatchService }], target: i0.ɵɵFactoryTarget.Injectable });
TransactionDetailsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionDetailsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionDetailsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.TransactionClientHttpService }, { type: i2.MapAPILoaderService }, { type: i3.PaymentsBatchService }]; } });
//# sourceMappingURL=transaction-details.service.js.map