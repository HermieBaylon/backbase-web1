import { Injectable } from '@angular/core';
import { GoogleMapsScriptProtocol } from '../model/transactions-map.model';
import * as i0 from "@angular/core";
export class MapAPILoaderService {
    constructor() {
        this.scriptID = 'bbGoogleMapsApiScript';
        this.callbackName = 'bbMapsAPILoader';
        this.apiLoadPromiseName = 'bbMapsAPILoaderPromise';
        this.windowRef = window;
        this.documentRef = document;
        this.configValue = {};
    }
    get config() {
        return this.configValue;
    }
    set config(config) {
        this.configValue = config;
    }
    get loadAPIPromise() {
        return this.windowRef[this.apiLoadPromiseName];
    }
    assignScriptLoadingPromise(scriptElem) {
        this.windowRef[this.apiLoadPromiseName] = new Promise((resolve, reject) => {
            this.windowRef[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    getScriptSrc(callbackName) {
        const protocolType = (this.configValue && this.configValue.protocol) || GoogleMapsScriptProtocol.HTTPS;
        let protocol = '';
        switch (protocolType) {
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this.configValue.hostAndPath || 'maps.googleapis.com/maps/api/js';
        // make sure we have places library for search component
        const libraries = this.configValue.libraries || [];
        if (libraries.indexOf('places') === -1) {
            this.configValue.libraries = [...libraries, 'places'];
        }
        const queryParams = {
            v: this.configValue.apiVersion || 'quarterly',
            callback: callbackName,
            key: this.configValue.apiKey,
            client: this.configValue.clientId,
            channel: this.configValue.channel,
            libraries: this.configValue.libraries,
            region: this.configValue.region,
            language: this.configValue.language,
        };
        const params = Object.keys(queryParams)
            .filter((key) => queryParams[key] !== undefined)
            .filter((key) => 
        // remove empty arrays
        !Array.isArray(queryParams[key]) ||
            (Array.isArray(queryParams[key]) && queryParams[key].length > 0))
            .map((key) => {
            let value = queryParams[key];
            if (Array.isArray(value)) {
                // join arrays as comma seperated strings
                value = value.join(',');
            }
            return `${key}=${value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
    load() {
        const window = this.windowRef;
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this.loadAPIPromise) {
            return this.loadAPIPromise;
        }
        const script = this.documentRef.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this.scriptID;
        script.src = this.getScriptSrc(this.callbackName);
        this.assignScriptLoadingPromise(script);
        this.documentRef.body.appendChild(script);
        return this.loadAPIPromise;
    }
}
MapAPILoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MapAPILoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=map-api-loader.service.js.map