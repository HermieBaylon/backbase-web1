import { Inject, Injectable, InjectionToken, LOCALE_ID } from '@angular/core';
import { TransactionClientHttpService, } from '@backbase/data-ang/transactions';
import { BehaviorSubject, combineLatest, iif, merge, of, ReplaySubject, Subject } from 'rxjs';
import { catchError, distinctUntilChanged, filter, first, map, scan, switchMap, tap } from 'rxjs/operators';
import { defaultFilterOptions, defaultInitialExportOptions, defaultInitialListOptions, defaultPaginationOptions, defaultSearchOptions, OnLoadAction, TransactionState, } from '../model/transactions-list-options.model';
import { TransactionsFilterOptions } from '../model/transactions-filter-options.model';
import { TransactionsList } from '../model/transactions-list.model';
import { AccountsService } from './accounts.service';
import { cacheRequest, deepEqual, multipleAccountsPredicate, onLoadTransactions, } from '../model/transactions-list-utils.model';
import { EndpointType } from './widget-properties.service';
import { DeprecationsService } from '@backbase/foundation-ang/core';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/transactions";
import * as i2 from "./accounts.service";
import * as i3 from "@backbase/foundation-ang/core";
export var LoadingState;
(function (LoadingState) {
    LoadingState["NotLoaded"] = "NotLoaded";
    LoadingState["LoadingMore"] = "LoadingMore";
    LoadingState["LoadingPage"] = "LoadingPage";
    LoadingState["Loading"] = "Loading";
    LoadingState["Loaded"] = "Loaded";
})(LoadingState || (LoadingState = {}));
export const showDetailsConfigToken = new InjectionToken('shows the transactions details modal');
export class TransactionsService {
    constructor(transactionsDataHttpService, accountService, deprecationsService, locale) {
        this.transactionsDataHttpService = transactionsDataHttpService;
        this.accountService = accountService;
        this.deprecationsService = deprecationsService;
        this.locale = locale;
        this.selectedAccount = new ReplaySubject(1);
        this.pageSize = new ReplaySubject(1);
        this.initialListOptions = new ReplaySubject(1);
        this.options = new BehaviorSubject({});
        this.listRefresh = new Subject();
        this.listOptions = new BehaviorSubject(defaultInitialListOptions);
        this.exportOptions = new BehaviorSubject(defaultInitialExportOptions);
        this.showPendingTransactionsOnTop = new ReplaySubject(1);
        this.getOrPostEndpoint = new BehaviorSubject(EndpointType.GET_REQUEST);
        this.transactionsList = merge(this.listOptions.pipe(filter((listOptions) => typeof listOptions.account.arrangementId !== 'undefined'), distinctUntilChanged(deepEqual)), this.listRefresh).pipe(cacheRequest((listOptions) => {
            this.loadingState.next(listOptions.onLoad === OnLoadAction.Append
                ? LoadingState.LoadingMore
                : listOptions.onLoad === OnLoadAction.ReplacePage
                    ? LoadingState.LoadingPage
                    : LoadingState.Loading);
            return combineLatest([
                this.loadTransactions(listOptions).pipe(tap(() => {
                    this.loadingState.next(LoadingState.Loaded);
                }), map((transactionsList) => ({
                    transactionsList,
                    onLoad: listOptions.onLoad,
                }))),
                iif(multipleAccountsPredicate(listOptions), this.accountService.getAllArrangements().pipe(map((accounts) => {
                    const accountMap = new Map();
                    accounts.forEach((account) => {
                        accountMap.set(account.id, account);
                    });
                    return accountMap;
                })), of(new Map())),
                this.isFilterApplied,
                this.isSearchApplied,
            ]).pipe(map(([transactions, accountMap, isFilterApplied, isSearchApplied]) => {
                transactions.transactionsList.items = transactions.transactionsList.items.map((transaction) => (Object.assign(Object.assign({}, transaction), { account: accountMap.get(transaction.arrangementId || '') })));
                transactions.transactionsList.initialRequest = !(isFilterApplied || isSearchApplied);
                return transactions;
            }));
        }), scan(onLoadTransactions, { items: [], totalCount: 0 }));
        this.loadingState = new BehaviorSubject(LoadingState.NotLoaded);
        this.isFilterApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.filter || {})));
        this.isSearchApplied = this.listOptions.pipe(map((options) => !TransactionsFilterOptions.isEmpty(options.search || {})));
        // Base this.options on this.selectedAccount, this.pageSize, this.initialListOptions
        combineLatest([this.selectedAccount, this.pageSize, this.initialListOptions, this.showPendingTransactionsOnTop])
            .pipe(map(([selectedAccount, pageSize, initialListOptions, showPendingTransactionsOnTop]) => (Object.assign(Object.assign(Object.assign({}, (showPendingTransactionsOnTop ? { state: TransactionState.completed } : {})), { account: {
                arrangementId: selectedAccount,
            }, pagination: {
                from: 0,
                size: pageSize,
            }, onLoad: OnLoadAction.Replace }), initialListOptions))))
            .subscribe(this.options);
        // Base this.listOptions on this.options
        this.options
            .pipe(scan((acc, curr) => Object.assign({}, acc, curr), defaultInitialListOptions))
            .subscribe(this.listOptions);
        // Base this.exportOptions on this.listOptions
        this.listOptions
            .pipe(filter((listOptions) => typeof listOptions.account.arrangementId !== 'undefined'), map((params) => (Object.assign(Object.assign({}, params), { pagination: undefined, state: undefined, exportType: 'csv', locale: 'en-US' }))))
            .subscribe(this.exportOptions);
    }
    loadTransactions(listOptions) {
        const transactionPayload = TransactionsList.toHttpRequest(listOptions);
        let transactionsResponse;
        if (this.isUsingPostEndpoints) {
            transactionsResponse = this.transactionsDataHttpService.getTransactionsWithPost({
                transactionListRequest: transactionPayload,
            }, 'response');
        }
        else {
            this.deprecationsService.logDeprecatedFeature('[TransactionsService: loadTransactions] GET endpoints deprecated. Please use POST endpoints by changing CXP configuration');
            transactionsResponse = this.transactionsDataHttpService.getTransactions(transactionPayload, 'response');
        }
        return transactionsResponse.pipe(map(TransactionsList.fromHttpResponse), catchError((err) => of({
            items: [],
            totalCount: 0,
            httpResponseError: err,
        })));
    }
    exportTransactions(exportOptions) {
        const exportPayload = TransactionsList.toHttpRequest(Object.assign(Object.assign({}, exportOptions), { locale: this.locale }));
        if (this.isUsingPostEndpoints) {
            return this.transactionsDataHttpService.getTransactionsExportWithPost({
                transactionListRequest: exportPayload,
            }, 'response');
        }
        else {
            this.deprecationsService.logDeprecatedFeature('[TransactionsService: exportTransactions] GET endpoints deprecated. Please use POST endpoints by changing CXP configuration');
            return this.transactionsDataHttpService.getTransactionsExport(exportPayload, 'response');
        }
    }
    search(query) {
        const searchOptions = {
            query,
        };
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions, search: searchOptions, onLoad: OnLoadAction.Replace }));
    }
    clearSearch() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultSearchOptions), { pagination: paginationOptions, onLoad: OnLoadAction.Replace }));
    }
    filter(filterOptions) {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions, filter: Object.assign({}, filterOptions), onLoad: OnLoadAction.Replace }));
    }
    clearFilter() {
        const paginationOptions = Object.assign(Object.assign({}, (this.options.getValue().pagination || defaultPaginationOptions.pagination)), { from: 0 });
        this.options.next(Object.assign(Object.assign(Object.assign({}, this.options.getValue()), defaultFilterOptions), { pagination: paginationOptions, onLoad: OnLoadAction.Replace }));
    }
    exportToType(type) {
        return this.exportOptions.pipe(first(), switchMap((exportOptions) => this.exportTransactions(Object.assign(Object.assign({}, exportOptions), { exportType: type }))));
    }
    loadMore() {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        const paginationOptions = Object.assign(Object.assign({}, currentPaginationOptions), { from: currentPaginationOptions.from + 1 });
        this.options.next({
            pagination: paginationOptions,
            onLoad: OnLoadAction.Append,
        });
    }
    sort(sortOptions) {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        this.options.next({
            sort: Object.assign({}, sortOptions),
            pagination: Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 }),
            onLoad: OnLoadAction.ReplacePage,
        });
    }
    pageChange(page) {
        const paginationOptions = Object.assign(Object.assign(Object.assign({}, defaultPaginationOptions.pagination), this.options.getValue().pagination), { from: page });
        this.options.next({
            pagination: paginationOptions,
            onLoad: OnLoadAction.ReplacePage,
        });
    }
    getTransactionsFrom(selectedAccount, pageSize, initialListOptions = of({}), showPendingTransactionsOnTop = of(false), getOrPostEndpoint = of(EndpointType.GET_REQUEST)) {
        selectedAccount.subscribe(this.selectedAccount);
        pageSize.subscribe(this.pageSize);
        initialListOptions.subscribe(this.initialListOptions);
        showPendingTransactionsOnTop.subscribe(this.showPendingTransactionsOnTop);
        getOrPostEndpoint.subscribe(this.getOrPostEndpoint);
    }
    getCurrentPage() {
        return this.listOptions.pipe(map((options) => (options.pagination || defaultPaginationOptions.pagination).from));
    }
    getTransactionsList() {
        return this.transactionsList;
    }
    retryFiltering() {
        this.listRefresh.next(this.listOptions.getValue());
    }
    refreshTransactions() {
        const currentPaginationOptions = this.options.getValue().pagination || defaultPaginationOptions.pagination;
        const paginationOptions = Object.assign(Object.assign({}, currentPaginationOptions), { from: 0 });
        const newOptions = Object.assign(Object.assign({}, this.listOptions.getValue()), { pagination: paginationOptions, onLoad: OnLoadAction.ReplacePage });
        if (deepEqual(newOptions, this.listOptions.getValue())) {
            this.listRefresh.next(this.listOptions.getValue());
        }
        else {
            this.options.next({
                pagination: paginationOptions,
                onLoad: OnLoadAction.ReplacePage,
            });
        }
    }
    get isUsingPostEndpoints() {
        return this.getOrPostEndpoint.getValue() === EndpointType.POST_REQUEST;
    }
    ngOnDestroy() {
        this.listRefresh.complete();
        this.selectedAccount.complete();
        this.pageSize.complete();
        this.initialListOptions.complete();
        this.options.complete();
        this.listOptions.complete();
        this.exportOptions.complete();
        this.showPendingTransactionsOnTop.complete();
        this.loadingState.complete();
        this.getOrPostEndpoint.complete();
    }
}
TransactionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsService, deps: [{ token: i1.TransactionClientHttpService }, { token: i2.AccountsService }, { token: i3.DeprecationsService }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Injectable });
TransactionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TransactionsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.TransactionClientHttpService }, { type: i2.AccountsService }, { type: i3.DeprecationsService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });
//# sourceMappingURL=transactions.service.js.map