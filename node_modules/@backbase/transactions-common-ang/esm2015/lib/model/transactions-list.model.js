import { sortFieldsDirectionHeader, totalCountHeader, availableExportTypes, unvailableExportTypesReasons, BillingStatusEnum, } from '../constants';
/* eslint-disable no-redeclare*/
// eslint-disable-next-line @typescript-eslint/no-namespace
export var TransactionsList;
(function (TransactionsList) {
    // eslint-disable-next-line complexity
    const processTransaction = (transaction) => {
        const amountSign = transaction.creditDebitIndicator === 'DBIT' ? -1 : 1;
        const formattedTransaction = Object.assign(Object.assign(Object.assign({}, transaction), { isPending: (function isPending(data) {
                let result = false;
                if (data && data.billingStatus) {
                    const billingStatus = data.billingStatus.toUpperCase();
                    result = billingStatus === BillingStatusEnum.pending || billingStatus === BillingStatusEnum.unbilled;
                }
                return result;
            })(transaction) }), (transaction.merchant
            ? {
                merchant: Object.assign(Object.assign({ id: transaction.merchant.id, name: transaction.merchant.name }, (transaction.merchant.logo ? { logo: transaction.merchant.logo } : {})), (transaction.merchant.website ? { website: transaction.merchant.website } : {})),
            }
            : {}));
        if (transaction.transactionAmountCurrency) {
            const amountNumber = parseFloat(transaction.transactionAmountCurrency.amount);
            formattedTransaction.transactionAmountCurrency = Object.assign(Object.assign({}, transaction.transactionAmountCurrency), { unsignedAmount: amountNumber, amount: (amountSign * (amountNumber || 0)).toString() });
        }
        if (transaction.instructedAmountCurrency) {
            const amountNumber = parseFloat(transaction.instructedAmountCurrency.amount);
            formattedTransaction.instructedAmountCurrency = Object.assign(Object.assign({}, transaction.instructedAmountCurrency), { unsignedAmount: amountNumber, amount: (amountSign * (amountNumber || 0)).toString() });
        }
        formattedTransaction.currencyExchangeAvailability =
            !!transaction.instructedAmountCurrency &&
                !!transaction.transactionAmountCurrency &&
                !!transaction.currencyExchangeRate;
        return formattedTransaction;
    };
    const processTransactions = (transactionsList) => (Object.assign(Object.assign({}, transactionsList), { items: transactionsList.items.map(processTransaction) }));
    const processTotalCountHeader = (totalCount) => (totalCount ? parseInt(totalCount, 10) : 0);
    const processAvailableExportTypes = (availableExports) => availableExports || '';
    const processUnavailableExportTypesReasons = (unavilableExportTypesReasonsValue) => JSON.parse(unavilableExportTypesReasonsValue || '{}');
    const processSortFieldsDirectionHeader = (sortFieldsDirection) => {
        if (sortFieldsDirection === null || !sortFieldsDirection.length) {
            return undefined;
        }
        const sortOption = sortFieldsDirection
            .split(',')[0]
            .trim()
            .replace(/\s{2,}/g, ' ');
        const [orderBy, direction] = sortOption.split(' ');
        if (!orderBy || (direction !== 'ASC' && direction !== 'DESC')) {
            throw new Error(`Invalid value for "initialSortOptions" property.
        Please use "<orderBy> <direction>" format, e.g., "bookingDate DESC",
        or leave it empty.`);
        }
        return {
            orderBy,
            direction,
        };
    };
    // eslint-disable-next-line no-inner-declarations
    function padValueWithZeros(value, size = 2) {
        return (value + '').padStart(size, '0');
    }
    // eslint-disable-next-line no-inner-declarations
    function formatDate(date) {
        const safeDate = date || '';
        if (/^[0-9]{4}-[0-9]{2}-[0-9]{2}/.exec(safeDate)) {
            const localDate = new Date(safeDate);
            const month = padValueWithZeros(localDate.getMonth() + 1);
            const day = padValueWithZeros(localDate.getDate());
            const year = localDate.getFullYear();
            return `${year}-${month}-${day}`;
        }
        else if (date !== undefined) {
            console.error(`invalid date provided ${date}`);
        }
        return undefined;
    }
    TransactionsList.fromHttpResponse = (response) => {
        const totalCount = processTotalCountHeader(response.headers.get(totalCountHeader));
        const sort = processSortFieldsDirectionHeader(response.headers.get(sortFieldsDirectionHeader));
        const availableExportTypesHeader = processAvailableExportTypes(response.headers.get(availableExportTypes));
        const unavailableExportTypesReasonsHeader = processUnavailableExportTypesReasons(response.headers.get(unvailableExportTypesReasons));
        return processTransactions(Object.assign(Object.assign({ items: response.body || [], totalCount }, (sort ? { sort } : {})), { availableExportTypesHeader,
            unavailableExportTypesReasonsHeader }));
    };
    TransactionsList.concat = (transactionsList1, transactionsList2) => {
        if (transactionsList2.httpResponseError) {
            return Object.assign(Object.assign({}, transactionsList1), { items: [...transactionsList1.items], httpResponseError: transactionsList2.httpResponseError });
        }
        return Object.assign(Object.assign(Object.assign(Object.assign({ items: [...transactionsList1.items, ...transactionsList2.items], totalCount: transactionsList1.totalCount }, (transactionsList2.sort ? { sort: transactionsList2.sort } : {})), (transactionsList2.availableExportTypesHeader
            ? {
                availableExportTypesHeader: transactionsList2.availableExportTypesHeader,
            }
            : {})), (transactionsList2.unavailableExportTypesReasonsHeader
            ? {
                unavailableExportTypesReasonsHeader: transactionsList2.unavailableExportTypesReasonsHeader,
            }
            : {})), { httpResponseError: transactionsList2.httpResponseError });
    };
    TransactionsList.hasLoadedAll = (transactionsList) => transactionsList.items.length === transactionsList.totalCount;
    TransactionsList.toHttpRequest = (listOptions) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2;
        const turnIntoArrayObject = (value, name, fn) => {
            if (!value) {
                return {};
            }
            return Array.isArray(value) ? { [name]: fn(value) } : { [name]: [fn(value)] };
        };
        const optionalItem = (name, value) => (value !== undefined ? { [name]: value } : {});
        const isTransactionListOption = (data) => Object.prototype.hasOwnProperty.call(data, 'pagination');
        const isTransactionExportOptions = (data) => Object.prototype.hasOwnProperty.call(data, 'exportType');
        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, turnIntoArrayObject(listOptions.account.arrangementId, 'arrangementsIds', (value) => value)), optionalItem('query', (_a = listOptions.search) === null || _a === void 0 ? void 0 : _a.query)), optionalItem('amountGreaterThan', (_c = (_b = listOptions.filter) === null || _b === void 0 ? void 0 : _b.amount) === null || _c === void 0 ? void 0 : _c.from)), optionalItem('amountLessThan', (_e = (_d = listOptions.filter) === null || _d === void 0 ? void 0 : _d.amount) === null || _e === void 0 ? void 0 : _e.to)), optionalItem('bookingDateGreaterThan', ((_g = (_f = listOptions.filter) === null || _f === void 0 ? void 0 : _f.date) === null || _g === void 0 ? void 0 : _g.from) === '' ? undefined : formatDate((_j = (_h = listOptions.filter) === null || _h === void 0 ? void 0 : _h.date) === null || _j === void 0 ? void 0 : _j.from))), optionalItem('bookingDateLessThan', ((_l = (_k = listOptions.filter) === null || _k === void 0 ? void 0 : _k.date) === null || _l === void 0 ? void 0 : _l.to) === '' ? undefined : formatDate((_o = (_m = listOptions.filter) === null || _m === void 0 ? void 0 : _m.date) === null || _o === void 0 ? void 0 : _o.to))), optionalItem('categories', (_p = listOptions.filter) === null || _p === void 0 ? void 0 : _p.categories)), optionalItem('fromCheckSerialNumber', (_r = (_q = listOptions.filter) === null || _q === void 0 ? void 0 : _q.checkSerialNumber) === null || _r === void 0 ? void 0 : _r.from)), optionalItem('toCheckSerialNumber', (_t = (_s = listOptions.filter) === null || _s === void 0 ? void 0 : _s.checkSerialNumber) === null || _t === void 0 ? void 0 : _t.to)), optionalItem('orderBy', (_u = listOptions.sort) === null || _u === void 0 ? void 0 : _u.orderBy)), optionalItem('direction', (_v = listOptions.sort) === null || _v === void 0 ? void 0 : _v.direction)), optionalItem('state', isTransactionListOption(listOptions) ? listOptions.state : undefined)), optionalItem('from', isTransactionListOption(listOptions) ? (_w = listOptions.pagination) === null || _w === void 0 ? void 0 : _w.from : undefined)), optionalItem('size', isTransactionListOption(listOptions) ? (_x = listOptions.pagination) === null || _x === void 0 ? void 0 : _x.size : undefined)), optionalItem('billingStatus', (_z = (_y = listOptions.filter) === null || _y === void 0 ? void 0 : _y.billingStatus) === null || _z === void 0 ? void 0 : _z.value)), optionalItem('creditDebitIndicator', (_1 = (_0 = listOptions.filter) === null || _0 === void 0 ? void 0 : _0.creditDebitIndicator) === null || _1 === void 0 ? void 0 : _1.value)), optionalItem('exportType', isTransactionExportOptions(listOptions) ? listOptions.exportType : undefined)), optionalItem('locale', isTransactionExportOptions(listOptions) ? listOptions.locale : undefined)), turnIntoArrayObject((_2 = listOptions.filter) === null || _2 === void 0 ? void 0 : _2.types, 'types', (value) => value.value));
    };
})(TransactionsList || (TransactionsList = {}));
/* eslint-enable no-redeclare*/
//# sourceMappingURL=transactions-list.model.js.map