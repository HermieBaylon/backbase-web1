import { getMonthDiff } from '../helpers/date-helpers';
/**
 * Validate if the given month limit is lies in between two dates
 *
 * @param number Number of months that will be validated
 * @param Date [from=new Date(0)] start range of the month limit
 * @param Date [to=new Date()] end range of the month limit
 * @returns boolean
 * @example isMonthLimitValid(5)
 */
export const isMonthLimitValid = (month, from = new Date(0), to = new Date()) => month > 0 && month <= getMonthDiff(from, to);
/**
 * Validate if the date lies in between two dates
 *
 * @param number Number of months that will be validated
 * @param Date [from=new Date(0)] start range of the month limit
 * @param Date [to=new Date()] end range of the month limit
 * @returns boolean
 * @example isDateLimitValid('1994-10-20')
 */
export const isDateLimitValid = (input, from = new Date(0), to = new Date()) => {
    const date = new Date(input);
    if (isNaN(date.getTime())) {
        return false;
    }
    return date >= from && date <= to;
};
/**
 * Validate if the date format is of type (yyyy-MM-dd, yyyy/MM/dd, yyyy.MM.dd)
 *
 * @param string input string
 * @returns boolean
 * @example isDateFormatValid('1994-10-20')
 */
export const isDateFormatValid = (input) => {
    const formats = [
        /([12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))/,
        /([12]\d{3}\.(0[1-9]|1[0-2])\.(0[1-9]|[12]\d|3[01]))/,
        /([12]\d{3}\/(0[1-9]|1[0-2])\/(0[1-9]|[12]\d|3[01]))/,
    ];
    return formats.some(format => format.test(input));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS12YWxpZGF0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL2FjY291bnQtc3RhdGVtZW50LWNvbW1vbi1hbmcvc3JjL3ZhbGlkYXRvcnMvZGF0ZS12YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRXZEOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFhLEVBQUUsT0FBYSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFXLElBQUksSUFBSSxFQUFFLEVBQVcsRUFBRSxDQUMzRyxLQUFLLEdBQUcsQ0FBQyxJQUFJLEtBQUssSUFBSSxZQUFZLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBRS9DOzs7Ozs7OztHQVFHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFhLEVBQUUsT0FBYSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFXLElBQUksSUFBSSxFQUFFLEVBQVcsRUFBRTtJQUMxRyxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRTtRQUN6QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsT0FBTyxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFLENBQUM7QUFDcEMsQ0FBQyxDQUFDO0FBRUY7Ozs7OztHQU1HO0FBQ0gsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxLQUFhLEVBQVcsRUFBRTtJQUMxRCxNQUFNLE9BQU8sR0FBRztRQUNkLG1EQUFtRDtRQUNuRCxxREFBcUQ7UUFDckQscURBQXFEO0tBQ3RELENBQUM7SUFDRixPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TW9udGhEaWZmIH0gZnJvbSAnLi4vaGVscGVycy9kYXRlLWhlbHBlcnMnO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHRoZSBnaXZlbiBtb250aCBsaW1pdCBpcyBsaWVzIGluIGJldHdlZW4gdHdvIGRhdGVzXG4gKlxuICogQHBhcmFtIG51bWJlciBOdW1iZXIgb2YgbW9udGhzIHRoYXQgd2lsbCBiZSB2YWxpZGF0ZWRcbiAqIEBwYXJhbSBEYXRlIFtmcm9tPW5ldyBEYXRlKDApXSBzdGFydCByYW5nZSBvZiB0aGUgbW9udGggbGltaXRcbiAqIEBwYXJhbSBEYXRlIFt0bz1uZXcgRGF0ZSgpXSBlbmQgcmFuZ2Ugb2YgdGhlIG1vbnRoIGxpbWl0XG4gKiBAcmV0dXJucyBib29sZWFuXG4gKiBAZXhhbXBsZSBpc01vbnRoTGltaXRWYWxpZCg1KVxuICovXG5leHBvcnQgY29uc3QgaXNNb250aExpbWl0VmFsaWQgPSAobW9udGg6IG51bWJlciwgZnJvbTogRGF0ZSA9IG5ldyBEYXRlKDApLCB0bzogRGF0ZSA9IG5ldyBEYXRlKCkpOiBib29sZWFuID0+XG4gIG1vbnRoID4gMCAmJiBtb250aCA8PSBnZXRNb250aERpZmYoZnJvbSwgdG8pO1xuXG4vKipcbiAqIFZhbGlkYXRlIGlmIHRoZSBkYXRlIGxpZXMgaW4gYmV0d2VlbiB0d28gZGF0ZXNcbiAqXG4gKiBAcGFyYW0gbnVtYmVyIE51bWJlciBvZiBtb250aHMgdGhhdCB3aWxsIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIERhdGUgW2Zyb209bmV3IERhdGUoMCldIHN0YXJ0IHJhbmdlIG9mIHRoZSBtb250aCBsaW1pdFxuICogQHBhcmFtIERhdGUgW3RvPW5ldyBEYXRlKCldIGVuZCByYW5nZSBvZiB0aGUgbW9udGggbGltaXRcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqIEBleGFtcGxlIGlzRGF0ZUxpbWl0VmFsaWQoJzE5OTQtMTAtMjAnKVxuICovXG5leHBvcnQgY29uc3QgaXNEYXRlTGltaXRWYWxpZCA9IChpbnB1dDogc3RyaW5nLCBmcm9tOiBEYXRlID0gbmV3IERhdGUoMCksIHRvOiBEYXRlID0gbmV3IERhdGUoKSk6IGJvb2xlYW4gPT4ge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoaW5wdXQpO1xuICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBkYXRlID49IGZyb20gJiYgZGF0ZSA8PSB0bztcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgaWYgdGhlIGRhdGUgZm9ybWF0IGlzIG9mIHR5cGUgKHl5eXktTU0tZGQsIHl5eXkvTU0vZGQsIHl5eXkuTU0uZGQpXG4gKlxuICogQHBhcmFtIHN0cmluZyBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqIEBleGFtcGxlIGlzRGF0ZUZvcm1hdFZhbGlkKCcxOTk0LTEwLTIwJylcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRGF0ZUZvcm1hdFZhbGlkID0gKGlucHV0OiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgY29uc3QgZm9ybWF0cyA9IFtcbiAgICAvKFsxMl1cXGR7M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18WzEyXVxcZHwzWzAxXSkpLyxcbiAgICAvKFsxMl1cXGR7M31cXC4oMFsxLTldfDFbMC0yXSlcXC4oMFsxLTldfFsxMl1cXGR8M1swMV0pKS8sXG4gICAgLyhbMTJdXFxkezN9XFwvKDBbMS05XXwxWzAtMl0pXFwvKDBbMS05XXxbMTJdXFxkfDNbMDFdKSkvLFxuICBdO1xuICByZXR1cm4gZm9ybWF0cy5zb21lKGZvcm1hdCA9PiBmb3JtYXQudGVzdChpbnB1dCkpO1xufTtcbiJdfQ==