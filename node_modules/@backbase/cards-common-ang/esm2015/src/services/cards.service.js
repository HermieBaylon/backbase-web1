import { __rest } from "tslib";
import { Injectable } from '@angular/core';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { catchError, distinctUntilChanged, map, publishReplay, refCount, switchMap } from 'rxjs/operators';
import { PaymentCardReplacementStatus, PaymentCardStatus, } from '../model/payment-card.model';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/cards";
import * as i2 from "./cards-backend.service";
const initialGetParams = {};
const deepEqual = (x, y) => x && y && typeof x === 'object' && typeof x === typeof y
    ? Object.keys(x).length === Object.keys(y).length && Object.keys(x).every((key) => deepEqual(x[key], y[key]))
    : x === y;
const cacheRequest = (request) => (source) => source.pipe(switchMap(request), publishReplay(1), refCount());
/**
 * @name CardsService
 *
 * @description
 * Service for retrieving cards from the backend.
 */
export class CardsService {
    constructor(cardsDataHttpService, cardsBackendService, cardsTravelNotice) {
        this.cardsDataHttpService = cardsDataHttpService;
        this.cardsBackendService = cardsBackendService;
        this.cardsTravelNotice = cardsTravelNotice;
        this.getParams = new BehaviorSubject(initialGetParams);
        this.paymentCards = this.getParams.pipe(distinctUntilChanged(deepEqual), cacheRequest((getParams) => this.cardsDataHttpService.getCards(getParams, 'response').pipe(map((response) => this.cardsBackendService.itemListToModel(response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }))));
        this.travelNotice = this.cardsTravelNotice.getTravelNotices('response').pipe(distinctUntilChanged(deepEqual), map((response) => (response.body === null ? [] : response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    /**
     * @name CardsService#getCards
     * @returns The (single-instance) observable of payment cards retrieved from the backend.
     *
     * @description
     * Returns the (single-instance) observable of payment cards retrieved from the backend.
     */
    getCards() {
        return this.paymentCards;
    }
    setParameters(typesParams) {
        typesParams
            .pipe(map((types) => ({
            types,
        })))
            .subscribe(this.getParams);
    }
    /**
     * @name CardsService#updateLockStatus
     * @returns An observable of the payment card with updated lock status.
     *
     * @description
     * Calls the backend to change the lock status and returns an observable of updated payment card
     * returned in the response.  If that response is empty, the existing payment card with the
     * updated lock status is returned.
     */
    updateLockStatus(card, lockStatus) {
        const body = this.cardsBackendService.getLockStatusUpdate(lockStatus);
        return this.cardsDataHttpService.updateLockStatus({ id: card.id, lockStatusPost: body }, 'response').pipe(map((response) => response.body === null
            ? Object.assign(Object.assign({}, card), { lockStatus }) : this.cardsBackendService.itemToModel(response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    /**
     * @name CardsService#initiateReplacement
     * @returns An observable of the payment card with updated replacement status.
     *
     * @description
     * Calls the backend to initiate replacement and returns an observable of the updated payment
     * card returned in the response.  If the response is empty, the existing payment card with
     * replacement status set to `UNDER_REPLACEMENT` is returned.
     */
    initiateReplacement(card, replacementReason) {
        const body = this.cardsBackendService.getReplacementUpdate(replacementReason);
        return this.cardsDataHttpService.requestReplacement({ id: card.id, requestReplacementPost: body }, 'response').pipe(map((response) => response.body === null
            ? Object.assign(Object.assign({}, card), { replacementStatus: PaymentCardReplacementStatus.UnderReplacement }) : this.cardsBackendService.itemToModel(response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    /**
     * @name CardsService#initiateActivation
     * @returns An observable of the payment card with updated status.
     *
     * @description
     * Calls the backend to activate a payment card and returns an observable of the updated payment
     * card returned in the response.  If the response is empty, the existing payment card with
     * status set to `ACTIVE` is returned.
     */
    initiateActivation(card, token) {
        const body = { token };
        return this.cardsDataHttpService.activate({ id: card.id, activatePost: body }, 'response').pipe(map((response) => response.body === null
            ? Object.assign(Object.assign({}, card), { status: PaymentCardStatus.Active }) : this.cardsBackendService.itemToModel(response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    /**
     * @name CardsService#updateLimit
     * @returns An observable of the payment card with updated limits.
     *
     * @description
     * Calls the backend to update a payment card and returns an observable of the updated payment
     * card returned in the response.  If the response is empty, the existing payment card with
     * limits updated is returned.
     */
    updateLimit(card, limit, updateAllLimits) {
        const limitPayload = updateAllLimits
            ? limit
            : limit.filter((newLimitItem, index) => { var _a; return newLimitItem.amount !== ((_a = card.limits) === null || _a === void 0 ? void 0 : _a[index].amount); });
        return this.cardsDataHttpService.changeLimits({ id: card.id, changeLimitsPostItem: limitPayload }, 'response').pipe(map((response) => {
            const limits = card.limits &&
                card.limits.map((item, index) => (Object.assign(Object.assign({}, item), { amount: limit[index].amount })));
            return response.body === null
                ? Object.assign(Object.assign({}, card), { limits }) : this.cardsBackendService.itemToModel(response.body);
        }), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    resetPIN(card, paymentCardResetPin) {
        return this.cardsDataHttpService.resetPin({ id: card.id, resetPinPost: paymentCardResetPin }, 'response').pipe(map((response) => response.body === null
            ? Object.assign({}, card) : this.cardsBackendService.itemToModel(response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    requestPIN(card, paymentCardResetPin) {
        return this.cardsDataHttpService.requestPin({ id: card.id, requestPinPost: paymentCardResetPin }, 'response').pipe(map((response) => response.body === null
            ? Object.assign({}, card) : this.cardsBackendService.itemToModel(response.body)), catchError((error) => {
            throw this.cardsBackendService.parseError(error);
        }));
    }
    /**
     *  Modified - added a observable to only respond with active cards.
     *
     * @returns Observable with all travel notices and payment cards with
     * status active
     */
    getTravelNotice() {
        const activeCards = this.paymentCards.pipe(map((cards) => cards.filter((card) => card.status === PaymentCardStatus.Active)));
        return combineLatest([activeCards, this.travelNotice]).pipe(map(([paymentCards, travelNotice]) => ({
            travelNoticeList: travelNotice.map((item) => this.cardsBackendService.travelNoticeToModel(item, paymentCards)),
            paymentCards,
        })));
    }
    postTravelNotice(travelNoticeItem) {
        const { cards } = travelNoticeItem, otherTravelNoticeProperties = __rest(travelNoticeItem, ["cards"]);
        const travelNoticeData = Object.assign(Object.assign({}, otherTravelNoticeProperties), { cardIds: cards.map((item) => item.id) });
        return this.cardsTravelNotice.createTravelNotice({ travelNotice: travelNoticeData });
    }
    deleteTravelNotice(travelNoticeItem) {
        const { id } = travelNoticeItem;
        if (!id)
            throw new Error('Error no matching id');
        return this.cardsTravelNotice.deleteTravelNoticeById({ id }, 'response');
    }
    ngOnDestroy() {
        this.getParams.complete();
    }
}
CardsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CardsService, deps: [{ token: i1.CardsHttpService }, { token: i2.CardsBackendService }, { token: i1.TravelNoticesHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
CardsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CardsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CardsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.CardsHttpService }, { type: i2.CardsBackendService }, { type: i1.TravelNoticesHttpService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZHMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2FyZHMtY29tbW9uLWFuZy9zcmMvc2VydmljZXMvY2FyZHMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsT0FBTyxFQUFFLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUV0RCxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBYyxNQUFNLE1BQU0sQ0FBQztBQUNsRSxPQUFPLEVBQUUsVUFBVSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSTNHLE9BQU8sRUFHTCw0QkFBNEIsRUFDNUIsaUJBQWlCLEdBQ2xCLE1BQU0sNkJBQTZCLENBQUM7Ozs7QUFJckMsTUFBTSxnQkFBZ0IsR0FBbUIsRUFBRSxDQUFDO0FBRTVDLE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBTSxFQUFFLENBQU0sRUFBVyxFQUFFLENBQzVDLENBQUMsSUFBSSxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLE9BQU8sQ0FBQyxLQUFLLE9BQU8sQ0FBQztJQUN0RCxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDN0csQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFFZCxNQUFNLFlBQVksR0FDaEIsQ0FBaUIsT0FBK0MsRUFBRSxFQUFFLENBQ3BFLENB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NUQsU0FBeUMsQ0FBbUIsQ0FBQztRQUNuRSxNQUFNLGdCQUFnQixHQUFHLGdDQUFLLDJCQUEyQixLQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQVMsQ0FBQztRQUUxRyxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxDQUFDLENBQUM7SUFDdkYsQ0FBQztJQUVELGtCQUFrQixDQUFDLGdCQUFtQztRQUNwRCxNQUFNLEVBQUUsRUFBRSxFQUFFLEdBQUcsZ0JBQWdCLENBQUM7UUFDaEMsSUFBSSxDQUFDLEVBQUU7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7UUFFakQsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsc0JBQXNCLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUMzRSxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDNUIsQ0FBQzs7MEdBcE9VLFlBQVk7OEdBQVosWUFBWTs0RkFBWixZQUFZO2tCQUR4QixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDYXJkc0h0dHBTZXJ2aWNlIGFzIEFwaUNhcmRzU2VydmljZSwgVHJhdmVsTm90aWNlLCBUcmF2ZWxOb3RpY2VzSHR0cFNlcnZpY2UgfSBmcm9tICdAYmFja2Jhc2UvZGF0YS1hbmcvY2FyZHMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBwdWJsaXNoUmVwbGF5LCByZWZDb3VudCwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FyZHNHZXRQYXJhbXMgfSBmcm9tICcuLi9tb2RlbC9jYXJkcy1nZXQtcGFyYW1zLm1vZGVsJztcbmltcG9ydCB7IFBheW1lbnRDYXJkTGltaXQgfSBmcm9tICcuLi9tb2RlbC9wYXltZW50LWNhcmQtbGltaXQubW9kZWwnO1xuaW1wb3J0IHsgUGF5bWVudENhcmRSZXBsYWNlbWVudFJlYXNvbiB9IGZyb20gJy4uL21vZGVsL3BheW1lbnQtY2FyZC1yZXBsYWNlbWVudC1yZWFzb24ubW9kZWwnO1xuaW1wb3J0IHtcbiAgUGF5bWVudENhcmQsXG4gIFBheW1lbnRDYXJkTG9ja1N0YXR1cyxcbiAgUGF5bWVudENhcmRSZXBsYWNlbWVudFN0YXR1cyxcbiAgUGF5bWVudENhcmRTdGF0dXMsXG59IGZyb20gJy4uL21vZGVsL3BheW1lbnQtY2FyZC5tb2RlbCc7XG5pbXBvcnQgeyBGdWxsVHJhdmVsTm90aWNlTW9kZWwsIFRyYXZlbE5vdGljZSBhcyBUcmF2ZWxOb3RpY2VNb2RlbCB9IGZyb20gJy4uL21vZGVsL3RyYXZlbC1ub3RpY2UubW9kZWwnO1xuaW1wb3J0IHsgQ2FyZHNCYWNrZW5kU2VydmljZSB9IGZyb20gJy4vY2FyZHMtYmFja2VuZC5zZXJ2aWNlJztcblxuY29uc3QgaW5pdGlhbEdldFBhcmFtczogQ2FyZHNHZXRQYXJhbXMgPSB7fTtcblxuY29uc3QgZGVlcEVxdWFsID0gKHg6IGFueSwgeTogYW55KTogYm9vbGVhbiA9PlxuICB4ICYmIHkgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHR5cGVvZiB4ID09PSB0eXBlb2YgeVxuICAgID8gT2JqZWN0LmtleXMoeCkubGVuZ3RoID09PSBPYmplY3Qua2V5cyh5KS5sZW5ndGggJiYgT2JqZWN0LmtleXMoeCkuZXZlcnkoKGtleSkgPT4gZGVlcEVxdWFsKHhba2V5XSwgeVtrZXldKSlcbiAgICA6IHggPT09IHk7XG5cbmNvbnN0IGNhY2hlUmVxdWVzdCA9XG4gIDxQYXJhbXMsIFJlc3VsdD4ocmVxdWVzdDogKHBhcmFtczogUGFyYW1zKSA9PiBPYnNlcnZhYmxlPFJlc3VsdD4pID0+XG4gIChzb3VyY2U6IE9ic2VydmFibGU8UGFyYW1zPik6IE9ic2VydmFibGU8UmVzdWx0PiA9PlxuICAgIHNvdXJjZS5waXBlKHN3aXRjaE1hcChyZXF1ZXN0KSwgcHVibGlzaFJlcGxheSgxKSwgcmVmQ291bnQoKSk7XG5cbi8qKlxuICogQG5hbWUgQ2FyZHNTZXJ2aWNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTZXJ2aWNlIGZvciByZXRyaWV2aW5nIGNhcmRzIGZyb20gdGhlIGJhY2tlbmQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYXJkc1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHJlYWRvbmx5IGdldFBhcmFtcyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q2FyZHNHZXRQYXJhbXM+KGluaXRpYWxHZXRQYXJhbXMpO1xuICBwcml2YXRlIHJlYWRvbmx5IHBheW1lbnRDYXJkczogT2JzZXJ2YWJsZTxBcnJheTxQYXltZW50Q2FyZD4+ID0gdGhpcy5nZXRQYXJhbXMucGlwZShcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZChkZWVwRXF1YWwpLFxuICAgIGNhY2hlUmVxdWVzdCgoZ2V0UGFyYW1zKSA9PlxuICAgICAgdGhpcy5jYXJkc0RhdGFIdHRwU2VydmljZS5nZXRDYXJkcyhnZXRQYXJhbXMsICdyZXNwb25zZScpLnBpcGUoXG4gICAgICAgIG1hcCgocmVzcG9uc2UpID0+IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5pdGVtTGlzdFRvTW9kZWwocmVzcG9uc2UuYm9keSkpLFxuICAgICAgICBjYXRjaEVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5wYXJzZUVycm9yKGVycm9yKTtcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgICksXG4gICk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSB0cmF2ZWxOb3RpY2U6IE9ic2VydmFibGU8VHJhdmVsTm90aWNlW10+ID0gdGhpcy5jYXJkc1RyYXZlbE5vdGljZS5nZXRUcmF2ZWxOb3RpY2VzKCdyZXNwb25zZScpLnBpcGUoXG4gICAgZGlzdGluY3RVbnRpbENoYW5nZWQoZGVlcEVxdWFsKSxcbiAgICBtYXAoKHJlc3BvbnNlKSA9PiAocmVzcG9uc2UuYm9keSA9PT0gbnVsbCA/IFtdIDogcmVzcG9uc2UuYm9keSkpLFxuICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICB0aHJvdyB0aGlzLmNhcmRzQmFja2VuZFNlcnZpY2UucGFyc2VFcnJvcihlcnJvcik7XG4gICAgfSksXG4gICk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIENhcmRzU2VydmljZSNnZXRDYXJkc1xuICAgKiBAcmV0dXJucyBUaGUgKHNpbmdsZS1pbnN0YW5jZSkgb2JzZXJ2YWJsZSBvZiBwYXltZW50IGNhcmRzIHJldHJpZXZlZCBmcm9tIHRoZSBiYWNrZW5kLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyB0aGUgKHNpbmdsZS1pbnN0YW5jZSkgb2JzZXJ2YWJsZSBvZiBwYXltZW50IGNhcmRzIHJldHJpZXZlZCBmcm9tIHRoZSBiYWNrZW5kLlxuICAgKi9cbiAgZ2V0Q2FyZHMoKTogT2JzZXJ2YWJsZTxBcnJheTxQYXltZW50Q2FyZD4+IHtcbiAgICByZXR1cm4gdGhpcy5wYXltZW50Q2FyZHM7XG4gIH1cblxuICBzZXRQYXJhbWV0ZXJzKHR5cGVzUGFyYW1zOiBPYnNlcnZhYmxlPHN0cmluZ1tdPikge1xuICAgIHR5cGVzUGFyYW1zXG4gICAgICAucGlwZShcbiAgICAgICAgbWFwKCh0eXBlcykgPT4gKHtcbiAgICAgICAgICB0eXBlcyxcbiAgICAgICAgfSkpLFxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSh0aGlzLmdldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgQ2FyZHNTZXJ2aWNlI3VwZGF0ZUxvY2tTdGF0dXNcbiAgICogQHJldHVybnMgQW4gb2JzZXJ2YWJsZSBvZiB0aGUgcGF5bWVudCBjYXJkIHdpdGggdXBkYXRlZCBsb2NrIHN0YXR1cy5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENhbGxzIHRoZSBiYWNrZW5kIHRvIGNoYW5nZSB0aGUgbG9jayBzdGF0dXMgYW5kIHJldHVybnMgYW4gb2JzZXJ2YWJsZSBvZiB1cGRhdGVkIHBheW1lbnQgY2FyZFxuICAgKiByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UuICBJZiB0aGF0IHJlc3BvbnNlIGlzIGVtcHR5LCB0aGUgZXhpc3RpbmcgcGF5bWVudCBjYXJkIHdpdGggdGhlXG4gICAqIHVwZGF0ZWQgbG9jayBzdGF0dXMgaXMgcmV0dXJuZWQuXG4gICAqL1xuICB1cGRhdGVMb2NrU3RhdHVzKGNhcmQ6IFBheW1lbnRDYXJkLCBsb2NrU3RhdHVzOiBQYXltZW50Q2FyZExvY2tTdGF0dXMpOiBPYnNlcnZhYmxlPFBheW1lbnRDYXJkPiB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5nZXRMb2NrU3RhdHVzVXBkYXRlKGxvY2tTdGF0dXMpO1xuXG4gICAgcmV0dXJuIHRoaXMuY2FyZHNEYXRhSHR0cFNlcnZpY2UudXBkYXRlTG9ja1N0YXR1cyh7IGlkOiBjYXJkLmlkLCBsb2NrU3RhdHVzUG9zdDogYm9keSB9LCAncmVzcG9uc2UnKS5waXBlKFxuICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9PT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYXJkLFxuICAgICAgICAgICAgICBsb2NrU3RhdHVzLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdGhpcy5jYXJkc0JhY2tlbmRTZXJ2aWNlLml0ZW1Ub01vZGVsKHJlc3BvbnNlLmJvZHkpLFxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5wYXJzZUVycm9yKGVycm9yKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgQ2FyZHNTZXJ2aWNlI2luaXRpYXRlUmVwbGFjZW1lbnRcbiAgICogQHJldHVybnMgQW4gb2JzZXJ2YWJsZSBvZiB0aGUgcGF5bWVudCBjYXJkIHdpdGggdXBkYXRlZCByZXBsYWNlbWVudCBzdGF0dXMuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDYWxscyB0aGUgYmFja2VuZCB0byBpbml0aWF0ZSByZXBsYWNlbWVudCBhbmQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIG9mIHRoZSB1cGRhdGVkIHBheW1lbnRcbiAgICogY2FyZCByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UuICBJZiB0aGUgcmVzcG9uc2UgaXMgZW1wdHksIHRoZSBleGlzdGluZyBwYXltZW50IGNhcmQgd2l0aFxuICAgKiByZXBsYWNlbWVudCBzdGF0dXMgc2V0IHRvIGBVTkRFUl9SRVBMQUNFTUVOVGAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBpbml0aWF0ZVJlcGxhY2VtZW50KFxuICAgIGNhcmQ6IFBheW1lbnRDYXJkLFxuICAgIHJlcGxhY2VtZW50UmVhc29uOiBQYXltZW50Q2FyZFJlcGxhY2VtZW50UmVhc29uIHwgc3RyaW5nLFxuICApOiBPYnNlcnZhYmxlPFBheW1lbnRDYXJkPiB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5nZXRSZXBsYWNlbWVudFVwZGF0ZShyZXBsYWNlbWVudFJlYXNvbik7XG5cbiAgICByZXR1cm4gdGhpcy5jYXJkc0RhdGFIdHRwU2VydmljZS5yZXF1ZXN0UmVwbGFjZW1lbnQoeyBpZDogY2FyZC5pZCwgcmVxdWVzdFJlcGxhY2VtZW50UG9zdDogYm9keSB9LCAncmVzcG9uc2UnKS5waXBlKFxuICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9PT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYXJkLFxuICAgICAgICAgICAgICByZXBsYWNlbWVudFN0YXR1czogUGF5bWVudENhcmRSZXBsYWNlbWVudFN0YXR1cy5VbmRlclJlcGxhY2VtZW50LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdGhpcy5jYXJkc0JhY2tlbmRTZXJ2aWNlLml0ZW1Ub01vZGVsKHJlc3BvbnNlLmJvZHkpLFxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5wYXJzZUVycm9yKGVycm9yKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgQ2FyZHNTZXJ2aWNlI2luaXRpYXRlQWN0aXZhdGlvblxuICAgKiBAcmV0dXJucyBBbiBvYnNlcnZhYmxlIG9mIHRoZSBwYXltZW50IGNhcmQgd2l0aCB1cGRhdGVkIHN0YXR1cy5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENhbGxzIHRoZSBiYWNrZW5kIHRvIGFjdGl2YXRlIGEgcGF5bWVudCBjYXJkIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgb2YgdGhlIHVwZGF0ZWQgcGF5bWVudFxuICAgKiBjYXJkIHJldHVybmVkIGluIHRoZSByZXNwb25zZS4gIElmIHRoZSByZXNwb25zZSBpcyBlbXB0eSwgdGhlIGV4aXN0aW5nIHBheW1lbnQgY2FyZCB3aXRoXG4gICAqIHN0YXR1cyBzZXQgdG8gYEFDVElWRWAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBpbml0aWF0ZUFjdGl2YXRpb24oY2FyZDogUGF5bWVudENhcmQsIHRva2VuOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFBheW1lbnRDYXJkPiB7XG4gICAgY29uc3QgYm9keSA9IHsgdG9rZW4gfTtcblxuICAgIHJldHVybiB0aGlzLmNhcmRzRGF0YUh0dHBTZXJ2aWNlLmFjdGl2YXRlKHsgaWQ6IGNhcmQuaWQsIGFjdGl2YXRlUG9zdDogYm9keSB9LCAncmVzcG9uc2UnKS5waXBlKFxuICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9PT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYXJkLFxuICAgICAgICAgICAgICBzdGF0dXM6IFBheW1lbnRDYXJkU3RhdHVzLkFjdGl2ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5pdGVtVG9Nb2RlbChyZXNwb25zZS5ib2R5KSxcbiAgICAgICksXG4gICAgICBjYXRjaEVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICB0aHJvdyB0aGlzLmNhcmRzQmFja2VuZFNlcnZpY2UucGFyc2VFcnJvcihlcnJvcik7XG4gICAgICB9KSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIENhcmRzU2VydmljZSN1cGRhdGVMaW1pdFxuICAgKiBAcmV0dXJucyBBbiBvYnNlcnZhYmxlIG9mIHRoZSBwYXltZW50IGNhcmQgd2l0aCB1cGRhdGVkIGxpbWl0cy5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENhbGxzIHRoZSBiYWNrZW5kIHRvIHVwZGF0ZSBhIHBheW1lbnQgY2FyZCBhbmQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIG9mIHRoZSB1cGRhdGVkIHBheW1lbnRcbiAgICogY2FyZCByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UuICBJZiB0aGUgcmVzcG9uc2UgaXMgZW1wdHksIHRoZSBleGlzdGluZyBwYXltZW50IGNhcmQgd2l0aFxuICAgKiBsaW1pdHMgdXBkYXRlZCBpcyByZXR1cm5lZC5cbiAgICovXG4gIHVwZGF0ZUxpbWl0KGNhcmQ6IFBheW1lbnRDYXJkLCBsaW1pdDogQXJyYXk8UGF5bWVudENhcmRMaW1pdD4sIHVwZGF0ZUFsbExpbWl0cz86IGJvb2xlYW4pOiBPYnNlcnZhYmxlPFBheW1lbnRDYXJkPiB7XG4gICAgY29uc3QgbGltaXRQYXlsb2FkID0gdXBkYXRlQWxsTGltaXRzXG4gICAgICA/IGxpbWl0XG4gICAgICA6IGxpbWl0LmZpbHRlcigobmV3TGltaXRJdGVtLCBpbmRleCkgPT4gbmV3TGltaXRJdGVtLmFtb3VudCAhPT0gY2FyZC5saW1pdHM/LltpbmRleF0uYW1vdW50KTtcblxuICAgIHJldHVybiB0aGlzLmNhcmRzRGF0YUh0dHBTZXJ2aWNlLmNoYW5nZUxpbWl0cyh7IGlkOiBjYXJkLmlkLCBjaGFuZ2VMaW1pdHNQb3N0SXRlbTogbGltaXRQYXlsb2FkIH0sICdyZXNwb25zZScpLnBpcGUoXG4gICAgICBtYXAoKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbWl0cyA9XG4gICAgICAgICAgY2FyZC5saW1pdHMgJiZcbiAgICAgICAgICBjYXJkLmxpbWl0cy5tYXAoKGl0ZW06IFBheW1lbnRDYXJkTGltaXQsIGluZGV4OiBudW1iZXIpID0+ICh7XG4gICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgYW1vdW50OiBsaW1pdFtpbmRleF0uYW1vdW50LFxuICAgICAgICAgIH0pKTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYm9keSA9PT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYXJkLFxuICAgICAgICAgICAgICBsaW1pdHMsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiB0aGlzLmNhcmRzQmFja2VuZFNlcnZpY2UuaXRlbVRvTW9kZWwocmVzcG9uc2UuYm9keSk7XG4gICAgICB9KSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5wYXJzZUVycm9yKGVycm9yKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICByZXNldFBJTihjYXJkOiBQYXltZW50Q2FyZCwgcGF5bWVudENhcmRSZXNldFBpbjogYW55KTogT2JzZXJ2YWJsZTxQYXltZW50Q2FyZD4ge1xuICAgIHJldHVybiB0aGlzLmNhcmRzRGF0YUh0dHBTZXJ2aWNlLnJlc2V0UGluKHsgaWQ6IGNhcmQuaWQsIHJlc2V0UGluUG9zdDogcGF5bWVudENhcmRSZXNldFBpbiB9LCAncmVzcG9uc2UnKS5waXBlKFxuICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9PT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYXJkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdGhpcy5jYXJkc0JhY2tlbmRTZXJ2aWNlLml0ZW1Ub01vZGVsKHJlc3BvbnNlLmJvZHkpLFxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5wYXJzZUVycm9yKGVycm9yKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICByZXF1ZXN0UElOKGNhcmQ6IFBheW1lbnRDYXJkLCBwYXltZW50Q2FyZFJlc2V0UGluOiBhbnkpOiBPYnNlcnZhYmxlPFBheW1lbnRDYXJkPiB7XG4gICAgcmV0dXJuIHRoaXMuY2FyZHNEYXRhSHR0cFNlcnZpY2UucmVxdWVzdFBpbih7IGlkOiBjYXJkLmlkLCByZXF1ZXN0UGluUG9zdDogcGF5bWVudENhcmRSZXNldFBpbiB9LCAncmVzcG9uc2UnKS5waXBlKFxuICAgICAgbWFwKChyZXNwb25zZSkgPT5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9PT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYXJkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDogdGhpcy5jYXJkc0JhY2tlbmRTZXJ2aWNlLml0ZW1Ub01vZGVsKHJlc3BvbnNlLmJvZHkpLFxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMuY2FyZHNCYWNrZW5kU2VydmljZS5wYXJzZUVycm9yKGVycm9yKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogIE1vZGlmaWVkIC0gYWRkZWQgYSBvYnNlcnZhYmxlIHRvIG9ubHkgcmVzcG9uZCB3aXRoIGFjdGl2ZSBjYXJkcy5cbiAgICpcbiAgICogQHJldHVybnMgT2JzZXJ2YWJsZSB3aXRoIGFsbCB0cmF2ZWwgbm90aWNlcyBhbmQgcGF5bWVudCBjYXJkcyB3aXRoXG4gICAqIHN0YXR1cyBhY3RpdmVcbiAgICovXG4gIGdldFRyYXZlbE5vdGljZSgpOiBPYnNlcnZhYmxlPEZ1bGxUcmF2ZWxOb3RpY2VNb2RlbD4ge1xuICAgIGNvbnN0IGFjdGl2ZUNhcmRzID0gdGhpcy5wYXltZW50Q2FyZHMucGlwZShcbiAgICAgIG1hcCgoY2FyZHM6IEFycmF5PFBheW1lbnRDYXJkPikgPT4gY2FyZHMuZmlsdGVyKChjYXJkOiBQYXltZW50Q2FyZCkgPT4gY2FyZC5zdGF0dXMgPT09IFBheW1lbnRDYXJkU3RhdHVzLkFjdGl2ZSkpLFxuICAgICk7XG5cbiAgICByZXR1cm4gY29tYmluZUxhdGVzdChbYWN0aXZlQ2FyZHMsIHRoaXMudHJhdmVsTm90aWNlXSkucGlwZShcbiAgICAgIG1hcCgoW3BheW1lbnRDYXJkcywgdHJhdmVsTm90aWNlXSkgPT4gKHtcbiAgICAgICAgdHJhdmVsTm90aWNlTGlzdDogdHJhdmVsTm90aWNlLm1hcCgoaXRlbSkgPT4gdGhpcy5jYXJkc0JhY2tlbmRTZXJ2aWNlLnRyYXZlbE5vdGljZVRvTW9kZWwoaXRlbSwgcGF5bWVudENhcmRzKSksXG4gICAgICAgIHBheW1lbnRDYXJkcyxcbiAgICAgIH0pKSxcbiAgICApO1xuICB9XG5cbiAgcG9zdFRyYXZlbE5vdGljZSh0cmF2ZWxOb3RpY2VJdGVtOiBUcmF2ZWxOb3RpY2VNb2RlbCk6IE9ic2VydmFibGU8VHJhdmVsTm90aWNlPiB7XG4gICAgY29uc3QgeyBjYXJkcywgLi4ub3RoZXJUcmF2ZWxOb3RpY2VQcm9wZXJ0aWVzIH0gPSB0cmF2ZWxOb3RpY2VJdGVtO1xuICAgIGNvbnN0IHRyYXZlbE5vdGljZURhdGEgPSB7IC4uLm90aGVyVHJhdmVsTm90aWNlUHJvcGVydGllcywgY2FyZElkczogY2FyZHMubWFwKChpdGVtKSA9PiBpdGVtLmlkKSB9IGFzIGFueTtcblxuICAgIHJldHVybiB0aGlzLmNhcmRzVHJhdmVsTm90aWNlLmNyZWF0ZVRyYXZlbE5vdGljZSh7IHRyYXZlbE5vdGljZTogdHJhdmVsTm90aWNlRGF0YSB9KTtcbiAgfVxuXG4gIGRlbGV0ZVRyYXZlbE5vdGljZSh0cmF2ZWxOb3RpY2VJdGVtOiBUcmF2ZWxOb3RpY2VNb2RlbCk6IE9ic2VydmFibGU8SHR0cFJlc3BvbnNlPGFueT4+IHtcbiAgICBjb25zdCB7IGlkIH0gPSB0cmF2ZWxOb3RpY2VJdGVtO1xuICAgIGlmICghaWQpIHRocm93IG5ldyBFcnJvcignRXJyb3Igbm8gbWF0Y2hpbmcgaWQnKTtcblxuICAgIHJldHVybiB0aGlzLmNhcmRzVHJhdmVsTm90aWNlLmRlbGV0ZVRyYXZlbE5vdGljZUJ5SWQoeyBpZCB9LCAncmVzcG9uc2UnKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZ2V0UGFyYW1zLmNvbXBsZXRlKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNhcmRzRGF0YUh0dHBTZXJ2aWNlOiBBcGlDYXJkc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjYXJkc0JhY2tlbmRTZXJ2aWNlOiBDYXJkc0JhY2tlbmRTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2FyZHNUcmF2ZWxOb3RpY2U6IFRyYXZlbE5vdGljZXNIdHRwU2VydmljZSxcbiAgKSB7fVxufVxuIl19