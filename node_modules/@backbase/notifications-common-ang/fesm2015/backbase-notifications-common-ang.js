import * as i0 from '@angular/core';
import { LOCALE_ID, Pipe, Inject, Component, Input, Directive, NgModule, Injectable, Optional } from '@angular/core';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1$1 from '@backbase/foundation-ang/core';
import { BbTemplate } from '@backbase/foundation-ang/core';
import * as i1 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import { combineLatest, BehaviorSubject, defer, of } from 'rxjs';
import { map, shareReplay, first, publishReplay, refCount } from 'rxjs/operators';

class NotificationLocalizationPipe {
    constructor(locale) {
        this.locale = locale;
    }
    transform(notification, property) {
        return (((notification.translations || {})[this.locale] || notification)[property] || '');
    }
}
/** @nocollapse */ NotificationLocalizationPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationLocalizationPipe, deps: [{ token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Pipe });
/** @nocollapse */ NotificationLocalizationPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationLocalizationPipe, name: "notificationLocalization" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationLocalizationPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'notificationLocalization',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; } });

const linkRegexp = /{{(.*)}}/;
class InterpolateLinkPipe {
    transform(template, value, focusableLink = true, classLink = '') {
        return template.replace(linkRegexp, (_, linkText) => `<a${classLink && ' class="' + classLink + '"'} href="${value.link}" target="_blank" rel="noopener noreferrer" tabindex="${focusableLink ? '0' : '-1'}">${linkText || value.link}</a>`);
    }
}
/** @nocollapse */ InterpolateLinkPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InterpolateLinkPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
/** @nocollapse */ InterpolateLinkPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InterpolateLinkPipe, name: "interpolateLink" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InterpolateLinkPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'interpolateLink',
                }]
        }] });

var NotificationOrigins;
(function (NotificationOrigins) {
    NotificationOrigins["Accounts"] = "Accounts";
    NotificationOrigins["Transactions"] = "Transaction";
    NotificationOrigins["Messages"] = "MessageCenter";
    NotificationOrigins["Payments"] = "Payment";
    NotificationOrigins["Limits"] = "Limits";
    NotificationOrigins["Contact"] = "Contact";
    NotificationOrigins["SavingGoals"] = "PFM";
    NotificationOrigins["AccountStatement"] = "AccountStatement";
    NotificationOrigins["FinancialInsights"] = "FinancialInsights";
})(NotificationOrigins || (NotificationOrigins = {}));

const NOTIFICAION_ORIGIN_ICONS = {
    [NotificationOrigins.Accounts]: 'current-accounts',
    [NotificationOrigins.Transactions]: 'swap-horiz',
    [NotificationOrigins.Messages]: 'mail-outline',
    [NotificationOrigins.SavingGoals]: 'donut-large',
    [NotificationOrigins.Contact]: 'contacts',
    [NotificationOrigins.Payments]: 'payments',
    [NotificationOrigins.AccountStatement]: 'description',
    [NotificationOrigins.Limits]: 'how-to-reg',
    [NotificationOrigins.FinancialInsights]: 'pie_chart_outline',
};

class NotificationsCapabilityIconComponent {
    constructor() {
        /**
         * Notification origin types
         */
        this.originTypes = NotificationOrigins;
        /**
         * Notification origin icons
         */
        this.originIcons = NOTIFICAION_ORIGIN_ICONS;
    }
}
/** @nocollapse */ NotificationsCapabilityIconComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCapabilityIconComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsCapabilityIconComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsCapabilityIconComponent, selector: "bb-notifications-capability-icon", inputs: { origin: "origin" }, ngImport: i0, template: "<ng-container\n  bbNotificationsCapabilityIconCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    origin: origin\n  }\"\n></ng-container>\n\n<ng-template bbNotificationsCapabilityIconCustomizable let-origin=\"context.origin\" let-host>\n  <div *ngIf=\"host.originIcons[origin]\" class=\"bb-stack bb-stack--align-center bb-text-support\">\n    <bb-icon-ui\n      size=\"sm\"\n      class=\"bb-stack__item bb-stack__item--spacing-sm\"\n      [name]=\"host.originIcons[origin]\"\n      data-role=\"notifications-capability-icon\"\n    ></bb-icon-ui>\n    <span\n      class=\"bb-stack__item bb-subheader bb-subheader--regular\"\n      data-role=\"notifications-capability-icon-label\"\n      i18n=\"Notification origin label@@notifications-capability-icon.origin.label\"\n    >\n      { origin, select, Accounts {Accounts} Transaction {Transactions} MessageCenter {Messages} Limits {Limits} Payment\n      {Payments} AccountStatement {Account Statement} Contact {Contact} PFM {Saving Goals} FinancialInsights {Financial\n      Insights} }\n    </span>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i1.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsCapabilityIconCustomizableDirective; }), selector: "[bbNotificationsCapabilityIconCustomizable]" }, { type: i0.forwardRef(function () { return i2.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCapabilityIconComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-capability-icon',
                    templateUrl: './notifications-capability-icon.component.html',
                }]
        }], propDecorators: { origin: [{
                type: Input
            }] } });
class NotificationsCapabilityIconCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsCapabilityIconCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCapabilityIconCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsCapabilityIconCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsCapabilityIconCustomizableDirective, selector: "[bbNotificationsCapabilityIconCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCapabilityIconCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsCapabilityIconCustomizable]',
                }]
        }] });

/**
 * Check if element is truncated with overflow:ellipsis
 */
function isElementContentTruncated({ offsetHeight, scrollHeight }) {
    return offsetHeight < scrollHeight;
}

class IsElementContentTruncatedDirective {
    constructor(elementRef, cd) {
        this.elementRef = elementRef;
        this.cd = cd;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.setIsContentTruncatedInParentComponent();
        });
    }
    setIsContentTruncatedInParentComponent() {
        const isContentTruncated = isElementContentTruncated(this.elementRef.nativeElement);
        this.hostRef.setIsContentTruncated(isContentTruncated);
        this.cd.markForCheck();
    }
}
/** @nocollapse */ IsElementContentTruncatedDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsElementContentTruncatedDirective, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ IsElementContentTruncatedDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IsElementContentTruncatedDirective, selector: "[bbIsElementContentTruncated]", inputs: { hostRef: "hostRef" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsElementContentTruncatedDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIsElementContentTruncated]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { hostRef: [{
                type: Input
            }] } });

const pipes = [NotificationLocalizationPipe, InterpolateLinkPipe];
const components = [NotificationsCapabilityIconComponent];
const directives = [NotificationsCapabilityIconCustomizableDirective, IsElementContentTruncatedDirective];
const uiModules = [IconModule];
class NotificationsCommonModule {
}
/** @nocollapse */ NotificationsCommonModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCommonModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NotificationsCommonModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCommonModule, declarations: [NotificationLocalizationPipe, InterpolateLinkPipe, NotificationsCapabilityIconComponent, NotificationsCapabilityIconCustomizableDirective, IsElementContentTruncatedDirective], imports: [CommonModule, IconModule], exports: [NotificationLocalizationPipe, InterpolateLinkPipe, NotificationsCapabilityIconComponent, NotificationsCapabilityIconCustomizableDirective, IsElementContentTruncatedDirective, IconModule] });
/** @nocollapse */ NotificationsCommonModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCommonModule, imports: [[CommonModule, ...uiModules], IconModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsCommonModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ...uiModules],
                    declarations: [...pipes, ...components, ...directives],
                    exports: [...pipes, ...components, ...directives, ...uiModules],
                }]
        }] });

const NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT = 'bb.event.notifications-badge.force-update';
const NOTIFICATIONS_CREATE_LOCAL_EVENT = 'bb.event.notifications-popups.notify';

const getPropertyValue = (input, prop) => combineLatest([input, prop]).pipe(map(([inputVal, propVal]) => (inputVal !== undefined ? inputVal : propVal)));

function propertiesListToArray() {
    return source$ => source$.pipe(map(properties => properties.replace(/\s/g, '').split(',')), map(properties => properties.filter(Boolean)));
}
const shareReplayOnce = () => function (source) {
    // use refCount: true to prevent memory leaks issue with shareReplay
    return source.pipe(shareReplay({ refCount: true, bufferSize: 1 }));
};

const modelItemToBoolean = (value) => {
    if (typeof value === 'boolean') {
        return value;
    }
    return value.trim() === 'true';
};
const modelItemToArray = (value) => value.replace(/\s/g, '').split(',');
const secondsToMilliseconds = (seconds) => seconds * 1000;

const DefaultBaseWidgetProperties = {
    allowedRoutes: [],
    origins: [],
    severityLevels: [],
};
class BaseWidgetPropertiesService {
    constructor(itemModel) {
        this.itemModel = itemModel;
        this.allowedRoutes$$ = new BehaviorSubject(undefined);
        this.origins$$ = new BehaviorSubject(undefined);
        this.severityLevels$$ = new BehaviorSubject(undefined);
        this.allowedRoutes$ = getPropertyValue(this.allowedRoutes$$, this.allowedRoutes);
        this.origins$ = getPropertyValue(this.origins$$, this.origins);
        this.severityLevels$ = getPropertyValue(this.severityLevels$$, this.severityLevels);
    }
    get allowedRoutes() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultBaseWidgetProperties.allowedRoutes);
        }
        return this.itemModel.property('allowedRoutes', '').pipe(first(), propertiesListToArray());
    }
    get origins() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultBaseWidgetProperties.origins);
        }
        return this.itemModel.property('origins', '').pipe(propertiesListToArray());
    }
    get severityLevels() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultBaseWidgetProperties.severityLevels);
        }
        return this.itemModel.property('severityLevels', '').pipe(propertiesListToArray());
    }
    setAllowedRoutes(value) {
        this.allowedRoutes$$.next(modelItemToArray(value));
    }
    setOrigins(value) {
        this.origins$$.next(modelItemToArray(value));
    }
    setSeverityLevels(value) {
        this.severityLevels$$.next(modelItemToArray(value));
    }
    defaultModelObservable(value) {
        return defer(() => of(value)).pipe(publishReplay(1), refCount());
    }
}
/** @nocollapse */ BaseWidgetPropertiesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseWidgetPropertiesService, deps: [{ token: i1$1.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ BaseWidgetPropertiesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseWidgetPropertiesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BaseWidgetPropertiesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.ItemModel, decorators: [{
                    type: Optional
                }] }]; } });

function toISOExtendedFormat(value) {
    // eslint-disable-next-line max-len
    // The date's format `2020-04-09T10:55:03.576+0000` from BE doesn't support in IE, Safari. Prevent `Invalid Date` result
    const offsetSign = value.slice(-5, -4);
    return offsetSign === '+' || '-' === offsetSign ? `${value.slice(0, -2)}:${value.slice(-2)}` : value;
}

class LeaveZoneScheduler {
    constructor(zone, scheduler) {
        this.zone = zone;
        this.scheduler = scheduler;
    }
    schedule(...args) {
        // eslint-disable-next-line prefer-spread
        return this.zone.runOutsideAngular(() => this.scheduler.schedule.apply(this.scheduler, args));
    }
    now() {
        return this.scheduler.now();
    }
}
class EnterZoneScheduler {
    constructor(zone, scheduler) {
        this.zone = zone;
        this.scheduler = scheduler;
    }
    schedule(...args) {
        // eslint-disable-next-line prefer-spread
        return this.zone.run(() => this.scheduler.schedule.apply(this.scheduler, args));
    }
    now() {
        return this.scheduler.now();
    }
}
function leaveZone(zone, scheduler) {
    return new LeaveZoneScheduler(zone, scheduler);
}
function enterZone(zone, scheduler) {
    return new EnterZoneScheduler(zone, scheduler);
}

/**
 * Generated bundle index. Do not edit.
 */

export { BaseWidgetPropertiesService, NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, NOTIFICATIONS_CREATE_LOCAL_EVENT, NotificationOrigins, NotificationsCapabilityIconComponent, NotificationsCapabilityIconCustomizableDirective, NotificationsCommonModule, enterZone, getPropertyValue, isElementContentTruncated, leaveZone, modelItemToArray, modelItemToBoolean, propertiesListToArray, secondsToMilliseconds, shareReplayOnce, toISOExtendedFormat, InterpolateLinkPipe as ӨInterpolateLinkPipe, IsElementContentTruncatedDirective as ӨIsElementContentTruncatedDirective, NotificationLocalizationPipe as ӨNotificationLocalizationPipe };
//# sourceMappingURL=backbase-notifications-common-ang.js.map
