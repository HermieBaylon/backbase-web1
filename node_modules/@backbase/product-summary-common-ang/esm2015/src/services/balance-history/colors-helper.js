export const getColorTrend = (index, series) => {
    const serie = series[index];
    if (serie.value === 0) {
        if (index > 0) {
            return getColorTrend(index - 1, series);
        }
        if (series.length > 1) {
            return series[1].value < 0 ? -1 : 1;
        }
    }
    if (serie.value < 0) {
        return -1;
    }
    return 1;
};
export const getCurrentSeriesName = (trend) => (trend === -1 ? 'negative' : 'positive');
export const getFirstSeries = (datum, trend) => [
    {
        name: getCurrentSeriesName(trend),
        series: [datum],
    },
];
export const createNewSeries = (result, lastResult, series, trend) => {
    const lastName = lastResult.series[lastResult.series.length - 1].name;
    const lastValue = lastResult.series[lastResult.series.length - 1].value;
    const valuesSum = Math.abs(lastValue) + Math.abs(series.value);
    const step = series.name.getTime() - lastName.getTime();
    const valuesRatio = Math.abs(lastValue) / valuesSum;
    const prevValue = lastResult.series[lastResult.series.length - 1].value;
    const crossingPoint = { name: new Date(lastName.getTime() + step * valuesRatio), value: 0 };
    const crossPointSection = prevValue ? [crossingPoint] : [];
    return [
        ...result.slice(0, -1),
        {
            name: lastResult.name,
            series: [...lastResult.series, ...crossPointSection],
        },
        {
            name: getCurrentSeriesName(trend),
            series: [crossingPoint, series],
        },
    ];
};
export const concatExistingSeries = (result, lastResult, series) => {
    const name = lastResult.name;
    return [
        ...result.slice(0, -1),
        {
            name,
            series: [...lastResult.series, series],
        },
    ];
};
export const splitDataByTrend = (series) => series.reduce((result, seriesData, i) => {
    const currentTrend = getColorTrend(i, series);
    if (i === 0) {
        return getFirstSeries(seriesData, currentTrend);
    }
    const previousTrend = getColorTrend(i - 1, series);
    const lastResult = result[result.length - 1];
    if (previousTrend === currentTrend) {
        return concatExistingSeries(result, lastResult, seriesData);
    }
    else {
        return createNewSeries(result, lastResult, seriesData, currentTrend);
    }
}, []);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sb3JzLWhlbHBlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvcHJvZHVjdC1zdW1tYXJ5LWNvbW1vbi1hbmcvc3JjL3NlcnZpY2VzL2JhbGFuY2UtaGlzdG9yeS9jb2xvcnMtaGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlBLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQWEsRUFBRSxNQUFnQixFQUFTLEVBQUU7SUFDdEUsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzVCLElBQUksS0FBSyxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7UUFDckIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO1lBQ2IsT0FBTyxhQUFhLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUN6QztRQUVELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQztLQUNGO0lBRUQsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRTtRQUNuQixPQUFPLENBQUMsQ0FBQyxDQUFDO0tBQ1g7SUFFRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHLENBQUMsS0FBWSxFQUEyQixFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFeEgsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQUMsS0FBYSxFQUFFLEtBQVksRUFBa0IsRUFBRSxDQUFDO0lBQzdFO1FBQ0Us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QUM7SUFDbkQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFN0MsSUFBSSxhQUFhLEtBQUssWUFBWSxFQUFFO1FBQ2xDLE9BQU8sb0JBQW9CLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQztLQUM3RDtTQUFNO1FBQ0wsT0FBTyxlQUFlLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDdEU7QUFDSCxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhU2V0LCBTZXJpZXMgfSBmcm9tICcuLi8uLi9tb2RlbC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFRyZW5kID0gMSB8IC0xO1xuXG5leHBvcnQgY29uc3QgZ2V0Q29sb3JUcmVuZCA9IChpbmRleDogbnVtYmVyLCBzZXJpZXM6IFNlcmllc1tdKTogVHJlbmQgPT4ge1xuICBjb25zdCBzZXJpZSA9IHNlcmllc1tpbmRleF07XG4gIGlmIChzZXJpZS52YWx1ZSA9PT0gMCkge1xuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIHJldHVybiBnZXRDb2xvclRyZW5kKGluZGV4IC0gMSwgc2VyaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2VyaWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBzZXJpZXNbMV0udmFsdWUgPCAwID8gLTEgOiAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZXJpZS52YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gMTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRDdXJyZW50U2VyaWVzTmFtZSA9ICh0cmVuZDogVHJlbmQpOiAncG9zaXRpdmUnIHwgJ25lZ2F0aXZlJyA9PiAodHJlbmQgPT09IC0xID8gJ25lZ2F0aXZlJyA6ICdwb3NpdGl2ZScpO1xuXG5leHBvcnQgY29uc3QgZ2V0Rmlyc3RTZXJpZXMgPSAoZGF0dW06IFNlcmllcywgdHJlbmQ6IFRyZW5kKTogQXJyYXk8RGF0YVNldD4gPT4gW1xuICB7XG4gICAgbmFtZTogZ2V0Q3VycmVudFNlcmllc05hbWUodHJlbmQpLFxuICAgIHNlcmllczogW2RhdHVtXSxcbiAgfSxcbl07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVOZXdTZXJpZXMgPSAoXG4gIHJlc3VsdDogQXJyYXk8RGF0YVNldD4sXG4gIGxhc3RSZXN1bHQ6IERhdGFTZXQsXG4gIHNlcmllczogU2VyaWVzLFxuICB0cmVuZDogVHJlbmQsXG4pOiBBcnJheTxEYXRhU2V0PiA9PiB7XG4gIGNvbnN0IGxhc3ROYW1lOiBEYXRlID0gbGFzdFJlc3VsdC5zZXJpZXNbbGFzdFJlc3VsdC5zZXJpZXMubGVuZ3RoIC0gMV0ubmFtZTtcbiAgY29uc3QgbGFzdFZhbHVlOiBudW1iZXIgPSBsYXN0UmVzdWx0LnNlcmllc1tsYXN0UmVzdWx0LnNlcmllcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgY29uc3QgdmFsdWVzU3VtOiBudW1iZXIgPSBNYXRoLmFicyhsYXN0VmFsdWUpICsgTWF0aC5hYnMoc2VyaWVzLnZhbHVlKTtcbiAgY29uc3Qgc3RlcDogbnVtYmVyID0gc2VyaWVzLm5hbWUuZ2V0VGltZSgpIC0gbGFzdE5hbWUuZ2V0VGltZSgpO1xuICBjb25zdCB2YWx1ZXNSYXRpbzogbnVtYmVyID0gTWF0aC5hYnMobGFzdFZhbHVlKSAvIHZhbHVlc1N1bTtcbiAgY29uc3QgcHJldlZhbHVlID0gbGFzdFJlc3VsdC5zZXJpZXNbbGFzdFJlc3VsdC5zZXJpZXMubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGNvbnN0IGNyb3NzaW5nUG9pbnQ6IFNlcmllcyA9IHsgbmFtZTogbmV3IERhdGUobGFzdE5hbWUuZ2V0VGltZSgpICsgc3RlcCAqIHZhbHVlc1JhdGlvKSwgdmFsdWU6IDAgfTtcbiAgY29uc3QgY3Jvc3NQb2ludFNlY3Rpb24gPSBwcmV2VmFsdWUgPyBbY3Jvc3NpbmdQb2ludF0gOiBbXTtcblxuICByZXR1cm4gW1xuICAgIC4uLnJlc3VsdC5zbGljZSgwLCAtMSksXG4gICAge1xuICAgICAgbmFtZTogbGFzdFJlc3VsdC5uYW1lLFxuICAgICAgc2VyaWVzOiBbLi4ubGFzdFJlc3VsdC5zZXJpZXMsIC4uLmNyb3NzUG9pbnRTZWN0aW9uXSxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IGdldEN1cnJlbnRTZXJpZXNOYW1lKHRyZW5kKSxcbiAgICAgIHNlcmllczogW2Nyb3NzaW5nUG9pbnQsIHNlcmllc10sXG4gICAgfSxcbiAgXTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb25jYXRFeGlzdGluZ1NlcmllcyA9IChyZXN1bHQ6IEFycmF5PERhdGFTZXQ+LCBsYXN0UmVzdWx0OiBEYXRhU2V0LCBzZXJpZXM6IFNlcmllcyk6IEFycmF5PERhdGFTZXQ+ID0+IHtcbiAgY29uc3QgbmFtZSA9IGxhc3RSZXN1bHQubmFtZTtcbiAgcmV0dXJuIFtcbiAgICAuLi5yZXN1bHQuc2xpY2UoMCwgLTEpLFxuICAgIHtcbiAgICAgIG5hbWUsXG4gICAgICBzZXJpZXM6IFsuLi5sYXN0UmVzdWx0LnNlcmllcywgc2VyaWVzXSxcbiAgICB9LFxuICBdO1xufTtcblxuZXhwb3J0IGNvbnN0IHNwbGl0RGF0YUJ5VHJlbmQgPSAoc2VyaWVzOiBBcnJheTxTZXJpZXM+KTogQXJyYXk8RGF0YVNldD4gPT5cbiAgc2VyaWVzLnJlZHVjZSgocmVzdWx0OiBBcnJheTxEYXRhU2V0Piwgc2VyaWVzRGF0YTogU2VyaWVzLCBpOiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjdXJyZW50VHJlbmQgPSBnZXRDb2xvclRyZW5kKGksIHNlcmllcyk7XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGdldEZpcnN0U2VyaWVzKHNlcmllc0RhdGEsIGN1cnJlbnRUcmVuZCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldmlvdXNUcmVuZCA9IGdldENvbG9yVHJlbmQoaSAtIDEsIHNlcmllcyk7XG4gICAgY29uc3QgbGFzdFJlc3VsdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAocHJldmlvdXNUcmVuZCA9PT0gY3VycmVudFRyZW5kKSB7XG4gICAgICByZXR1cm4gY29uY2F0RXhpc3RpbmdTZXJpZXMocmVzdWx0LCBsYXN0UmVzdWx0LCBzZXJpZXNEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5ld1NlcmllcyhyZXN1bHQsIGxhc3RSZXN1bHQsIHNlcmllc0RhdGEsIGN1cnJlbnRUcmVuZCk7XG4gICAgfVxuICB9LCBbXSk7XG4iXX0=