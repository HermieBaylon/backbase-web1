import '@angular/localize/init';
import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, NgModule, HostListener, InjectionToken, Injectable, Inject, Optional, Pipe } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as i2 from '@backbase/ui-ang/notification';
import { NotificationModule } from '@backbase/ui-ang/notification';
import * as i1 from '@backbase/data-ang/arrangements';
import { MaskableAttribute } from '@backbase/data-ang/arrangements';
import { ReplaySubject, BehaviorSubject, of, combineLatest } from 'rxjs';
import { distinctUntilChanged, filter, tap, switchMap, catchError, scan, map, take, publishReplay, refCount, pluck, shareReplay } from 'rxjs/operators';
import { PUBSUB } from '@backbase/foundation-ang/web-sdk';
import * as i1$1 from '@backbase/data-ang/financial-institution-manager';
import * as i1$2 from '@backbase/data-ang/accesscontrol';
import * as i1$3 from '@backbase/foundation-ang/core';
import { By } from '@angular/platform-browser';
import * as i1$4 from '@backbase/ui-ang/account-number-pipe';
import { AccountNumberPipeModule } from '@backbase/ui-ang/account-number-pipe';
import { PaymentCardNumberModule } from '@backbase/ui-ang/payment-card-number-pipe';
import * as i1$5 from '@backbase/ui-ang/date-pipe';
import { BbDatePipeModule, BbDatePipe } from '@backbase/ui-ang/date-pipe';

class ProductSummaryAccountDetailsBaseComponent {
    constructor() {
        /**
         * List of maskable attributes. Holds states of the attributes.
         */
        this.maskableAttributes = [];
        /**
         * Event when a user clicked on the `unmask-attribute-button` button
         */
        this.unmaskAttribute = new EventEmitter();
        /**
         * Event when a user clicked on the `mask-attribute-button` button
         */
        this.maskAttribute = new EventEmitter();
        /**
         * All unmaskable attributes
         */
        this.maskableAttribute = MaskableAttribute;
        /**
         * Details info sections availability
         */
        this.infoAvailability = {};
    }
    /**
     * Product type data that this component displays.
     */
    set product(data) {
        this._product = data;
        this.infoAvailability = this.getProductInfoAvailability(data);
    }
    get product() {
        return this._product;
    }
    /**
     * Returns `true` if the given `attributeName` is masked
     *
     * @param attributeName
     */
    isMasked(attributeName) {
        const maskableAttribute = this.maskableAttributes.find(attribute => attribute.attributeName === attributeName);
        return (maskableAttribute === null || maskableAttribute === void 0 ? void 0 : maskableAttribute.masked) === undefined ? true : maskableAttribute === null || maskableAttribute === void 0 ? void 0 : maskableAttribute.masked;
    }
    /**
     * Event handler for the `click` event of the unmask buttons
     * Emits `MaskableAttribute` to the `unmaskAttribute` Output
     *
     * @param attributeName
     */
    onUnmaskAttribute(attributeName) {
        if (Object.values(MaskableAttribute).includes(attributeName)) {
            this.unmaskAttribute.emit(attributeName);
        }
    }
    /**
     * Event handler for the `click` event of the mask buttons
     * Emits `MaskableAttribute` to the `maskAttribute` Output
     *
     * @param attributeName
     */
    onMaskAttribute(attributeName) {
        if (Object.values(MaskableAttribute).includes(attributeName)) {
            this.maskAttribute.emit(attributeName);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,no-unused-vars
    getProductInfoAvailability(product) {
        return {};
    }
}
ProductSummaryAccountDetailsBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountDetailsBaseComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
ProductSummaryAccountDetailsBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: ProductSummaryAccountDetailsBaseComponent, selector: "ng-component", inputs: { product: "product", maskableAttributes: "maskableAttributes" }, outputs: { unmaskAttribute: "unmaskAttribute", maskAttribute: "maskAttribute" }, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountDetailsBaseComponent, decorators: [{
            type: Component,
            args: [{ template: '' }]
        }], propDecorators: { product: [{
                type: Input
            }], maskableAttributes: [{
                type: Input
            }], unmaskAttribute: [{
                type: Output
            }], maskAttribute: [{
                type: Output
            }] } });

class ProductSummaryAccountDetailsBaseModule {
}
ProductSummaryAccountDetailsBaseModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountDetailsBaseModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductSummaryAccountDetailsBaseModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountDetailsBaseModule, declarations: [ProductSummaryAccountDetailsBaseComponent], exports: [ProductSummaryAccountDetailsBaseComponent] });
ProductSummaryAccountDetailsBaseModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountDetailsBaseModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountDetailsBaseModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ProductSummaryAccountDetailsBaseComponent],
                    exports: [ProductSummaryAccountDetailsBaseComponent],
                }]
        }] });

const SIZE_TABLET_DEFAULT = 768;
const SIZE_MOBILE_DEFAULT = 375;

class ResponsiveContainerComponent {
    constructor(element, changeDetector) {
        /**
         * Specifies screen size: `mobile` | `tablet` | 'screen'
         *
         * @default 'screen'
         */
        this._responsiveView = 'screen';
        this._sizeTablet = SIZE_TABLET_DEFAULT;
        this._sizeMobile = SIZE_MOBILE_DEFAULT;
        this._element = element;
        this._changeDetector = changeDetector;
    }
    get responsiveView() {
        return this._customResponsiveView || this._responsiveView;
    }
    set responsiveView(value) {
        this._customResponsiveView = value;
    }
    get sizeMobile() {
        return this._sizeMobile;
    }
    set sizeMobile(value) {
        this._sizeMobile = value;
    }
    get sizeTablet() {
        return this._sizeTablet;
    }
    set sizeTablet(value) {
        this._sizeTablet = value;
    }
    /**
     * @internal
     */
    ngAfterViewInit() {
        if (!this._customResponsiveView) {
            this.checkElementSize();
            this._changeDetector.detectChanges();
        }
    }
    /**
     * Event handler on `windows:resize`
     * Checks size of the container
     */
    onResize() {
        if (!this._customResponsiveView) {
            this.checkElementSize();
        }
    }
    /**
     * Checks width of the parent container and updates `isSmallScreen$` and `isExtraSmallScreen$`
     */
    checkElementSize() {
        var _a, _b;
        const containerWidth = ((_b = (_a = this._element.nativeElement) === null || _a === void 0 ? void 0 : _a.firstElementChild) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect().width) || 0;
        this._responsiveView = this.getResponsiveView(containerWidth);
    }
    getResponsiveView(containerWidth) {
        let responseView = 'screen';
        if (containerWidth <= this.sizeMobile) {
            responseView = 'mobile';
        }
        else if (containerWidth <= this.sizeTablet) {
            responseView = 'tablet';
        }
        return responseView;
    }
}
ResponsiveContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ResponsiveContainerComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ResponsiveContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: ResponsiveContainerComponent, selector: "ng-component", inputs: { responsiveView: "responsiveView" }, host: { listeners: { "window:resize": "onResize()" } }, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ResponsiveContainerComponent, decorators: [{
            type: Component,
            args: [{ template: '' }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { responsiveView: [{
                type: Input
            }], onResize: [{
                type: HostListener,
                args: ['window:resize', []]
            }] } });

class ResponsiveContainerModule {
}
ResponsiveContainerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ResponsiveContainerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ResponsiveContainerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ResponsiveContainerModule, declarations: [ResponsiveContainerComponent], exports: [ResponsiveContainerComponent] });
ResponsiveContainerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ResponsiveContainerModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ResponsiveContainerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [ResponsiveContainerComponent],
                    exports: [ResponsiveContainerComponent],
                }]
        }] });

const WINDOW = new InjectionToken('ProductSummaryCommon :: WindowToken');
const windowFactory = () => window;
const WindowProvider = {
    provide: WINDOW,
    useFactory: windowFactory,
};
/**
 * Injection token for widget properties configuration
 */
const PRODUCT_SUMMARY_WIDGET_PROPERTIES = new InjectionToken('ProductSummaryCommon :: WidgetProperties');
/**
 * Injection token for account alias displaying level configuration
 */
const ACCOUNT_ALIAS_DISPLAYING_LEVEL = new InjectionToken('ProductSummaryCommon :: AccountAliasDisplayingLevel');

const sharedModules = [NotificationModule, ProductSummaryAccountDetailsBaseModule, ResponsiveContainerModule];
class ProductSummaryCommon {
}
ProductSummaryCommon.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryCommon, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductSummaryCommon.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryCommon, imports: [CommonModule, NotificationModule, ProductSummaryAccountDetailsBaseModule, ResponsiveContainerModule], exports: [NotificationModule, ProductSummaryAccountDetailsBaseModule, ResponsiveContainerModule] });
ProductSummaryCommon.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryCommon, providers: [WindowProvider], imports: [[CommonModule, ...sharedModules], NotificationModule, ProductSummaryAccountDetailsBaseModule, ResponsiveContainerModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryCommon, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ...sharedModules],
                    exports: [...sharedModules],
                    providers: [WindowProvider],
                }]
        }] });

class DownloadResourcesService {
    constructor(localWindow) {
        this.localWindow = localWindow;
    }
    downloadFile(name, type, data) {
        const fileData = new Blob([data], { type });
        if (this.isFileSaverAvailable()) {
            this.downloadViaFileSaver(name, fileData);
        }
        else {
            this.downloadViaLink(name, fileData);
        }
    }
    isFileSaverAvailable() {
        const { navigator } = this.localWindow;
        // @ts-ignore
        return navigator !== undefined && navigator.msSaveOrOpenBlob !== undefined;
    }
    downloadViaFileSaver(name, data) {
        const { navigator } = this.localWindow;
        // @ts-ignore
        navigator.msSaveOrOpenBlob(data, name);
    }
    downloadViaLink(name, data) {
        const { document, URL } = this.localWindow;
        const downloadLink = document.createElement('a');
        downloadLink.href = URL.createObjectURL(data);
        downloadLink.download = name;
        downloadLink.click();
        downloadLink.remove();
    }
}
DownloadResourcesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DownloadResourcesService, deps: [{ token: WINDOW }], target: i0.ɵɵFactoryTarget.Injectable });
DownloadResourcesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DownloadResourcesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DownloadResourcesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });

/**
 * Utility service for DOM manipulations
 */
class DomAttributesService {
    constructor() {
        this.idPrefix = 'bb_product_summary_element_';
        this.nextId = 0;
    }
    /**
     * Generates unique Id for product-summary DOM elements
     */
    generateId() {
        return `${this.idPrefix}${this.nextId++}`;
    }
}
DomAttributesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DomAttributesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DomAttributesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DomAttributesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DomAttributesService, decorators: [{
            type: Injectable
        }] });

var HttpResponseType;
(function (HttpResponseType) {
    HttpResponseType["BODY"] = "body";
    HttpResponseType["RESPONSE"] = "response";
    HttpResponseType["EVENT"] = "event";
})(HttpResponseType || (HttpResponseType = {}));
var BalanceHistoryExportFormat;
(function (BalanceHistoryExportFormat) {
    BalanceHistoryExportFormat["JSON"] = "application/json";
    BalanceHistoryExportFormat["CSV"] = "text/csv";
})(BalanceHistoryExportFormat || (BalanceHistoryExportFormat = {}));
var PaginationType;
(function (PaginationType) {
    PaginationType["LOAD_MORE"] = "load-more";
    PaginationType["PAGINATION"] = "pagination";
})(PaginationType || (PaginationType = {}));
var ProductKindNames;
(function (ProductKindNames) {
    ProductKindNames["CURRENT_ACCOUNT"] = "Current Account";
    ProductKindNames["SAVINGS_ACCOUNT"] = "Savings Account";
    ProductKindNames["TERM_DEPOSIT"] = "Term Deposit";
    ProductKindNames["LOAN"] = "Loan";
    ProductKindNames["CREDIT_CARD"] = "Credit Card";
    ProductKindNames["DEBIT_CARD"] = "Debit Card";
    ProductKindNames["INVESTMENT_ACCOUNT"] = "Investment Account";
})(ProductKindNames || (ProductKindNames = {}));
/**
 * Default values of "kindUri" per product kind
 */
var ProductKindUri;
(function (ProductKindUri) {
    ProductKindUri["CREDIT_CARD"] = "credit-card";
    ProductKindUri["CURRENT_ACCOUNT"] = "current-account";
    ProductKindUri["DEBIT_CARD"] = "debit-card";
    ProductKindUri["INVESTMENT_ACCOUNT"] = "investment-account";
    ProductKindUri["LOAN"] = "loan";
    ProductKindUri["POCKET"] = "pocket";
    ProductKindUri["POCKET_PARENT"] = "pocket-parent";
    ProductKindUri["SAVINGS_ACCOUNT"] = "savings-account";
    ProductKindUri["TERM_DEPOSIT"] = "term-deposit";
})(ProductKindUri || (ProductKindUri = {}));
/**
 * Available navigation types from account
 */
var AccountNavigationType;
(function (AccountNavigationType) {
    AccountNavigationType["PAYMENTS"] = "PAYMENTS";
    AccountNavigationType["TRANSACTIONS"] = "TRANSACTIONS";
    AccountNavigationType["BALANCE_HISTORY"] = "BALANCE_HISTORY";
    AccountNavigationType["STATEMENTS"] = "STATEMENTS";
})(AccountNavigationType || (AccountNavigationType = {}));
/**
 * Privileges applicable to product summary business functions
 */
var ProductSummaryPrivilege;
(function (ProductSummaryPrivilege) {
    ProductSummaryPrivilege["VIEW"] = "view";
    ProductSummaryPrivilege["EDIT"] = "edit";
})(ProductSummaryPrivilege || (ProductSummaryPrivilege = {}));
/**
 * Displaying level of account aliases
 */
var AccountAliasDisplayingLevel;
(function (AccountAliasDisplayingLevel) {
    AccountAliasDisplayingLevel["ACCOUNT"] = "ACCOUNT";
    AccountAliasDisplayingLevel["USER"] = "USER";
})(AccountAliasDisplayingLevel || (AccountAliasDisplayingLevel = {}));
/**
 * Duplicates validation settings from the `user-preferences` schema of fe-presentation-spec
 * TODO: remove these constants, when min/max length settings will be part of the generated client API
 */
const UserPreferencesValidationSettings = {
    ALIAS_MAX_LENGTH: 50,
};

//TODO: check if this can be like id
const defaultArrangementName = '';
const WidgetProperty = {
    BUSINESS_FUNCTION: 'businessFunction',
    RESOURCE_NAME: 'resourceName',
    PRIVILEGE_TYPE: 'privilege',
    SIZE: 'size',
    ACTIVE_VIEW: 'activeView',
};
const SMALL_SCREEN_SIZE = 640;
const EXTRA_SMALL_SCREEN_SIZE = 576;
const DEFAULT_DEBOUNCE_TIME = 300;
var DefaultProductKindNameList;
(function (DefaultProductKindNameList) {
    DefaultProductKindNameList["CURRENT_ACCOUNT"] = "current-account";
    DefaultProductKindNameList["SAVINGS_ACCOUNT"] = "savings-account";
    DefaultProductKindNameList["TERM_DEPOSIT"] = "term-deposit";
    DefaultProductKindNameList["LOAN"] = "loan";
    DefaultProductKindNameList["CREDIT_CARD"] = "credit-card";
    DefaultProductKindNameList["DEBIT_CARD"] = "debit-card";
    DefaultProductKindNameList["INVESTMENT_ACCOUNT"] = "investment-account";
})(DefaultProductKindNameList || (DefaultProductKindNameList = {}));
const DefaultProductKindName = DefaultProductKindNameList.CURRENT_ACCOUNT;
const CardProductKindName = ['credit card', 'debit card'];
/**
 * Default value for allowed navigation types per account,
 * by default all navigation types are allowed
 */
const DefaultAllowedNavigationTypes = [
    AccountNavigationType.BALANCE_HISTORY,
    AccountNavigationType.PAYMENTS,
    AccountNavigationType.TRANSACTIONS,
    AccountNavigationType.STATEMENTS,
];

const getColorTrend = (index, series) => {
    const serie = series[index];
    if (serie.value === 0) {
        if (index > 0) {
            return getColorTrend(index - 1, series);
        }
        if (series.length > 1) {
            return series[1].value < 0 ? -1 : 1;
        }
    }
    if (serie.value < 0) {
        return -1;
    }
    return 1;
};
const getCurrentSeriesName = (trend) => (trend === -1 ? 'negative' : 'positive');
const getFirstSeries = (datum, trend) => [
    {
        name: getCurrentSeriesName(trend),
        series: [datum],
    },
];
const createNewSeries = (result, lastResult, series, trend) => {
    const lastName = lastResult.series[lastResult.series.length - 1].name;
    const lastValue = lastResult.series[lastResult.series.length - 1].value;
    const valuesSum = Math.abs(lastValue) + Math.abs(series.value);
    const step = series.name.getTime() - lastName.getTime();
    const valuesRatio = Math.abs(lastValue) / valuesSum;
    const prevValue = lastResult.series[lastResult.series.length - 1].value;
    const crossingPoint = { name: new Date(lastName.getTime() + step * valuesRatio), value: 0 };
    const crossPointSection = prevValue ? [crossingPoint] : [];
    return [
        ...result.slice(0, -1),
        {
            name: lastResult.name,
            series: [...lastResult.series, ...crossPointSection],
        },
        {
            name: getCurrentSeriesName(trend),
            series: [crossingPoint, series],
        },
    ];
};
const concatExistingSeries = (result, lastResult, series) => {
    const name = lastResult.name;
    return [
        ...result.slice(0, -1),
        {
            name,
            series: [...lastResult.series, series],
        },
    ];
};
const splitDataByTrend = (series) => series.reduce((result, seriesData, i) => {
    const currentTrend = getColorTrend(i, series);
    if (i === 0) {
        return getFirstSeries(seriesData, currentTrend);
    }
    const previousTrend = getColorTrend(i - 1, series);
    const lastResult = result[result.length - 1];
    if (previousTrend === currentTrend) {
        return concatExistingSeries(result, lastResult, seriesData);
    }
    else {
        return createNewSeries(result, lastResult, seriesData, currentTrend);
    }
}, []);

class BalanceHistoryNotFound {
    constructor(response) {
        this.response = response;
        this.kind = 'BalanceHistoryNotFound';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
class BalanceHistoryBadRequest {
    constructor(response) {
        this.response = response;
        this.kind = 'BalanceHistoryBadRequest';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
class BalanceHistoryAccessDenied {
    constructor(response) {
        this.response = response;
        this.kind = 'BalanceHistoryAccessDenied';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
class BalanceHistoryUnknownError {
    constructor(response) {
        this.response = response;
        this.kind = 'BalanceHistoryUnknownError';
        this.messages = [response.message];
    }
}
class BalanceHistoryConnectivityError {
    constructor(response) {
        this.response = response;
        this.kind = 'BalanceHistoryConnectivityError';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
const parseBalanceHistoryError = (error) => {
    if (error.error instanceof ErrorEvent) {
        return new BalanceHistoryUnknownError(error);
    }
    else {
        switch (error.status) {
            case 0:
                return new BalanceHistoryConnectivityError(error);
            case 401:
                return new BalanceHistoryAccessDenied(error);
            case 403:
                return new BalanceHistoryAccessDenied(error);
            case 400:
                return new BalanceHistoryBadRequest(error);
            case 404:
                return new BalanceHistoryNotFound(error);
            default:
                return new BalanceHistoryUnknownError(error);
        }
    }
};

class BalanceHistoryCommonService {
    constructor(accountDataService) {
        this.accountDataService = accountDataService;
        this.reportDefaultFileName = {
            [BalanceHistoryExportFormat.CSV]: 'balance-history.csv',
            [BalanceHistoryExportFormat.JSON]: 'balance-history.json',
        };
        this.requestObjectSeries = new ReplaySubject(1);
        this.requestObjectPaginated = new ReplaySubject(1);
        this.errorSeries = new BehaviorSubject(undefined);
        this.errorPaginated = new BehaviorSubject(undefined);
        this.loadingPaginated = new BehaviorSubject(true);
        this.loadingSeries = new BehaviorSubject(true);
        this.balanceHistorySeries = this.requestObjectSeries.pipe(distinctUntilChanged(), filter(param => !!param.arrangementIds), tap(() => this.loadingSeries.next(true)), tap(() => this.errorSeries.next(undefined)), switchMap(res => this.getBalanceHistorySeries(res).pipe(catchError((errorSeries) => {
            this.errorSeries.next(errorSeries);
            return of(undefined);
        }))), tap(() => this.loadingSeries.next(false)));
        this.balanceHistoryPaginated = this.requestObjectPaginated.pipe(distinctUntilChanged(), filter(param => !!param.arrangementId), tap(() => this.loadingPaginated.next(true)), tap(() => this.errorPaginated.next(undefined)), switchMap(res => this.getBalanceHistoryPaginated(res).pipe(catchError((errorPaginated) => {
            this.errorPaginated.next(errorPaginated);
            return of({
                count: 0,
                items: [],
                params: res,
            });
        }))), scan((acc, curr) => ({
            count: curr.count,
            items: this.responsesMerge(acc, curr),
            params: curr.params,
        })), tap(() => this.loadingPaginated.next(false)));
    }
    getBalanceHistorySeries(request) {
        const parameters = this.getBalanceHistoryRequestParameters(request);
        return this.accountDataService.getBalanceHistory(parameters).pipe(catchError((error) => {
            throw parseBalanceHistoryError(error);
        }));
    }
    getBalanceHistoryPaginated(request) {
        const paginationType = request.params ? request.params.paginationType || '' : '';
        const from = request.params ? request.params.from || 0 : 0;
        const parameters = this.getBalanceHistoryForArrangementRequestParameters(request);
        return this.accountDataService.getBalanceHistoryForArrangement(parameters, HttpResponseType.RESPONSE).pipe(map((res) => this.mapResponseWithCount(res, { from, paginationType })), catchError((error) => {
            throw parseBalanceHistoryError(error);
        }));
    }
    loadBalanceHistorySeries(requestObjectSeries) {
        requestObjectSeries.subscribe(this.requestObjectSeries);
    }
    loadBalanceHistoryPaginated(requestObjectPaginated) {
        requestObjectPaginated.subscribe(this.requestObjectPaginated);
    }
    /**
     * Returns URL for fetching balance history data
     *
     * @param format
     * @param exportParameters
     */
    exportBalanceHistory(format, exportParameters) {
        const parameters = this.getBalanceHistoryRequestParameters(exportParameters, format);
        return this.accountDataService.getBalanceHistoryUrl(parameters);
    }
    /**
     * Fetches balance history data in one of the available formats
     *
     * @param format
     * @param exportParameters
     */
    getBalanceHistory(format, exportParameters) {
        const parameters = this.getBalanceHistoryRequestParameters(exportParameters, format);
        const options = { httpHeaderAccept: format };
        return this.accountDataService.getBalanceHistory(parameters, HttpResponseType.RESPONSE, false, options).pipe(map(({ headers, body }) => {
            const defaultFileName = this.reportDefaultFileName[format];
            const fileNameInHeaders = this.getFileNameFromHeaders(headers);
            return { name: fileNameInHeaders || defaultFileName, content: body };
        }));
    }
    responsesMerge(acc, current) {
        if (acc &&
            acc.items &&
            current &&
            current.items &&
            acc.params.paginationType === PaginationType.LOAD_MORE &&
            current.params.from !== 0) {
            return [...acc.items, ...current.items];
        }
        return current.items;
    }
    processBalanceHistory(balanceHistory) {
        const [balanceHistoryItem] = balanceHistory.items;
        const defaultSeries = {
            name: defaultArrangementName,
            series: balanceHistoryItem.balanceHistory.map(({ dateTo, value, valuePtc }) => ({
                name: new Date(dateTo),
                value: (value ? value.balance : valuePtc),
            })),
        };
        return defaultSeries ? splitDataByTrend(defaultSeries.series) : [];
    }
    mapResponseWithCount(response, { from, paginationType }) {
        // eslint-disable-next-line no-null/no-null
        if (response.body === null) {
            throw new Error();
        }
        const headerCount = response.headers ? response.headers.get('x-total-count') : undefined;
        const counter = headerCount ? parseInt(headerCount, 10) : response.body.length || 0;
        return {
            count: counter,
            items: response.body,
            params: { from, paginationType },
        };
    }
    getBalanceHistoryRequestParameters({ arrangementIds, params }, requestFormat) {
        const format = requestFormat !== null && requestFormat !== void 0 ? requestFormat : params.format;
        return Object.assign({ arrangementIds }, this.toRequestParameters(Object.assign(Object.assign({}, params), { format })));
    }
    getBalanceHistoryForArrangementRequestParameters({ arrangementId, params, }) {
        const format = undefined;
        return Object.assign({ arrangementId }, this.toRequestParameters(Object.assign(Object.assign({}, params), { format })));
    }
    toRequestParameters(params) {
        const requestParameters = Object.assign(Object.assign({}, params), { timePeriod: params.timePeriod });
        delete requestParameters.paginationType;
        if (!requestParameters.format) {
            delete requestParameters.format;
        }
        if (requestParameters.timePeriod) {
            delete requestParameters.dateFrom;
            delete requestParameters.dateTo;
        }
        else {
            delete requestParameters.timePeriod;
        }
        return requestParameters;
    }
    getFileNameFromHeaders(headers) {
        const contentDisposition = (headers && headers.get('content-disposition')) || '';
        const contentDispositionWithoutQuotes = contentDisposition.replace(/['"]*/g, '');
        return (contentDispositionWithoutQuotes.match(/filename[^;=\n]*=([^;\n]*)/) || [])[1];
    }
}
BalanceHistoryCommonService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BalanceHistoryCommonService, deps: [{ token: i1.AccountsHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
BalanceHistoryCommonService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BalanceHistoryCommonService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BalanceHistoryCommonService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.AccountsHttpService }]; } });

class AccountsOverviewNotFound {
    constructor(response) {
        this.response = response;
        this.kind = 'AccountsOverviewNotFound';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
class AccountsOverviewBadRequest {
    constructor(response) {
        this.response = response;
        this.kind = 'AccountsOverviewBadRequest';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
class AccountsOverviewAccessDenied {
    constructor(response) {
        this.response = response;
        this.kind = 'AccountsOverviewAccessDenied';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
class AccountsOverviewUnknownError {
    constructor(response) {
        this.response = response;
        this.kind = 'AccountsOverviewUnknownError';
        this.messages = [response.message];
    }
}
class AccountsOverviewConnectivityError {
    constructor(response) {
        this.response = response;
        this.kind = 'AccountsOverviewConnectivityError';
        this.messages = ((response.error || {}).errors || []).map((e) => e.message);
    }
}
const parseError = (error) => {
    if (error.error instanceof ErrorEvent) {
        return new AccountsOverviewUnknownError(error);
    }
    else {
        switch (error.status) {
            case 0:
                return new AccountsOverviewConnectivityError(error);
            case 401:
                return new AccountsOverviewAccessDenied(error);
            case 403:
                return new AccountsOverviewAccessDenied(error);
            case 400:
                return new AccountsOverviewBadRequest(error);
            case 404:
                return new AccountsOverviewNotFound(error);
            default:
                return new AccountsOverviewUnknownError(error);
        }
    }
};

const bbEventToggleAccountFavoriteUpdate = 'bb.event.toggle-account-favorite.update';
class ProductSummaryAccountsService {
    constructor(productSummaryDataService, accountDataService, balancesHttpService, notificationService, pubSub) {
        this.productSummaryDataService = productSummaryDataService;
        this.accountDataService = accountDataService;
        this.balancesHttpService = balancesHttpService;
        this.notificationService = notificationService;
        this.pubSub = pubSub;
        this.requestObject = new ReplaySubject(1);
        this.favoriteRequestComplete = new BehaviorSubject(true);
        this.updateError = new BehaviorSubject(undefined);
        this.error = new BehaviorSubject(undefined);
        this.loading = new BehaviorSubject(true);
        this.aggregatedBalancesErrorSubject = new BehaviorSubject(undefined);
        this.aggregatedBalancesError = this.aggregatedBalancesErrorSubject.asObservable();
        this.loadingAggregatedBalancesSubject = new BehaviorSubject(false);
        this.loadingAggregatedBalances = this.loadingAggregatedBalancesSubject.asObservable();
        this.refreshAggregatedBalancesSubject = new BehaviorSubject(false);
        this.accountsList = combineLatest([
            this.requestObject,
            this.favoriteRequestComplete,
        ]).pipe(distinctUntilChanged(), tap(() => this.loading.next(true)), switchMap(([requestObject]) => this.getAccounts(requestObject)), scan((acc, curr) => ({
            count: curr.count,
            items: this.mergeResponses(acc, curr),
            params: curr.params,
        })), tap(() => this.error.next(undefined)), catchError((error) => {
            this.error.next(error);
            return of(undefined);
        }), tap(() => this.loading.next(false)));
        this.aggregatedBalances = combineLatest([
            this.refreshAggregatedBalancesSubject,
        ]).pipe(tap(() => this.loadingAggregatedBalancesSubject.next(true)), switchMap(() => this.getAggregatedBalances()), tap(() => this.loadingAggregatedBalancesSubject.next(false)));
        this.pubSub.subscribe(bbEventToggleAccountFavoriteUpdate, this.retriggerGetAccounts.bind(this));
    }
    getAccountById(arrangementId) {
        return this.accountDataService.getArrangementById({ arrangementId });
    }
    /**
     * Fetches an unmasked attribute for the given `UnmaskedAttributeRequestParams`
     *
     * @param requestParameters
     */
    getUnmaskedAttribute(requestParameters) {
        return this.accountDataService.unmaskedAttribute(requestParameters, 'body', false, {
            httpHeaderAccept: 'text/plain',
        });
    }
    toggleAccountFavorite(body, errorTemplateRef, successTemplateRef) {
        return this.putAccountFavorite(body).pipe(take(1), tap(() => {
            this.showNotification(successTemplateRef, 'success');
            this.updateError.next(undefined);
            this.pubSub.publish(bbEventToggleAccountFavoriteUpdate, undefined);
        }), catchError((error) => {
            this.updateError.next(error);
            this.showNotification(errorTemplateRef, 'error');
            return of(undefined);
        }));
    }
    putAccountFavorite(accountUserPreferences) {
        return this.accountDataService.updateUserPreferences({ accountUserPreferences }).pipe(catchError((error) => {
            throw parseError(error);
        }));
    }
    getAccounts(requestObject) {
        const paginationType = requestObject.paginationType || '';
        const from = requestObject.from || 0;
        const params = Object.assign({}, requestObject);
        delete params.paginationType;
        return this.productSummaryDataService.getArrangementsByBusinessFunction(params, HttpResponseType.RESPONSE).pipe(map(res => this.mapResponseWithCount(res, { from, paginationType })), catchError((error) => {
            throw parseError(error);
        }));
    }
    mapResponseWithCount(response, { from, paginationType }) {
        // eslint-disable-next-line no-null/no-null
        if (response.body === null) {
            throw new Error();
        }
        const headerCount = response.headers ? response.headers.get('x-total-count') : undefined;
        const counter = headerCount ? parseInt(headerCount, 10) : response.body.length || 0;
        return {
            count: counter,
            items: response.body || [],
            params: { from, paginationType },
        };
    }
    mergeResponses(acc, current) {
        if (acc &&
            acc.items &&
            current &&
            current.items &&
            acc.params.paginationType === PaginationType.LOAD_MORE &&
            current.params.from !== 0) {
            return [...acc.items, ...current.items];
        }
        return current.items;
    }
    showNotification(templateRef, modifier) {
        this.notificationService.showNotification({
            header: templateRef,
            modifier,
            message: '',
        });
    }
    getAccountsFrom(requestObject) {
        requestObject.subscribe(this.requestObject);
    }
    refreshAggregatedBalances() {
        this.refreshAggregatedBalancesSubject.next(true);
    }
    getAggregatedBalances() {
        const requestParameters = {};
        return this.balancesHttpService.getAggregations(requestParameters).pipe(map(response => this.mapResponseToAggregatedBalances(response)), tap(() => this.aggregatedBalancesErrorSubject.next(undefined)), catchError(error => this.parseAggregatedBalanceError(error)));
    }
    mapResponseToAggregatedBalances(aggregations) {
        const allBalances = (aggregations || [{}])[0];
        return allBalances && allBalances.aggregatedBalances;
    }
    parseAggregatedBalanceError(error) {
        this.aggregatedBalancesErrorSubject.next(error);
        return of(undefined);
    }
    retriggerGetAccounts() {
        this.favoriteRequestComplete.next(true);
    }
}
ProductSummaryAccountsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountsService, deps: [{ token: i1.ProductSummaryHttpService }, { token: i1.ArrangementsHttpService }, { token: i1.BalancesHttpService }, { token: i2.NotificationService }, { token: PUBSUB }], target: i0.ɵɵFactoryTarget.Injectable });
ProductSummaryAccountsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryAccountsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.ProductSummaryHttpService }, { type: i1.ArrangementsHttpService }, { type: i1.BalancesHttpService }, { type: i2.NotificationService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }]; } });

const toKebabCase = (accountType = '') => accountType ? accountType.trim().toLowerCase().split(' ').join('-') : '';
const isCardNumber = (account) => Boolean(account.productKindName && CardProductKindName.includes(account.productKindName.toLowerCase()));
const modelItemToBoolean = (value) => {
    if (typeof value === 'boolean') {
        return value;
    }
    return value === 'true';
};
const isFavorite = (account) => {
    const accountPreferencesFavoriteValue = account.userPreferences && account.userPreferences.favorite;
    const accountFavoriteValue = 'favorite' in account ? account.favorite : undefined;
    return accountPreferencesFavoriteValue !== null && accountPreferencesFavoriteValue !== void 0 ? accountPreferencesFavoriteValue : accountFavoriteValue;
};
const isProductVisible = (product) => {
    if (product.userPreferences && product.userPreferences.visible !== undefined) {
        return product.userPreferences.visible;
    }
    else if (product.visible !== undefined) {
        return product.visible;
    }
    return true;
};
const isFunction = (param) => typeof param === 'function';
const findBy = (collection, key, value) => collection.find(item => item && item[key] === value);
const findByName = (collection, name) => findBy(collection, 'name', name);
const getAccountAlias = (account) => {
    if (account.userPreferences) {
        return account.userPreferences.alias ? account.userPreferences.alias : account.bankAlias || account.name;
    }
    else {
        return account.bankAlias || account.name || ''; // todo: replace with `??` typesScript is upgraded to 3.7.0
    }
};
const getProductKindIconName = (productKindName) => {
    let iconName = toKebabCase(productKindName);
    const isDefaultProductKindName = Object.values(DefaultProductKindNameList).some(name => iconName === name);
    if (!isDefaultProductKindName) {
        iconName = 'account';
    }
    return `${iconName}s`;
};
/**
 * Gets a valid product number type for a given product
 *
 * @param product
 *
 * for CreditCard/DebitCard:
 * - returns `number` if exists
 * - else `IBAN` if exists
 * - otherwise `BBAN`
 * for other products:
 * - returns `IBAN` if exists
 * - else `BBAN` if exists
 * - otherwise `number`
 */
const getProductNumberType = (product) => {
    const isCardFormat = isCardNumber(product);
    if (isCardFormat && 'number' in product) {
        return 'cardNumber';
    }
    else if ('IBAN' in product) {
        return 'iban';
    }
    else if ('BBAN' in product || isCardFormat) {
        return 'bban';
    }
    else {
        return 'cardNumber';
    }
};
const processErrorMessages = (messages) => messages ? messages.join(' ') : undefined;
/**
 * Sets the passed unmasked attribute to the item
 *
 * @param item
 * @param attributeName
 * @param attributeValue
 */
// eslint-disable-next-line @typescript-eslint/ban-types
const setAttribute = (item, attributeName, attributeValue) => (Object.assign(Object.assign({}, (item ? item : {})), (attributeName ? { [attributeName]: attributeValue } : {})));
/**
 * Verifies if values is defined (not null and not undefined)
 *
 * @param value
 */
// eslint-disable-next-line no-null/no-null
const isDefined = (value) => value !== null && value !== undefined;
/**
 * Returns configuration property based on the priority
 */
const filterInputParameters = (input, prop) => combineLatest([input, prop]).pipe(map(([inputVal, propVal]) => (inputVal !== undefined ? inputVal : propVal)));
/**
 * Caches the request (shares between subscribers)
 *
 * @param request
 */
const cacheRequest = (request) => (source) => source.pipe(switchMap(request), publishReplay(1), refCount());
/**
 * Returns route parameter
 * takes parameter from component route if parameter exists, otherwise looks for parameter in parent routes
 *
 * @param route
 * @param param
 */
const getRouteParameter = (route, param) => {
    const routeParam = route.paramMap.pipe(pluck('params', param));
    const allParams = route.parent ? [routeParam, getRouteParameter(route.parent, param)] : [routeParam];
    return combineLatest(allParams).pipe(map(params => params[0] || params[1]), map(value => value !== null && value !== void 0 ? value : ''));
};
/**
 * Returns true if product has external info (external logo, alias, etc.)
 *
 * @param product
 */
const hasExternalInfo = (product) => product.financialInstitutionId !== undefined;

/**
 * A service for getting external info for products
 */
class ProductsExternalInfoService {
    constructor(financialInstitutionsHttpService) {
        this.financialInstitutionsHttpService = financialInstitutionsHttpService;
    }
    getProductsWithExternalInfo(products) {
        const productsList = Array.isArray(products) ? products : [products];
        const financialInstitutionIds = this.getAssignedFinancialInstitutionIds(productsList);
        return financialInstitutionIds.length
            ? this.getFinancialInstitutions(financialInstitutionIds).pipe(map(institutions => Array.isArray(products)
                ? productsList.map(product => this.addExternalInfoToProduct(product, institutions))
                : this.addExternalInfoToProduct(products, institutions)))
            : of(products);
    }
    getAssignedFinancialInstitutionIds(items) {
        const itemsWithExternalInfo = items.filter(hasExternalInfo);
        const financialInstitutionIds = itemsWithExternalInfo.map(item => item.financialInstitutionId);
        return financialInstitutionIds.filter((item, index) => financialInstitutionIds.indexOf(item, index + 1) === -1);
    }
    addExternalInfoToProduct(product, institutions) {
        return Object.assign(Object.assign({}, product), this.getExternalInfo(product, institutions));
    }
    getExternalInfo(product, institutions) {
        const isExternalInfoAvailable = hasExternalInfo(product);
        return isExternalInfoAvailable
            ? { financialInstitution: institutions.find(institution => institution.id === product.financialInstitutionId) }
            : {};
    }
    getFinancialInstitutions(ids) {
        return this.financialInstitutionsHttpService.getFinancialInstitutions({ ids }).pipe(pluck('financialInstitutions'));
    }
}
ProductsExternalInfoService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductsExternalInfoService, deps: [{ token: i1$1.FinancialInstitutionManagerClientHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductsExternalInfoService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductsExternalInfoService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductsExternalInfoService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.FinancialInstitutionManagerClientHttpService }]; } });

class ProductSummaryUserPermissionsService {
    constructor(usersDataService) {
        this.usersDataService = usersDataService;
        this.productSummaryPermissionParameters = {
            resourceName: 'Product Summary',
            functionName: 'Product Summary',
        };
        this.manageArrangementsPermissionParameters = {
            resourceName: 'Product Summary',
            functionName: 'Manage Arrangement Alias',
        };
        this.productSummaryPrivileges = this.usersDataService.getUserPrivileges(this.productSummaryPermissionParameters).pipe(map(privileges => privileges.map(({ privilege }) => privilege)), shareReplay());
        this.managerArrangementsPrivileges = this.usersDataService.getUserPrivileges(this.manageArrangementsPermissionParameters).pipe(map(privileges => privileges.map(({ privilege }) => privilege)), shareReplay());
        this.hasFullViewPermission = this.productSummaryPrivileges.pipe(map(privileges => privileges.includes(ProductSummaryPrivilege.VIEW)), shareReplay());
        this.hasFullEditPermission = this.productSummaryPrivileges.pipe(map(privileges => privileges.includes(ProductSummaryPrivilege.EDIT)), shareReplay());
        this.hasArrangementAliasEditPermission = this.managerArrangementsPrivileges.pipe(map(privileges => privileges.includes(ProductSummaryPrivilege.EDIT)), shareReplay());
        this.allowedAccountNavigationTypes = this.hasFullViewPermission.pipe(map(hasFullViewPermission => hasFullViewPermission
            ? DefaultAllowedNavigationTypes
            : DefaultAllowedNavigationTypes.filter(type => type !== AccountNavigationType.BALANCE_HISTORY)), shareReplay());
    }
}
ProductSummaryUserPermissionsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryUserPermissionsService, deps: [{ token: i1$2.UsersHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
ProductSummaryUserPermissionsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryUserPermissionsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryUserPermissionsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.UsersHttpService }]; } });

/** @dynamic */
class ProductSummaryWidgetPropertiesService {
    /**
     * @internal
     * @param defaultConfiguration
     * @param itemModel
     */
    constructor(defaultConfiguration, itemModel) {
        this.defaultConfiguration = defaultConfiguration;
        this.itemModel = itemModel;
        /**
         * Widget properties configuration
         */
        this.configuration = new BehaviorSubject({});
        /**
         * Gets a property value for each value in `propertyNames` input,
         * joins them into `WidgetProperties` structure
         */
        const propertyNames = Object.keys(defaultConfiguration);
        this.properties = combineLatest(propertyNames.map(propertyName => this.getWidgetProperty(propertyName))).pipe(map(properties => propertyNames.reduce((widgetProperties, propertyName, index) => (Object.assign(Object.assign({}, widgetProperties), { [propertyName]: properties[index] })), {})));
    }
    /**
     * Sets widget properties
     *
     * @param config
     */
    setConfiguration(config) {
        this.configuration.next(config);
    }
    /**
     * Returns observable with a widget property
     *
     * @param propertyName
     */
    getProperty(propertyName) {
        return this.properties.pipe(map(properties => properties[propertyName]));
    }
    /**
     * Returns a widget configuration property,
     * takes the value in the following order:
     * - configuration value if exists (widget input)
     * - item-model value if exists (CXP configuration)
     * - default value (constant value)
     */
    getWidgetProperty(propertyName) {
        const defaultValue = this.defaultConfiguration[propertyName];
        const configurationValue$ = this.configuration.pipe(map(configuration => configuration[propertyName]));
        const modelValue$ = this.itemModel
            ? this.itemModel.property(propertyName, defaultValue)
            : of(defaultValue);
        return combineLatest([configurationValue$, modelValue$]).pipe(map(([configurationValue, modelValue]) => (configurationValue !== undefined ? configurationValue : modelValue)));
    }
}
ProductSummaryWidgetPropertiesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryWidgetPropertiesService, deps: [{ token: PRODUCT_SUMMARY_WIDGET_PROPERTIES }, { token: i1$3.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
ProductSummaryWidgetPropertiesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryWidgetPropertiesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductSummaryWidgetPropertiesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [PRODUCT_SUMMARY_WIDGET_PROPERTIES]
                }] }, { type: i1$3.ItemModel, decorators: [{
                    type: Optional
                }] }]; } });

const CurrencyToCountryMap = {
    BDT: 'BD',
    EUR: 'EU',
    XOF: 'TG',
    BGN: 'BG',
    BAM: 'BA',
    BBD: 'BB',
    XPF: 'NC',
    BMD: 'BM',
    BND: 'BN',
    BOB: 'BO',
    BHD: 'BH',
    BIF: 'BI',
    BTN: 'BT',
    JMD: 'JM',
    NOK: 'NO',
    BWP: 'BW',
    WST: 'WS',
    USD: 'US',
    BRL: 'BR',
    BSD: 'BS',
    GBP: 'GB',
    BYR: 'BY',
    BZD: 'BZ',
    RUB: 'RU',
    RWF: 'RW',
    RSD: 'RS',
    TMT: 'TM',
    TJS: 'TJ',
    RON: 'RO',
    NZD: 'CK',
    GTQ: 'GT',
    XAF: 'TD',
    JPY: 'JP',
    GYD: 'GY',
    GEL: 'GE',
    XCD: 'AI',
    GNF: 'GN',
    GMD: 'GM',
    DKK: 'DK',
    GIP: 'GI',
    GHS: 'GH',
    OMR: 'OM',
    TND: 'TN',
    JOD: 'JO',
    HRK: 'HR',
    HTG: 'HT',
    HUF: 'HU',
    HKD: 'HK',
    HNL: 'HN',
    AUD: 'AU',
    VEF: 'VE',
    ILS: 'IL',
    PYG: 'PY',
    IQD: 'IQ',
    PAB: 'PA',
    PGK: 'PG',
    PEN: 'PE',
    PKR: 'PK',
    PHP: 'PH',
    PLN: 'PL',
    ZMK: 'ZM',
    MAD: 'MA',
    EGP: 'EG',
    ZAR: 'ZA',
    VND: 'VN',
    SBD: 'SB',
    ETB: 'ET',
    SOS: 'SO',
    ZWL: 'ZW',
    SAR: 'SA',
    ERN: 'ER',
    MDL: 'MD',
    MGA: 'MG',
    UZS: 'UZ',
    MMK: 'MM',
    MOP: 'MO',
    MNT: 'MN',
    MKD: 'MK',
    MUR: 'MU',
    MWK: 'MW',
    MVR: 'MV',
    MRO: 'MR',
    UGX: 'UG',
    TZS: 'TZ',
    MYR: 'MY',
    MXN: 'MX',
    SHP: 'SH',
    FJD: 'FJ',
    FKP: 'FK',
    NIO: 'NI',
    NAD: 'NA',
    VUV: 'VU',
    NGN: 'NG',
    NPR: 'NP',
    CHF: 'LI',
    COP: 'CO',
    CNY: 'CN',
    CLP: 'CL',
    CAD: 'CA',
    CDF: 'CD',
    CZK: 'CZ',
    CRC: 'CR',
    ANG: 'SX',
    CVE: 'CV',
    CUP: 'CU',
    SZL: 'SZ',
    SYP: 'SY',
    KGS: 'KG',
    KES: 'KE',
    SSP: 'SS',
    SRD: 'SR',
    KHR: 'KH',
    KMF: 'KM',
    STD: 'ST',
    KRW: 'KR',
    KPW: 'KP',
    KWD: 'KW',
    SLL: 'SL',
    SCR: 'SC',
    KZT: 'KZ',
    KYD: 'KY',
    SGD: 'SG',
    SEK: 'SE',
    SDG: 'SD',
    DOP: 'DO',
    DJF: 'DJ',
    YER: 'YE',
    DZD: 'DZ',
    UYU: 'UY',
    LBP: 'LB',
    LAK: 'LA',
    TWD: 'TW',
    TTD: 'TT',
    TRY: 'TR',
    LKR: 'LK',
    TOP: 'TO',
    LTL: 'LT',
    LRD: 'LR',
    LSL: 'LS',
    THB: 'TH',
    LYD: 'LY',
    AED: 'AE',
    AFN: 'AF',
    ISK: 'IS',
    IRR: 'IR',
    AMD: 'AM',
    ALL: 'AL',
    AOA: 'AO',
    ARS: 'AR',
    AWG: 'AW',
    INR: 'IN',
    AZN: 'AZ',
    IDR: 'ID',
    UAH: 'UA',
    QAR: 'QA',
    MZN: 'MZ',
};

const balanceHistorySeriesMock = {
    items: [
        {
            arrangementId: '3cdb2224-8926-4b4d-a99f-1c9dfbbb4699',
            balanceHistory: [
                {
                    dateFrom: '2017-05-10T00:00:00.000Z',
                    dateTo: '2017-06-01T00:00:00.000Z',
                    value: {
                        currency: 'EUR',
                        balance: '12',
                    },
                    valuePtc: '12',
                },
                {
                    dateFrom: '2017-05-11T00:00:00Z',
                    dateTo: '2017-06-01T00:00:00Z',
                    value: {
                        currency: 'EUR',
                        balance: '22',
                    },
                    valuePtc: '22',
                },
                {
                    dateFrom: '2017-05-23T00:00:00+0000',
                    dateTo: '2017-06-01T00:00:00+0000',
                    value: {
                        currency: 'EUR',
                        balance: '32',
                    },
                    valuePtc: '32',
                },
                {
                    dateFrom: '2017-06-01T00:00:00.000Z',
                    dateTo: '2017-06-01T00:00:00.000Z',
                    value: {
                        currency: 'EUR',
                        balance: '54',
                    },
                    valuePtc: '54',
                },
                {
                    dateFrom: '2017-06-02T00:00:00.000Z',
                    dateTo: '2017-06-01T00:00:00.000Z',
                    value: {
                        currency: 'EUR',
                        balance: '34',
                    },
                    valuePtc: '34',
                },
                {
                    dateFrom: '2017-06-12T00:00:00.000Z',
                    dateTo: '2017-06-01T00:00:00.000Z',
                    value: {
                        currency: 'EUR',
                        balance: '4',
                    },
                    valuePtc: '4',
                },
                {
                    dateFrom: '2017-06-18T00:00:00.000Z',
                    dateTo: '2017-06-01T00:00:00.000Z',
                    value: {
                        currency: 'EUR',
                        balance: '-14',
                    },
                    valuePtc: '-14',
                },
            ],
        },
    ],
};
const balanceHistoryPaginatedMock = [
    {
        dateFrom: '2017-05-10T00:00:00.000Z',
        dateTo: '2017-06-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '12',
        },
        valuePtc: '12',
    },
    {
        dateFrom: '2017-05-11T00:00:00.000Z',
        dateTo: '2017-06-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '22',
        },
        valuePtc: '22',
    },
    {
        dateFrom: '2017-05-23T00:00:00.000Z',
        dateTo: '2017-06-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '32',
        },
        valuePtc: '32',
    },
    {
        dateFrom: '2017-06-01T00:00:00.000Z',
        dateTo: '2017-06-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '54',
        },
        valuePtc: '54',
    },
    {
        dateFrom: '2017-06-02T00:00:00.000Z',
        dateTo: '2017-07-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '34',
        },
        valuePtc: '34',
    },
    {
        dateFrom: '2017-06-12T00:00:00.000Z',
        dateTo: '2017-07-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '4',
        },
        valuePtc: '4',
    },
    {
        dateFrom: '2017-06-18T00:00:00.000Z',
        dateTo: '2017-07-01T00:00:00.000Z',
        value: {
            currency: 'EUR',
            balance: '-14',
        },
        valuePtc: '-14',
    },
];
const balanceHistoryPaginatedMockWithCount = {
    count: 3,
    items: balanceHistoryPaginatedMock,
    params: { from: 1, paginationType: 'load-more' },
};
const emptyBalanceHistoryPaginatedMockWithCount = {
    count: 0,
    items: [],
    params: { from: 0, paginationType: 'pagination' },
};
const requestObjectMockSeries = {
    arrangementIds: '1',
    params: {
        dateFrom: '2017-06-18',
        dateTo: '2017-06-18',
        timePeriod: '',
        format: '',
        paginationType: 'pagination',
        from: 0,
    },
};
const requestObjectMockPaginated = {
    arrangementId: '1',
    params: {
        dateFrom: '2017-06-18',
        dateTo: '2017-06-18',
        timePeriod: '',
        format: '',
        paginationType: 'pagination',
        from: 0,
    },
};
const processedBalanceHistoryMock = [
    {
        name: defaultArrangementName,
        series: [
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: '12',
            },
            {
                name: new Date('2017-06-01T00:00:00Z'),
                value: '22',
            },
            {
                name: new Date('2017-06-01T00:00:00+0000'),
                value: '32',
            },
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: '54',
            },
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: '34',
            },
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: '4',
            },
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: 0,
            },
        ],
    },
    {
        name: defaultArrangementName,
        series: [
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: 0,
            },
            {
                name: new Date('2017-06-01T00:00:00.000Z'),
                value: '-14',
            },
        ],
    },
];
const mockRequestObject = {
    businessFunction: '',
    resourceName: '',
    privilege: '',
    paginationType: PaginationType.LOAD_MORE,
};
const mockAccountsResponse = [
    {
        id: '1cdb2224-8926-4b4d-a99f-1c9dfbbb4699',
        externalArrangementId: 'kjh4567-asd1-11e7-b114-b2f933d50000',
        externalLegalEntityId: 'COOOOO1',
        externalProductId: '1234567',
        name: 'Mr and Mrs J. Smith',
        productKindName: 'Current Account',
        bankAlias: 'Secret account',
        bookedBalance: 100.1,
        availableBalance: 100.2,
        creditLimit: 100.3,
        IBAN: 'GB29NWBK60161331926819',
        BBAN: 'BBAN',
        currency: 'EUR',
        externalTransferAllowed: true,
        urgentTransferAllowed: false,
        accruedInterest: 2.2,
        principalAmount: 100.4,
        currentInvestmentValue: 100.5,
        legalEntityIds: ['257da57a-11e4-4553-9175-54baf755069b', 'cd83683b-13f2-43d8-882b-39c9ab27d499'],
        productId: '36c8fc42-ec97-4f83-8a7c-d622625007f3',
        productTypeName: 'Current Account',
        BIC: 'BICExample1',
        bankBranchCode: 'bankBranchCode1',
        accountOpeningDate: '2016-01-28T16:41:41.090Z',
        accountInterestRate: 100.2,
        valueDateBalance: 100.1,
        creditLimitUsage: 100.3,
        creditLimitInterestRate: 100.4,
        creditLimitExpiryDate: '2019-09-28T16:41:41.090Z',
        debitCards: [
            {
                number: '4578',
                expiryDate: '2018-08-22T16:41:41.090Z',
            },
            {
                number: '3241',
                expiryDate: '2019-01-14T16:41:41.090Z',
            },
        ],
        startDate: '2016-02-28T16:41:41.090Z',
        termUnit: 'Y',
        termNumber: 50,
        maturityDate: '2017-02-28T16:41:41.090Z',
        maturityAmount: 99.5,
        autoRenewalIndicator: true,
        interestPaymentFrequencyUnit: 'M',
        interestPaymentFrequencyNumber: 15,
        interestSettlementAccount: 'interestSettlementAccount1',
        outstandingPrincipalAmount: 100.2,
        monthlyInstalmentAmount: 100.1,
        amountInArrear: 100.3,
        minimumRequiredBalance: 80.4,
        creditCardAccountNumber: '123456',
        validThru: '2019-02-28T16:41:41.090Z',
        applicableInterestRate: 101.2,
        remainingCredit: 50,
        outstandingPayment: 105.5,
        minimumPayment: 51.1,
        minimumPaymentDueDate: '2018-02-28T16:41:41.090Z',
        totalInvestmentValue: 110.2,
        accountHolderAddressLine1: 'accountHolderAddressLine11',
        accountHolderAddressLine2: 'accountHolderAddressLine12',
        creditAccount: true,
        debitAccount: true,
        visible: true,
        lastUpdateDate: '2019-09-28T16:41:41.090Z',
    },
    {
        id: '2222222-8926-4b4d-a99f-1c9dfbbb4610',
        externalArrangementId: 'kjh4567-asd1-11e7-b114-b2f933d50000',
        externalLegalEntityId: 'COOOOO1',
        externalProductId: '1234567',
        name: 'Mr and Mrs J. Smith second one',
        productKindName: 'Current Account',
        bankAlias: 'Secret account Mr and Mrs J. Smith second one',
        bookedBalance: 100.1,
        availableBalance: 100.2,
        creditLimit: 100.3,
        IBAN: 'GB29NWBK60161331926819',
        BBAN: 'BBAN',
        currency: 'EUR',
        externalTransferAllowed: true,
        urgentTransferAllowed: false,
        accruedInterest: 2.2,
        principalAmount: 100.4,
        currentInvestmentValue: 100.5,
        legalEntityIds: ['257da57a-11e4-4553-9175-54baf755069b', 'cd83683b-13f2-43d8-882b-39c9ab27d499'],
        productId: '36c8fc42-ec97-4f83-8a7c-d622625007f3',
        productTypeName: 'Current Account',
        BIC: 'BICExample2',
        bankBranchCode: 'bankBranchCode1',
        accountOpeningDate: '2016-01-28T16:41:41.090Z',
        accountInterestRate: 100.2,
        valueDateBalance: 100.1,
        creditLimitUsage: 100.3,
        creditLimitInterestRate: 100.4,
        creditLimitExpiryDate: '2019-09-28T16:41:41.090Z',
        debitCards: [
            {
                number: '6378',
                expiryDate: '2018-02-12T16:41:41.090Z',
            },
            {
                number: '5111',
                expiryDate: '2019-03-24T16:41:41.090Z',
            },
        ],
        startDate: '2016-02-28T16:41:41.090Z',
        termUnit: 'Y',
        termNumber: 50,
        maturityDate: '2017-02-28T16:41:41.090Z',
        maturityAmount: 99.5,
        autoRenewalIndicator: true,
        interestPaymentFrequencyUnit: 'M',
        interestPaymentFrequencyNumber: 15,
        interestSettlementAccount: 'interestSettlementAccount1',
        outstandingPrincipalAmount: 100.2,
        monthlyInstalmentAmount: 100.1,
        amountInArrear: 100.3,
        minimumRequiredBalance: 80.4,
        creditCardAccountNumber: '123456',
        validThru: '2019-02-28T16:41:41.090Z',
        applicableInterestRate: 101.2,
        remainingCredit: 50,
        outstandingPayment: 105.5,
        minimumPayment: 51.1,
        minimumPaymentDueDate: '2018-02-28T16:41:41.090Z',
        totalInvestmentValue: 110.2,
        accountHolderAddressLine1: 'accountHolderAddressLine11',
        accountHolderAddressLine2: 'accountHolderAddressLine12',
        creditAccount: true,
        debitAccount: true,
        visible: true,
        lastUpdateDate: '2019-09-28T16:41:41.090Z',
        userPreferences: {
            visible: true,
            alias: 'nice',
            favorite: true,
        },
    },
    {
        id: '1cdb2224-8926-4b4d-a99f-1c9dfbbb4699',
        externalArrangementId: 'kjh4567-asd1-11e7-b114-b2f933d50000',
        externalLegalEntityId: 'COOOOO1',
        externalProductId: '1234567',
        name: 'Mr and Mrs J. Smith',
        productKindName: 'Current Account',
        bankAlias: 'Secret account',
        bookedBalance: 100.1,
        availableBalance: 100.2,
        creditLimit: 100.3,
        IBAN: 'GB29NWBK60161331926819',
        BBAN: 'BBAN',
        currency: 'EUR',
        externalTransferAllowed: true,
        urgentTransferAllowed: false,
        accruedInterest: 2.2,
        principalAmount: 100.4,
        currentInvestmentValue: 100.5,
        legalEntityIds: ['257da57a-11e4-4553-9175-54baf755069b', 'cd83683b-13f2-43d8-882b-39c9ab27d499'],
        productId: '36c8fc42-ec97-4f83-8a7c-d622625007f3',
        productTypeName: 'Current Account',
        BIC: 'BICExample1',
        bankBranchCode: 'bankBranchCode1',
        accountOpeningDate: '2016-01-28T16:41:41.090Z',
        accountInterestRate: 100.2,
        valueDateBalance: 100.1,
        creditLimitUsage: 100.3,
        creditLimitInterestRate: 100.4,
        creditLimitExpiryDate: '2019-09-28T16:41:41.090Z',
        debitCards: [
            {
                number: '4578',
                expiryDate: '2018-08-22T16:41:41.090Z',
            },
            {
                number: '3241',
                expiryDate: '2019-01-14T16:41:41.090Z',
            },
        ],
        startDate: '2016-02-28T16:41:41.090Z',
        termUnit: 'Y',
        termNumber: 50,
        maturityDate: '2017-02-28T16:41:41.090Z',
        maturityAmount: 99.5,
        autoRenewalIndicator: true,
        interestPaymentFrequencyUnit: 'M',
        interestPaymentFrequencyNumber: 15,
        interestSettlementAccount: 'interestSettlementAccount1',
        outstandingPrincipalAmount: 100.2,
        monthlyInstalmentAmount: 100.1,
        amountInArrear: 100.3,
        minimumRequiredBalance: 80.4,
        creditCardAccountNumber: '123456',
        validThru: '2019-02-28T16:41:41.090Z',
        applicableInterestRate: 101.2,
        remainingCredit: 50,
        outstandingPayment: 105.5,
        minimumPayment: 51.1,
        minimumPaymentDueDate: '2018-02-28T16:41:41.090Z',
        totalInvestmentValue: 110.2,
        accountHolderAddressLine1: 'accountHolderAddressLine11',
        accountHolderAddressLine2: 'accountHolderAddressLine12',
        creditAccount: true,
        debitAccount: true,
        visible: true,
        lastUpdateDate: '2019-09-28T16:41:41.090Z',
        userPreferences: {
            alias: 'nice',
        },
    },
];
const accountsWithCount = {
    count: 3,
    items: mockAccountsResponse,
    params: { from: 1, paginationType: 'load-more' },
};
const balanceAggregationResponseMock = [
    {
        aggregatedBalances: [
            {
                currencyCode: 'EUR',
                amount: '3289.0',
                numberOfArrangements: 3,
            },
            {
                currencyCode: 'USD',
                amount: '2500.0',
                numberOfArrangements: 10,
            },
        ],
    },
];

/* eslint-enable */
// eslint-disable-next-line no-null/no-null
const isPlainObject = (obj) => typeof obj === 'object' && obj !== null;
/**
 * Equality check between two "plain" (i.e. JSON compatible) values.
 * By "plain" value, we mean a primitive or an object/array that contains only other primitives and no methods or internal state.
 */
const isEqual = (a, b) => {
    if (Array.isArray(a) && Array.isArray(b)) {
        return a.length === b.length && a.every((aValue, i) => isEqual(aValue, b[i]));
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        return false;
    }
    if (isPlainObject(a) && isPlainObject(b)) {
        const aObject = a;
        const bObject = b;
        const aKeys = Object.keys(aObject);
        const bKeys = Object.keys(bObject);
        return aKeys.length === bKeys.length && aKeys.every(aKey => isEqual(aObject[aKey], bObject[aKey]));
    }
    return a === b;
};

class TestHelper {
    constructor(fixture) {
        this._fixture = fixture;
    }
    getElement(locator) {
        return this._fixture.debugElement.query(By.css(locator));
    }
    getElements(locator) {
        return this._fixture.debugElement.queryAll(By.css(locator));
    }
    getText(locator) {
        const element = this.getElement(locator);
        if (element) {
            return element.nativeElement.textContent.trim();
        }
        return undefined;
    }
    isElementPresent(locator) {
        return isDefined(this.getElement(locator));
    }
}

/**
 * Converts number to an absolute value
 * {{ -100 | bbAbsoluteValue }}
 */
class AbsoluteValuePipe {
    /**
     * @name AbsoluteValuePipe#transform
     * @param value - number value
     *
     * @description
     * Converts number to an absolute value
     */
    transform(value) {
        return value !== undefined ? Math.abs(value) : NaN;
    }
}
AbsoluteValuePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AbsoluteValuePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
AbsoluteValuePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AbsoluteValuePipe, name: "bbAbsoluteValue" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AbsoluteValuePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bbAbsoluteValue',
                }]
        }] });

const sharedPipes$2 = [AccountNumberPipeModule, PaymentCardNumberModule];
const pipes$3 = [AbsoluteValuePipe];
class FormatPipeModule {
}
FormatPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormatPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FormatPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormatPipeModule, declarations: [AbsoluteValuePipe], imports: [CommonModule, AccountNumberPipeModule, PaymentCardNumberModule], exports: [AccountNumberPipeModule, PaymentCardNumberModule, AbsoluteValuePipe] });
FormatPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormatPipeModule, imports: [[CommonModule, ...sharedPipes$2], AccountNumberPipeModule, PaymentCardNumberModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FormatPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ...sharedPipes$2],
                    declarations: [...pipes$3],
                    exports: [...sharedPipes$2, ...pipes$3],
                }]
        }] });

/**
 * Gets a valid account number that should be displayed for Product (iban, bban or cardNumber)
 */
class ProductNumberValuePipe {
    /**
     * @name ProductNumberValuePipe#transform
     * @param product - a product that contains account number
     *
     * @description
     * Provides a valid account number for the product,
     * for example:
     * - IBAN for CurrentAccount product
     * - BBAN for CurrentAccount product that doesn't have IBAN
     * - number for CreditCard product
     */
    transform(product) {
        const productNumberType = getProductNumberType(product);
        if (productNumberType === 'iban' && 'IBAN' in product) {
            return product.IBAN;
        }
        else if (productNumberType === 'bban' && 'BBAN' in product) {
            return product.BBAN;
        }
        else if ('number' in product) {
            return product.number;
        }
        return '';
    }
}
ProductNumberValuePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberValuePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ProductNumberValuePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberValuePipe, name: "bbProductNumberValue" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberValuePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bbProductNumberValue',
                }]
        }] });

/**
 * Gets a valid account number type that should be displayed for Product (iban, bban or cardNumber)
 */
class ProductNumberTypePipe {
    /**
     * @name ProductNumberTypePipe#transform
     * @param product - a product that contains account number
     *
     * @description
     * Provides a valid account number for the product,
     * for example:
     * - 'iban' for CurrentAccount product
     * - 'bban' for CurrentAccount product that doesn't have IBAN
     * - 'cardNumber' for CreditCard product
     */
    transform(product) {
        return getProductNumberType(product);
    }
}
ProductNumberTypePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberTypePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
ProductNumberTypePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberTypePipe, name: "bbProductNumberType" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberTypePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bbProductNumberType',
                }]
        }] });

/**
 * Provides numbers format per product or number type
 * a format includes masking and formatting configuration
 *
 * TODO: remove this pipe when all necessary ui-ang components support using `bbAccountNumber` pipe
 */
class ProductNumberFormatPipe {
    /**
     * @name ProductNumberFormatPipe#constructor
     * @param accountsDisplayingFormatService - AccountsDisplayingFormatService
     *
     * @internal
     */
    constructor(accountsDisplayingFormatService) {
        this.accountsDisplayingFormatService = accountsDisplayingFormatService;
    }
    /**
     * @name ProductNumberFormatPipe#transform
     * @param product - product that should be formatted or specific product number type
     *
     * @description
     * Formats account numbers
     */
    transform(product) {
        const productType = typeof product === 'object' ? getProductNumberType(product) : product;
        const displayingFormat = this.accountsDisplayingFormatService.getDefaultFormat(productType);
        return Object.assign({ length: 0, maskRange: [0, 0] }, displayingFormat);
    }
}
ProductNumberFormatPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberFormatPipe, deps: [{ token: i1$4.AccountsDisplayingFormatService }], target: i0.ɵɵFactoryTarget.Pipe });
ProductNumberFormatPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberFormatPipe, name: "bbProductNumberFormat" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberFormatPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bbProductNumberFormat',
                }]
        }], ctorParameters: function () { return [{ type: i1$4.AccountsDisplayingFormatService }]; } });

const sharedPipes$1 = [AccountNumberPipeModule, PaymentCardNumberModule];
const pipes$2 = [ProductNumberValuePipe, ProductNumberTypePipe, ProductNumberFormatPipe];
class ProductNumberPipeModule {
}
ProductNumberPipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberPipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ProductNumberPipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberPipeModule, declarations: [ProductNumberValuePipe, ProductNumberTypePipe, ProductNumberFormatPipe], imports: [CommonModule, AccountNumberPipeModule, PaymentCardNumberModule], exports: [AccountNumberPipeModule, PaymentCardNumberModule, ProductNumberValuePipe, ProductNumberTypePipe, ProductNumberFormatPipe] });
ProductNumberPipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberPipeModule, imports: [[CommonModule, ...sharedPipes$1], AccountNumberPipeModule, PaymentCardNumberModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ProductNumberPipeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ...sharedPipes$1],
                    declarations: [...pipes$2],
                    exports: [...sharedPipes$1, ...pipes$2],
                }]
        }] });

/**
 * Verifies if values is defined (not null and not undefined)
 */
class IsDefinedPipe {
    /**
     * @name IsDefinedPipe#transform
     * @param value - value of any type
     *
     * @description
     * Verifies if values is defined
     * for example:
     * - true for '' string
     * - true for 0 number
     * - false for undefined value
     */
    transform(value) {
        return isDefined(value);
    }
}
IsDefinedPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsDefinedPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
IsDefinedPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsDefinedPipe, name: "bbIsDefined" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsDefinedPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bbIsDefined',
                }]
        }] });

/**
 * Verifies if the passed item is presented in the array
 * Note: deep-equal is not supported
 *
 * @usageNotes
 * ### Example
 * ```html
 * <div *ngIf="{{ item|bbIsArray:array }}"></div>
 * ```
 */
class IsInArrayPipe {
    /**
     * Verifies if `item` is presented in `array`
     *
     * @param item
     * @param array
     */
    transform(item, array) {
        if (array && array.length) {
            return array.indexOf(item) !== -1;
        }
        return false;
    }
}
IsInArrayPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsInArrayPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
IsInArrayPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsInArrayPipe, name: "bbIsInArray" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsInArrayPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'bbIsInArray' }]
        }] });

/**
 * Verifies if the passed item is a percent value
 *
 * @usageNotes
 * ### Example
 * ```html
 * <div *ngIf="{{ "10%"|bbIsPercentValue }}"></div>
 * ```
 */
class IsPercentValue {
    /**
     * Verifies if the passed item is a percent value
     *
     * @param item
     */
    transform(item) {
        if (isDefined(item) && typeof item === 'string') {
            const percentIndex = item.indexOf('%');
            return percentIndex === 0 || percentIndex === item.length - 1;
        }
        return false;
    }
}
IsPercentValue.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsPercentValue, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
IsPercentValue.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsPercentValue, name: "bbIsPercentValue" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsPercentValue, decorators: [{
            type: Pipe,
            args: [{ name: 'bbIsPercentValue' }]
        }] });

/**
 * Verifies if "kind" of productKindItem is equal to expected "kind"
 *
 * @usageNotes
 * ### Example
 * ```html
 * <div *ngIf="productKind | bbIsProductKind:expectedProductKindType"></div>
 * ```
 */
class IsProductKindPipe {
    /**
     * Verifies if "kind" of productKindItem is equal to expected "kind"
     *
     * @param productKindItem
     * @param expectedProductKindType
     */
    transform(productKindItem, expectedProductKindType) {
        if (isDefined(productKindItem === null || productKindItem === void 0 ? void 0 : productKindItem.kindUri)) {
            return Array.isArray(expectedProductKindType)
                ? expectedProductKindType.includes(productKindItem === null || productKindItem === void 0 ? void 0 : productKindItem.kindUri)
                : (productKindItem === null || productKindItem === void 0 ? void 0 : productKindItem.kindUri) === expectedProductKindType;
        }
        return false;
    }
}
IsProductKindPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsProductKindPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
IsProductKindPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsProductKindPipe, name: "bbIsProductKind" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IsProductKindPipe, decorators: [{
            type: Pipe,
            args: [{ name: 'bbIsProductKind' }]
        }] });

const pipes$1 = [IsDefinedPipe, IsInArrayPipe, IsPercentValue, IsProductKindPipe];
class ValidationModule {
}
ValidationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValidationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ValidationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValidationModule, declarations: [IsDefinedPipe, IsInArrayPipe, IsPercentValue, IsProductKindPipe], imports: [CommonModule], exports: [IsDefinedPipe, IsInArrayPipe, IsPercentValue, IsProductKindPipe] });
ValidationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValidationModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValidationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [...pipes$1],
                    exports: [...pipes$1],
                }]
        }] });

/**
 * Returns localised info of date of update
 *
 * @usageNotes
 * ### Example
 * ```html
 * <p>{{ '2020-10-10' | bbDateUpdateAgo }}</p>
 * <p>{{ '2020-10-10' | bbDateUpdateAgo:'mediumDate' }}</p>
 * ```
 */
class DateUpdatedAgoPipe {
    /**
     * @name DateUpdatedAgoPipe#constructor
     * @param datePipe - BbDatePipe
     *
     * @internal
     */
    constructor(datePipe) {
        this.datePipe = datePipe;
        this.millisecondsInPeriod = {
            day: 86400000,
            hours: 7200000,
            hour: 3600000,
            minutes: 120000,
            minute: 60000,
        };
        this.localisationByPeriod = {
            date: (date) => $localize `:@@product-summary.update-date.date:Updated on ${date}`,
            hours: (hours) => $localize `:@@product-summary.update-date.hours:Updated ${hours} hours ago`,
            hour: () => $localize `:@@product-summary.update-date.hour:Updated 1 hour ago`,
            minutes: (minutes) => $localize `:@@product-summary.update-date.minutes:Updated ${minutes} minutes ago`,
            minute: () => $localize `:@@product-summary.update-date.minute:Updated 1 minute ago`,
        };
    }
    /**
     * @name DateUpdatedAgoPipe#transform
     * @param updateTimestamp - update date
     * @param dateFormat - the format type for the date to be formatted (for update time >= 1 day ago)
     *
     * @description
     * Returns localised info of date of update
     *
     * Example:
     *  transform(hourAgo) - 'Updated 1 hour ago'
     *  transform(minuteAgo) - 'Updated 1 minute ago'
     */
    transform(updateTimestamp, dateFormat = 'longDate') {
        const millisecondsAgo = Math.max(new Date().getTime() - new Date(updateTimestamp).getTime(), 0);
        if (millisecondsAgo < this.millisecondsInPeriod.minutes) {
            return this.localisationByPeriod.minute();
        }
        else if (millisecondsAgo < this.millisecondsInPeriod.hour) {
            const minutesAgo = Math.floor(millisecondsAgo / this.millisecondsInPeriod.minute);
            return this.localisationByPeriod.minutes(minutesAgo);
        }
        else if (millisecondsAgo < this.millisecondsInPeriod.hours) {
            return this.localisationByPeriod.hour();
        }
        else if (millisecondsAgo < this.millisecondsInPeriod.day) {
            const hoursAgo = Math.floor(millisecondsAgo / this.millisecondsInPeriod.hour);
            return this.localisationByPeriod.hours(hoursAgo);
        }
        else {
            const updateDate = this.datePipe.transform(updateTimestamp, dateFormat);
            return this.localisationByPeriod.date(updateDate);
        }
    }
}
DateUpdatedAgoPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateUpdatedAgoPipe, deps: [{ token: i1$5.BbDatePipe }], target: i0.ɵɵFactoryTarget.Pipe });
DateUpdatedAgoPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateUpdatedAgoPipe, name: "bbDateUpdatedAgo" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DateUpdatedAgoPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'bbDateUpdatedAgo',
                }]
        }], ctorParameters: function () { return [{ type: i1$5.BbDatePipe }]; } });

const sharedPipes = [BbDatePipeModule];
const pipes = [DateUpdatedAgoPipe];
class DatePipeModule {
}
DatePipeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DatePipeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DatePipeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DatePipeModule, declarations: [DateUpdatedAgoPipe], imports: [CommonModule, BbDatePipeModule], exports: [DateUpdatedAgoPipe, BbDatePipeModule] });
DatePipeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DatePipeModule, providers: [BbDatePipe], imports: [[CommonModule, ...sharedPipes], BbDatePipeModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DatePipeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ...sharedPipes],
                    declarations: [...pipes],
                    exports: [...pipes, ...sharedPipes],
                    providers: [BbDatePipe],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ACCOUNT_ALIAS_DISPLAYING_LEVEL, AbsoluteValuePipe, AccountAliasDisplayingLevel, AccountNavigationType, AccountsOverviewAccessDenied, AccountsOverviewBadRequest, AccountsOverviewConnectivityError, AccountsOverviewNotFound, AccountsOverviewUnknownError, BalanceHistoryAccessDenied, BalanceHistoryBadRequest, BalanceHistoryCommonService, BalanceHistoryConnectivityError, BalanceHistoryExportFormat, BalanceHistoryNotFound, BalanceHistoryUnknownError, CardProductKindName, CurrencyToCountryMap, DEFAULT_DEBOUNCE_TIME, DatePipeModule, DateUpdatedAgoPipe, DefaultAllowedNavigationTypes, DefaultProductKindName, DefaultProductKindNameList, DomAttributesService, DownloadResourcesService, EXTRA_SMALL_SCREEN_SIZE, FormatPipeModule, HttpResponseType, IsDefinedPipe, IsInArrayPipe, IsPercentValue, IsProductKindPipe, PRODUCT_SUMMARY_WIDGET_PROPERTIES, PaginationType, ProductKindNames, ProductKindUri, ProductNumberFormatPipe, ProductNumberPipeModule, ProductNumberTypePipe, ProductNumberValuePipe, ProductSummaryAccountDetailsBaseComponent, ProductSummaryAccountDetailsBaseModule, ProductSummaryAccountsService, ProductSummaryCommon, ProductSummaryPrivilege, ProductSummaryUserPermissionsService, ProductSummaryWidgetPropertiesService, ProductsExternalInfoService, ResponsiveContainerComponent, ResponsiveContainerModule, SMALL_SCREEN_SIZE, TestHelper, UserPreferencesValidationSettings, ValidationModule, WINDOW, WidgetProperty, WindowProvider, accountsWithCount, balanceAggregationResponseMock, balanceHistoryPaginatedMock, balanceHistoryPaginatedMockWithCount, balanceHistorySeriesMock, bbEventToggleAccountFavoriteUpdate, cacheRequest, defaultArrangementName, emptyBalanceHistoryPaginatedMockWithCount, filterInputParameters, findBy, findByName, getAccountAlias, getProductKindIconName, getProductNumberType, getRouteParameter, hasExternalInfo, isCardNumber, isDefined, isEqual, isFavorite, isFunction, isPlainObject, isProductVisible, mockAccountsResponse, mockRequestObject, modelItemToBoolean, parseBalanceHistoryError, parseError, processErrorMessages, processedBalanceHistoryMock, requestObjectMockPaginated, requestObjectMockSeries, setAttribute, toKebabCase, windowFactory };
//# sourceMappingURL=backbase-product-summary-common-ang.js.map
