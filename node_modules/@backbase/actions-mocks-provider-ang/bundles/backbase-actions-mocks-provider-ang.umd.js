(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/common/http'), require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@backbase/actions-mocks-provider-ang', ['@angular/core','exports', '@angular/common/http', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,(global.backbase = global.backbase || {}, global.backbase['actions-mocks-provider-ang'] = {}), global.ng.common.http, global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (ɵngcc0,exports, http, core, rxjs, operators) { 'use strict';

    var unhandledError = new http.HttpErrorResponse({
        status: 500,
        statusText: 'Unhandled Exception',
    });

    var generateId = function () { return Math.random().toString(16).slice(2); };
    var actionItemsToResponse = function (items) { return ['notification', 'email', 'sms'].map(function (type) { return ({
        type: type,
        enabled: items.findIndex(function (item) { return item.type === type; }) !== -1,
    }); }); };

    var ACCOUNT_IDS_ERRORS = {
        // 2nd account from top
        '1cdb2224-8926-4b4d-a99f-1c9dfbbb4692': unhandledError,
    };
    var ActionsInterceptor = /** @class */ (function () {
        function ActionsInterceptor() {
            this.actionsGetErrorCode = parseInt(localStorage.getItem('actionsGetErrorCode') || '', 10);
        }
        ActionsInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            if (localStorage.getItem('enableMocks') !== 'true') {
                return next.handle(req);
            }
            // empty response in mocks data module causes error
            // PUT for /action-recipes, excluding /action-recipes/batch
            if (req.url.match(/\/action-recipes\/(?!batch).*$/) && req.method === 'PUT') {
                var response_1 = new http.HttpResponse({
                    status: 202,
                });
                return rxjs.of(response_1).pipe(operators.delay(500), operators.tap(function () { return console.log('CUSTOM INTERCEPTOR:', req, response_1); }));
            }
            if (req.url.match(/\/action-recipes\/batch$/) && req.method === 'PUT') {
                return next.handle(req).pipe(operators.map(function (event) {
                    var _a, _b, _c;
                    if (event instanceof http.HttpResponse) {
                        if (!req.body || !req.body.actionRecipes)
                            return event;
                        var recipe = req.body.actionRecipes[0];
                        if (ACCOUNT_IDS_ERRORS[recipe.arrangementId]) {
                            var errorResponse = ACCOUNT_IDS_ERRORS[recipe.arrangementId];
                            console.log('[ACTIONS INTERCEPTOR]', req, errorResponse);
                            throw errorResponse;
                        }
                        var response = event.clone({
                            body: {
                                actionRecipes: [
                                    Object.assign(Object.assign({ id: generateId() }, recipe), { actions: actionItemsToResponse(recipe.actions), recurrence: {
                                            daysOfWeek: (_a = recipe === null || recipe === void 0 ? void 0 : recipe.recurrence) === null || _a === void 0 ? void 0 : _a.daysOfWeek,
                                            hoursOfDay: (_c = (_b = recipe === null || recipe === void 0 ? void 0 : recipe.recurrence) === null || _b === void 0 ? void 0 : _b.hoursOfDay) === null || _c === void 0 ? void 0 : _c.map(function (hour) { return Number(hour); }).sort(function (a, b) { return a - b; }),
                                        } }),
                                ],
                            },
                        });
                        console.log('[ACTIONS INTERCEPTOR]', req, response);
                        return response;
                    }
                    return event;
                }));
            }
            if (req.url.match(/\/action-recipes$/) && req.method === 'GET') {
                return next.handle(req).pipe(operators.map(function (event) {
                    if (_this.actionsGetErrorCode) {
                        var errorResponse = new http.HttpErrorResponse({
                            status: _this.actionsGetErrorCode,
                        });
                        console.log('[ACTIONS INTERCEPTOR]', req, errorResponse);
                        throw errorResponse;
                    }
                    return event;
                }));
            }
            return next.handle(req);
        };
ActionsInterceptor.ɵfac = function ActionsInterceptor_Factory(t) { return new (t || ActionsInterceptor)(); };
ActionsInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ActionsInterceptor, factory: function (t) { return ActionsInterceptor.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ActionsInterceptor, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return ActionsInterceptor;
    }());
    var ActionsMocksProvider = {
        provide: http.HTTP_INTERCEPTORS,
        useClass: ActionsInterceptor,
        multi: true,
    };

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ActionsMocksProvider = ActionsMocksProvider;
    exports.ɵa = ActionsInterceptor;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=backbase-actions-mocks-provider-ang.umd.js.map