import { HttpErrorResponse, HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { of } from 'rxjs';
import { delay, tap, map } from 'rxjs/operators';

const unhandledError = new HttpErrorResponse({
    status: 500,
    statusText: 'Unhandled Exception',
});

const generateId = () => Math.random().toString(16).slice(2);
const actionItemsToResponse = (items) => ['notification', 'email', 'sms'].map(type => ({
    type,
    enabled: items.findIndex(item => item.type === type) !== -1,
}));

const ACCOUNT_IDS_ERRORS = {
    // 2nd account from top
    '1cdb2224-8926-4b4d-a99f-1c9dfbbb4692': unhandledError,
};
class ActionsInterceptor {
    constructor() {
        this.actionsGetErrorCode = parseInt(localStorage.getItem('actionsGetErrorCode') || '', 10);
    }
    intercept(req, next) {
        if (localStorage.getItem('enableMocks') !== 'true') {
            return next.handle(req);
        }
        // empty response in mocks data module causes error
        // PUT for /action-recipes, excluding /action-recipes/batch
        if (req.url.match(/\/action-recipes\/(?!batch).*$/) && req.method === 'PUT') {
            const response = new HttpResponse({
                status: 202,
            });
            return of(response).pipe(delay(500), tap(() => console.log('CUSTOM INTERCEPTOR:', req, response)));
        }
        if (req.url.match(/\/action-recipes\/batch$/) && req.method === 'PUT') {
            return next.handle(req).pipe(map((event) => {
                var _a, _b, _c;
                if (event instanceof HttpResponse) {
                    if (!req.body || !req.body.actionRecipes)
                        return event;
                    const recipe = req.body.actionRecipes[0];
                    if (ACCOUNT_IDS_ERRORS[recipe.arrangementId]) {
                        const errorResponse = ACCOUNT_IDS_ERRORS[recipe.arrangementId];
                        console.log('[ACTIONS INTERCEPTOR]', req, errorResponse);
                        throw errorResponse;
                    }
                    const response = event.clone({
                        body: {
                            actionRecipes: [
                                Object.assign(Object.assign({ id: generateId() }, recipe), { actions: actionItemsToResponse(recipe.actions), recurrence: {
                                        daysOfWeek: (_a = recipe === null || recipe === void 0 ? void 0 : recipe.recurrence) === null || _a === void 0 ? void 0 : _a.daysOfWeek,
                                        hoursOfDay: (_c = (_b = recipe === null || recipe === void 0 ? void 0 : recipe.recurrence) === null || _b === void 0 ? void 0 : _b.hoursOfDay) === null || _c === void 0 ? void 0 : _c.map((hour) => Number(hour)).sort((a, b) => a - b),
                                    } }),
                            ],
                        },
                    });
                    console.log('[ACTIONS INTERCEPTOR]', req, response);
                    return response;
                }
                return event;
            }));
        }
        if (req.url.match(/\/action-recipes$/) && req.method === 'GET') {
            return next.handle(req).pipe(map((event) => {
                if (this.actionsGetErrorCode) {
                    const errorResponse = new HttpErrorResponse({
                        status: this.actionsGetErrorCode,
                    });
                    console.log('[ACTIONS INTERCEPTOR]', req, errorResponse);
                    throw errorResponse;
                }
                return event;
            }));
        }
        return next.handle(req);
    }
}
ActionsInterceptor.decorators = [
    { type: Injectable }
];
const ActionsMocksProvider = {
    provide: HTTP_INTERCEPTORS,
    useClass: ActionsInterceptor,
    multi: true,
};

/**
 * Generated bundle index. Do not edit.
 */

export { ActionsMocksProvider, ActionsInterceptor as Éµa };
//# sourceMappingURL=backbase-actions-mocks-provider-ang.js.map
