#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const loadJson = file => JSON.parse(fs.readFileSync(
  path.resolve(process.cwd(), file)
).toString());

const loadWorkspaceDependencies = () => fs.readdirSync('..') // all workspace build libs
  .filter((packageDir => !packageDir.includes('@tmp')))
  .map(packageDir => loadJson(`../${packageDir}/package.json`))
  .reduce((acc, workspacePackage) => ({
    ...acc,
    [workspacePackage.name]: workspacePackage.version,
  }), {});

const packageLock = loadJson('../../../package-lock.json');
const workspaceDependencies = loadWorkspaceDependencies();

const lockedVersion = (dep, version) => {
  if (dep === 'tslib') {
    return version; // don't lock tslib (special case)
  }
  // if versions isn't '<placeholder>' don't lock it
  if (version !== '<placeholder>') {
    return version;
  }

  // check if it's a dependency on another package in the workspace
  let lock;
  if (workspaceDependencies[dep] !== undefined) {
    lock = workspaceDependencies[dep];
  } else if (packageLock.dependencies[dep] !== undefined) {
    lock = packageLock.dependencies[dep].version;
  } else {
    process.stderr.write(`${dep} not in package-lock\n`);
    process.exit(1);
  }

  process.stdout.write(`Locking ${dep} to ${lock}\n`);

  return lock;
};

const lockDependencies = dependencies => Object.entries(dependencies)
  .map(([dep, version]) => [dep, lockedVersion(dep, version)])
  .reduce((deps, [dep, version]) => ({ ...deps, [dep]: version }), {});

const packageJson = loadJson('./package.json');
if (packageJson.dependencies) {
  packageJson.dependencies = lockDependencies(packageJson.dependencies);
}
if (packageJson.peerDependencies) {
  packageJson.peerDependencies = lockDependencies(packageJson.peerDependencies);
}

fs.writeFileSync('./package.json', JSON.stringify(packageJson, null, 2));
