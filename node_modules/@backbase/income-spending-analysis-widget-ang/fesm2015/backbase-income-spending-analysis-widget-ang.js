import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Input, ViewEncapsulation, HostBinding, HostListener, Injectable, EventEmitter, Directive, Output, PLATFORM_ID, Inject, ContentChild, ViewChild, NgModule, LOCALE_ID, Optional } from '@angular/core';
import * as i1$1 from '@backbase/ui-ang/css-variables-lib';
import { CssVariablesService } from '@backbase/ui-ang/css-variables-lib';
import * as i3 from '@swimlane/ngx-charts';
import { trimLabel, PlacementTypes, throttleable, StyleTypes, ShowTypes, formatLabel, BaseChartComponent, calculateViewDimensions, ColorHelper, ScaleType, NgxChartsModule } from '@swimlane/ngx-charts';
import { max } from 'd3-array';
import { pie, arc } from 'd3-shape';
import * as i1 from '@angular/common';
import { CommonModule, CurrencyPipe, getCurrencySymbol, DatePipe } from '@angular/common';
import { __decorate } from 'tslib';
import { DomPortalHost, ComponentPortal } from '@angular/cdk/portal';
import * as i3$1 from '@backbase/ui-ang/amount';
import { AmountModule } from '@backbase/ui-ang/amount';
import * as i3$2 from '@backbase/foundation-ang/core';
import { BbTemplate, BackbaseCoreModule } from '@backbase/foundation-ang/core';
import { combineLatest, BehaviorSubject, from, zip, of } from 'rxjs';
import { map, shareReplay, filter, switchMap, catchError, share, mergeMap, tap, pluck } from 'rxjs/operators';
import * as i1$2 from '@backbase/data-ang/transactions';
import * as i4 from '@angular/router';
import * as i7 from '@backbase/ui-ang/period-selector';
import { PeriodSelectorModule } from '@backbase/ui-ang/period-selector';
import * as i10 from '@backbase/ui-ang/empty-state';
import { EmptyStateModule } from '@backbase/ui-ang/empty-state';
import * as i11 from '@backbase/ui-ang/loading-indicator';
import { LoadingIndicatorModule } from '@backbase/ui-ang/loading-indicator';
import * as i12 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';

const CARET_SIZE_CSS_VAR = '--chart-tooltip-caret-size';
var ArrowClasses;
(function (ArrowClasses) {
    ArrowClasses["LEFT"] = "bb-arrow-left";
    ArrowClasses["RIGHT"] = "bb-arrow-right";
})(ArrowClasses || (ArrowClasses = {}));

class PieLabelComponent {
    constructor() {
        /**
         * Radius of the circle.
         */
        this.radius = 0;
        /**
         * The maximum number of labels displayed.
         */
        this.max = 1;
        /**
         * Value of the label.
         */
        this.value = 0;
        /**
         * Make the radius of each slice proportional to it's value.
         */
        this.explodeSlices = false;
        /**
         * Enable/Disable animations.
         */
        this.animations = true;
        /**
         * Enable/Disable label trimming.
         */
        this.labelTrim = true;
        /**
         * Set the label trimming size.
         */
        this.labelTrimSize = 10;
        this.isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
        this.trimLabel = trimLabel;
    }
    get labelText() {
        return this.labelTrim ? trimLabel(this.label || '', this.labelTrimSize) : this.label;
    }
    get textX() {
        return this.data ? this.data.pos[0] : 0;
    }
    get textY() {
        return this.data ? this.data.pos[1] : 0;
    }
    get textTransition() {
        return this.isIE || !this.animations ? '' : 'transform 0.75s';
    }
    get styleTransform() {
        return this.isIE ? '' : `translate3d(${this.textX}px, ${this.textY}px, 0)`;
    }
    get attrTransform() {
        return !this.isIE ? '' : `translate(${this.textX}, ${this.textY})`;
    }
    ngOnInit() {
        if (typeof this.data === 'undefined') {
            throw new Error(`"data" input is required in "${this.constructor.name}"`);
        }
    }
}
PieLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieLabelComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PieLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PieLabelComponent, selector: "g[bb-charts-pie-label]", inputs: { data: "data", radius: "radius", label: "label", color: "color", icon: "icon", max: "max", value: "value", explodeSlices: "explodeSlices", animations: "animations", labelTrim: "labelTrim", labelTrimSize: "labelTrimSize", template: "template" }, ngImport: i0, template: `
    <ng-container *ngIf="template; else defaultTemplate">
      <ng-template
        [ngTemplateOutlet]="template"
        [ngTemplateOutletContext]="{ data: data, color: color, icon: icon, label: labelText }"
      >
      </ng-template>
    </ng-container>

    <ng-template #defaultTemplate>
      <svg:g [attr.transform]="attrTransform" [style.transform]="styleTransform" [style.transition]="textTransition">
        <svg:text
          class="pie-label"
          [class.animation]="animations"
          dy=".35em"
          [style.textAnchor]="'middle'"
          [style.shapeRendering]="'crispEdges'"
        >
          {{ labelText }}
        </svg:text>
      </svg:g>
    </ng-template>
  `, isInline: true, directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieLabelComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'g[bb-charts-pie-label]',
                    template: `
    <ng-container *ngIf="template; else defaultTemplate">
      <ng-template
        [ngTemplateOutlet]="template"
        [ngTemplateOutletContext]="{ data: data, color: color, icon: icon, label: labelText }"
      >
      </ng-template>
    </ng-container>

    <ng-template #defaultTemplate>
      <svg:g [attr.transform]="attrTransform" [style.transform]="styleTransform" [style.transition]="textTransition">
        <svg:text
          class="pie-label"
          [class.animation]="animations"
          dy=".35em"
          [style.textAnchor]="'middle'"
          [style.shapeRendering]="'crispEdges'"
        >
          {{ labelText }}
        </svg:text>
      </svg:g>
    </ng-template>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { data: [{
                type: Input
            }], radius: [{
                type: Input
            }], label: [{
                type: Input
            }], color: [{
                type: Input
            }], icon: [{
                type: Input
            }], max: [{
                type: Input
            }], value: [{
                type: Input
            }], explodeSlices: [{
                type: Input
            }], animations: [{
                type: Input
            }], labelTrim: [{
                type: Input
            }], labelTrimSize: [{
                type: Input
            }], template: [{
                type: Input
            }] } });

class InjectionRegisteryService {
    constructor(injectionService) {
        this.injectionService = injectionService;
        this.defaults = {};
        this.components = new Map();
    }
    getByType(type = this.type) {
        return this.components.get(type);
    }
    create(bindings) {
        return this.createByType(this.type, bindings);
    }
    createByType(type, bindings) {
        bindings = this.assignDefaults(bindings);
        const component = this.injectComponent(type, bindings);
        this.register(type, component);
        return component;
    }
    destroy(instance) {
        const compsByType = this.components.get(instance.componentType);
        if (compsByType && compsByType.length) {
            const idx = compsByType.indexOf(instance);
            if (idx > -1) {
                const component = compsByType[idx];
                component.destroy();
                compsByType.splice(idx, 1);
            }
        }
    }
    destroyAll() {
        this.destroyByType(this.type);
    }
    destroyByType(type) {
        const comps = this.components.get(type);
        if (comps && comps.length) {
            let i = comps.length - 1;
            while (i >= 0) {
                this.destroy(comps[i--]);
            }
        }
    }
    injectComponent(type, bindings) {
        return this.injectionService.appendComponent(type, bindings);
    }
    assignDefaults(bindings) {
        const inputs = Object.assign({}, this.defaults.inputs);
        const outputs = Object.assign({}, this.defaults.outputs);
        if (!bindings.inputs && !bindings.outputs) {
            bindings = { inputs: bindings };
        }
        if (inputs) {
            bindings.inputs = Object.assign(Object.assign({}, inputs), bindings.inputs);
        }
        if (outputs) {
            bindings.outputs = Object.assign(Object.assign({}, outputs), bindings.outputs);
        }
        return bindings;
    }
    register(type, component) {
        if (!this.components.has(type)) {
            this.components.set(type, []);
        }
        const types = this.components.get(type) || [];
        types.push(component);
    }
}

const caretOffset = 7;
function verticalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'top') {
        return elDimensions.top - caretOffset;
    }
    if (alignment === 'bottom') {
        return elDimensions.top + elDimensions.height - popoverDimensions.height + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.top + elDimensions.height / 2 - popoverDimensions.height / 2;
    }
    return undefined;
}
function horizontalPosition(elDimensions, popoverDimensions, alignment) {
    if (alignment === 'left') {
        return elDimensions.left - caretOffset;
    }
    if (alignment === 'right') {
        return elDimensions.left + elDimensions.width - popoverDimensions.width + caretOffset;
    }
    if (alignment === 'center') {
        return elDimensions.left + elDimensions.width / 2 - popoverDimensions.width / 2;
    }
    return undefined;
}
/**
 * Position helper for the popover directive.
 *
 * @export
 */
class PositionHelper {
    /**
     * Calculate vertical alignment position
     *
     * @memberOf PositionHelper
     */
    static calculateVerticalAlignment(elDimensions, popoverDimensions, alignment) {
        let result = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.height > window.innerHeight) {
            result = window.innerHeight - popoverDimensions.height;
        }
        return result || 0;
    }
    /**
     * Calculate vertical caret position
     *
     * @memberOf PositionHelper
     */
    static calculateVerticalCaret(elDimensions, popoverDimensions, caretDimensions, alignment) {
        let result = 0;
        if (alignment === 'top') {
            result = elDimensions.height / 2 - caretDimensions.height / 2 + caretOffset;
        }
        if (alignment === 'bottom') {
            result = popoverDimensions.height - elDimensions.height / 2 - caretDimensions.height / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.height / 2 - caretDimensions.height / 2;
        }
        const popoverPosition = verticalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.height > window.innerHeight) {
            result += popoverPosition + popoverDimensions.height - window.innerHeight;
        }
        return result;
    }
    /**
     * Calculate horz alignment position
     *
     * @memberOf PositionHelper
     */
    static calculateHorizontalAlignment(elDimensions, popoverDimensions, alignment) {
        let result = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (result + popoverDimensions.width > window.innerWidth) {
            result = window.innerWidth - popoverDimensions.width;
        }
        return result || 0;
    }
    /**
     * Calculate horz caret position
     *
     * @memberOf PositionHelper
     */
    static calculateHorizontalCaret(elDimensions, popoverDimensions, caretDimensions, alignment) {
        let result = 0;
        if (alignment === 'left') {
            result = elDimensions.width / 2 - caretDimensions.width / 2 + caretOffset;
        }
        if (alignment === 'right') {
            result = popoverDimensions.width - elDimensions.width / 2 - caretDimensions.width / 2 - caretOffset;
        }
        if (alignment === 'center') {
            result = popoverDimensions.width / 2 - caretDimensions.width / 2;
        }
        const popoverPosition = horizontalPosition(elDimensions, popoverDimensions, alignment);
        if (popoverPosition + popoverDimensions.width > window.innerWidth) {
            result += popoverPosition + popoverDimensions.width - window.innerWidth;
        }
        return result;
    }
    /**
     * Checks if the element's position should be flipped
     *
     * @memberOf PositionHelper
     */
    static shouldFlip(elDimensions, popoverDimensions, placement, spacing) {
        let flip = false;
        if (placement === 'right') {
            if (elDimensions.left + elDimensions.width + popoverDimensions.width + spacing > window.innerWidth) {
                flip = true;
            }
        }
        if (placement === 'left') {
            if (elDimensions.left - popoverDimensions.width - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'top') {
            if (elDimensions.top - popoverDimensions.height - spacing < 0) {
                flip = true;
            }
        }
        if (placement === 'bottom') {
            if (elDimensions.top + elDimensions.height + popoverDimensions.height + spacing > window.innerHeight) {
                flip = true;
            }
        }
        return flip;
    }
    /**
     * Position caret
     *
     * @memberOf PositionHelper
     */
    static positionCaret(placement, elmDim, hostDim, caretDimensions, alignment) {
        let top = 0;
        let left = 0;
        if (placement === PlacementTypes.Right) {
            left = -7;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.Left) {
            left = elmDim.width;
            top = PositionHelper.calculateVerticalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.Top) {
            top = elmDim.height;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        else if (placement === PlacementTypes.Bottom) {
            top = -7;
            left = PositionHelper.calculateHorizontalCaret(hostDim, elmDim, caretDimensions, alignment);
        }
        return { top, left };
    }
    /**
     * Position content
     *
     * @memberOf PositionHelper
     */
    static positionContent(placement, elmDim, hostDim, spacing, alignment) {
        let top = 0;
        let left = 0;
        if (placement === PlacementTypes.Right) {
            left = hostDim.left + hostDim.width + spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.Left) {
            left = hostDim.left - elmDim.width - spacing;
            top = PositionHelper.calculateVerticalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.Top) {
            top = hostDim.top - elmDim.height - spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        else if (placement === PlacementTypes.Bottom) {
            top = hostDim.top + hostDim.height + spacing;
            left = PositionHelper.calculateHorizontalAlignment(hostDim, elmDim, alignment);
        }
        return { top, left };
    }
    /**
     * Determine placement based on flip
     *
     * @memberOf PositionHelper
     */
    static determinePlacement(placement, elmDim, hostDim, spacing) {
        const shouldFlip = PositionHelper.shouldFlip(hostDim, elmDim, placement, spacing);
        if (shouldFlip) {
            if (placement === PlacementTypes.Right) {
                return PlacementTypes.Left;
            }
            else if (placement === PlacementTypes.Left) {
                return PlacementTypes.Right;
            }
            else if (placement === PlacementTypes.Top) {
                return PlacementTypes.Bottom;
            }
            else if (placement === PlacementTypes.Bottom) {
                return PlacementTypes.Top;
            }
        }
        return placement;
    }
}

class TooltipContentComponent {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    get cssClasses() {
        let clz = 'ngx-charts-tooltip-content';
        clz += ` position-${this.placement}`;
        clz += ` type-${this.type}`;
        clz += ` ${this.cssClass}`;
        return clz;
    }
    ngAfterViewInit() {
        setTimeout(this.position.bind(this));
    }
    position() {
        // if host is not there, don't show
        if (!this.host) {
            return;
        }
        const nativeElm = this.element.nativeElement;
        const hostDim = this.host.nativeElement.getBoundingClientRect();
        // if no dims were found, never show
        if (!hostDim.height && !hostDim.width)
            return;
        const elmDim = nativeElm.getBoundingClientRect();
        this.checkFlip(hostDim, elmDim);
        this.positionContent(nativeElm, hostDim, elmDim);
        // animate its entry
        setTimeout(() => this.renderer.addClass(nativeElm, 'animate'), 1);
    }
    positionContent(nativeElm, hostDim, elmDim) {
        // if custom position is requested, ignore library's calculations
        if (this.pos && this.pos.length === 2) {
            const arrowSize = (this.context.arrowSize || 0) * (this.placement === PlacementTypes.Right ? 1 : -1);
            const l = this.pos[0] + arrowSize + elmDim.width * (this.placement === PlacementTypes.Right ? 0 : -1);
            const t = this.pos[1] - elmDim.height / 2;
            this.renderer.setStyle(nativeElm, 'top', `${t}px`);
            this.renderer.setStyle(nativeElm, 'left', `${l}px`);
            return;
        }
        const { top, left } = PositionHelper.positionContent(this.placement, elmDim, hostDim, this.spacing, this.alignment);
        this.renderer.setStyle(nativeElm, 'top', `${top}px`);
        this.renderer.setStyle(nativeElm, 'left', `${left}px`);
    }
    checkFlip(hostDim, elmDim) {
        this.placement = PositionHelper.determinePlacement(this.placement, elmDim, hostDim, this.spacing);
    }
    onWindowResize() {
        this.position();
    }
}
TooltipContentComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipContentComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
TooltipContentComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TooltipContentComponent, selector: "bb-tooltip-content", inputs: { host: "host", type: "type", placement: "placement", alignment: "alignment", spacing: "spacing", cssClass: "cssClass", title: "title", template: "template", context: "context", pos: "pos" }, host: { listeners: { "window:resize": "onWindowResize()" }, properties: { "class": "this.cssClasses" } }, ngImport: i0, template: `
    <div class="tooltip-content">
      <span *ngIf="!title">
        <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ model: context }"> </ng-template>
      </span>
      <span *ngIf="title" [innerHTML]="title"> </span>
    </div>
  `, isInline: true, styles: [".ngx-charts-tooltip-content{position:fixed;border-radius:3px;z-index:5000;display:block;font-weight:normal;opacity:0;pointer-events:none!important}.ngx-charts-tooltip-content.type-popover{background:#fff;color:#060709;border:1px solid #72809b;box-shadow:0 1px 3px #0003,0 1px 1px #00000024,0 2px 1px -1px #0000001f;font-size:13px;padding:4px}.ngx-charts-tooltip-content.type-popover .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid #fff}.ngx-charts-tooltip-content.type-popover .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid #fff}.ngx-charts-tooltip-content.type-tooltip{color:#fff;background:rgba(0,0,0,.75);font-size:12px;padding:0 10px;text-align:center;pointer-events:auto}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-left{border-top:7px solid transparent;border-bottom:7px solid transparent;border-left:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-top{border-left:7px solid transparent;border-right:7px solid transparent;border-top:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-right{border-top:7px solid transparent;border-bottom:7px solid transparent;border-right:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content.type-tooltip .tooltip-caret.position-bottom{border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:7px solid rgba(0,0,0,.75)}.ngx-charts-tooltip-content .tooltip-label{display:block;line-height:1em;padding:8px 5px 5px;font-size:1em}.ngx-charts-tooltip-content .tooltip-val{display:block;font-size:1.3em;line-height:1em;padding:0 5px 8px}.ngx-charts-tooltip-content .tooltip-caret{position:absolute;z-index:5001;width:0;height:0}.ngx-charts-tooltip-content.position-right{transform:translate(10px)}.ngx-charts-tooltip-content.position-left{transform:translate(-10px)}.ngx-charts-tooltip-content.position-top{transform:translateY(-10px)}.ngx-charts-tooltip-content.position-bottom{transform:translateY(10px)}.ngx-charts-tooltip-content.animate{opacity:1;transition:opacity .3s,transform .3s;transform:translate(0);pointer-events:auto}.area-tooltip-container{padding:5px 0;pointer-events:none}.tooltip-item{text-align:left;line-height:1.2em;padding:5px 0}.tooltip-item .tooltip-item-color{display:inline-block;height:12px;width:12px;margin-right:5px;color:#5b646b;border-radius:3px}\n"], directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], encapsulation: i0.ViewEncapsulation.None });
__decorate([
    throttleable(100)
], TooltipContentComponent.prototype, "onWindowResize", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-tooltip-content',
                    template: `
    <div class="tooltip-content">
      <span *ngIf="!title">
        <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ model: context }"> </ng-template>
      </span>
      <span *ngIf="title" [innerHTML]="title"> </span>
    </div>
  `,
                    encapsulation: ViewEncapsulation.None,
                    styleUrls: ['./tooltip.component.scss'],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { host: [{
                type: Input
            }], type: [{
                type: Input
            }], placement: [{
                type: Input
            }], alignment: [{
                type: Input
            }], spacing: [{
                type: Input
            }], cssClass: [{
                type: Input
            }], title: [{
                type: Input
            }], template: [{
                type: Input
            }], context: [{
                type: Input
            }], pos: [{
                type: Input
            }], cssClasses: [{
                type: HostBinding,
                args: ['class']
            }], onWindowResize: [{
                type: HostListener,
                args: ['window:resize']
            }] } });

function isViewContainerRef(x) {
    return x.element;
}
/**
 * Injection service is a helper to append components
 * dynamically to a known location in the DOM, most
 * noteably for dialogs/tooltips appending to body.
 *
 * @export
 */
class InjectionService {
    constructor(applicationRef, componentFactoryResolver, injector) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    /**
     * Sets a default global root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param container
     */
    static setGlobalRootViewContainer(container) {
        InjectionService.globalRootViewContainer = container;
    }
    /**
     * Gets the root view container to inject the component to.
     *
     * @memberOf InjectionService
     */
    getRootViewContainer() {
        if (this._container)
            return this._container;
        if (InjectionService.globalRootViewContainer)
            return InjectionService.globalRootViewContainer;
        if (this.applicationRef.components.length)
            return this.applicationRef.components[0];
        throw new Error('View Container not found! ngUpgrade needs to manually set this via setRootViewContainer or setGlobalRootViewContainer.');
    }
    /**
     * Overrides the default root view container. This is useful for
     * things like ngUpgrade that doesn't have a ApplicationRef root.
     *
     * @param container
     *
     * @memberOf InjectionService
     */
    setRootViewContainer(container) {
        this._container = container;
    }
    /**
     * Gets the html element for a component ref.
     *
     * @param componentRef
     *
     * @memberOf InjectionService
     */
    getComponentRootNode(component) {
        if (isViewContainerRef(component)) {
            return component.element.nativeElement;
        }
        if (component.hostView && component.hostView.rootNodes.length > 0) {
            return component.hostView.rootNodes[0];
        }
        // the top most component root node has no `hostView`
        return component.location.nativeElement;
    }
    /**
     * Gets the root component container html element.
     *
     * @memberOf InjectionService
     */
    getRootViewContainerNode(component) {
        return this.getComponentRootNode(component);
    }
    /**
     * Projects the bindings onto the component
     *
     * @param component
     * @param options
     *
     * @memberOf InjectionService
     */
    projectComponentBindings(component, bindings) {
        if (bindings) {
            if (bindings.inputs !== undefined) {
                const bindingKeys = Object.getOwnPropertyNames(bindings.inputs);
                for (const bindingName of bindingKeys) {
                    component.instance[bindingName] = bindings.inputs[bindingName];
                }
            }
            if (bindings.outputs !== undefined) {
                const eventKeys = Object.getOwnPropertyNames(bindings.outputs);
                for (const eventName of eventKeys) {
                    component.instance[eventName] = bindings.outputs[eventName];
                }
            }
        }
        return component;
    }
    /**
     * Appends a component to a adjacent location
     *
     * @param componentClass
     * @param [options={}]
     * @param [location]
     *
     * @memberOf InjectionService
     */
    appendComponent(componentClass, bindings = {}, location) {
        if (!location)
            location = this.getRootViewContainer();
        const appendLocation = this.getComponentRootNode(location);
        const portalHost = new DomPortalHost(appendLocation, this.componentFactoryResolver, this.applicationRef, this.injector);
        const portal = new ComponentPortal(componentClass);
        const componentRef = portalHost.attach(portal);
        this.projectComponentBindings(componentRef, bindings);
        return componentRef;
    }
}
// eslint-disable-next-line
InjectionService.globalRootViewContainer = null;
InjectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InjectionService, deps: [{ token: i0.ApplicationRef }, { token: i0.ComponentFactoryResolver }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
InjectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InjectionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InjectionService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.ApplicationRef }, { type: i0.ComponentFactoryResolver }, { type: i0.Injector }]; } });

class TooltipService extends InjectionRegisteryService {
    constructor(injectionService) {
        super(injectionService);
        this.injectionService = injectionService;
        this.type = TooltipContentComponent;
    }
}
TooltipService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipService, deps: [{ token: InjectionService }], target: i0.ɵɵFactoryTarget.Injectable });
TooltipService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: InjectionService }]; } });

class TooltipDirective {
    constructor(tooltipService, viewContainerRef, renderer) {
        this.tooltipService = tooltipService;
        this.viewContainerRef = viewContainerRef;
        this.renderer = renderer;
        this.tooltipCssClass = '';
        this.tooltipTitle = '';
        this.tooltipAppendToBody = true;
        this.tooltipSpacing = 10;
        this.tooltipDisabled = false;
        this.tooltipShowCaret = true;
        this.tooltipPlacement = PlacementTypes.Top;
        this.tooltipAlignment = PlacementTypes.Center;
        this.tooltipType = StyleTypes.popover;
        this.tooltipCloseOnClickOutside = true;
        this.tooltipCloseOnMouseLeave = true;
        this.tooltipHideTimeout = 300;
        this.tooltipShowTimeout = 100;
        this.tooltipShowEvent = ShowTypes.all;
        this.tooltipImmediateExit = false;
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.show = new EventEmitter();
        this.hide = new EventEmitter();
    }
    get listensForFocus() {
        return this.tooltipShowEvent === ShowTypes.all || this.tooltipShowEvent === ShowTypes.focus;
    }
    get listensForHover() {
        return this.tooltipShowEvent === ShowTypes.all || this.tooltipShowEvent === ShowTypes.mouseover;
    }
    ngOnDestroy() {
        this.hideTooltip(true);
    }
    onFocus() {
        if (this.listensForFocus) {
            this.showTooltip();
        }
    }
    onBlur() {
        if (this.listensForFocus) {
            this.hideTooltip(true);
        }
    }
    onMouseEnter() {
        if (this.listensForHover) {
            this.showTooltip();
        }
    }
    onMouseLeave(target) {
        if (this.listensForHover && this.tooltipCloseOnMouseLeave) {
            clearTimeout(this.timeout);
            if (this.component) {
                const contentDom = this.component.instance.element.nativeElement;
                const contains = contentDom.contains(target);
                if (contains)
                    return;
            }
            this.hideTooltip(this.tooltipImmediateExit);
        }
    }
    onMouseClick() {
        if (this.listensForHover) {
            this.hideTooltip(true);
        }
    }
    showTooltip(immediate) {
        if (this.component || this.tooltipDisabled)
            return;
        const time = immediate ? 0 : this.tooltipShowTimeout;
        clearTimeout(this.timeout);
        this.timeout = setTimeout(() => {
            this.tooltipService.destroyAll();
            const options = this.createBoundOptions();
            this.component = this.tooltipService.create(options);
            // add a tiny timeout to avoid event re-triggers
            setTimeout(() => {
                if (this.component) {
                    this.addHideListeners(this.component.instance.element.nativeElement);
                }
            }, 10);
            this.show.emit(true);
        }, time);
    }
    addHideListeners(tooltip) {
        // on mouse enter, cancel the hide triggered by the leave
        this.mouseEnterContentEvent = this.renderer.listen(tooltip, 'mouseenter', () => {
            clearTimeout(this.timeout);
        });
        // content mouse leave listener
        if (this.tooltipCloseOnMouseLeave) {
            this.mouseLeaveContentEvent = this.renderer.listen(tooltip, 'mouseleave', () => {
                this.hideTooltip(this.tooltipImmediateExit);
            });
        }
        // content close on click outside
        if (this.tooltipCloseOnClickOutside) {
            this.documentClickEvent = this.renderer.listen(document, 'click', (event) => {
                const contains = tooltip.contains(event.target);
                if (!contains)
                    this.hideTooltip();
            });
        }
    }
    hideTooltip(immediate = false) {
        if (!this.component)
            return;
        const destroyFn = () => {
            // remove events
            if (this.mouseLeaveContentEvent)
                this.mouseLeaveContentEvent();
            if (this.mouseEnterContentEvent)
                this.mouseEnterContentEvent();
            if (this.documentClickEvent)
                this.documentClickEvent();
            // emit events
            this.hide.emit(true);
            // destroy component
            this.tooltipService.destroy(this.component);
            this.component = undefined;
        };
        clearTimeout(this.timeout);
        if (!immediate) {
            this.timeout = setTimeout(destroyFn, this.tooltipHideTimeout);
        }
        else {
            destroyFn();
        }
    }
    createBoundOptions() {
        return {
            title: this.tooltipTitle,
            template: this.tooltipTemplate,
            host: this.viewContainerRef.element,
            placement: this.tooltipPlacement,
            alignment: this.tooltipAlignment,
            type: this.tooltipType,
            showCaret: this.tooltipShowCaret,
            cssClass: this.tooltipCssClass,
            spacing: this.tooltipSpacing,
            context: this.tooltipContext,
            pos: this.tooltipPosition,
        };
    }
}
TooltipDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipDirective, deps: [{ token: TooltipService }, { token: i0.ViewContainerRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
TooltipDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TooltipDirective, selector: "[bb-tooltip]", inputs: { tooltipCssClass: "tooltipCssClass", tooltipTitle: "tooltipTitle", tooltipPosition: "tooltipPosition", tooltipAppendToBody: "tooltipAppendToBody", tooltipSpacing: "tooltipSpacing", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipPlacement: "tooltipPlacement", tooltipAlignment: "tooltipAlignment", tooltipType: "tooltipType", tooltipCloseOnClickOutside: "tooltipCloseOnClickOutside", tooltipCloseOnMouseLeave: "tooltipCloseOnMouseLeave", tooltipHideTimeout: "tooltipHideTimeout", tooltipShowTimeout: "tooltipShowTimeout", tooltipTemplate: "tooltipTemplate", tooltipShowEvent: "tooltipShowEvent", tooltipContext: "tooltipContext", tooltipImmediateExit: "tooltipImmediateExit" }, outputs: { show: "show", hide: "hide" }, host: { listeners: { "focusin": "onFocus()", "blur": "onBlur()", "mouseenter": "onMouseEnter()", "mouseleave": "onMouseLeave($event.target)", "click": "onMouseClick()" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[bb-tooltip]',
                }]
        }], ctorParameters: function () { return [{ type: TooltipService }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }]; }, propDecorators: { tooltipCssClass: [{
                type: Input
            }], tooltipTitle: [{
                type: Input
            }], tooltipPosition: [{
                type: Input
            }], tooltipAppendToBody: [{
                type: Input
            }], tooltipSpacing: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], tooltipShowCaret: [{
                type: Input
            }], tooltipPlacement: [{
                type: Input
            }], tooltipAlignment: [{
                type: Input
            }], tooltipType: [{
                type: Input
            }], tooltipCloseOnClickOutside: [{
                type: Input
            }], tooltipCloseOnMouseLeave: [{
                type: Input
            }], tooltipHideTimeout: [{
                type: Input
            }], tooltipShowTimeout: [{
                type: Input
            }], tooltipTemplate: [{
                type: Input
            }], tooltipShowEvent: [{
                type: Input
            }], tooltipContext: [{
                type: Input
            }], tooltipImmediateExit: [{
                type: Input
            }], show: [{
                type: Output
            }], hide: [{
                type: Output
            }], onFocus: [{
                type: HostListener,
                args: ['focusin']
            }], onBlur: [{
                type: HostListener,
                args: ['blur']
            }], onMouseEnter: [{
                type: HostListener,
                args: ['mouseenter']
            }], onMouseLeave: [{
                type: HostListener,
                args: ['mouseleave', ['$event.target']]
            }], onMouseClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class PieSeriesComponent {
    constructor(currencyPipe) {
        this.currencyPipe = currencyPipe;
        /**
         * Array of Chart data objects needed for the chart to be rendered.
         */
        this.series = [];
        /**
         * Inner slice radius.
         */
        this.innerRadius = 60;
        /**
         * Outer slice radius.
         */
        this.outerRadius = 80;
        /**
         * Slice offsets.
         */
        this.margins = [0, 0, 0, 0];
        /**
         * Flag to show/hide labels.
         */
        this.showLabels = false;
        /**
         * Preselects an active slice of the chart.
         */
        this.activeEntries = [];
        /**
         * Sets the threshold in which the label of each section is visible.
         */
        this.labelThreshold = 0;
        /**
         * Enable/disable label trimming.
         */
        this.trimLabels = true;
        /**
         * Set the max length of the label characters.
         */
        this.maxLabelLength = 10;
        /**
         * Disable/enable the tooltip.
         */
        this.tooltipDisabled = false;
        /**
         * Enable/Disable animations.
         */
        this.animations = true;
        /**
         * EventEmitter for triggering a select event.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.select = new EventEmitter();
        /**
         * EventEmitter for triggering a activate event.
         */
        this.activate = new EventEmitter();
        /**
         * EventEmitter for triggering a deactivate event.
         */
        this.deactivate = new EventEmitter();
        /**
         * EventEmitter for triggering a dblclick event.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.dblclick = new EventEmitter();
        this.data = [];
    }
    ngOnChanges() {
        this.update();
    }
    update() {
        const pieGenerator = pie()
            .value((d) => d.value)
            // eslint-disable-next-line no-null/no-null
            .sort(null);
        const arcData = pieGenerator(this.series);
        this.max = max(arcData, (d) => {
            return d.value;
        });
        this.data = this.calculateLabelPositions(arcData);
        this.tooltipText = this.tooltipText || this.defaultTooltipText;
    }
    midAngle(d) {
        return d.startAngle + (d.endAngle - d.startAngle) / 2;
    }
    outerArc(padding) {
        const r = this.outerRadius + padding;
        return arc().innerRadius(r).outerRadius(r);
    }
    calculateLabelPositions(pieData) {
        const labelPositions = pieData;
        labelPositions.forEach((d) => {
            d.pos = this.outerArc(30).centroid(d);
            d.edge = this.outerArc(0).centroid(d);
        });
        return labelPositions;
    }
    labelVisible(myArc) {
        return this.showLabels && myArc.data.portion > this.labelThreshold;
    }
    getTooltipTitle(a) {
        if (this.tooltipTemplate || typeof this.tooltipText !== 'function') {
            return undefined;
        }
        return this.tooltipText(a);
    }
    getTooltipPlacement(a) {
        return this.midAngle(a) > Math.PI ? PlacementTypes.Left : PlacementTypes.Right;
    }
    labelText(myArc) {
        if (this.labelFormatting) {
            return this.labelFormatting(myArc.data.value);
        }
        return (this.currencyPipe.transform(myArc.data.value, myArc.data.totalAmount.currencyCode, undefined, '1.0-0') ||
            myArc.data.value.toString());
    }
    label(myArc) {
        return formatLabel(myArc.data.name);
    }
    defaultTooltipText(myArc) {
        const label = this.label(myArc);
        const val = formatLabel(myArc.data.value);
        return `
      <span class="tooltip-label">${label}</span>
      <span class="tooltip-val">${val}</span>
    `;
    }
    getTooltipPosition(myArc) {
        const halfWidth = this.outerRadius + this.margins[0];
        let position = [0, 0];
        if (this.chartElement) {
            const chartDims = this.chartElement.nativeElement.getBoundingClientRect();
            position = [chartDims.left + halfWidth, chartDims.top + halfWidth];
        }
        return [position[0] + myArc.edge[0], position[1] + myArc.edge[1]];
    }
    color(myArc) {
        return this.colors ? this.colors.getColor(this.label(myArc)) : '';
    }
    icon(myArc) {
        if (!this.colors || !this.colors.customColors) {
            return '';
        }
        const label = this.label(myArc);
        const found = this.colors.customColors.find((item) => item.name === label);
        return found ? found.icon : '';
    }
    trackBy(index, item) {
        return item.data.name;
    }
    onClick(data) {
        this.select.emit(data);
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find((d) => {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    }
}
PieSeriesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieSeriesComponent, deps: [{ token: i1.CurrencyPipe }], target: i0.ɵɵFactoryTarget.Component });
PieSeriesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PieSeriesComponent, selector: "g[bb-charts-pie-series]", inputs: { colors: "colors", series: "series", dims: "dims", chartElement: "chartElement", innerRadius: "innerRadius", outerRadius: "outerRadius", margins: "margins", explodeSlices: "explodeSlices", showLabels: "showLabels", gradient: "gradient", activeEntries: "activeEntries", labelThreshold: "labelThreshold", labelFormatting: "labelFormatting", labelTemplate: "labelTemplate", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipText: "tooltipText", tooltipDisabled: "tooltipDisabled", tooltipTemplate: "tooltipTemplate", animations: "animations" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dblclick: "dblclick" }, usesOnChanges: true, ngImport: i0, template: `
    <svg:g
      *ngFor="let arc of data; trackBy: trackBy"
      data-role="analysis-donut-chart-segment"
      bb-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="getTooltipPlacement(arc)"
      [tooltipType]="'tooltip'"
      [tooltipShowCaret]="false"
      [tooltipSpacing]="0"
      [tooltipTitle]="getTooltipTitle(arc)"
      [tooltipPosition]="getTooltipPosition(arc)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="arc.data"
    >
      <svg:g
        bb-charts-pie-label
        *ngIf="labelVisible(arc)"
        [data]="arc"
        [radius]="outerRadius"
        [color]="color(arc)"
        [icon]="icon(arc)"
        [label]="labelText(arc)"
        [labelTrim]="trimLabels"
        [labelTrimSize]="maxLabelLength"
        [template]="labelTemplate"
        [max]="max"
        [value]="arc.value"
        [explodeSlices]="explodeSlices"
        [animations]="animations"
      ></svg:g>
      <svg:g
        ngx-charts-pie-arc
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [gradient]="gradient"
        [data]="arc.data"
        [max]="max"
        [explodeSlices]="explodeSlices"
        [isActive]="isActive(arc.data)"
        [animate]="animations"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        (dblclick)="dblclick.emit($event)"
      ></svg:g>
    </svg:g>
  `, isInline: true, components: [{ type: PieLabelComponent, selector: "g[bb-charts-pie-label]", inputs: ["data", "radius", "label", "color", "icon", "max", "value", "explodeSlices", "animations", "labelTrim", "labelTrimSize", "template"] }, { type: i3.PieArcComponent, selector: "g[ngx-charts-pie-arc]", inputs: ["startAngle", "endAngle", "cornerRadius", "explodeSlices", "gradient", "animate", "pointerEvents", "isActive", "fill", "innerRadius", "outerRadius", "value", "max", "data"], outputs: ["select", "activate", "deactivate", "dblclick"] }], directives: [{ type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: TooltipDirective, selector: "[bb-tooltip]", inputs: ["tooltipCssClass", "tooltipTitle", "tooltipPosition", "tooltipAppendToBody", "tooltipSpacing", "tooltipDisabled", "tooltipShowCaret", "tooltipPlacement", "tooltipAlignment", "tooltipType", "tooltipCloseOnClickOutside", "tooltipCloseOnMouseLeave", "tooltipHideTimeout", "tooltipShowTimeout", "tooltipTemplate", "tooltipShowEvent", "tooltipContext", "tooltipImmediateExit"], outputs: ["show", "hide"] }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieSeriesComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'g[bb-charts-pie-series]',
                    template: `
    <svg:g
      *ngFor="let arc of data; trackBy: trackBy"
      data-role="analysis-donut-chart-segment"
      bb-tooltip
      [tooltipDisabled]="tooltipDisabled"
      [tooltipPlacement]="getTooltipPlacement(arc)"
      [tooltipType]="'tooltip'"
      [tooltipShowCaret]="false"
      [tooltipSpacing]="0"
      [tooltipTitle]="getTooltipTitle(arc)"
      [tooltipPosition]="getTooltipPosition(arc)"
      [tooltipTemplate]="tooltipTemplate"
      [tooltipContext]="arc.data"
    >
      <svg:g
        bb-charts-pie-label
        *ngIf="labelVisible(arc)"
        [data]="arc"
        [radius]="outerRadius"
        [color]="color(arc)"
        [icon]="icon(arc)"
        [label]="labelText(arc)"
        [labelTrim]="trimLabels"
        [labelTrimSize]="maxLabelLength"
        [template]="labelTemplate"
        [max]="max"
        [value]="arc.value"
        [explodeSlices]="explodeSlices"
        [animations]="animations"
      ></svg:g>
      <svg:g
        ngx-charts-pie-arc
        [startAngle]="arc.startAngle"
        [endAngle]="arc.endAngle"
        [innerRadius]="innerRadius"
        [outerRadius]="outerRadius"
        [fill]="color(arc)"
        [value]="arc.data.value"
        [gradient]="gradient"
        [data]="arc.data"
        [max]="max"
        [explodeSlices]="explodeSlices"
        [isActive]="isActive(arc.data)"
        [animate]="animations"
        (select)="onClick($event)"
        (activate)="activate.emit($event)"
        (deactivate)="deactivate.emit($event)"
        (dblclick)="dblclick.emit($event)"
      ></svg:g>
    </svg:g>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.CurrencyPipe }]; }, propDecorators: { colors: [{
                type: Input
            }], series: [{
                type: Input
            }], dims: [{
                type: Input
            }], chartElement: [{
                type: Input
            }], innerRadius: [{
                type: Input
            }], outerRadius: [{
                type: Input
            }], margins: [{
                type: Input
            }], explodeSlices: [{
                type: Input
            }], showLabels: [{
                type: Input
            }], gradient: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], labelThreshold: [{
                type: Input
            }], labelFormatting: [{
                type: Input
            }], labelTemplate: [{
                type: Input
            }], trimLabels: [{
                type: Input
            }], maxLabelLength: [{
                type: Input
            }], tooltipText: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], tooltipTemplate: [{
                type: Input
            }], animations: [{
                type: Input
            }], select: [{
                type: Output
            }], activate: [{
                type: Output
            }], deactivate: [{
                type: Output
            }], dblclick: [{
                type: Output
            }] } });

class PieChartComponent extends BaseChartComponent {
    constructor(chartElement, zone, cd, platformId) {
        super(chartElement, zone, cd, platformId);
        this.chartElement = chartElement;
        this.zone = zone;
        this.cd = cd;
        /**
         * Array of Chart data objects needed for the chart to be rendered.
         */
        this.series = [];
        /**
         * Flag to show/hide the chart labels.
         */
        this.labels = false;
        /**
         * Flag to show/hide the chart legend.
         */
        this.legend = false;
        /**
         * Title for the chart legend.
         */
        this.legendTitle = 'Legend';
        /**
         * Make the radius of each slice proportional to it's value.
         */
        this.explodeSlices = false;
        /**
         * Sets the type of the chart.
         */
        this.doughnut = false;
        /**
         * The width of the charts arc.
         */
        this.arcWidth = 0.25;
        /**
         * Preselects an active slice of the chart.
         */
        this.activeEntries = [];
        /**
         * Disable/enable the tooltip.
         */
        this.tooltipDisabled = false;
        /**
         * Sets the threshold in which the label of each section is visible.
         */
        this.labelThreshold = 0;
        /**
         * Enable/disable label trimming.
         */
        this.trimLabels = true;
        /**
         * Set the max length of the label characters.
         */
        this.maxLabelLength = 10;
        /**
         * EventEmitter for triggering a dblclick event.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.dblclick = new EventEmitter();
        /**
         * EventEmitter for triggering a select event.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.select = new EventEmitter();
        /**
         * EventEmitter for triggering a activate event.
         */
        this.activate = new EventEmitter();
        /**
         * EventEmitter for triggering a deactivate event.
         */
        this.deactivate = new EventEmitter();
        this.domain = [];
        this.margins = [50, 50, 50, 50];
    }
    get chartEl() {
        return this.chartElement;
    }
    update() {
        super.update();
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margins,
            showLegend: this.legend,
        });
        const xOffset = this.margins[3] + this.dims.width / 2;
        const yOffset = this.margins[0] + this.dims.height / 2;
        this.translation = `translate(${xOffset}, ${yOffset})`;
        this.outerRadius = Math.min(this.dims.width, this.dims.height) / 2;
        this.innerRadius = 0;
        if (this.doughnut) {
            this.innerRadius = this.outerRadius * (1 - this.arcWidth);
        }
        this.domain = this.getDomain();
        // sort data according to domain
        this.series.sort((a, b) => {
            return this.domain.indexOf(a.name) - this.domain.indexOf(b.name);
        });
        this.data = this.series;
        this.setColors();
        this.legendOptions = this.getLegendOptions();
    }
    getDomain() {
        const items = [];
        this.results.map((d) => {
            let label = d.name;
            if (label.constructor.name === 'Date') {
                label = label.toLocaleDateString();
            }
            else {
                label = label.toLocaleString();
            }
            if (items.indexOf(label) === -1) {
                items.push(label);
            }
        });
        return items;
    }
    onClick(data) {
        this.select.emit(data);
    }
    setColors() {
        this.colors = new ColorHelper(this.scheme, ScaleType.Ordinal, this.domain, this.customColors);
    }
    getLegendOptions() {
        return {
            scaleType: ScaleType.Ordinal,
            domain: this.domain,
            colors: this.colors,
            title: this.legendTitle,
        };
    }
    onActivate(item) {
        const idx = this.activeEntries.findIndex((d) => {
            return d.name === item.name && d.value === item.value;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item, ...this.activeEntries];
        this.activate.emit({ value: item, entries: this.activeEntries });
    }
    onDeactivate(item) {
        const idx = this.activeEntries.findIndex((d) => {
            return d.name === item.name && d.value === item.value;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = [...this.activeEntries]; // NOSONAR false positive - https://github.com/SonarSource/SonarTS/issues/760
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    }
}
PieChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieChartComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });
PieChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PieChartComponent, selector: "bb-charts-pie-chart", inputs: { series: "series", labels: "labels", legend: "legend", legendTitle: "legendTitle", explodeSlices: "explodeSlices", doughnut: "doughnut", arcWidth: "arcWidth", gradient: "gradient", activeEntries: "activeEntries", tooltipDisabled: "tooltipDisabled", labelFormatting: "labelFormatting", labelTemplate: "labelTemplate", labelThreshold: "labelThreshold", trimLabels: "trimLabels", maxLabelLength: "maxLabelLength", tooltipText: "tooltipText" }, outputs: { dblclick: "dblclick", select: "select", activate: "activate", deactivate: "deactivate" }, queries: [{ propertyName: "tooltipTemplate", first: true, predicate: ["tooltipTemplate"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="translation" class="pie-chart chart">
        <svg:g
          bb-charts-pie-series
          [colors]="colors"
          [series]="series"
          [chartElement]="chartEl"
          [showLabels]="labels"
          [labelThreshold]="labelThreshold"
          [labelFormatting]="labelFormatting"
          [labelTemplate]="labelTemplate"
          [trimLabels]="trimLabels"
          [maxLabelLength]="maxLabelLength"
          [activeEntries]="activeEntries"
          [innerRadius]="innerRadius"
          [outerRadius]="outerRadius"
          [margins]="margins"
          [explodeSlices]="explodeSlices"
          [gradient]="gradient"
          [animations]="animations"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipText]="tooltipText"
          (dblclick)="dblclick.emit($event)"
          (select)="onClick($event)"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `, isInline: true, styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .bar,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:normal}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}.pie-label{font-size:11px}.pie-label.animation{animation:.75s ease-in fadeIn}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.pie-label-line{stroke-dasharray:100%}.pie-label-line.animation{animation:3s linear drawOut;transition:d .75s}@keyframes drawOut{0%{stroke-dashoffset:100%}to{stroke-dashoffset:0}}\n"], components: [{ type: i3.ChartComponent, selector: "ngx-charts-chart", inputs: ["showLegend", "animations", "legendType", "view", "legendOptions", "activeEntries"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }, { type: PieSeriesComponent, selector: "g[bb-charts-pie-series]", inputs: ["colors", "series", "dims", "chartElement", "innerRadius", "outerRadius", "margins", "explodeSlices", "showLabels", "gradient", "activeEntries", "labelThreshold", "labelFormatting", "labelTemplate", "trimLabels", "maxLabelLength", "tooltipText", "tooltipDisabled", "tooltipTemplate", "animations"], outputs: ["select", "activate", "deactivate", "dblclick"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-charts-pie-chart',
                    template: `
    <ngx-charts-chart
      [view]="[width, height]"
      [showLegend]="legend"
      [legendOptions]="legendOptions"
      [activeEntries]="activeEntries"
      [animations]="animations"
      (legendLabelActivate)="onActivate($event)"
      (legendLabelDeactivate)="onDeactivate($event)"
      (legendLabelClick)="onClick($event)"
    >
      <svg:g [attr.transform]="translation" class="pie-chart chart">
        <svg:g
          bb-charts-pie-series
          [colors]="colors"
          [series]="series"
          [chartElement]="chartEl"
          [showLabels]="labels"
          [labelThreshold]="labelThreshold"
          [labelFormatting]="labelFormatting"
          [labelTemplate]="labelTemplate"
          [trimLabels]="trimLabels"
          [maxLabelLength]="maxLabelLength"
          [activeEntries]="activeEntries"
          [innerRadius]="innerRadius"
          [outerRadius]="outerRadius"
          [margins]="margins"
          [explodeSlices]="explodeSlices"
          [gradient]="gradient"
          [animations]="animations"
          [tooltipDisabled]="tooltipDisabled"
          [tooltipTemplate]="tooltipTemplate"
          [tooltipText]="tooltipText"
          (dblclick)="dblclick.emit($event)"
          (select)="onClick($event)"
          (activate)="onActivate($event)"
          (deactivate)="onDeactivate($event)"
        />
      </svg:g>
    </ngx-charts-chart>
  `,
                    styleUrls: ['./pie-chart.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; }, propDecorators: { series: [{
                type: Input
            }], labels: [{
                type: Input
            }], legend: [{
                type: Input
            }], legendTitle: [{
                type: Input
            }], explodeSlices: [{
                type: Input
            }], doughnut: [{
                type: Input
            }], arcWidth: [{
                type: Input
            }], gradient: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], labelFormatting: [{
                type: Input
            }], labelTemplate: [{
                type: Input
            }], labelThreshold: [{
                type: Input
            }], trimLabels: [{
                type: Input
            }], maxLabelLength: [{
                type: Input
            }], tooltipText: [{
                type: Input
            }], dblclick: [{
                type: Output
            }], select: [{
                type: Output
            }], activate: [{
                type: Output
            }], deactivate: [{
                type: Output
            }], tooltipTemplate: [{
                type: ContentChild,
                args: ['tooltipTemplate', { static: true }]
            }] } });

class DonutChartComponent {
    constructor(cssVariableService) {
        this.cssVariableService = cssVariableService;
        /**
         * Sets the threshold in which the label of each section is visible.
         */
        this.relevancePercentage = 0;
        this.classes = 'absolute-center w-100 h-100';
    }
    get template() {
        return this.tooltipTmpl || this.defaultTooltipTemplate;
    }
    expandModel(model) {
        if (!this.data) {
            return model;
        }
        const data = this.data.find((item) => item.name === model.name) || model;
        return Object.assign(data, {
            arrowClass: data.totalPortion - data.portion / 2 >= 50 ? ArrowClasses.RIGHT : ArrowClasses.LEFT,
            arrowSize: this.arrowSize,
        });
    }
    ngOnInit() {
        this.cssVariableService
            .getCssVariable(CARET_SIZE_CSS_VAR)
            .then((value) => (this.arrowSize = parseInt(value || '', 10) || 0));
    }
}
DonutChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DonutChartComponent, deps: [{ token: i1$1.CssVariablesService }], target: i0.ɵɵFactoryTarget.Component });
DonutChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DonutChartComponent, selector: "bb-donut-chart-ui", inputs: { data: "data", colors: "colors", relevancePercentage: "relevancePercentage", tooltipTmpl: "tooltipTmpl", labelTmpl: "labelTmpl" }, host: { properties: { "class": "this.classes" } }, viewQueries: [{ propertyName: "defaultTooltipTemplate", first: true, predicate: ["defaultTooltipTemplate"], descendants: true, static: true }], ngImport: i0, template: "<bb-charts-pie-chart\n  [results]=\"data\"\n  [series]=\"data\"\n  [customColors]=\"colors\"\n  [doughnut]=\"true\"\n  [arcWidth]=\"0.4\"\n  [labels]=\"true\"\n  [labelThreshold]=\"relevancePercentage\"\n  [labelTemplate]=\"labelTmpl\"\n>\n  <ng-template #tooltipTemplate let-model=\"model\">\n    <ng-container *ngTemplateOutlet=\"template; context: expandModel(model)\"></ng-container>\n  </ng-template>\n</bb-charts-pie-chart>\n\n<ng-template\n  #defaultTooltipTemplate\n  let-name=\"name\"\n  let-totalAmount=\"totalAmount\"\n>\n  <h3 class=\"chart-tooltip-analysis-category\">\n    {{ name }}\n  </h3>\n  <h4 class=\"chart-tooltip-analysis-amount\">\n    <bb-amount-ui\n      [amount]=\"totalAmount.amount\"\n      [currency]=\"totalAmount.currencyCode\"\n    ></bb-amount-ui>\n  </h4>\n</ng-template>\n", components: [{ type: PieChartComponent, selector: "bb-charts-pie-chart", inputs: ["series", "labels", "legend", "legendTitle", "explodeSlices", "doughnut", "arcWidth", "gradient", "activeEntries", "tooltipDisabled", "labelFormatting", "labelTemplate", "labelThreshold", "trimLabels", "maxLabelLength", "tooltipText"], outputs: ["dblclick", "select", "activate", "deactivate"] }, { type: i3$1.AmountComponent, selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }], directives: [{ type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DonutChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-donut-chart-ui',
                    templateUrl: './donut-chart.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CssVariablesService }]; }, propDecorators: { data: [{
                type: Input
            }], colors: [{
                type: Input
            }], relevancePercentage: [{
                type: Input
            }], tooltipTmpl: [{
                type: Input
            }], labelTmpl: [{
                type: Input
            }], defaultTooltipTemplate: [{
                type: ViewChild,
                args: ['defaultTooltipTemplate', { static: true }]
            }], classes: [{
                type: HostBinding,
                args: ['class']
            }] } });

class TooltipModule {
}
TooltipModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TooltipModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipModule, declarations: [TooltipContentComponent, TooltipDirective], imports: [CommonModule], exports: [TooltipContentComponent, TooltipDirective] });
TooltipModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipModule, providers: [InjectionService, TooltipService], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TooltipModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [TooltipContentComponent, TooltipDirective],
                    providers: [InjectionService, TooltipService],
                    exports: [TooltipContentComponent, TooltipDirective],
                    imports: [CommonModule],
                    entryComponents: [TooltipContentComponent],
                }]
        }] });

class PieChartModule {
}
PieChartModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieChartModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PieChartModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieChartModule, declarations: [PieChartComponent, PieSeriesComponent, PieLabelComponent], imports: [CommonModule, NgxChartsModule, TooltipModule], exports: [PieChartComponent, NgxChartsModule] });
PieChartModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieChartModule, providers: [CurrencyPipe], imports: [[CommonModule, NgxChartsModule, TooltipModule], NgxChartsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PieChartModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NgxChartsModule, TooltipModule],
                    declarations: [PieChartComponent, PieSeriesComponent, PieLabelComponent],
                    exports: [PieChartComponent, NgxChartsModule],
                    providers: [CurrencyPipe],
                    entryComponents: [PieChartComponent],
                }]
        }] });

class DonutChartModule {
}
DonutChartModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DonutChartModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
DonutChartModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DonutChartModule, declarations: [DonutChartComponent], imports: [CommonModule, AmountModule, PieChartModule], exports: [DonutChartComponent, PieChartModule, AmountModule] });
DonutChartModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DonutChartModule, providers: [CssVariablesService], imports: [[CommonModule, AmountModule, PieChartModule], PieChartModule, AmountModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DonutChartModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, AmountModule, PieChartModule],
                    declarations: [DonutChartComponent],
                    exports: [DonutChartComponent, PieChartModule, AmountModule],
                    providers: [CssVariablesService],
                }]
        }] });

var AnalysisTypes;
(function (AnalysisTypes) {
    AnalysisTypes["INCOME"] = "CRDT";
    AnalysisTypes["SPENDING"] = "DBIT";
})(AnalysisTypes || (AnalysisTypes = {}));
const PROPERTIES = {
    analysisType: {
        name: 'analysisIndicator',
        value: AnalysisTypes.SPENDING,
    },
};
var Interval;
(function (Interval) {
    Interval["DAY"] = "DAY";
    Interval["WEEK"] = "WEEK";
    Interval["MONTH"] = "MONTH";
    Interval["YEAR"] = "YEAR";
})(Interval || (Interval = {}));
const DEFAULT_INTERVAL = Interval.MONTH;
const RELEVANCE_PERCENTAGE = 2;
const CATEGORY_COLORS_CSS_VAR = '--chart-categories-colors';
const BAR_COLORS_CSS_VAR = '--chart-group-bar-color';
var TrendTextClasses;
(function (TrendTextClasses) {
    TrendTextClasses["POSITIVE"] = "text-danger";
    TrendTextClasses["NEGATIVE"] = "text-success";
})(TrendTextClasses || (TrendTextClasses = {}));
var TrendArrowClasses;
(function (TrendArrowClasses) {
    TrendArrowClasses["POSITIVE"] = "arrow-upward";
    TrendArrowClasses["NEGATIVE"] = "arrow-downward";
})(TrendArrowClasses || (TrendArrowClasses = {}));
const PERIODS = [
    {
        interval: 'MONTH',
        duration: 1,
        default: true,
    },
    {
        interval: 'MONTH',
        duration: 6,
    },
    {
        interval: 'MONTH',
        duration: 12,
    },
];
const DB_DATE_FORMAT = 'yyyy-MM-dd';

class MonthSelectorComponent {
    constructor() {
        this.hostRef = this;
        /**
         * Event emitter for selecting a tab.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.change = new EventEmitter();
        /**
         * Default selected tab
         */
        this.selectedTab = PERIODS[Math.max(PERIODS.map((item) => item.default).indexOf(true), 0)].duration;
    }
    /**
     * Change selected tab and triggers the change event after
     * creating start, end dates based on selected tab
     */
    onPeriodRangeChange(num) {
        this.selectedTab = num;
        // (monthsRange - 1) to get data starting from this month and 5 months before it,
        // which will end up to 6 months in total (the same of 12 months)
        const startDate = new Date();
        startDate.setMonth(startDate.getMonth() - (num - 1), 1);
        this.change.emit({
            tabIndex: num,
            period: {
                start: startDate,
                end: new Date(),
            },
        });
    }
}
MonthSelectorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthSelectorComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MonthSelectorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MonthSelectorComponent, selector: "bb-month-selector-ui", inputs: { selectedTab: "selectedTab" }, outputs: { change: "change" }, ngImport: i0, template: "<div class=\"bb-block bb-block--lg bb-income-spending-analysis-periods bb-button-bar\">\n  <div class=\"btn-group btn-group-toggle\">\n      <button\n        data-role=\"1-month-btn\"\n        class=\"btn btn-secondary\"\n        [ngClass]=\"{active: selectedTab === 1}\"\n        value=\"1\"\n        (click)=\"onPeriodRangeChange(1)\"\n      >\n        <span\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.one\"\n        >1</span>\n        <span\n          class=\"d-none d-md-inline\"\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.one.largescreen\"\n        >&nbsp;month</span>\n        <span\n          class=\"d-md-none\"\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.one.mobilescreen\"\n        >m</span>\n      </button>\n      <button\n        data-role=\"6-month-btn\"\n        class=\"btn btn-secondary\"\n        [ngClass]=\"{active: selectedTab === 6}\"\n        value=\"6\"\n        (click)=\"onPeriodRangeChange(6)\"\n      >\n        <span\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.six\"\n        >6</span>\n        <span\n          class=\"d-none d-md-inline\"\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.six.largescreen\"\n        >&nbsp;months</span>\n        <span\n          class=\"d-md-none\"\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.six.mobilescreen\"\n        >m</span>\n      </button>\n      <button\n        data-role=\"12-month-btn\"\n        class=\"btn btn-secondary\"\n        [ngClass]=\"{active: selectedTab === 12}\"\n        value=\"12\"\n        (click)=\"onPeriodRangeChange(12)\"\n      >\n        <span\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.twelve\"\n        >12</span>\n        <span\n          class=\"d-none d-md-inline\"\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.twelve.largescreen\"\n        >&nbsp;months</span>\n        <span\n          class=\"d-md-none\"\n          i18n=\"Data period|One month label@@incomeSpendingAnalysis.label.duration.month.twelve.mobilescreen\"\n        >m</span>\n      </button>\n    </div>\n</div>\n", directives: [{ type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MonthSelectorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-month-selector-ui',
                    templateUrl: './month-selector.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { change: [{
                type: Output
            }], selectedTab: [{
                type: Input
            }] } });

class IncomeSpendingAnalysisWidgetService {
    constructor(categoryTotalsHttpService, categoryPeriodTotalsHttpService) {
        this.categoryTotalsHttpService = categoryTotalsHttpService;
        this.categoryPeriodTotalsHttpService = categoryPeriodTotalsHttpService;
    }
    loadAnalysisData(params) {
        return this.categoryTotalsHttpService.getCategorytotals(params);
    }
    loadAnalysisPeriodData(params) {
        return this.categoryPeriodTotalsHttpService.getCategoryPeriodTotals(params);
    }
}
IncomeSpendingAnalysisWidgetService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetService, deps: [{ token: i1$2.CategoryTotalsHttpService }, { token: i1$2.CategoryPeriodTotalsHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
IncomeSpendingAnalysisWidgetService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.CategoryTotalsHttpService }, { type: i1$2.CategoryPeriodTotalsHttpService }]; } });

const filterInputParameters = (input, prop) => combineLatest([input, prop]).pipe(map(([inputVal, propVal]) => (inputVal !== undefined ? inputVal : propVal)));
class IncomeSpendingAnalysisWidgetComponent {
    constructor(service, cssVariableService, model, route, datePipe, cd, locale) {
        this.service = service;
        this.cssVariableService = cssVariableService;
        this.model = model;
        this.route = route;
        this.datePipe = datePipe;
        this.cd = cd;
        this.locale = locale;
        this.hostRef = this;
        this.isIE = /(edge|msie|trident)/i.test(navigator.userAgent);
        this.analysisTypeSubject = new BehaviorSubject(undefined);
        this.endDateValue = new Date();
        this.startDateValue = new Date(this.endDateValue.getFullYear(), this.endDateValue.getMonth(), 1);
        this.initialDateParams = {
            periodStartDate: this.datePipe.transform(this.startDateValue, DB_DATE_FORMAT) || '',
            periodEndDate: this.datePipe.transform(this.endDateValue, DB_DATE_FORMAT) || '',
            intervalDuration: DEFAULT_INTERVAL,
        };
        this.labelPositioned = false;
        this.iconHeight = 0;
        this.labelHeight = 0;
        this.iconWidth = 0;
        this.selectedTab = PERIODS[Math.max(PERIODS.map((item) => item.default).indexOf(true), 0)].duration;
        // BarChart Options
        this.chartOptions = from(this.cssVariableService.getCssVariable(BAR_COLORS_CSS_VAR)).pipe(map((cssVar) => {
            return {
                colors: cssVar ? [cssVar.slice(0, cssVar.indexOf(','))] : [''],
                showXAxis: true,
                showYAxis: true,
                gradient: false,
                showLegend: false,
                showXAxisLabel: true,
                showYAxisLabel: true,
                roundEdges: false,
            };
        }));
        this.isLoading = false;
        this.analysisType = filterInputParameters(this.analysisTypeSubject.asObservable(), this.getProperty(PROPERTIES.analysisType).pipe(map((val) => val)));
        this.arrangementIds = this.getRouteParam(this.route, 'selectedAccount').pipe(map((selectedAccount) => (selectedAccount ? [selectedAccount] : [])));
        this.dateParams = new BehaviorSubject(this.initialDateParams);
        this.dataParams = combineLatest(this.arrangementIds, this.dateParams.asObservable(), this.analysisType).pipe(map(([arrangementIds, dateParams, creditDebitIndicator]) => {
            this.error = undefined;
            return Object.assign(Object.assign({ arrangementIds: arrangementIds || [] }, dateParams), { creditDebitIndicator });
        }), shareReplay(1));
        this.analysisData = this.dataParams.pipe(filter((data) => !!data.arrangementIds.length), switchMap((params) => this.service.loadAnalysisData(params)), map((data) => {
            if (!data || !data.items) {
                return data;
            }
            this.labelPositioned = false;
            let totalPortion = 0;
            return Object.assign(Object.assign({}, data), { series: data.items
                    .sort((a, b) => (parseFloat(b.totalAmount.amount) > parseFloat(a.totalAmount.amount) ? 1 : -1))
                    .map((item) => (Object.assign(Object.assign({}, item), { name: item.category, value: parseFloat(item.totalAmount.amount), cssClass: this.transformCategoryToIconName(item.category), totalPortion: (totalPortion += item.portion) }))) });
        }), catchError((err) => this.handleError(err)), share());
        this.analysisPeriodData = zip(this.analysisData, this.dataParams).pipe(mergeMap(([data, params]) => {
            const categories = (data.items || []).map((item) => item.category);
            const newParams = Object.assign(Object.assign({}, params), { categories: categories.length ? categories : [''] });
            return this.service.loadAnalysisPeriodData(newParams).pipe(map(this.formatPeriodData), map((series) => ({ series, categoryData: data, items: [] })));
        }), tap(() => {
            this.isLoading = false;
            this.cd.markForCheck();
        }), catchError((err) => this.handleError(err)));
        this.colors = combineLatest([
            this.analysisData,
            from(this.cssVariableService.getCssVariable(CATEGORY_COLORS_CSS_VAR)),
        ]).pipe(map(([data, cssVar]) => {
            if (!cssVar || !data || !data.series || !data.series.length) {
                return [];
            }
            const identities = cssVar.split(',').reduce((accumulator, definition) => {
                const [category, color, icon] = definition.trim().split(' ');
                return Object.assign(Object.assign({}, accumulator), { [category]: {
                        color,
                        icon,
                    } });
            }, {});
            return data.series.map((item) => {
                var _a, _b;
                return ({
                    name: item.name || '',
                    value: ((_a = identities[item.cssClass]) === null || _a === void 0 ? void 0 : _a.color) || '',
                    icon: ((_b = identities[item.cssClass]) === null || _b === void 0 ? void 0 : _b.icon) || '',
                });
            });
        }));
        this.formatPeriodData = this.formatPeriodData.bind(this);
    }
    set analysisTypeValue(value) {
        this.analysisTypeSubject.next(value);
    }
    getRouteParam(route, param) {
        const paramValue = route.paramMap.pipe(pluck('params', param));
        if (!route.parent) {
            return paramValue;
        }
        // ensure that level that has actual value keeps it from being cleared
        return combineLatest(paramValue, this.getRouteParam(route.parent, param)).pipe(map((params) => params[0] || params[1]));
    }
    getProperty(property) {
        return this.model ? this.model.property(property.name, property.value) : of(property.value);
    }
    get startDate() {
        return this.startDateValue;
    }
    get endDate() {
        return this.endDateValue;
    }
    get formatters() {
        return {
            end: (date) => {
                const now = new Date();
                if (now.getFullYear() === date.getFullYear() &&
                    now.getMonth() === date.getMonth() &&
                    now.getDate() === date.getDate()) {
                    return this.translationNow.nativeElement.textContent;
                }
                return this.datePipe.transform(date, 'mediumDate') || '';
            },
        };
    }
    get isSpending() {
        return this.analysisType.pipe(map((property) => property === AnalysisTypes.SPENDING));
    }
    get relevance() {
        return RELEVANCE_PERCENTAGE;
    }
    selectTab(num) {
        this.selectedTab = PERIODS[Math.max(PERIODS.map((item) => item.duration).indexOf(num), 0)].duration;
    }
    handleError(error) {
        this.error = error.statusText;
        return of({ items: [] });
    }
    formatPeriodData(res) {
        if (!res || !res.periods || !res.total) {
            return [];
        }
        return parseFloat(res.total.amount) !== 0
            ? res.periods.map((period) => {
                var _a;
                return ({
                    name: this.datePipe.transform(period.intervalStartDate, 'MMM') || '',
                    value: period.total ? parseFloat(period.total.amount) : 0,
                    currencyCode: (_a = period.total) === null || _a === void 0 ? void 0 : _a.currencyCode,
                });
            })
            : [];
    }
    transformCategoryToIconName(transactionCategory) {
        return `${transactionCategory.toLowerCase().replace(/\W/g, '-').replace(/-{2,}/g, '-')}`;
    }
    textX(data) {
        return data ? data.pos[0] : 0;
    }
    textY(data) {
        return data ? data.pos[1] : 0;
    }
    getCategoryClass(cssClass) {
        return `bb-transaction-category-${cssClass}`;
    }
    getTextTransition() {
        return this.isIE ? '' : 'transform 0.75s';
    }
    getTransformOffsetY(data) {
        const percetage = data.data.totalPortion - data.data.portion / 2;
        return percetage > 25 && percetage < 75 ? this.iconHeight + this.labelHeight : -this.labelHeight;
    }
    getStyleTransform(data, offsetX, offsetY) {
        return this.isIE ? '' : `translate3d(${this.textX(data) + offsetX}px, ${this.textY(data) + offsetY}px, 0)`;
    }
    getAttrTransform(data, offsetX, offsetY) {
        return !this.isIE ? '' : `translate(${this.textX(data) + offsetX}, ${this.textY(data) + offsetY})`;
    }
    textClass(value, isSpending = true) {
        // positive trend has different meaning for income and for spending
        const multiplier = isSpending ? 1 : -1;
        return value * multiplier > 0 ? TrendTextClasses.POSITIVE : TrendTextClasses.NEGATIVE;
    }
    iconClass(value) {
        if (value < -1) {
            return TrendArrowClasses.NEGATIVE;
        }
        else if (value > 1) {
            return TrendArrowClasses.POSITIVE;
        }
        return '';
    }
    abs(value) {
        return Math.abs(value);
    }
    onPeriodRangeChange(monthSelectorData) {
        this.selectTab(monthSelectorData.tabIndex);
        this.onPeriodChange(monthSelectorData.period);
    }
    onPeriodChange(period) {
        this.isLoading = true;
        this.startDateValue = period.start;
        this.endDateValue = period.end;
        this.dateParams.next(Object.assign(Object.assign({}, this.initialDateParams), { periodStartDate: this.datePipe.transform(period.start, DB_DATE_FORMAT) || '', periodEndDate: this.datePipe.transform(period.end, DB_DATE_FORMAT) || '' }));
    }
    customYAxisTickFormatting(totalPeriodSeries) {
        var _a, _b;
        const currencyCode = (_b = (_a = totalPeriodSeries.categoryData) === null || _a === void 0 ? void 0 : _a.total) === null || _b === void 0 ? void 0 : _b.currencyCode;
        const currencySymbol = currencyCode ? getCurrencySymbol(currencyCode, 'wide', this.locale) : currencyCode;
        return (amount) => `${currencySymbol} ${amount}`;
    }
    ngAfterViewChecked() {
        if (this.labelPositioned || !this.chartIcon || !this.chartLabel) {
            return;
        }
        this.labelHeight = this.chartLabel.nativeElement.getBoundingClientRect().height / 2;
        this.iconHeight = this.chartIcon.nativeElement.getBoundingClientRect().height;
        this.iconWidth = (this.chartIcon.nativeElement.getBoundingClientRect().width - 2) / 2;
        this.labelPositioned = true;
        this.cd.detectChanges();
    }
}
IncomeSpendingAnalysisWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetComponent, deps: [{ token: IncomeSpendingAnalysisWidgetService }, { token: i1$1.CssVariablesService }, { token: i3$2.ItemModel, optional: true }, { token: i4.ActivatedRoute }, { token: i1.DatePipe }, { token: i0.ChangeDetectorRef }, { token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
IncomeSpendingAnalysisWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisWidgetComponent, selector: "bb-income-spending-analysis-widget", inputs: { analysisTypeValue: ["analysisType", "analysisTypeValue"] }, providers: [DatePipe], viewQueries: [{ propertyName: "chartIcon", first: true, predicate: ["bbChartLabelIcon"], descendants: true }, { propertyName: "chartLabel", first: true, predicate: ["bbChartLabelText"], descendants: true }, { propertyName: "translationNow", first: true, predicate: ["transNow"], descendants: true, static: true }], ngImport: i0, template: "<ng-container\n  bbIncomeSpendingAnalysisCustomizable\n  [bbHostRef]=\"hostRef\"\n  [bbTemplateContext]=\"{ isLoading: hostRef.isLoading, analysisData: hostRef.analysisData, analysisPeriodData: hostRef.analysisPeriodData, colors: hostRef.colors | async, isSpending: hostRef.isSpending | async, chartOptions: hostRef.chartOptions | async }\"\n></ng-container>\n\n<ng-template\n  bbIncomeSpendingAnalysisCustomizable\n  let-hostRef\n  let-analysisData=\"context.analysisData\"\n  let-analysisPeriodData=\"context.analysisPeriodData\"\n  let-colors=\"context.colors\"\n  let-isSpending=\"context.isSpending\"\n  let-chartOptions=\"context.chartOptions\"\n>\n  <ng-container *ngIf=\"!hostRef.error; else errorState\">\n    <div class=\"card\">\n      <div class=\"card-body\">\n        <ng-container\n          bbIncomeSpendingAnalysisMonthSelectorCustomizable\n          [bbHostRef]=\"hostRef\"\n        ></ng-container>\n\n        <ng-container\n          *ngIf=\"hostRef.selectedTab === 1\"\n          bbIncomeSpendingAnalysisPeriodSelectorCustomizable\n          [bbHostRef]=\"hostRef\"\n        ></ng-container>\n        <ng-container *ngIf=\"(arrangementIds | async)?.length; else emptyState\">\n          <ng-container *ngIf=\"hostRef.selectedTab === 1\">\n            <ng-container *ngIf=\"analysisData | async as data ; else loadingState\">\n              <ng-container *ngIf=\"data?.items?.length; else emptyState\">\n                <ng-container\n                  bbIncomeSpendingAnalysisChartWrapperCustomizable\n                  [bbHostRef]=\"hostRef\"\n                  [bbTemplateContext]=\"{ data: data, colors: colors, isSpending: isSpending }\"\n                ></ng-container>\n              </ng-container>\n            </ng-container>\n          </ng-container>\n          <ng-container *ngIf=\"hostRef.selectedTab !== 1\">\n            <ng-container *ngIf=\"analysisPeriodData | async as data; else loadingState\">\n              <ng-container *ngIf=\"!hostRef.isLoading else loadingState\">\n                <ng-container *ngIf=\"data.series && data.series.length; else emptyState\">\n                  <ng-container\n                    bbIncomeSpendingAnalysisBarChartWrapperCustomizable\n                    [bbHostRef]=\"hostRef\"\n                    [bbTemplateContext]=\"{ data: data, chartOptions: chartOptions }\"\n                  ></ng-container>\n                </ng-container>\n\n                <ng-container *ngIf=\"data.categoryData?.items?.length else emptyState\">\n                  <ng-container\n                    bbIncomeSpendingAnalysisCategoriesListCustomizable\n                    [bbHostRef]=\"hostRef\"\n                    [bbTemplateContext]=\"{ data: data.categoryData, isSpending: isSpending }\"\n                  ></ng-container>\n                </ng-container>\n              </ng-container>\n            </ng-container>\n          </ng-container>\n        </ng-container>\n\n      </div>\n    </div>\n  </ng-container>\n\n  <ng-template bbIncomeSpendingAnalysisMonthSelectorCustomizable let-hostRef>\n    <bb-month-selector-ui\n      [selectedTab]=\"hostRef.selectedTab\"\n      (change)=\"hostRef.onPeriodRangeChange($event)\"\n    ></bb-month-selector-ui>\n  </ng-template>\n\n  <ng-template bbIncomeSpendingAnalysisPeriodSelectorCustomizable let-hostRef>\n    <div class=\"bb-stack bb-stack--center bb-block bb-block--lg\">\n      <bb-period-selector-ui\n        [periodStart]=\"hostRef.startDate\"\n        [periodEnd]=\"hostRef.endDate\"\n        [periodFormatters]=\"hostRef.formatters\"\n        (periodChange)=\"hostRef.onPeriodChange($event)\"\n      ></bb-period-selector-ui>\n    </div>\n  </ng-template>\n \n  <ng-template\n    bbIncomeSpendingAnalysisChartWrapperCustomizable\n    let-hostRef\n    let-data=\"context.data\"\n    let-colors=\"context.colors\"\n    let-isSpending=\"context.isSpending\"\n  >\n    <div class=\"bb-stack bb-stack--center position-relative chart-donut chart-donut-large chart-donut-container-inflated\">\n      <div class=\"absolute-center\">\n        <div class=\"text-center text-muted font-weight-bold chart-donut-center-word\" data-role=\"donut-chart-label\">\n          <span\n            *ngIf=\"isSpending\"\n            i18n=\"Total spending|Label for total spending amount@@incomeSpendingAnalysis.label.total.spending\"\n          >\n            Total spending\n          </span>\n          <span\n            *ngIf=\"!isSpending\"\n            i18n=\"Total income|Label for total income amount@@incomeSpendingAnalysis.label.total.income\"\n          >\n            Total income\n          </span>\n        </div>\n        <div class=\"h6 text-center\">\n          <bb-amount-ui\n            [amount]=\"data.total.amount\"\n            [currency]=\"data.total.currencyCode\"\n          ></bb-amount-ui>\n        </div>\n      </div>\n      <ng-container\n        bbIncomeSpendingAnalysisChartCustomizable\n        [bbHostRef]=\"hostRef\"\n        [bbTemplateContext]=\"{ data: data, colors: colors, isSpending: isSpending }\"\n      ></ng-container>\n    </div>\n  </ng-template>\n\n  <ng-template\n    bbIncomeSpendingAnalysisChartCustomizable\n    let-hostRef\n    let-data=\"context.data\"\n    let-colors=\"context.colors\"\n  >\n    <bb-donut-chart-ui\n      [data]=\"data.series\"\n      [colors]=\"colors\"\n      [relevancePercentage]=\"hostRef.relevance\"\n      [tooltipTmpl]=\"donutChartTooltip\"\n      [labelTmpl]=\"donutChartLabel\"\n    ></bb-donut-chart-ui>\n  </ng-template>\n\n  <ng-template #errorState>\n    <bb-empty-state-ui\n      title=\"\"\n      [subtitle]=\"error\"\n      iconModifier=\"error\"\n      iconSize=\"xxl\"\n      iconColor=\"gray\"\n      iconClasses=\"text-muted\"\n    ></bb-empty-state-ui>\n  </ng-template>\n\n  <ng-template #loadingState>\n    <bb-loading-indicator-ui\n      i18n-text=\"Loading analysis data|Text to display while loading income/spending analysis data@@incomeSpendingAnalysis.state.loadingData\"\n      text=\"Loading analysis data...\">\n    </bb-loading-indicator-ui>\n  </ng-template>\n\n  <ng-template #emptyState>\n    <div class=\"bb-stack bb-stack--center\">\n      <bb-empty-state-ui\n      i18n-title=\"No data title|Title of a message that is shown when there is no data to display@@incomeSpendingAnalysis.state.noResults.title\"\n      title=\"No Data Found\"\n      i18n-subtitle=\"No data subtitle|Subtitle of a message that is shown when there is no data to display@@incomeSpendingAnalysis.state.noResults.subtitle\"\n      subtitle=\"You don't have any data to be displayed. Please try selecting a different period.\"\n      iconSize=\"xxl\"\n      iconModifier=\"donut-small\"\n      class=\"bb-text-align-center\"\n    ></bb-empty-state-ui>\n    </div>\n  </ng-template>\n\n  <ng-template bbIncomeSpendingAnalysisCategoriesListCustomizable let-hostRef let-data=\"context.data\" let-isSpending=\"context.isSpending\">\n    <div class=\"list-group-item rounded-0 border-left-0 border-right-0 border-top-0 list-item-transaction-accordion pt-3\" data-role=\"category-list-header\">\n      <div class=\"transaction-item row align-items-center\" role=\"row\">\n        <div class=\"col-6\">\n          <span *ngIf=\"isSpending\" class=\"h5\" i18n=\"Spending per category|Categories list spending label@@categories.list.spending.label\">\n            Spending per category\n          </span>\n          <span *ngIf=\"!isSpending\" class=\"h5\" i18n=\"Income per category|Categories list income label@@categories.list.income.label\">\n            Income per category\n          </span>\n        </div>\n        <div class=\"col-6\">\n          <div class=\"transaction-amount text-right h5 m-0\">\n            <span i18n=\"Total amount|Total amount label@@categories.list.total.label\">\n              Total amount\n            </span>\n            <bb-amount-ui [amount]=\"data.total.amount\" [currency]=\"data.total.currencyCode\"></bb-amount-ui>\n          </div>\n        </div>\n      </div>\n    </div>\n    <div class=\"list-group-item rounded-0 border-left-0 border-right-0 list-item-transaction-accordion py-3\" *ngFor=\"let item of data?.items\" data-role=\"category-list-item\">\n      <div class=\"transaction-item row d-flex align-items-center\" role=\"row\">\n        <div class=\"transaction-category-icon col-6 d-flex align-items-center\">\n          <bb-icon-ui \n            size=\"sm\" \n            backgroundType=\"circle\" \n            name=\"category-{{ hostRef.transformCategoryToIconName(item.category) }}\"\n          ></bb-icon-ui>\n          <strong>\n            <span class=\"bb-transaction-category-name px-3\">{{item.category}}</span>\n          </strong>\n        </div>\n        <div class=\"col-6\">\n          <div class=\"transaction-amount text-right\">\n            <bb-amount-ui [amount]=\"item.totalAmount.amount\" [currency]=\"item.totalAmount.currencyCode\"></bb-amount-ui>\n          </div>\n        </div>\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template bbIncomeSpendingAnalysisBarChartWrapperCustomizable let-chartOptions=\"context.chartOptions\" let-data=\"context.data\">\n    <div class=\"d-block chart-bar\">\n      <ngx-charts-bar-vertical\n        [scheme]=\"{domain: chartOptions.colors}\"\n        [results]=\"data.series\"\n        [gradient]=\"chartOptions.gradient\"\n        [xAxis]=\"chartOptions.showXAxis\"\n        [yAxis]=\"chartOptions.showYAxis\"\n        [legend]=\"chartOptions.showLegend\"\n        [showXAxisLabel]=\"chartOptions.showXAxisLabel\"\n        [showYAxisLabel]=\"chartOptions.showYAxisLabel\"\n        [yAxisTickFormatting]=\"customYAxisTickFormatting(data)\"\n        [showGridLines]=\"true\"\n        [roundEdges]=\"chartOptions.roundEdges\"\n      >\n        <ng-template #tooltipTemplate let-model=\"model\">\n          <div class=\"my-2\">\n            <span class=\"mr-2\">{{model.name}}</span>\n            <bb-amount-ui class=\"ml-2\" [amount]=\"model.value\" [currency]=\"data.categoryData.total.currencyCode\"></bb-amount-ui>\n          </div>\n        </ng-template>\n      </ngx-charts-bar-vertical>\n    </div>\n  </ng-template>\n\n  <ng-template\n    #donutChartLabel\n    let-data=\"data\"\n    let-color=\"color\"\n    let-label=\"label\"\n    let-icon=\"icon\"\n  >\n    <svg:g\n      [attr.transform]=\"hostRef.getAttrTransform(data, -hostRef.iconWidth, hostRef.getTransformOffsetY(data))\"\n      [style.transform]=\"hostRef.getStyleTransform(data, -hostRef.iconWidth, hostRef.getTransformOffsetY(data))\"\n      [style.fill]=\"color\"\n    >\n      <svg:text\n        #bbChartLabelIcon\n        class=\"bb-transaction-category bb-transaction-category-icon\"\n        [ngClass]=\"hostRef.getCategoryClass(data?.data?.cssClass)\"\n        data-role=\"donut-chart-segment-icon\"\n        aria-hidden=\"true\"\n      >\n        {{ icon }}\n      </svg:text>\n    </svg:g>\n    <svg:g\n      [attr.transform]=\"hostRef.getAttrTransform(data, 0, 0)\"\n      [style.transform]=\"hostRef.getStyleTransform(data, 0, 0)\"\n      [style.transition]=\"hostRef.getTextTransition()\"\n    >\n      <svg:text\n        #bbChartLabelText\n        class=\"font-weight-bold\"\n        [class.animation]=\"true\"\n        dy=\".35em\"\n        [style.fill]=\"color\"\n        [style.textAnchor]=\"'middle'\"\n        [style.shapeRendering]=\"'crispEdges'\"\n        data-role=\"donut-chart-segment-label\"\n        aria-hidden=\"true\"\n      >\n        {{ label }}\n      </svg:text>\n    </svg:g>\n    <span class=\"sr-only\" i18n=\"Chart section, interpolation category, interpolation amount|Label for chart displaying category, amount, and introduction@@incomeSpendingAnalysis.donutChart.label\">\n      Chart section, {{data?.data?.cssClass}}, {{label}}\n    </span>\n  </ng-template>\n\n  <ng-template\n    #donutChartTooltip\n    let-name=\"name\"\n    let-cssClass=\"cssClass\"\n    let-totalAmount=\"totalAmount\"\n    let-portion=\"portion\"\n    let-trend=\"trend\"\n    let-arrowClass=\"arrowClass\"\n  >\n    <div\n      bbDynamicId\n      #tooltipElement\n      class=\"row pb-3 position-relative chart-tooltip chart-tooltip-default text-left\"\n      [ngClass]=\"arrowClass\"\n      aria-live=\"polite\"\n    >\n      <span class=\"d-flex chart-tooltip-analysis-category text-muted\">\n        <span\n          *ngIf=\"hostRef.relevance >= portion\"\n          class=\"d-inline-block mr-1\"\n        >\n          <bb-icon-ui \n            size=\"md\"\n            backgroundType=\"circle\"\n            name=\"category-{{ hostRef.transformCategoryToIconName(cssClass) }}\"\n          ></bb-icon-ui>\n        </span>\n        {{ name }}\n      </span>\n      <div>\n        <div class=\"row\">\n          <strong>\n            <bb-amount-ui \n              class=\"h5 my-1 col-12 chart-tooltip-analysis-amount\" \n              [amount]=\"totalAmount.amount\"\n              [currency]=\"totalAmount.currencyCode\"\n            ></bb-amount-ui>\n          </strong>\n        </div>\n        <p \n          *ngIf=\"totalAmount.amount !== undefined\" \n          class=\"chart-tooltip-analysis-portion text-muted\"\n          i18n=\"Slice portion|Active slice portion of total amount@@donut-chart.tooltip.portion\"\n        >\n          {{ portion }}% of total\n        </p>\n        <ng-container *ngIf=\"trend !== undefined\">\n          <hr class=\"chart-tooltip-divider p-0\">\n          <p \n            class=\"chart-tooltip-analysis-trend\" \n            [ngClass]=\"hostRef.textClass(trend, isSpending)\"\n          >\n            <span class=\"d-flex align-items-center d-block mt-1\">\n              <bb-icon-ui \n                class=\"mr-1\" \n                [name]=\"hostRef.iconClass(trend)\"\n              ></bb-icon-ui>\n              <span class=\"h5 m-0 d-block\">\n                <ng-container *ngIf=\"hostRef.abs(trend) >= 1\">\n                  {{ hostRef.abs(trend) }}%\n                </ng-container>\n              </span>\n            </span>\n            <span class=\"chart-tooltip-info-text text-muted w-100\">\n              <ng-container \n                *ngIf=\"trend <= -1\"\n                i18n=\"Less than previous month|Text to describe that trend is negative@@donut-chart.tooltip.trend.less\"\n              >\n                less than previous month\n              </ng-container>\n              <ng-container \n                *ngIf=\"trend >= 1\"\n                i18n=\"More than previous month|Text to describe that trend is positive@@donut-chart.tooltip.trend.more\"\n              >\n                more than previous month\n              </ng-container>\n              <ng-container \n                *ngIf=\"trend > -1 && trend < 1\"\n                i18n=\"Same as previous month|Text to describe that trend is around zero@@donut-chart.tooltip.trend.same\"\n              >\n                Same as previous month\n              </ng-container>\n            </span>\n          </p>\n        </ng-container>\n      </div>\n    </div>\n  </ng-template>\n</ng-template>\n\n<span #transNow class=\"ng-cloak\" i18n=\"Now|Label for current day in period selector@@incomeSpendingAnalysis.period.now\">Now</span>\n", components: [{ type: i0.forwardRef(function () { return MonthSelectorComponent; }), selector: "bb-month-selector-ui", inputs: ["selectedTab"], outputs: ["change"] }, { type: i0.forwardRef(function () { return i7.PeriodSelectorComponent; }), selector: "bb-period-selector-ui", inputs: ["periodStart", "periodEnd", "periodFormatters", "period"], outputs: ["periodChange"] }, { type: i0.forwardRef(function () { return i3$1.AmountComponent; }), selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }, { type: i0.forwardRef(function () { return DonutChartComponent; }), selector: "bb-donut-chart-ui", inputs: ["data", "colors", "relevancePercentage", "tooltipTmpl", "labelTmpl"] }, { type: i0.forwardRef(function () { return i10.EmptyStateComponent; }), selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }, { type: i0.forwardRef(function () { return i11.LoadingIndicatorComponent; }), selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i0.forwardRef(function () { return i12.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return i3.BarVerticalComponent; }), selector: "ngx-charts-bar-vertical", inputs: ["legend", "legendTitle", "legendPosition", "tooltipDisabled", "showGridLines", "activeEntries", "trimXAxisTicks", "trimYAxisTicks", "rotateXAxisTicks", "maxXAxisTickLength", "maxYAxisTickLength", "barPadding", "roundDomains", "roundEdges", "showDataLabel", "noBarWhenZero", "xAxis", "yAxis", "showXAxisLabel", "showYAxisLabel", "xAxisLabel", "yAxisLabel", "gradient", "schemeType", "xAxisTickFormatting", "yAxisTickFormatting", "xAxisTicks", "yAxisTicks", "yScaleMax", "yScaleMin", "dataLabelFormatting"], outputs: ["activate", "deactivate"] }], directives: [{ type: i0.forwardRef(function () { return IncomeSpendingAnalysisCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisCustomizable]" }, { type: i0.forwardRef(function () { return i1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return IncomeSpendingAnalysisMonthSelectorCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisMonthSelectorCustomizable]" }, { type: i0.forwardRef(function () { return IncomeSpendingAnalysisPeriodSelectorCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisPeriodSelectorCustomizable]" }, { type: i0.forwardRef(function () { return IncomeSpendingAnalysisChartWrapperCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisChartWrapperCustomizable]" }, { type: i0.forwardRef(function () { return IncomeSpendingAnalysisBarChartWrapperCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisBarChartWrapperCustomizable]" }, { type: i0.forwardRef(function () { return IncomeSpendingAnalysisCategoriesListCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisCategoriesListCustomizable]" }, { type: i0.forwardRef(function () { return IncomeSpendingAnalysisChartCustomizableDirective; }), selector: "[bbIncomeSpendingAnalysisChartCustomizable]" }, { type: i0.forwardRef(function () { return i1.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i0.forwardRef(function () { return i1.NgClass; }), selector: "[ngClass]", inputs: ["class", "ngClass"] }], pipes: { "async": i0.forwardRef(function () { return i1.AsyncPipe; }) }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-income-spending-analysis-widget',
                    templateUrl: './income-spending-analysis.component.html',
                    providers: [DatePipe],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: IncomeSpendingAnalysisWidgetService }, { type: i1$1.CssVariablesService }, { type: i3$2.ItemModel, decorators: [{
                    type: Optional
                }] }, { type: i4.ActivatedRoute }, { type: i1.DatePipe }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; }, propDecorators: { analysisTypeValue: [{
                type: Input,
                args: ['analysisType']
            }], chartIcon: [{
                type: ViewChild,
                args: ['bbChartLabelIcon']
            }], chartLabel: [{
                type: ViewChild,
                args: ['bbChartLabelText']
            }], translationNow: [{
                type: ViewChild,
                args: ['transNow', { static: true }]
            }] } });
class IncomeSpendingAnalysisCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisCustomizableDirective, selector: "[bbIncomeSpendingAnalysisCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisCustomizable]',
                }]
        }] });
class IncomeSpendingAnalysisPeriodSelectorCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisPeriodSelectorCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisPeriodSelectorCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisPeriodSelectorCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisPeriodSelectorCustomizableDirective, selector: "[bbIncomeSpendingAnalysisPeriodSelectorCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisPeriodSelectorCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisPeriodSelectorCustomizable]',
                }]
        }] });
class IncomeSpendingAnalysisChartWrapperCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisChartWrapperCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisChartWrapperCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisChartWrapperCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisChartWrapperCustomizableDirective, selector: "[bbIncomeSpendingAnalysisChartWrapperCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisChartWrapperCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisChartWrapperCustomizable]',
                }]
        }] });
class IncomeSpendingAnalysisCategoriesListCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisCategoriesListCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisCategoriesListCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisCategoriesListCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisCategoriesListCustomizableDirective, selector: "[bbIncomeSpendingAnalysisCategoriesListCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisCategoriesListCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisCategoriesListCustomizable]',
                }]
        }] });
class IncomeSpendingAnalysisChartCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisChartCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisChartCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisChartCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisChartCustomizableDirective, selector: "[bbIncomeSpendingAnalysisChartCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisChartCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisChartCustomizable]',
                }]
        }] });
class IncomeSpendingAnalysisBarChartWrapperCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisBarChartWrapperCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisBarChartWrapperCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisBarChartWrapperCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisBarChartWrapperCustomizableDirective, selector: "[bbIncomeSpendingAnalysisBarChartWrapperCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisBarChartWrapperCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisBarChartWrapperCustomizable]',
                }]
        }] });
class IncomeSpendingAnalysisMonthSelectorCustomizableDirective extends BbTemplate {
}
IncomeSpendingAnalysisMonthSelectorCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisMonthSelectorCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
IncomeSpendingAnalysisMonthSelectorCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: IncomeSpendingAnalysisMonthSelectorCustomizableDirective, selector: "[bbIncomeSpendingAnalysisMonthSelectorCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisMonthSelectorCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbIncomeSpendingAnalysisMonthSelectorCustomizable]',
                }]
        }] });

const components = [IncomeSpendingAnalysisWidgetComponent, MonthSelectorComponent];
const customizables = [
    IncomeSpendingAnalysisCustomizableDirective,
    IncomeSpendingAnalysisPeriodSelectorCustomizableDirective,
    IncomeSpendingAnalysisMonthSelectorCustomizableDirective,
    IncomeSpendingAnalysisChartWrapperCustomizableDirective,
    IncomeSpendingAnalysisCategoriesListCustomizableDirective,
    IncomeSpendingAnalysisChartCustomizableDirective,
    IncomeSpendingAnalysisBarChartWrapperCustomizableDirective,
];
const modules = [
    AmountModule,
    DonutChartModule,
    EmptyStateModule,
    IconModule,
    LoadingIndicatorModule,
    PeriodSelectorModule,
];
class IncomeSpendingAnalysisWidgetModule {
}
IncomeSpendingAnalysisWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IncomeSpendingAnalysisWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetModule, declarations: [IncomeSpendingAnalysisWidgetComponent, MonthSelectorComponent, IncomeSpendingAnalysisCustomizableDirective,
        IncomeSpendingAnalysisPeriodSelectorCustomizableDirective,
        IncomeSpendingAnalysisMonthSelectorCustomizableDirective,
        IncomeSpendingAnalysisChartWrapperCustomizableDirective,
        IncomeSpendingAnalysisCategoriesListCustomizableDirective,
        IncomeSpendingAnalysisChartCustomizableDirective,
        IncomeSpendingAnalysisBarChartWrapperCustomizableDirective], imports: [CommonModule, i3$2.BackbaseCoreModule, AmountModule,
        DonutChartModule,
        EmptyStateModule,
        IconModule,
        LoadingIndicatorModule,
        PeriodSelectorModule], exports: [IncomeSpendingAnalysisWidgetComponent, MonthSelectorComponent, IncomeSpendingAnalysisCustomizableDirective,
        IncomeSpendingAnalysisPeriodSelectorCustomizableDirective,
        IncomeSpendingAnalysisMonthSelectorCustomizableDirective,
        IncomeSpendingAnalysisChartWrapperCustomizableDirective,
        IncomeSpendingAnalysisCategoriesListCustomizableDirective,
        IncomeSpendingAnalysisChartCustomizableDirective,
        IncomeSpendingAnalysisBarChartWrapperCustomizableDirective, AmountModule,
        DonutChartModule,
        EmptyStateModule,
        IconModule,
        LoadingIndicatorModule,
        PeriodSelectorModule] });
IncomeSpendingAnalysisWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetModule, providers: [IncomeSpendingAnalysisWidgetService], imports: [[
            CommonModule,
            BackbaseCoreModule.withConfig({
                classMap: { IncomeSpendingAnalysisWidgetComponent },
            }),
            ...modules,
        ], AmountModule,
        DonutChartModule,
        EmptyStateModule,
        IconModule,
        LoadingIndicatorModule,
        PeriodSelectorModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: IncomeSpendingAnalysisWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        BackbaseCoreModule.withConfig({
                            classMap: { IncomeSpendingAnalysisWidgetComponent },
                        }),
                        ...modules,
                    ],
                    declarations: [...components, ...customizables],
                    providers: [IncomeSpendingAnalysisWidgetService],
                    exports: [...components, ...customizables, ...modules],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { DonutChartComponent, DonutChartModule, IncomeSpendingAnalysisBarChartWrapperCustomizableDirective, IncomeSpendingAnalysisCategoriesListCustomizableDirective, IncomeSpendingAnalysisChartCustomizableDirective, IncomeSpendingAnalysisChartWrapperCustomizableDirective, IncomeSpendingAnalysisCustomizableDirective, IncomeSpendingAnalysisMonthSelectorCustomizableDirective, IncomeSpendingAnalysisPeriodSelectorCustomizableDirective, IncomeSpendingAnalysisWidgetComponent, IncomeSpendingAnalysisWidgetModule, IncomeSpendingAnalysisWidgetService, MonthSelectorComponent, PieChartComponent, PieChartModule };
//# sourceMappingURL=backbase-income-spending-analysis-widget-ang.js.map
