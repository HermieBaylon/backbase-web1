/**
 * Configuration of a Widget Input or Output Pipeline
 */
class CommunicationDefinition {
    /**
     * @param transport The transport identifier string
     * @param param A transport-specific param
     */
    constructor(
    /**
     * The transport identifier string
     */
    transport, 
    /**
     * A transport-specific param
     */
    param) {
        this.transport = transport;
        this.param = param;
    }
    /**
     * Determine if a `CommunicationDefinition` is equal to this one.
     *
     * @param other The other `CommunicationDefinition` to compare to
     */
    equals(other) {
        return this.transport === other.transport && this.param === other.param;
    }
}
function human() {
    return {
        fromProperty(value) {
            const splitAt = value.indexOf(' ');
            if (splitAt === -1) {
                return undefined;
            }
            const transport = value.substr(0, splitAt);
            const param = value.substr(splitAt + 1);
            if (param.includes(' ')) {
                return undefined;
            }
            return new CommunicationDefinition(transport, param);
        },
        toProperty(definition) {
            if (definition.param.includes(' ')) {
                throw new Error('Human SerializerDeserializer cannot serialize CommunicationDefinition containing a space in the param');
            }
            return `${definition.transport} ${definition.param}`;
        },
    };
}
function mangled() {
    return {
        fromProperty(value) {
            if (!value.startsWith(':0:')) {
                return undefined;
            }
            let blob;
            try {
                blob = atob(value.slice(':0:'.length));
            }
            catch (e) {
                // Not valid base64
                return undefined;
            }
            const splitAt = blob.indexOf(' ');
            const transport = blob.substr(0, splitAt);
            const param = blob.substr(splitAt + 1);
            return new CommunicationDefinition(transport, param);
        },
        toProperty(definition) {
            const mangledValue = btoa(`${definition.transport} ${definition.param}`);
            return `:0:${mangledValue}`;
        },
    };
}
function isValidStructure(blob) {
    if (typeof blob !== 'object' || blob === null || !('transport' in blob) || !('param' in blob)) {
        return false;
    }
    const structure = blob;
    return typeof structure.transport === 'string' && typeof structure.param === 'string';
}
function mangledJson() {
    return {
        fromProperty(value) {
            if (!value.startsWith(':1:')) {
                return undefined;
            }
            let blob;
            try {
                blob = JSON.parse(value.slice(':1:'.length));
            }
            catch (e) {
                // Not valid JSON
                return undefined;
            }
            if (!isValidStructure(blob)) {
                return undefined;
            }
            return new CommunicationDefinition(blob.transport, blob.param);
        },
        toProperty(definition) {
            const json = JSON.stringify({ transport: definition.transport, param: definition.param });
            return `:1:${json}`;
        },
    };
}
function tryParse(inputValue, parsers, parse) {
    for (const parser of parsers) {
        const result = parse(parser, inputValue);
        if (result !== undefined) {
            return result;
        }
    }
    return undefined;
}
function combined(parsers) {
    return {
        fromProperty(inputValue) {
            return tryParse(inputValue, parsers, (parser, value) => parser.fromProperty(value));
        },
        toProperty(definition) {
            const first = parsers[0];
            return first.toProperty(definition);
        },
    };
}

/**
 * Pre-configured `SerializerDeserializer`
 *
 * This `SerializerDeserializer` will attempt to Deserialize Property falling back to older methods
 * for backwards compatibility. Serialization will be performed using the newest method available.
 */
const serializerDeserializer = combined([mangledJson(), mangled(), human()]);

/**
 * Generated bundle index. Do not edit.
 */

export { CommunicationDefinition, serializerDeserializer, human as ɵa, mangled as ɵb, mangledJson as ɵc, combined as ɵd };

//# sourceMappingURL=backbase-communication-property.js.map