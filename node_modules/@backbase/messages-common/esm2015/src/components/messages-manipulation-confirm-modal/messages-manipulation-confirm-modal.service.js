import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ManipulationType } from './manipulation-confirm-modal-types.model';
import * as i0 from "@angular/core";
import * as i1 from "../../services/shared-methods/shared-methods.service";
export class MessagesManipulationConfirmModalService {
    constructor(shared) {
        this.shared = shared;
        this.initialModalVal = {
            opened: false,
            type: undefined,
        };
        this.emitToggleModal = new BehaviorSubject(this.initialModalVal);
        /**
         * Toggle modal event emitter
         */
        this.emitToggleModal$ = this.emitToggleModal.asObservable();
    }
    /**
     * Toggle confirm modal
     *
     * @param shouldOpen Should open modal flag
     * @param type Manipulation type
     * @param form Form data
     * @param prevValue Previous value
     */
    toggleModal(shouldOpen, type, form, prevValue) {
        let opened = shouldOpen;
        if (type === ManipulationType.discard) {
            opened = this.shared.isFormInvalid(form, prevValue);
        }
        this.emitToggleModal.next({ opened, type });
    }
}
MessagesManipulationConfirmModalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesManipulationConfirmModalService, deps: [{ token: i1.SharedMethodsService }], target: i0.ɵɵFactoryTarget.Injectable });
MessagesManipulationConfirmModalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesManipulationConfirmModalService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesManipulationConfirmModalService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.SharedMethodsService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzc2FnZXMtbWFuaXB1bGF0aW9uLWNvbmZpcm0tbW9kYWwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbWVzc2FnZXMtY29tbW9uL3NyYy9jb21wb25lbnRzL21lc3NhZ2VzLW1hbmlwdWxhdGlvbi1jb25maXJtLW1vZGFsL21lc3NhZ2VzLW1hbmlwdWxhdGlvbi1jb25maXJtLW1vZGFsLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQUUsZUFBZSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxnQkFBZ0IsRUFBa0MsTUFBTSwwQ0FBMEMsQ0FBQzs7O0FBSTVHLE1BQU0sT0FBTyx1Q0FBdUM7SUFZbEQsWUFBNkIsTUFBNEI7UUFBNUIsV0FBTSxHQUFOLE1BQU0sQ0FBc0I7UUFYeEMsb0JBQWUsR0FBbUM7WUFDakUsTUFBTSxFQUFFLEtBQUs7WUFDYixJQUFJLEVBQUUsU0FBUztTQUNoQixDQUFDO1FBQ2Usb0JBQWUsR0FBRyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFN0U7O1dBRUc7UUFDSSxxQkFBZ0IsR0FBK0MsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUU5QyxDQUFDO0lBRTdEOzs7Ozs7O09BT0c7SUFDSCxXQUFXLENBQ1QsVUFBbUIsRUFDbkIsSUFBbUMsRUFDbkMsSUFBNEIsRUFDNUIsU0FBa0M7UUFFbEMsSUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDO1FBQ3hCLElBQUksSUFBSSxLQUFLLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtZQUNyQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUM5QyxDQUFDOztxSUFsQ1UsdUNBQXVDO3lJQUF2Qyx1Q0FBdUM7NEZBQXZDLHVDQUF1QztrQkFEbkQsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTWFuaXB1bGF0aW9uVHlwZSwgTWVzc2FnZXNDb25maXJtYXRpb25Nb2RhbE1vZGVsIH0gZnJvbSAnLi9tYW5pcHVsYXRpb24tY29uZmlybS1tb2RhbC10eXBlcy5tb2RlbCc7XG5pbXBvcnQgeyBTaGFyZWRNZXRob2RzU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3NoYXJlZC1tZXRob2RzL3NoYXJlZC1tZXRob2RzLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWVzc2FnZXNNYW5pcHVsYXRpb25Db25maXJtTW9kYWxTZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBpbml0aWFsTW9kYWxWYWw6IE1lc3NhZ2VzQ29uZmlybWF0aW9uTW9kYWxNb2RlbCA9IHtcbiAgICBvcGVuZWQ6IGZhbHNlLFxuICAgIHR5cGU6IHVuZGVmaW5lZCxcbiAgfTtcbiAgcHJpdmF0ZSByZWFkb25seSBlbWl0VG9nZ2xlTW9kYWwgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuaW5pdGlhbE1vZGFsVmFsKTtcblxuICAvKipcbiAgICogVG9nZ2xlIG1vZGFsIGV2ZW50IGVtaXR0ZXJcbiAgICovXG4gIHB1YmxpYyBlbWl0VG9nZ2xlTW9kYWwkOiBPYnNlcnZhYmxlPE1lc3NhZ2VzQ29uZmlybWF0aW9uTW9kYWxNb2RlbD4gPSB0aGlzLmVtaXRUb2dnbGVNb2RhbC5hc09ic2VydmFibGUoKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHNoYXJlZDogU2hhcmVkTWV0aG9kc1NlcnZpY2UpIHt9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSBjb25maXJtIG1vZGFsXG4gICAqXG4gICAqIEBwYXJhbSBzaG91bGRPcGVuIFNob3VsZCBvcGVuIG1vZGFsIGZsYWdcbiAgICogQHBhcmFtIHR5cGUgTWFuaXB1bGF0aW9uIHR5cGVcbiAgICogQHBhcmFtIGZvcm0gRm9ybSBkYXRhXG4gICAqIEBwYXJhbSBwcmV2VmFsdWUgUHJldmlvdXMgdmFsdWVcbiAgICovXG4gIHRvZ2dsZU1vZGFsKFxuICAgIHNob3VsZE9wZW46IGJvb2xlYW4sXG4gICAgdHlwZT86IE1hbmlwdWxhdGlvblR5cGUgfCB1bmRlZmluZWQsXG4gICAgZm9ybT86IEZvcm1Hcm91cCB8IHVuZGVmaW5lZCxcbiAgICBwcmV2VmFsdWU/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9LFxuICApIHtcbiAgICBsZXQgb3BlbmVkID0gc2hvdWxkT3BlbjtcbiAgICBpZiAodHlwZSA9PT0gTWFuaXB1bGF0aW9uVHlwZS5kaXNjYXJkKSB7XG4gICAgICBvcGVuZWQgPSB0aGlzLnNoYXJlZC5pc0Zvcm1JbnZhbGlkKGZvcm0sIHByZXZWYWx1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0VG9nZ2xlTW9kYWwubmV4dCh7IG9wZW5lZCwgdHlwZSB9KTtcbiAgfVxufVxuIl19