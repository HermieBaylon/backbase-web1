import { ChangeDetectionStrategy, Component, Directive, forwardRef, Input, ViewChild, } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject, EMPTY, Subject } from 'rxjs';
import { catchError, filter, finalize, map, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { FileAttachment, } from './services/base-attachments.service';
import { BbTemplate } from '@backbase/foundation-ang/core';
import * as i0 from "@angular/core";
import * as i1 from "./services/base-attachments.service";
import * as i2 from "../../services/shared-methods/shared-methods.service";
import * as i3 from "./services/messages-upload-attachments.service";
import * as i4 from "@backbase/ui-ang/input-file";
import * as i5 from "@backbase/ui-ang/file-attachment";
import * as i6 from "@angular/common";
export class MessagesUploadAttachmentsComponent {
    constructor(cd, service, sharedService, uploadService) {
        this.cd = cd;
        this.service = service;
        this.sharedService = sharedService;
        this.uploadService = uploadService;
        /**
         * Disabled state flag
         */
        this.disabled = false;
        /**
         * Input to define adding file multiple times
         * True by defaults
         */
        this.multiple = true;
        /**
         * The accepted file formats.
         */
        this.accept = '*';
        this.initAttachments$ = new BehaviorSubject(undefined);
        /**
         * The file attachments array.
         */
        this.attachments = [];
        this.hostRef = this;
        this.maxSizeBytesValue = 0;
        this.value = [];
        this.newlyAddedAttachments = [];
        this.loading = 0;
        this.unsubscribe = new Subject();
        /**
         * The method from the ControlValueAccessor interface for responding to the value change.
         * Implemented through the registerOnChange method.
         */
        this.onChange = () => { };
        /**
         * The method from the ControlValueAccessor interface for responding to the change of the untouched state.
         * Implemented through the registerOnTouched method.
         */
        this.onTouched = () => { };
        /**
         * The method for responding to the validation change. Implemented through the registerOnValidatorChange method.
         */
        this.onValidationChange = () => { };
    }
    /**
     * Maximum size for file upload in megabytes
     */
    set maxSize(value) {
        if (value) {
            const number = Number(value);
            this.maxSizeMegabytesValue = number;
            this.maxSizeBytesValue = number * 1024 * 1024;
        }
    }
    /**
     * Array of attachments objects
     */
    set initAttachments(value) {
        this.initAttachments$.next(value);
    }
    /**
     * The method to upload a file attachment.
     *
     * @param input
     */
    onFileAdded(input) {
        const file = input && input.files && input.files[0];
        this.onTouched();
        if (file) {
            input.value = '';
            if (this.maxSizeBytesValue && file.size > this.maxSizeBytesValue) {
                this.sharedService.openNotification(this.maxAttachmentSizeErrorTpl, 'error');
                return;
            }
            const attachment = new FileAttachment(file, this.service);
            const index = this.attachments.push(attachment);
            this.loading++;
            this.onValidationChange();
            attachment
                .uploadAttachment()
                .pipe(take(1), tap(value => this.onValueChanged(value || undefined)), catchError(error => {
                this.removeRedundantAttachment(index - 1);
                return this.showErrorNotification(error);
            }), finalize(() => {
                this.loading--;
                this.onValidationChange();
                this.cd.markForCheck();
            }), takeUntil(this.uploadService.reset$))
                .subscribe();
            attachment.onDelete.pipe(takeUntil(this.unsubscribe)).subscribe(i => this.removeRedundantAttachment(i));
        }
    }
    ngOnInit() {
        this.uploadService.reset$
            .pipe(map(type => {
            const value = type ? [...this.newlyAddedAttachments].map(({ id }) => id) : [];
            this.attachments = [];
            this.value = [];
            this.newlyAddedAttachments = [];
            this.cd.markForCheck();
            return { value, type };
        }), filter(({ value, type }) => !!(value.length && type)), switchMap(({ value }) => this.deleteAttachments(value)), takeUntil(this.unsubscribe))
            .subscribe();
    }
    ngOnDestroy() {
        this.unsubscribe.next(true);
        this.unsubscribe.complete();
    }
    /**
     * The method from the ControlValueAccessor interface for setting the initial value (previously uploaded attachments)
     * for file attachments input.
     *
     * @param value Previously uploaded attachments
     */
    writeValue(value) {
        if (value && value.length) {
            this.value = [...value];
            this.initAttachments$.pipe(takeUntil(this.uploadService.reset$)).subscribe(attachments => {
                if (attachments) {
                    this.attachments = attachments.reduce((acc, item) => {
                        const attachment = new FileAttachment(item, this.service);
                        // @ts-ignore
                        acc.push(attachment);
                        attachment.onDelete.pipe(takeUntil(this.unsubscribe)).subscribe(i => this.removeRedundantAttachment(i));
                        return acc;
                    }, []);
                }
            });
        }
        this.cd.markForCheck();
    }
    /**
     * The method from the ControlValueAccessor interface for setting the onChange function implementation.
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * The method from the ControlValueAccessor interface for setting the onTouched function implementation.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * The method from the Validator interface. Registers a callback function to call when the validator inputs change.
     */
    registerOnValidatorChange(fn) {
        this.onValidationChange = fn;
    }
    /**
     * The method from the ControlValueAccessor interface for setting the disabled state.
     *
     * @param isDisabled Is disabled flag
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cd.markForCheck();
    }
    /**
     * The method from the Validator interface. This method performs synchronous validation against the provided control.
     *
     * @returns Validation errors
     */
    validate() {
        return this.loading ? { loading: true } : null;
    }
    deleteAttachments(ids) {
        return this.service.deleteAttachments(ids).pipe(catchError(error => this.showErrorNotification(error)));
    }
    removeRedundantAttachment(index) {
        this.value.splice(index, 1);
        this.attachments.splice(index, 1);
        this.onChange(this.value);
    }
    onValueChanged(value) {
        if (value) {
            this.value.push(value);
            this.newlyAddedAttachments.push(value);
            this.onChange(this.value);
        }
    }
    showErrorNotification(error) {
        this.sharedService.openNotification(this.sharedService.getErrorMessage(error), 'error');
        return EMPTY;
    }
}
MessagesUploadAttachmentsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesUploadAttachmentsComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.BaseUploadAttachmentsService }, { token: i2.SharedMethodsService }, { token: i3.MessagesUploadAttachmentsService }], target: i0.ɵɵFactoryTarget.Component });
MessagesUploadAttachmentsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.14", type: MessagesUploadAttachmentsComponent, selector: "bb-messages-upload-attachments-ui, bb-messages-upload-attachments", inputs: { maxSize: "maxSize", initAttachments: "initAttachments", disabled: "disabled", multiple: "multiple", attachmentButtonText: "attachmentButtonText", accept: "accept" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => MessagesUploadAttachmentsComponent),
            multi: true,
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => MessagesUploadAttachmentsComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "maxAttachmentSizeErrorTpl", first: true, predicate: ["maxAttachmentSizeError"], descendants: true }], ngImport: i0, template: "<ng-container bbMessagesUploadAttachmentsCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n\n<ng-template bbMessagesUploadAttachmentsCustomizable let-host>\n  <bb-input-file-ui\n    [buttonText]=\"host.attachmentButtonText ? host.attachmentButtonText : attachFile.elementRef.nativeElement.innerText\"\n    [disabled]=\"host.disabled\"\n    [accept]=\"host.accept\"\n    *ngIf=\"!(!host.multiple && host.attachments.length)\"\n    (change)=\"host.onFileAdded($event.target)\"\n  ></bb-input-file-ui>\n\n  <div class=\"row\">\n    <div class=\"col-auto\" *ngFor=\"let attachment of host.attachments; let i = index\">\n      <div class=\"bb-block bb-block--md\">\n        <bb-file-attachment-ui\n          [name]=\"attachment.name\"\n          [size]=\"attachment.size\"\n          [loading]=\"attachment.loading\"\n          [deletable]=\"true\"\n          [disabled]=\"true\"\n          (delete)=\"attachment.deleteAttachment(attachment.id, i)\"\n        ></bb-file-attachment-ui>\n      </div>\n    </div>\n  </div>\n\n  <ng-template #attachFile i18n=\"Attach file@@messages.messagesEmployeeUploadAttachments.attachFile\"\n    >Attach file</ng-template\n  >\n</ng-template>\n\n<ng-template #maxAttachmentSizeError>\n  <span\n    i18n=\"\n      Uploaded file exceeds the maximum allowed size@@messages.messagesEmployeeUploadAttachments.maxAttachmentSizeError\"\n    >The file you are trying to upload exceeds the maximum attachment size of\n  </span>\n  <span>{{ maxSizeMegabytesValue }}</span>\n  <span i18n=\"Mb|Megabytes@@messages.messagesEmployeeUploadAttachments.maxAttachmentSizeError.megabytes\">Mb</span>.\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i4.InputFileComponent; }), selector: "bb-input-file-ui", inputs: ["accept", "maxSizeInMb", "multiple", "color", "autofocus", "buttonText", "buttonSize", "iconName"] }, { type: i0.forwardRef(function () { return i5.FileAttachmentComponent; }), selector: "bb-file-attachment-ui", inputs: ["name", "size", "fileContent", "loading", "deletable", "disabled", "block"], outputs: ["delete"] }], directives: [{ type: i0.forwardRef(function () { return MessagesUploadAttachmentsCustomizableDirective; }), selector: "[bbMessagesEmployeeUploadAttachmentsCustomizable],[bbMessagesUploadAttachmentsCustomizable]" }, { type: i0.forwardRef(function () { return i6.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i6.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesUploadAttachmentsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-messages-upload-attachments-ui, bb-messages-upload-attachments',
                    templateUrl: './messages-upload-attachments.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => MessagesUploadAttachmentsComponent),
                            multi: true,
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => MessagesUploadAttachmentsComponent),
                            multi: true,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.BaseUploadAttachmentsService }, { type: i2.SharedMethodsService }, { type: i3.MessagesUploadAttachmentsService }]; }, propDecorators: { maxSize: [{
                type: Input
            }], initAttachments: [{
                type: Input
            }], disabled: [{
                type: Input
            }], multiple: [{
                type: Input
            }], attachmentButtonText: [{
                type: Input
            }], accept: [{
                type: Input
            }], maxAttachmentSizeErrorTpl: [{
                type: ViewChild,
                args: ['maxAttachmentSizeError']
            }] } });
export class MessagesUploadAttachmentsCustomizableDirective extends BbTemplate {
}
MessagesUploadAttachmentsCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesUploadAttachmentsCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
MessagesUploadAttachmentsCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.14", type: MessagesUploadAttachmentsCustomizableDirective, selector: "[bbMessagesEmployeeUploadAttachmentsCustomizable],[bbMessagesUploadAttachmentsCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: MessagesUploadAttachmentsCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbMessagesEmployeeUploadAttachmentsCustomizable],[bbMessagesUploadAttachmentsCustomizable]',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzc2FnZXMtdXBsb2FkLWF0dGFjaG1lbnRzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvbWVzc2FnZXMtY29tbW9uL3NyYy9jb21wb25lbnRzL3VwbG9hZC1hdHRhY2htZW50cy9tZXNzYWdlcy11cGxvYWQtYXR0YWNobWVudHMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9tZXNzYWdlcy1jb21tb24vc3JjL2NvbXBvbmVudHMvdXBsb2FkLWF0dGFjaG1lbnRzL21lc3NhZ2VzLXVwbG9hZC1hdHRhY2htZW50cy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxTQUFTLEVBQ1QsVUFBVSxFQUNWLEtBQUssRUFJTCxTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixhQUFhLEVBQUUsaUJBQWlCLEVBQStCLE1BQU0sZ0JBQWdCLENBQUM7QUFFckgsT0FBTyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ25FLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEcsT0FBTyxFQUVMLGNBQWMsR0FFZixNQUFNLHFDQUFxQyxDQUFDO0FBQzdDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7Ozs7Ozs7QUFzQjNELE1BQU0sT0FBTyxrQ0FBa0M7SUFpRTdDLFlBQ1ksRUFBcUIsRUFDckIsT0FBcUMsRUFDckMsYUFBbUMsRUFDbkMsYUFBK0M7UUFIL0MsT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUFDckIsWUFBTyxHQUFQLE9BQU8sQ0FB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QUFFO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLG1DQUFtQyxDQUFDOzRCQUNqRSxLQUFLLEVBQUUsSUFBSTt5QkFDWjt3QkFDRDs0QkFDRSxPQUFPLEVBQUUsYUFBYTs0QkFDdEIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsbUNBQW1DLENBQUM7NEJBQ2pFLEtBQUssRUFBRSxJQUFJO3lCQUNaO3FCQUNGO2lCQUNGO3FPQUtjLE9BQU87c0JBQW5CLEtBQUs7Z0JBWUYsZUFBZTtzQkFEbEIsS0FBSztnQkFRRyxRQUFRO3NCQUFoQixLQUFLO2dCQU1HLFFBQVE7c0JBQWhCLEtBQUs7Z0JBS0csb0JBQW9CO3NCQUE1QixLQUFLO2dCQUtHLE1BQU07c0JBQWQsS0FBSztnQkFLK0IseUJBQXlCO3NCQUE3RCxTQUFTO3VCQUFDLHdCQUF3Qjs7QUFzTnJDLE1BQU0sT0FBTyw4Q0FBK0MsU0FBUSxVQUduRTs7NElBSFksOENBQThDO2dJQUE5Qyw4Q0FBOEM7NEZBQTlDLDhDQUE4QztrQkFIMUQsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsNkZBQTZGO2lCQUN4RyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBEaXJlY3RpdmUsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEh0dHBFcnJvclJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBFTVBUWSwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgY2F0Y2hFcnJvciwgZmlsdGVyLCBmaW5hbGl6ZSwgbWFwLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgQmFzZVVwbG9hZEF0dGFjaG1lbnRzU2VydmljZSxcbiAgRmlsZUF0dGFjaG1lbnQsXG4gIEZpbGVBdHRhY2htZW50SW50ZXJmYWNlLFxufSBmcm9tICcuL3NlcnZpY2VzL2Jhc2UtYXR0YWNobWVudHMuc2VydmljZSc7XG5pbXBvcnQgeyBCYlRlbXBsYXRlIH0gZnJvbSAnQGJhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2NvcmUnO1xuaW1wb3J0IHsgU2hhcmVkTWV0aG9kc1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zaGFyZWQtbWV0aG9kcy9zaGFyZWQtbWV0aG9kcy5zZXJ2aWNlJztcbmltcG9ydCB7IE1lc3NhZ2VzVXBsb2FkQXR0YWNobWVudHNTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9tZXNzYWdlcy11cGxvYWQtYXR0YWNobWVudHMuc2VydmljZSc7XG5pbXBvcnQgeyBEZWxldGVSZXNwb25zZUJvZHksIE1ldGFkYXRhIH0gZnJvbSAnQGJhY2tiYXNlL21lc3NhZ2VzLXY1LWh0dHAtYW5nJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYmItbWVzc2FnZXMtdXBsb2FkLWF0dGFjaG1lbnRzLXVpLCBiYi1tZXNzYWdlcy11cGxvYWQtYXR0YWNobWVudHMnLFxuICB0ZW1wbGF0ZVVybDogJy4vbWVzc2FnZXMtdXBsb2FkLWF0dGFjaG1lbnRzLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWVzc2FnZXNVcGxvYWRBdHRhY2htZW50c0NvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNZXNzYWdlc1VwbG9hZEF0dGFjaG1lbnRzQ29tcG9uZW50KSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VzVXBsb2FkQXR0YWNobWVudHNDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yLCBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBNYXhpbXVtIHNpemUgZm9yIGZpbGUgdXBsb2FkIGluIG1lZ2FieXRlc1xuICAgKi9cbiAgQElucHV0KCkgc2V0IG1heFNpemUodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY29uc3QgbnVtYmVyID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgIHRoaXMubWF4U2l6ZU1lZ2FieXRlc1ZhbHVlID0gbnVtYmVyO1xuICAgICAgdGhpcy5tYXhTaXplQnl0ZXNWYWx1ZSA9IG51bWJlciAqIDEwMjQgKiAxMDI0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhdHRhY2htZW50cyBvYmplY3RzXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgaW5pdEF0dGFjaG1lbnRzKHZhbHVlOiBBcnJheTxNZXRhZGF0YT4gfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLmluaXRBdHRhY2htZW50cyQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzYWJsZWQgc3RhdGUgZmxhZ1xuICAgKi9cbiAgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogSW5wdXQgdG8gZGVmaW5lIGFkZGluZyBmaWxlIG11bHRpcGxlIHRpbWVzXG4gICAqIFRydWUgYnkgZGVmYXVsdHNcbiAgICovXG4gIEBJbnB1dCgpIG11bHRpcGxlID0gdHJ1ZTtcblxuICAvKipcbiAgICogVGhlIGF0dGFjaG1lbnQgYnV0dG9uIHRleHQuXG4gICAqL1xuICBASW5wdXQoKSBhdHRhY2htZW50QnV0dG9uVGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgYWNjZXB0ZWQgZmlsZSBmb3JtYXRzLlxuICAgKi9cbiAgQElucHV0KCkgYWNjZXB0ID0gJyonO1xuXG4gIC8qKlxuICAgKiBUaGUgbm90aWZpY2F0aW9uIGZvciB0aGUgbWF4aW11bSBhdHRhY2htZW50IHNpemUgZXhjZWVkZWQgZXJyb3IuXG4gICAqL1xuICBAVmlld0NoaWxkKCdtYXhBdHRhY2htZW50U2l6ZUVycm9yJykgbWF4QXR0YWNobWVudFNpemVFcnJvclRwbDogVGVtcGxhdGVSZWY8YW55PiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHJlYWRvbmx5IGluaXRBdHRhY2htZW50cyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEFycmF5PE1ldGFkYXRhPiB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAvKipcbiAgICogVGhlIGZpbGUgYXR0YWNobWVudHMgYXJyYXkuXG4gICAqL1xuICBhdHRhY2htZW50czogQXJyYXk8RmlsZUF0dGFjaG1lbnRJbnRlcmZhY2U+ID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBmaWxlIGF0dGFjaG1lbnRzIGFycmF5LlxuICAgKi9cbiAgbWF4U2l6ZU1lZ2FieXRlc1ZhbHVlOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgcmVhZG9ubHkgaG9zdFJlZiA9IHRoaXM7XG4gIHByaXZhdGUgbWF4U2l6ZUJ5dGVzVmFsdWUgPSAwO1xuICBwcml2YXRlIHZhbHVlOiBBcnJheTxNZXRhZGF0YT4gPSBbXTtcbiAgcHJpdmF0ZSBuZXdseUFkZGVkQXR0YWNobWVudHM6IEFycmF5PE1ldGFkYXRhPiA9IFtdO1xuICBwcml2YXRlIGxvYWRpbmcgPSAwO1xuICBwcml2YXRlIHJlYWRvbmx5IHVuc3Vic2NyaWJlID0gbmV3IFN1YmplY3QoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByb3RlY3RlZCBzZXJ2aWNlOiBCYXNlVXBsb2FkQXR0YWNobWVudHNTZXJ2aWNlLFxuICAgIHByb3RlY3RlZCBzaGFyZWRTZXJ2aWNlOiBTaGFyZWRNZXRob2RzU2VydmljZSxcbiAgICBwcm90ZWN0ZWQgdXBsb2FkU2VydmljZTogTWVzc2FnZXNVcGxvYWRBdHRhY2htZW50c1NlcnZpY2UsXG4gICkge31cblxuICAvKipcbiAgICogVGhlIG1ldGhvZCB0byB1cGxvYWQgYSBmaWxlIGF0dGFjaG1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFxuICAgKi9cbiAgb25GaWxlQWRkZWQoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICBjb25zdCBmaWxlID0gaW5wdXQgJiYgaW5wdXQuZmlsZXMgJiYgaW5wdXQuZmlsZXNbMF07XG5cbiAgICB0aGlzLm9uVG91Y2hlZCgpO1xuXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIGlucHV0LnZhbHVlID0gJyc7XG5cbiAgICAgIGlmICh0aGlzLm1heFNpemVCeXRlc1ZhbHVlICYmIGZpbGUuc2l6ZSA+IHRoaXMubWF4U2l6ZUJ5dGVzVmFsdWUpIHtcbiAgICAgICAgdGhpcy5zaGFyZWRTZXJ2aWNlLm9wZW5Ob3RpZmljYXRpb24odGhpcy5tYXhBdHRhY2htZW50U2l6ZUVycm9yVHBsLCAnZXJyb3InKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBuZXcgRmlsZUF0dGFjaG1lbnQoZmlsZSwgdGhpcy5zZXJ2aWNlKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5hdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuXG4gICAgICB0aGlzLmxvYWRpbmcrKztcbiAgICAgIHRoaXMub25WYWxpZGF0aW9uQ2hhbmdlKCk7XG5cbiAgICAgIGF0dGFjaG1lbnRcbiAgICAgICAgLnVwbG9hZEF0dGFjaG1lbnQoKVxuICAgICAgICAucGlwZShcbiAgICAgICAgICB0YWtlKDEpLFxuICAgICAgICAgIHRhcCh2YWx1ZSA9PiB0aGlzLm9uVmFsdWVDaGFuZ2VkKHZhbHVlIHx8IHVuZGVmaW5lZCkpLFxuICAgICAgICAgIGNhdGNoRXJyb3IoZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVSZWR1bmRhbnRBdHRhY2htZW50KGluZGV4IC0gMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dFcnJvck5vdGlmaWNhdGlvbihlcnJvcik7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZmluYWxpemUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nLS07XG4gICAgICAgICAgICB0aGlzLm9uVmFsaWRhdGlvbkNoYW5nZSgpO1xuXG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRha2VVbnRpbCh0aGlzLnVwbG9hZFNlcnZpY2UucmVzZXQkKSxcbiAgICAgICAgKVxuICAgICAgICAuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGF0dGFjaG1lbnQub25EZWxldGUucGlwZSh0YWtlVW50aWwodGhpcy51bnN1YnNjcmliZSkpLnN1YnNjcmliZShpID0+IHRoaXMucmVtb3ZlUmVkdW5kYW50QXR0YWNobWVudChpKSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy51cGxvYWRTZXJ2aWNlLnJlc2V0JFxuICAgICAgLnBpcGUoXG4gICAgICAgIG1hcCh0eXBlID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHR5cGUgPyBbLi4udGhpcy5uZXdseUFkZGVkQXR0YWNobWVudHNdLm1hcCgoeyBpZCB9KSA9PiBpZCkgOiBbXTtcblxuICAgICAgICAgIHRoaXMuYXR0YWNobWVudHMgPSBbXTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgdGhpcy5uZXdseUFkZGVkQXR0YWNobWVudHMgPSBbXTtcbiAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuXG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUgfTtcbiAgICAgICAgfSksXG4gICAgICAgIGZpbHRlcigoeyB2YWx1ZSwgdHlwZSB9KSA9PiAhISh2YWx1ZS5sZW5ndGggJiYgdHlwZSkpLFxuICAgICAgICBzd2l0Y2hNYXAoKHsgdmFsdWUgfSkgPT4gdGhpcy5kZWxldGVBdHRhY2htZW50cyh2YWx1ZSkpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy51bnN1YnNjcmliZSksXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlLm5leHQodHJ1ZSk7XG4gICAgdGhpcy51bnN1YnNjcmliZS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZnJvbSB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIGZvciBzZXR0aW5nIHRoZSBpbml0aWFsIHZhbHVlIChwcmV2aW91c2x5IHVwbG9hZGVkIGF0dGFjaG1lbnRzKVxuICAgKiBmb3IgZmlsZSBhdHRhY2htZW50cyBpbnB1dC5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFByZXZpb3VzbHkgdXBsb2FkZWQgYXR0YWNobWVudHNcbiAgICovXG4gIHdyaXRlVmFsdWUodmFsdWU6IEFycmF5PE1ldGFkYXRhPiB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLnZhbHVlID0gWy4uLnZhbHVlXTtcbiAgICAgIHRoaXMuaW5pdEF0dGFjaG1lbnRzJC5waXBlKHRha2VVbnRpbCh0aGlzLnVwbG9hZFNlcnZpY2UucmVzZXQkKSkuc3Vic2NyaWJlKGF0dGFjaG1lbnRzID0+IHtcbiAgICAgICAgaWYgKGF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgdGhpcy5hdHRhY2htZW50cyA9IGF0dGFjaG1lbnRzLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRhY2htZW50OiBGaWxlQXR0YWNobWVudCA9IG5ldyBGaWxlQXR0YWNobWVudChpdGVtLCB0aGlzLnNlcnZpY2UpO1xuXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBhY2MucHVzaChhdHRhY2htZW50KTtcblxuICAgICAgICAgICAgYXR0YWNobWVudC5vbkRlbGV0ZS5waXBlKHRha2VVbnRpbCh0aGlzLnVuc3Vic2NyaWJlKSkuc3Vic2NyaWJlKGkgPT4gdGhpcy5yZW1vdmVSZWR1bmRhbnRBdHRhY2htZW50KGkpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZnJvbSB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIGZvciByZXNwb25kaW5nIHRvIHRoZSB2YWx1ZSBjaGFuZ2UuXG4gICAqIEltcGxlbWVudGVkIHRocm91Z2ggdGhlIHJlZ2lzdGVyT25DaGFuZ2UgbWV0aG9kLlxuICAgKi9cbiAgb25DaGFuZ2U6IChuZXdWYWx1ZTogQXJyYXk8TWV0YWRhdGE+KSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZnJvbSB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIGZvciByZXNwb25kaW5nIHRvIHRoZSBjaGFuZ2Ugb2YgdGhlIHVudG91Y2hlZCBzdGF0ZS5cbiAgICogSW1wbGVtZW50ZWQgdGhyb3VnaCB0aGUgcmVnaXN0ZXJPblRvdWNoZWQgbWV0aG9kLlxuICAgKi9cbiAgb25Ub3VjaGVkOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZm9yIHJlc3BvbmRpbmcgdG8gdGhlIHZhbGlkYXRpb24gY2hhbmdlLiBJbXBsZW1lbnRlZCB0aHJvdWdoIHRoZSByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlIG1ldGhvZC5cbiAgICovXG4gIG9uVmFsaWRhdGlvbkNoYW5nZTogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIGZyb20gdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSBmb3Igc2V0dGluZyB0aGUgb25DaGFuZ2UgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZnJvbSB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlIGZvciBzZXR0aW5nIHRoZSBvblRvdWNoZWQgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1ldGhvZCBmcm9tIHRoZSBWYWxpZGF0b3IgaW50ZXJmYWNlLiBSZWdpc3RlcnMgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHZhbGlkYXRvciBpbnB1dHMgY2hhbmdlLlxuICAgKi9cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCkge1xuICAgIHRoaXMub25WYWxpZGF0aW9uQ2hhbmdlID0gZm47XG4gIH1cblxuICAvKipcbiAgICogVGhlIG1ldGhvZCBmcm9tIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UgZm9yIHNldHRpbmcgdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gaXNEaXNhYmxlZCBJcyBkaXNhYmxlZCBmbGFnXG4gICAqL1xuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtZXRob2QgZnJvbSB0aGUgVmFsaWRhdG9yIGludGVyZmFjZS4gVGhpcyBtZXRob2QgcGVyZm9ybXMgc3luY2hyb25vdXMgdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBwcm92aWRlZCBjb250cm9sLlxuICAgKlxuICAgKiBAcmV0dXJucyBWYWxpZGF0aW9uIGVycm9yc1xuICAgKi9cbiAgdmFsaWRhdGUoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLmxvYWRpbmcgPyB7IGxvYWRpbmc6IHRydWUgfSA6IG51bGw7XG4gIH1cblxuICBwcml2YXRlIGRlbGV0ZUF0dGFjaG1lbnRzKGlkczogQXJyYXk8c3RyaW5nPik6IE9ic2VydmFibGU8RGVsZXRlUmVzcG9uc2VCb2R5IHwgbnVsbCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnNlcnZpY2UuZGVsZXRlQXR0YWNobWVudHMoaWRzKS5waXBlKGNhdGNoRXJyb3IoZXJyb3IgPT4gdGhpcy5zaG93RXJyb3JOb3RpZmljYXRpb24oZXJyb3IpKSk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVJlZHVuZGFudEF0dGFjaG1lbnQoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMudmFsdWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLmF0dGFjaG1lbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5vbkNoYW5nZSh0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgb25WYWx1ZUNoYW5nZWQodmFsdWU/OiBNZXRhZGF0YSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgIHRoaXMubmV3bHlBZGRlZEF0dGFjaG1lbnRzLnB1c2godmFsdWUpO1xuICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNob3dFcnJvck5vdGlmaWNhdGlvbihlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpIHtcbiAgICB0aGlzLnNoYXJlZFNlcnZpY2Uub3Blbk5vdGlmaWNhdGlvbih0aGlzLnNoYXJlZFNlcnZpY2UuZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgJ2Vycm9yJyk7XG5cbiAgICByZXR1cm4gRU1QVFk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2JiTWVzc2FnZXNFbXBsb3llZVVwbG9hZEF0dGFjaG1lbnRzQ3VzdG9taXphYmxlXSxbYmJNZXNzYWdlc1VwbG9hZEF0dGFjaG1lbnRzQ3VzdG9taXphYmxlXScsXG59KVxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VzVXBsb2FkQXR0YWNobWVudHNDdXN0b21pemFibGVEaXJlY3RpdmUgZXh0ZW5kcyBCYlRlbXBsYXRlPFxuICBNZXNzYWdlc1VwbG9hZEF0dGFjaG1lbnRzQ29tcG9uZW50LFxuICB1bmRlZmluZWRcbj4ge31cbiIsIjxuZy1jb250YWluZXIgYmJNZXNzYWdlc1VwbG9hZEF0dGFjaG1lbnRzQ3VzdG9taXphYmxlIFtiYkhvc3RSZWZdPVwiaG9zdFJlZlwiPjwvbmctY29udGFpbmVyPlxuXG48bmctdGVtcGxhdGUgYmJNZXNzYWdlc1VwbG9hZEF0dGFjaG1lbnRzQ3VzdG9taXphYmxlIGxldC1ob3N0PlxuICA8YmItaW5wdXQtZmlsZS11aVxuICAgIFtidXR0b25UZXh0XT1cImhvc3QuYXR0YWNobWVudEJ1dHRvblRleHQgPyBob3N0LmF0dGFjaG1lbnRCdXR0b25UZXh0IDogYXR0YWNoRmlsZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuaW5uZXJUZXh0XCJcbiAgICBbZGlzYWJsZWRdPVwiaG9zdC5kaXNhYmxlZFwiXG4gICAgW2FjY2VwdF09XCJob3N0LmFjY2VwdFwiXG4gICAgKm5nSWY9XCIhKCFob3N0Lm11bHRpcGxlICYmIGhvc3QuYXR0YWNobWVudHMubGVuZ3RoKVwiXG4gICAgKGNoYW5nZSk9XCJob3N0Lm9uRmlsZUFkZGVkKCRldmVudC50YXJnZXQpXCJcbiAgPjwvYmItaW5wdXQtZmlsZS11aT5cblxuICA8ZGl2IGNsYXNzPVwicm93XCI+XG4gICAgPGRpdiBjbGFzcz1cImNvbC1hdXRvXCIgKm5nRm9yPVwibGV0IGF0dGFjaG1lbnQgb2YgaG9zdC5hdHRhY2htZW50czsgbGV0IGkgPSBpbmRleFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImJiLWJsb2NrIGJiLWJsb2NrLS1tZFwiPlxuICAgICAgICA8YmItZmlsZS1hdHRhY2htZW50LXVpXG4gICAgICAgICAgW25hbWVdPVwiYXR0YWNobWVudC5uYW1lXCJcbiAgICAgICAgICBbc2l6ZV09XCJhdHRhY2htZW50LnNpemVcIlxuICAgICAgICAgIFtsb2FkaW5nXT1cImF0dGFjaG1lbnQubG9hZGluZ1wiXG4gICAgICAgICAgW2RlbGV0YWJsZV09XCJ0cnVlXCJcbiAgICAgICAgICBbZGlzYWJsZWRdPVwidHJ1ZVwiXG4gICAgICAgICAgKGRlbGV0ZSk9XCJhdHRhY2htZW50LmRlbGV0ZUF0dGFjaG1lbnQoYXR0YWNobWVudC5pZCwgaSlcIlxuICAgICAgICA+PC9iYi1maWxlLWF0dGFjaG1lbnQtdWk+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgPG5nLXRlbXBsYXRlICNhdHRhY2hGaWxlIGkxOG49XCJBdHRhY2ggZmlsZUBAbWVzc2FnZXMubWVzc2FnZXNFbXBsb3llZVVwbG9hZEF0dGFjaG1lbnRzLmF0dGFjaEZpbGVcIlxuICAgID5BdHRhY2ggZmlsZTwvbmctdGVtcGxhdGVcbiAgPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNtYXhBdHRhY2htZW50U2l6ZUVycm9yPlxuICA8c3BhblxuICAgIGkxOG49XCJcbiAgICAgIFVwbG9hZGVkIGZpbGUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemVAQG1lc3NhZ2VzLm1lc3NhZ2VzRW1wbG95ZWVVcGxvYWRBdHRhY2htZW50cy5tYXhBdHRhY2htZW50U2l6ZUVycm9yXCJcbiAgICA+VGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gdXBsb2FkIGV4Y2VlZHMgdGhlIG1heGltdW0gYXR0YWNobWVudCBzaXplIG9mXG4gIDwvc3Bhbj5cbiAgPHNwYW4+e3sgbWF4U2l6ZU1lZ2FieXRlc1ZhbHVlIH19PC9zcGFuPlxuICA8c3BhbiBpMThuPVwiTWJ8TWVnYWJ5dGVzQEBtZXNzYWdlcy5tZXNzYWdlc0VtcGxveWVlVXBsb2FkQXR0YWNobWVudHMubWF4QXR0YWNobWVudFNpemVFcnJvci5tZWdhYnl0ZXNcIj5NYjwvc3Bhbj4uXG48L25nLXRlbXBsYXRlPlxuIl19