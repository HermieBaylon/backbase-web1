{"version":3,"file":"payments.service.js","sourceRoot":"","sources":["../../../../../../libs/manage-upcoming-and-historical-payments-journey/src/lib/services/payments.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { HttpResponse } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport {\n  GetPaymentOrdersRequestParams,\n  IdentifiedPaymentOrder,\n  PaymentOrderCancelPostResponse,\n  PaymentOrdersHttpService,\n} from '@backbase/data-ang/payment-order';\nimport { BehaviorSubject, combineLatest, merge, Observable, of, ReplaySubject, Subject } from 'rxjs';\nimport { distinctUntilChanged, filter, finalize, map, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { sortItems, unifyItems } from '../helpers/utils';\nimport { PaymentActionsTypes, PaymentsResponse, PaymentState } from '../models/payments.model';\n\n@Injectable()\nexport class PaymentService {\n  private readonly loadMore$ = new BehaviorSubject<GetPaymentOrdersRequestParams['from']>(undefined);\n  private readonly loadPayments$ = new ReplaySubject<GetPaymentOrdersRequestParams>(1);\n  private readonly returnCachedData$ = new Subject<void>();\n  private readonly loadingSub$ = new ReplaySubject<boolean>(1);\n  private readonly actingSub$ = new ReplaySubject<boolean>(1);\n  private payments?: PaymentsResponse;\n  private totalCounts = { withExecutionDate: 0, withNextExecutionDate: 0 };\n  /**\n   * Observable flag that checks whether a payment is loading\n   */\n  readonly loading$ = this.loadingSub$.pipe(distinctUntilChanged());\n  /**\n   * Observable to check the payment type\n   */\n  readonly acting$ = this.actingSub$.pipe(distinctUntilChanged());\n\n  private readonly paymentActions$ = combineLatest([\n    this.loadPayments$.pipe(map(params => ({ type: PaymentActionsTypes.LoadPayments, ...params }))),\n    this.loadMore$.pipe(map(from => ({ type: PaymentActionsTypes.LoadMore, from }))),\n  ]).pipe(\n    map(([state, loadMore]) => ({ ...state, ...(loadMore.from ? loadMore : null) })),\n    filter((action: PaymentState) => action.type !== undefined),\n  );\n\n  private readonly paymentState$ = merge(\n    this.paymentActions$,\n    this.returnCachedData$.pipe(map(() => ({ type: PaymentActionsTypes.ReturnCachedData }))),\n  ).pipe(\n    switchMap(({ type, ...params }) => {\n      if (type === PaymentActionsTypes.ReturnCachedData) {\n        return of(this.payments);\n      }\n\n      const isLoadMore = type === PaymentActionsTypes.LoadMore;\n      this.loadingSub$.next(true);\n      return this.combinePaymentCalls(params).pipe(\n        map(response => this.handlePaymentSuccess({ ...response, isLoadMore })),\n        finalize(() => this.loadingSub$.next(false)),\n      );\n    }),\n    shareReplay(),\n  );\n\n  /**\n   * Getter for the payments\n   */\n  public get payments$() {\n    return this.paymentState$;\n  }\n\n  constructor(private readonly paymentOrdersService: PaymentOrdersHttpService) {}\n\n  /**\n   * Loads the upcoming payments\n   *\n   * @returns\n   */\n  loadPayments(params?: GetPaymentOrdersRequestParams) {\n    this.loadPayments$.next(params);\n  }\n\n  /**\n   * Loads more payments\n   *\n   * @param from Loads from value\n   * @returns\n   */\n  loadMore(from: number) {\n    this.loadMore$.next(from);\n  }\n\n  /**\n   * Cancels a payment order\n   *\n   * @param paymentOrderId Payment order id\n   * @param version Payment version\n   */\n  cancelPayment(paymentOrderId: string, version: number): Observable<HttpResponse<PaymentOrderCancelPostResponse>> {\n    this.actingSub$.next(true);\n    return this.paymentOrdersService\n      .postCancelByPaymentOrderId(\n        {\n          paymentOrderId,\n          paymentOrderCancelPostRequest: { version },\n        },\n        'response',\n      )\n      .pipe(\n        finalize(() => this.actingSub$.next(false)),\n        tap(() => {\n          this.handleCancelPaymentSuccess(paymentOrderId);\n        }),\n      );\n  }\n\n  private handleCancelPaymentSuccess(paymentOrderId: string) {\n    if (this.payments) {\n      const newItems = this.payments.items.filter(item => item.id !== paymentOrderId);\n      this.payments = {\n        items: newItems,\n        totalCount: this.payments.totalCount,\n      };\n      this.returnCachedData$.next();\n    }\n  }\n\n  private handlePaymentSuccess(payload: PaymentsResponse & { isLoadMore: boolean }) {\n    const orders: IdentifiedPaymentOrder[] = [];\n    if (payload.isLoadMore) {\n      const existingPayments = this.payments?.items || [];\n      orders.push(...existingPayments);\n    }\n\n    this.payments = {\n      items: [...orders, ...payload.items],\n      totalCount: payload.totalCount || payload.items.length,\n    };\n\n    return this.payments;\n  }\n\n  private fetchPayments(params: GetPaymentOrdersRequestParams): Observable<PaymentsResponse> {\n    return this.paymentOrdersService.getPaymentOrders(params, 'response').pipe(\n      map(response => {\n        const totalCount = response.headers.get('x-total-count');\n        return {\n          totalCount: Number(totalCount),\n          items: response.body || [],\n        };\n      }),\n    );\n  }\n\n  private combinePaymentCalls(params: GetPaymentOrdersRequestParams): Observable<PaymentsResponse> {\n    /* Payment-order endpoint doesn't allow to make a call with both nextExecutionDateFrom and executionDateFrom parameters.\n     * nextExecutionDateFrom is needed for recurring payments, executionDateFrom is needed for both recurring and one-off payments\n     */\n    if (params.nextExecutionDateFrom && params.executionDateFrom) {\n      return this.handleMultipleCalls(params);\n    } else {\n      return this.fetchPayments(params);\n    }\n  }\n\n  private handleMultipleCalls(params: GetPaymentOrdersRequestParams) {\n    const { nextExecutionDateFrom, executionDateFrom, size, ...others } = params;\n    const sizePerCall = (size || 0) / 2; // Divide pageSize with 2 because there will be two calls\n    let callWithNextExecution = this.fetchPayments({ ...others, nextExecutionDateFrom, size: sizePerCall });\n    let callWithExecution = this.fetchPayments({ ...others, executionDateFrom, size: sizePerCall });\n\n    const hasMore = (totalCount: number) => (params?.from || 0) * sizePerCall < totalCount;\n    const mapPaymentCalls = (call: Observable<PaymentsResponse>, totalCount: number) => {\n      return hasMore(totalCount) ? call : of({ items: [], totalCount });\n    };\n\n    if (params.from && params.from > 0) {\n      callWithNextExecution = mapPaymentCalls(callWithNextExecution, this.totalCounts.withNextExecutionDate);\n      callWithExecution = mapPaymentCalls(callWithExecution, this.totalCounts.withExecutionDate);\n    }\n\n    return combineLatest([callWithExecution, callWithNextExecution]).pipe(\n      map(([firstCall, secondCall]) => {\n        const items = [...firstCall.items, ...secondCall.items];\n        this.totalCounts = {\n          withExecutionDate: firstCall.totalCount,\n          withNextExecutionDate: secondCall.totalCount,\n        };\n\n        return {\n          // Take highest value by multiplying it in order to produce load-more button logic correctly\n          totalCount: Math.max(firstCall.totalCount, secondCall.totalCount) * 2,\n          items: unifyItems(sortItems(items, params.direction || 'DESC')),\n        };\n      }),\n    );\n  }\n}\n"]}