import { __rest } from "tslib";
import { Injectable } from '@angular/core';
import { PaymentOrdersHttpService, } from '@backbase/data-ang/payment-order';
import { BehaviorSubject, combineLatest, merge, of, ReplaySubject, Subject } from 'rxjs';
import { distinctUntilChanged, filter, finalize, map, shareReplay, switchMap, tap } from 'rxjs/operators';
import { sortItems, unifyItems } from '../helpers/utils';
import { PaymentActionsTypes } from '../models/payments.model';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/payment-order";
export class PaymentService {
    constructor(paymentOrdersService) {
        this.paymentOrdersService = paymentOrdersService;
        this.loadMore$ = new BehaviorSubject(undefined);
        this.loadPayments$ = new ReplaySubject(1);
        this.returnCachedData$ = new Subject();
        this.loadingSub$ = new ReplaySubject(1);
        this.actingSub$ = new ReplaySubject(1);
        this.totalCounts = { withExecutionDate: 0, withNextExecutionDate: 0 };
        /**
         * Observable flag that checks whether a payment is loading
         */
        this.loading$ = this.loadingSub$.pipe(distinctUntilChanged());
        /**
         * Observable to check the payment type
         */
        this.acting$ = this.actingSub$.pipe(distinctUntilChanged());
        this.paymentActions$ = combineLatest([
            this.loadPayments$.pipe(map(params => (Object.assign({ type: PaymentActionsTypes.LoadPayments }, params)))),
            this.loadMore$.pipe(map(from => ({ type: PaymentActionsTypes.LoadMore, from }))),
        ]).pipe(map(([state, loadMore]) => (Object.assign(Object.assign({}, state), (loadMore.from ? loadMore : null)))), filter((action) => action.type !== undefined));
        this.paymentState$ = merge(this.paymentActions$, this.returnCachedData$.pipe(map(() => ({ type: PaymentActionsTypes.ReturnCachedData })))).pipe(switchMap((_a) => {
            var { type } = _a, params = __rest(_a, ["type"]);
            if (type === PaymentActionsTypes.ReturnCachedData) {
                return of(this.payments);
            }
            const isLoadMore = type === PaymentActionsTypes.LoadMore;
            this.loadingSub$.next(true);
            return this.combinePaymentCalls(params).pipe(map(response => this.handlePaymentSuccess(Object.assign(Object.assign({}, response), { isLoadMore }))), finalize(() => this.loadingSub$.next(false)));
        }), shareReplay());
    }
    /**
     * Getter for the payments
     */
    get payments$() {
        return this.paymentState$;
    }
    /**
     * Loads the upcoming payments
     *
     * @returns
     */
    loadPayments(params) {
        this.loadPayments$.next(params);
    }
    /**
     * Loads more payments
     *
     * @param from Loads from value
     * @returns
     */
    loadMore(from) {
        this.loadMore$.next(from);
    }
    /**
     * Cancels a payment order
     *
     * @param paymentOrderId Payment order id
     * @param version Payment version
     */
    cancelPayment(paymentOrderId, version) {
        this.actingSub$.next(true);
        return this.paymentOrdersService
            .postCancelByPaymentOrderId({
            paymentOrderId,
            paymentOrderCancelPostRequest: { version },
        }, 'response')
            .pipe(finalize(() => this.actingSub$.next(false)), tap(() => {
            this.handleCancelPaymentSuccess(paymentOrderId);
        }));
    }
    handleCancelPaymentSuccess(paymentOrderId) {
        if (this.payments) {
            const newItems = this.payments.items.filter(item => item.id !== paymentOrderId);
            this.payments = {
                items: newItems,
                totalCount: this.payments.totalCount,
            };
            this.returnCachedData$.next();
        }
    }
    handlePaymentSuccess(payload) {
        var _a;
        const orders = [];
        if (payload.isLoadMore) {
            const existingPayments = ((_a = this.payments) === null || _a === void 0 ? void 0 : _a.items) || [];
            orders.push(...existingPayments);
        }
        this.payments = {
            items: [...orders, ...payload.items],
            totalCount: payload.totalCount || payload.items.length,
        };
        return this.payments;
    }
    fetchPayments(params) {
        return this.paymentOrdersService.getPaymentOrders(params, 'response').pipe(map(response => {
            const totalCount = response.headers.get('x-total-count');
            return {
                totalCount: Number(totalCount),
                items: response.body || [],
            };
        }));
    }
    combinePaymentCalls(params) {
        /* Payment-order endpoint doesn't allow to make a call with both nextExecutionDateFrom and executionDateFrom parameters.
         * nextExecutionDateFrom is needed for recurring payments, executionDateFrom is needed for both recurring and one-off payments
         */
        if (params.nextExecutionDateFrom && params.executionDateFrom) {
            return this.handleMultipleCalls(params);
        }
        else {
            return this.fetchPayments(params);
        }
    }
    handleMultipleCalls(params) {
        const { nextExecutionDateFrom, executionDateFrom, size } = params, others = __rest(params, ["nextExecutionDateFrom", "executionDateFrom", "size"]);
        const sizePerCall = (size || 0) / 2; // Divide pageSize with 2 because there will be two calls
        let callWithNextExecution = this.fetchPayments(Object.assign(Object.assign({}, others), { nextExecutionDateFrom, size: sizePerCall }));
        let callWithExecution = this.fetchPayments(Object.assign(Object.assign({}, others), { executionDateFrom, size: sizePerCall }));
        const hasMore = (totalCount) => ((params === null || params === void 0 ? void 0 : params.from) || 0) * sizePerCall < totalCount;
        const mapPaymentCalls = (call, totalCount) => {
            return hasMore(totalCount) ? call : of({ items: [], totalCount });
        };
        if (params.from && params.from > 0) {
            callWithNextExecution = mapPaymentCalls(callWithNextExecution, this.totalCounts.withNextExecutionDate);
            callWithExecution = mapPaymentCalls(callWithExecution, this.totalCounts.withExecutionDate);
        }
        return combineLatest([callWithExecution, callWithNextExecution]).pipe(map(([firstCall, secondCall]) => {
            const items = [...firstCall.items, ...secondCall.items];
            this.totalCounts = {
                withExecutionDate: firstCall.totalCount,
                withNextExecutionDate: secondCall.totalCount,
            };
            return {
                // Take highest value by multiplying it in order to produce load-more button logic correctly
                totalCount: Math.max(firstCall.totalCount, secondCall.totalCount) * 2,
                items: unifyItems(sortItems(items, params.direction || 'DESC')),
            };
        }));
    }
}
/** @nocollapse */ PaymentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService, deps: [{ token: i1.PaymentOrdersHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ PaymentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.PaymentOrdersHttpService }]; } });
//# sourceMappingURL=payments.service.js.map