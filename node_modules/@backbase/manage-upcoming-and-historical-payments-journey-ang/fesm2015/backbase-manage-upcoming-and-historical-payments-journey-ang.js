import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, InjectionToken, Injectable, Optional, Inject, NgModule } from '@angular/core';
import * as i1 from '@backbase/ui-ang/modal';
import { ModalModule } from '@backbase/ui-ang/modal';
import * as i8 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import * as i1$1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from '@backbase/ui-ang/payment-card-number-pipe';
import { PaymentCardNumberModule } from '@backbase/ui-ang/payment-card-number-pipe';
import * as i1$2 from '@backbase/data-ang/payment-order';
import { Status } from '@backbase/data-ang/payment-order';
import * as i2$1 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import * as i3 from '@backbase/ui-ang/amount';
import { AmountModule } from '@backbase/ui-ang/amount';
import * as i4 from '@backbase/ui-ang/badge';
import { BadgeModule } from '@backbase/ui-ang/badge';
import * as i7 from '@backbase/ui-ang/tooltip-directive';
import { TooltipModule } from '@backbase/ui-ang/tooltip-directive';
import * as i5 from '@backbase/ui-ang/ellipsis';
import { EllipsisModule } from '@backbase/ui-ang/ellipsis';
import * as i2$2 from '@backbase/ui-ang/load-button';
import { LoadButtonModule } from '@backbase/ui-ang/load-button';
import * as i3$1 from '@backbase/ui-ang/empty-state';
import { EmptyStateModule } from '@backbase/ui-ang/empty-state';
import * as i3$2 from '@backbase/ui-ang/notification';
import { BehaviorSubject, ReplaySubject, Subject, combineLatest, merge, of } from 'rxjs';
import { distinctUntilChanged, map, filter, switchMap, finalize, shareReplay, tap, catchError, takeUntil } from 'rxjs/operators';
import { __rest } from 'tslib';
import * as i6 from '@backbase/ui-ang/loading-indicator';
import { LoadingIndicatorModule } from '@backbase/ui-ang/loading-indicator';
import '@angular/localize/init';
import * as i2$3 from '@backbase/ui-ang/header';
import { HeaderModule } from '@backbase/ui-ang/header';
import * as i1$3 from '@angular/router';
import { provideRoutes, RouterModule } from '@angular/router';
import * as i1$4 from '@backbase/foundation-ang/core';
import { BackbaseCoreModule } from '@backbase/foundation-ang/core';
import * as i3$3 from '@backbase/ui-ang/tab';
import { TabModule } from '@backbase/ui-ang/tab';

class CommunicationService {
}

class UpcomingPaymentsCancelPaymentConfirmationComponent {
    constructor() {
        this.modelOptions = {
            backdrop: 'static',
            keyboard: false,
        };
        /**
         * Indicator for confirmation dialog open state.
         * Default value is `false`.
         */
        this.isOpen = false;
        /**
         * Indicator for recurring payment state.
         * Default value is `false`.
         */
        this.isRecurring = false;
        /**
         * Changes will be triggered on keepPayment event emit.
         */
        this.keepPayment = new EventEmitter();
        /**
         * Changes will be triggered on cancelPayment event emit.
         */
        this.cancelPayment = new EventEmitter();
    }
    onKeepPaymentClick() {
        this.keepPayment.emit();
    }
    onCancelPaymentClick() {
        this.cancelPayment.emit();
    }
}
/** @nocollapse */ UpcomingPaymentsCancelPaymentConfirmationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsCancelPaymentConfirmationComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsCancelPaymentConfirmationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsCancelPaymentConfirmationComponent, selector: "bb-upcoming-payments-cancel-payment-confirmation", inputs: { isOpen: "isOpen", isRecurring: "isRecurring" }, outputs: { keepPayment: "keepPayment", cancelPayment: "cancelPayment" }, ngImport: i0, template: "<bb-modal-ui [isOpen]=\"isOpen\" [modalOptions]=\"modelOptions\">\n  <bb-modal-header-ui data-role=\"cancel-payment-confirmation-header\">\n    <ng-template bbCustomModalHeader>\n      <h2 i18n=\"Cancel payment|Dialog header@@upcoming-payments.recurring.confirm.dialog.header\">\n        {isRecurring, select, true {Cancel Recurring Payment?} other {Cancel Upcoming Payment?}}\n      </h2>\n    </ng-template>\n  </bb-modal-header-ui>\n\n  <bb-modal-body-ui data-role=\"cancel-payment-confirmation-body\">\n    <ng-template bbCustomModalBody>\n      <ng-container\n        i18n=\"\n          Confirmation message body|confirmation message for cancel payment\n          dialog@@upcoming-payments.confirm.dialog.body.message\"\n      >\n        {isRecurring, select, true {This recurring payment will be permanently cancelled.} other {This upcoming payment\n        will be permanently cancelled.}}\n      </ng-container>\n    </ng-template>\n  </bb-modal-body-ui>\n\n  <bb-modal-footer-ui #footerRef data-role=\"cancel-payment-confirmation-footer\">\n    <ng-template bbCustomModalFooter>\n      <div class=\"bb-button-bar\">\n        <button\n          bbButton\n          class=\"bb-button-bar__button\"\n          (click)=\"onCancelPaymentClick()\"\n          color=\"danger\"\n          data-role=\"cancel-payment-confirm-btn\"\n          i18n=\"Cancel payment|Request payment cancellation@@upcoming-payments.confirm.dialog.action.cancelPayment\"\n        >\n          Cancel payment\n        </button>\n\n        <button\n          bbButton\n          class=\"bb-button-bar__button\"\n          (click)=\"onKeepPaymentClick()\"\n          color=\"link\"\n          data-role=\"keep-payment-btn\"\n          i18n=\"\n            Keep payment|keep payment and close confirmation dialog@@upcoming-payments.confirm.dialog.action.keepPayment\"\n        >\n          Not now\n        </button>\n      </div>\n    </ng-template>\n  </bb-modal-footer-ui>\n</bb-modal-ui>\n", components: [{ type: i1.ModalComponent, selector: "bb-modal-ui", inputs: ["isOpen", "aria-labelledby", "aria-describedby", "modalOptions"], outputs: ["confirm", "cancel", "isOpenChange"] }, { type: i1.ModalHeaderComponent, selector: "bb-modal-header-ui", inputs: ["title"], outputs: ["close"] }, { type: i1.ModalBodyComponent, selector: "bb-modal-body-ui" }, { type: i1.ModalFooterComponent, selector: "bb-modal-footer-ui", inputs: ["confirmText", "cancelText"], outputs: ["confirm", "cancel"] }], directives: [{ type: i1.CustomModalHeaderDirective, selector: "ng-template[bbCustomModalHeader]" }, { type: i1.CustomModalBodyDirective, selector: "ng-template[bbCustomModalBody]" }, { type: i1.CustomModalFooterDirective, selector: "ng-template[bbCustomModalFooter]" }, { type: i8.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsCancelPaymentConfirmationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-cancel-payment-confirmation',
                    templateUrl: 'cancel-payment-confirmation.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { isOpen: [{
                type: Input
            }], isRecurring: [{
                type: Input
            }], keepPayment: [{
                type: Output
            }], cancelPayment: [{
                type: Output
            }] } });

const P2P_PAYMENT_TYPE = 'P2P_TRANSFER';
const P2P_REASON_CODES = {
    pending: 'PP01',
    inProcess: 'PP02',
};

class UpcomingPaymentsDetailsListComponent {
    constructor() {
        this.accountNumberFormat = {
            length: 36,
            maskRange: [0, -4],
            segments: 4,
        };
    }
    get transactionInformation() {
        var _a;
        return (_a = this.payment) === null || _a === void 0 ? void 0 : _a.transferTransactionInformation;
    }
    get originatorAccount() {
        var _a, _b, _c, _d, _e;
        return ((_b = (_a = this.transactionInformation) === null || _a === void 0 ? void 0 : _a.counterparty) === null || _b === void 0 ? void 0 : _b.role) === 'DEBTOR'
            ? (_d = (_c = this.payment) === null || _c === void 0 ? void 0 : _c.transferTransactionInformation) === null || _d === void 0 ? void 0 : _d.counterpartyAccount
            : (_e = this.payment) === null || _e === void 0 ? void 0 : _e.originatorAccount;
    }
    get counterPartyAccount() {
        var _a, _b, _c, _d, _e;
        return ((_b = (_a = this.transactionInformation) === null || _a === void 0 ? void 0 : _a.counterparty) === null || _b === void 0 ? void 0 : _b.role) === 'DEBTOR'
            ? (_c = this.payment) === null || _c === void 0 ? void 0 : _c.originatorAccount
            : (_e = (_d = this.payment) === null || _d === void 0 ? void 0 : _d.transferTransactionInformation) === null || _e === void 0 ? void 0 : _e.counterpartyAccount;
    }
    get paymentTypeInfo() {
        var _a, _b;
        const text = (_a = this.config) === null || _a === void 0 ? void 0 : _a.paymentTypeInfoTexts[((_b = this.payment) === null || _b === void 0 ? void 0 : _b.paymentType) || ''];
        return $localize `:@@upcoming-and-history-payments-details.payment-type-info:${text || ''}`;
    }
    get isAccountNumber() {
        var _a, _b, _c, _d;
        const scheme = (_d = (_c = (_b = (_a = this.payment) === null || _a === void 0 ? void 0 : _a.transferTransactionInformation) === null || _b === void 0 ? void 0 : _b.counterpartyAccount) === null || _c === void 0 ? void 0 : _c.identification) === null || _d === void 0 ? void 0 : _d.schemeName;
        return ['IBAN', 'BBAN'].includes(scheme || '');
    }
    get isP2PTransfer() {
        var _a;
        return ((_a = this.payment) === null || _a === void 0 ? void 0 : _a.paymentType) === P2P_PAYMENT_TYPE;
    }
}
/** @nocollapse */ UpcomingPaymentsDetailsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsDetailsListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsDetailsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsDetailsListComponent, selector: "bb-upcoming-payments-details-list", inputs: { payment: "payment", config: "config" }, ngImport: i0, template: "<div class=\"break-word bb-block bb-block--lg\">\n  <div class=\"bb-text-bold\" i18n=\"Paying From Account@@upcoming-payments.payment.details.fromAccount.name\">\n    From account\n  </div>\n  <div>\n    {{\n      transactionInformation?.counterparty?.role === 'DEBTOR'\n        ? transactionInformation?.counterparty?.name\n        : payment?.originator?.name\n    }}\n  </div>\n  <div class=\"bb-block bb-block--md\" data-role=\"paying-from-account\">\n    <div class=\"contextual-alternates-off\" *ngIf=\"config?.maskAccounts; else unmaskedAccount\">\n      {{ originatorAccount?.identification?.identification | paymentCardNumber: accountNumberFormat | slice: -14 }}\n    </div>\n    <ng-template #unmaskedAccount>\n      {{ originatorAccount?.identification?.identification }}\n    </ng-template>\n  </div>\n\n  <div class=\"bb-text-bold\" i18n=\"Counter Party Name@@upcoming-payments.payment.details.toAccount.details\">\n    To recipient\n  </div>\n  <div data-role=\"counter-party-name\">\n    {{\n      transactionInformation?.counterparty?.role === 'DEBTOR'\n        ? payment?.originator?.name\n        : transactionInformation?.counterparty?.name\n    }}\n  </div>\n  <div class=\"bb-block bb-block--md\" data-role=\"counter-party-account\">\n    <div\n      class=\"contextual-alternates-off\"\n      *ngIf=\"config?.maskAccounts && isAccountNumber; else unmaskedCounterpartyTemp\"\n    >\n      {{ counterPartyAccount?.identification?.identification | paymentCardNumber: accountNumberFormat | slice: -14 }}\n    </div>\n    <ng-template #unmaskedCounterpartyTemp>\n      {{ counterPartyAccount?.identification?.identification }}\n    </ng-template>\n  </div>\n  <ng-container *ngIf=\"payment?.paymentSetupId && isP2PTransfer\">\n    <div\n      class=\"bb-text-bold\"\n      i18n=\"@@upcoming-payments.payment.details.toAccount.confirmation-number\"\n      data-role=\"payment-details-confirmation-number-title\"\n    >\n      Confirmation number\n    </div>\n    <div data-role=\"payment-details-confirmation-number\">\n      {{ payment?.paymentSetupId }}\n    </div>\n  </ng-container>\n</div>\n\n<hr class=\"bb-block bb-block--lg\" />\n\n<ng-container *ngIf=\"payment?.paymentMode !== 'RECURRING'; else recurringTemp\">\n  <div class=\"bb-text-bold\" i18n=\"Execution Date@@upcoming-payments.payment.details.executionDate\">Send date</div>\n  <div class=\"bb-block bb-block--md\" data-role=\"execution-date\">\n    {{ payment?.schedule?.nextExecutionDate || payment?.requestedExecutionDate | date: 'longDate' }}\n  </div>\n</ng-container>\n\n<ng-template #recurringTemp>\n  <div class=\"bb-text-bold\" i18n=\"Start Date@@upcoming-payments.payment.details.schedule.startDate\">Start date</div>\n  <div class=\"bb-block bb-block--md\" data-role=\"start-date\">\n    {{ payment?.schedule?.startDate | date: 'longDate' }}\n  </div>\n\n  <ng-container *ngIf=\"payment?.schedule?.endDate\">\n    <div class=\"bb-text-bold\" i18n=\"End Date@@upcoming-payments.payment.details.schedule.endDate\">End date</div>\n    <div class=\"bb-block bb-block--md\" data-role=\"end-date\">\n      {{ payment?.schedule?.endDate | date: 'longDate' }}\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"payment?.schedule?.transferFrequency\">\n    <div class=\"bb-text-bold\" i18n=\"Recurring Frequency@@upcoming-payments.payment.details.schedule.transferFrequency\">\n      Frequency\n    </div>\n    <div class=\"bb-block bb-block--md\" data-role=\"recurring-frequency\">\n      {{ payment?.schedule?.transferFrequency | titlecase }}\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"payment?.schedule?.repeat\">\n    <div class=\"bb-text-bold\" i18n=\"Number of Occurrences@@upcoming-payments.payment.details.schedule.repeat\">\n      Number of occurrences\n    </div>\n    <div class=\"bb-block bb-block--md\">\n      {{ payment?.schedule?.repeat }}\n    </div>\n  </ng-container>\n</ng-template>\n\n<ng-container *ngIf=\"transactionInformation?.remittanceInformation\">\n  <div class=\"bb-text-bold\" i18n=\"Description@@upcoming-payments.payment.details.remittanceInformation.content\">\n    Description\n  </div>\n  <div class=\"bb-block bb-block--md break-word\" data-role=\"description\">\n    {{ transactionInformation?.remittanceInformation?.content }}\n  </div>\n</ng-container>\n\n<ng-container *ngIf=\"paymentTypeInfo\">\n  <hr class=\"bb-block bb-block--lg\" />\n  <div class=\"bb-text-bold\" i18n=\"@@upcoming-payments.payment.details.payment-type\">Payment Type</div>\n  <div class=\"bb-block bb-block--md break-word\">\n    {{ paymentTypeInfo }}\n  </div>\n</ng-container>\n", directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "slice": i1$1.SlicePipe, "paymentCardNumber": i2.PaymentCardNumberPipe, "date": i1$1.DatePipe, "titlecase": i1$1.TitleCasePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsDetailsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-details-list',
                    templateUrl: 'upcoming-payments-details-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { payment: [{
                type: Input
            }], config: [{
                type: Input
            }] } });

const mapPaymentOrdersToUpcomingPayments = (payments) => {
    return payments.reduce((acc, item) => {
        var _a;
        const executionDate = ((_a = item.schedule) === null || _a === void 0 ? void 0 : _a.nextExecutionDate) || item.requestedExecutionDate || '';
        const index = acc.findIndex(upcomingPayment => upcomingPayment.executionDate === executionDate);
        if (index <= -1) {
            acc.push({ executionDate, items: [item] });
        }
        else {
            acc[index].items.push(item);
        }
        return acc;
    }, []);
};
const mapStatusText = (payment) => {
    const reasonCodeMap = {
        [P2P_REASON_CODES.pending]: { text: 'Pending', color: 'warning' },
        [P2P_REASON_CODES.inProcess]: {
            text: 'Accepted by recipient',
            color: '',
        },
    };
    switch (payment === null || payment === void 0 ? void 0 : payment.status) {
        case Status.ACCEPTED:
            return (payment === null || payment === void 0 ? void 0 : payment.paymentType) === P2P_PAYMENT_TYPE ? reasonCodeMap[(payment === null || payment === void 0 ? void 0 : payment.reasonCode) || ''] : undefined;
        case Status.REJECTED:
            return { text: 'Rejected', color: 'danger' };
        case Status.CANCELLED:
            return { text: 'Cancelled', color: 'info' };
        case Status.PROCESSED:
            return { text: 'Sent to recipient', color: '' };
        default:
            return undefined;
    }
};

class UpcomingPaymentsDetailsComponent {
    constructor() {
        this.p2pReasonCodes = P2P_REASON_CODES;
        this.p2pPaymentType = P2P_PAYMENT_TYPE;
        /**
         * Indicator for details dialog open state.
         * Default value is `false`.
         */
        this.isOpen = false;
        /**
         * Changes will be triggered on cancelPayment event emit.
         */
        this.cancelPayment = new EventEmitter();
        /**
         * Changes will be triggered on close event emit.
         */
        this.close = new EventEmitter();
        /**
         * Changes will be triggered on editPayment event emit.
         */
        this.editPayment = new EventEmitter();
    }
    /**
     * Maps the status texts
     */
    get statusText() {
        const statusText = mapStatusText(this.payment);
        return (statusText && {
            text: $localize `:@@upcoming-payments-list-item-badge:${statusText.text}`,
            color: statusText.color,
        });
    }
    onCancelPayment() {
        this.cancelPayment.emit();
    }
    onClose() {
        this.isOpen = false;
        this.close.emit();
    }
    onEditPayment() {
        this.editPayment.emit(this.payment);
    }
}
/** @nocollapse */ UpcomingPaymentsDetailsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsDetailsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsDetailsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsDetailsComponent, selector: "bb-upcoming-payments-details", inputs: { isOpen: "isOpen", payment: "payment", config: "config" }, outputs: { cancelPayment: "cancelPayment", close: "close", editPayment: "editPayment" }, ngImport: i0, template: "<bb-modal-ui [isOpen]=\"isOpen\" (cancel)=\"onClose()\" (confirm)=\"onClose()\">\n  <bb-modal-header-ui>\n    <ng-template bbCustomModalHeader>\n      <div class=\"bb-upcoming-payments-details-header__wrapper bb-block--lg\">\n        <div class=\"bb-block--sm\">\n          <bb-icon-ui\n            [name]=\"payment?.paymentMode === 'RECURRING' ? 'repeat' : 'call-made'\"\n            [size]=\"'xl'\"\n            backgroundType=\"square\"\n            color=\"{{ payment?.paymentMode === 'RECURRING' ? 'secondary' : 'inactive' }}\"\n          ></bb-icon-ui>\n        </div>\n\n        <div\n          class=\"bb-text-bold bb-block--sm\"\n          *ngIf=\"payment?.transferTransactionInformation?.counterparty as counterparty\"\n        >\n          {{ counterparty?.role === 'DEBTOR' ? payment?.originator?.name : counterparty?.name }}\n        </div>\n\n        <div class=\"bb-heading-3 bb-block--sm\">\n          <bb-amount-ui\n            [currency]=\"payment?.transferTransactionInformation?.instructedAmount?.currencyCode\"\n            [amount]=\"payment?.transferTransactionInformation?.instructedAmount?.amount\"\n            [mapCurrency]=\"config?.uiComponentProps?.mapCurrency\"\n          ></bb-amount-ui>\n        </div>\n        <bb-badge-ui\n          *ngIf=\"statusText?.text && statusText?.color\"\n          color=\"{{ statusText?.color }}\"\n          text=\"{{ statusText?.text }}\"\n        ></bb-badge-ui>\n        <ng-container *ngIf=\"statusText?.text && !statusText?.color\">\n          <div class=\"bb-inline-stack\">\n            <span class=\"text-muted bb-stack__item bb-stack__item--spacing-sm\">{{ statusText?.text }}</span>\n            <span\n              bbTooltip=\"This payment can\u2019t be cancelled because it has already been accepted by the recipient.\"\n              i18n-bbTooltip=\"@@upcoming-payments-journey.payment-item.details-modal.tooltip\"\n              placement=\"bottom\"\n              triggers=\"hover\"\n            >\n              <bb-icon-ui name=\"info\" class=\"text-muted bb-stack\" size=\"sm\"></bb-icon-ui>\n            </span>\n          </div>\n        </ng-container>\n      </div>\n\n      <button\n        (click)=\"onClose()\"\n        type=\"button\"\n        class=\"bb-upcoming-payments-details__modal-header-button-close\"\n        aria-label=\"Close payment detail dialog\"\n        data-role=\"close-popup-btn\"\n        i18n-aria-label=\"Close payment detail dialog@@upcoming-payemnts.payment.details.header.close\"\n      >\n        <bb-icon-ui name=\"clear\" class=\"bb-stack\"></bb-icon-ui>\n      </button>\n    </ng-template>\n  </bb-modal-header-ui>\n\n  <bb-modal-body-ui>\n    <ng-template bbCustomModalBody>\n      <bb-upcoming-payments-details-list [payment]=\"payment\" [config]=\"config\"></bb-upcoming-payments-details-list>\n    </ng-template>\n  </bb-modal-body-ui>\n\n  <bb-modal-footer-ui #footerRef>\n    <ng-template bbCustomModalFooter>\n      <div class=\"bb-button-bar\" *ngIf=\"payment?.status === 'ACCEPTED'\">\n        <button\n          bbButton\n          *ngIf=\"!(payment?.reasonCode === p2pReasonCodes.inProcess)\"\n          class=\"bb-button-bar__button\"\n          (click)=\"onCancelPayment()\"\n          color=\"danger\"\n          data-role=\"cancel-payment-btn\"\n          i18n=\"Cancel payment|Cancel selected payment@@upcoming-payments.payment.details.action.cancel\"\n        >\n          Cancel payment\n        </button>\n\n        <button\n          bbButton\n          *ngIf=\"!(payment?.paymentType === p2pPaymentType)\"\n          (click)=\"onEditPayment()\"\n          class=\"bb-button-bar__button\"\n          i18n=\"Edit payment|Edit selected payment@@upcoming-payments.payment.details.action.edit\"\n          type=\"button\"\n        >\n          Edit\n        </button>\n      </div>\n    </ng-template>\n  </bb-modal-footer-ui>\n</bb-modal-ui>\n", components: [{ type: i1.ModalComponent, selector: "bb-modal-ui", inputs: ["isOpen", "aria-labelledby", "aria-describedby", "modalOptions"], outputs: ["confirm", "cancel", "isOpenChange"] }, { type: i1.ModalHeaderComponent, selector: "bb-modal-header-ui", inputs: ["title"], outputs: ["close"] }, { type: i2$1.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i3.AmountComponent, selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }, { type: i4.BadgeComponent, selector: "bb-badge-ui", inputs: ["color", "text", "abbr", "circle", "wrap", "ariaLabel"] }, { type: i1.ModalBodyComponent, selector: "bb-modal-body-ui" }, { type: UpcomingPaymentsDetailsListComponent, selector: "bb-upcoming-payments-details-list", inputs: ["payment", "config"] }, { type: i1.ModalFooterComponent, selector: "bb-modal-footer-ui", inputs: ["confirmText", "cancelText"], outputs: ["confirm", "cancel"] }], directives: [{ type: i1.CustomModalHeaderDirective, selector: "ng-template[bbCustomModalHeader]" }, { type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i7.TooltipDirective, selector: "[bbTooltip]", inputs: ["bbTooltip", "triggers"] }, { type: i1.CustomModalBodyDirective, selector: "ng-template[bbCustomModalBody]" }, { type: i1.CustomModalFooterDirective, selector: "ng-template[bbCustomModalFooter]" }, { type: i8.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsDetailsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-details',
                    templateUrl: 'upcoming-payments-details.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { isOpen: [{
                type: Input
            }], payment: [{
                type: Input
            }], config: [{
                type: Input
            }], cancelPayment: [{
                type: Output
            }], close: [{
                type: Output
            }], editPayment: [{
                type: Output
            }] } });

const getDateOnly = (dateArg = new Date()) => {
    const date = new Date(dateArg);
    const month = String(date.getMonth() + 1);
    const day = String(date.getDate());
    const year = String(date.getFullYear());
    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
};
const getRelativeDate = (next, ISOStringFormat) => {
    const date = new Date();
    if (next) {
        date.setDate(date.getDate() + next);
    }
    return ISOStringFormat ? date.toISOString() : getDateOnly(date);
};
const sortItems = (payments, sortDirection) => {
    return payments.sort((item1, item2) => {
        var _a, _b;
        const item1Date = ((_a = item1.schedule) === null || _a === void 0 ? void 0 : _a.nextExecutionDate) || item1.requestedExecutionDate;
        const item2Date = ((_b = item2.schedule) === null || _b === void 0 ? void 0 : _b.nextExecutionDate) || item2.requestedExecutionDate;
        const sortValue = new Date(item1Date || '').getTime() - new Date(item2Date || '').getTime();
        return sortDirection === 'ASC' ? sortValue : -sortValue;
    });
};
const unifyItems = (payments) => {
    return payments.reduce((result, item) => {
        const hasPeer = result.some(i => i.id === item.id);
        return hasPeer ? result : result.concat(item);
    }, []);
};

const ManageUpcomingAndHistoricalPaymentsJourneyConfigurationToken = new InjectionToken('ManageUpcomingAndHistoricalPaymentsJourneyConfigurationToken injection token');

const configDefaults = {
    notificationDismissTime: 3000,
    maskAccounts: false,
    upcomingPaymentParams: {
        orderBy: 'requestedExecutionDate',
        direction: 'ASC',
        status: ['ACCEPTED'],
        executionDateFrom: getDateOnly(),
        nextExecutionDateFrom: getDateOnly(),
        from: 0,
        size: 50,
    },
    historyPaymentParams: {
        orderBy: 'requestedExecutionDate',
        direction: 'DESC',
        status: ['CANCELLED', 'REJECTED', 'PROCESSED'],
        from: 0,
        size: 50,
    },
    paymentTypeInfoTexts: {
        INTERNAL_TRANSFER: 'Internal account transfer',
        INTRABANK_TRANSFER: 'Pay someone using account number',
        P2P_TRANSFER: 'Pay someone using mobile number or email address',
    },
    journeyTitle: 'Scheduled Transfers',
    uiComponentProps: {
        mapCurrency: true,
    },
};
class ManageUpcomingAndHistoricalPaymentsJourneyConfigService {
    constructor(config) {
        this.config = config;
        this._config = Object.assign(Object.assign({}, configDefaults), (this.config || {}));
    }
    get defaults() {
        return configDefaults;
    }
    get notificationDismissTime() {
        return this._config.notificationDismissTime;
    }
    get maskAccounts() {
        return this._config.maskAccounts;
    }
    get historyPaymentParams() {
        return this._config.historyPaymentParams;
    }
    get upcomingPaymentParams() {
        return this._config.upcomingPaymentParams;
    }
    get paymentTypeInfoTexts() {
        return this._config.paymentTypeInfoTexts;
    }
    get journeyTitle() {
        return this._config.journeyTitle;
    }
    get uiComponentProps() {
        return this._config.uiComponentProps;
    }
}
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService, deps: [{ token: ManageUpcomingAndHistoricalPaymentsJourneyConfigurationToken, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ManageUpcomingAndHistoricalPaymentsJourneyConfigurationToken]
                }] }]; } });

class UpcomingPaymentsItemComponent {
    constructor(communicatonService, config) {
        this.communicatonService = communicatonService;
        this.config = config;
        this.p2pReasonCodes = P2P_REASON_CODES;
        this.p2pPaymentType = P2P_PAYMENT_TYPE;
        /**
         * Changes will be triggered on cancelPayment event emit.
         */
        this.cancelPayment = new EventEmitter();
    }
    get transactionInformation() {
        var _a;
        return (_a = this.payment) === null || _a === void 0 ? void 0 : _a.transferTransactionInformation;
    }
    get schedule() {
        var _a, _b;
        return (_b = (_a = this.payment) === null || _a === void 0 ? void 0 : _a.schedule) === null || _b === void 0 ? void 0 : _b.transferFrequency;
    }
    get isRecurring() {
        var _a;
        return ((_a = this.payment) === null || _a === void 0 ? void 0 : _a.paymentMode) === 'RECURRING';
    }
    get statusText() {
        const statusText = mapStatusText(this.payment);
        return (statusText && {
            text: $localize `:@@upcoming-payments-list-item-badge:${statusText.text}`,
            color: statusText.color,
        });
    }
    onCancelClick(event) {
        event.stopPropagation();
        this.cancelPayment.emit();
    }
    onEditClick(event) {
        var _a;
        if (this.payment) {
            event.stopPropagation();
            (_a = this.communicatonService) === null || _a === void 0 ? void 0 : _a.navigateToEditPayment(this.payment);
        }
    }
}
/** @nocollapse */ UpcomingPaymentsItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsItemComponent, deps: [{ token: CommunicationService, optional: true }, { token: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsItemComponent, selector: "bb-upcoming-payments-item", inputs: { payment: "payment" }, outputs: { cancelPayment: "cancelPayment" }, ngImport: i0, template: "<div class=\"bb-stack\" data-role=\"upcoming-payment-item\">\n  <bb-icon-ui\n    name=\"{{ isRecurring ? 'repeat' : 'call-made' }}\"\n    class=\"bb-stack__item bb-stack__item--spacing-md\"\n    backgroundType=\"square\"\n    size=\"lg\"\n    color=\"{{ isRecurring ? 'secondary' : 'inactive' }}\"\n  ></bb-icon-ui>\n  <ng-container *ngIf=\"transactionInformation\">\n    <div class=\"bb-stack__item bb-stack__item--fill bb-ellipsis bb-ellipsis--single-line\">\n      <div class=\"bb-stack bb-block bb-block--xs\">\n        <span class=\"sr-only\" i18n=\"screenReader@@upcoming-payments.group.item.counterparty\">\n          Counter party name:\n        </span>\n        <div\n          class=\"bb-text-bold bb-stack__item bb-stack__item--spacing-md bb-ellipsis bb-ellipsis--single-line\"\n          data-role=\"upcoming-payment-item-counterparty-name\"\n        >\n          {{\n            transactionInformation?.counterparty?.role === 'DEBTOR'\n              ? payment?.originator?.name\n              : transactionInformation?.counterparty?.name\n          }}\n        </div>\n        <bb-badge-ui\n          *ngIf=\"statusText?.text && statusText?.color\"\n          class=\"bb-stack__item\"\n          color=\"{{ statusText?.color }}\"\n          text=\"{{ statusText?.text }}\"\n        ></bb-badge-ui>\n      </div>\n      <div class=\"bb-inline-stack text-muted bb-subtitle\">\n        <span i18n=\"@@upcoming-payments.group.item.from-label\">From&nbsp;</span>\n        <div class=\"bb-inline-stack__item bb-inline-stack__item--spacing-none bb-block bb-block--full-width\">\n          <bb-ellipsis-ui\n            [text]=\"\n              transactionInformation?.counterparty?.role === 'DEBTOR'\n                ? transactionInformation?.counterparty?.name\n                : payment?.originator?.name\n            \"\n          ></bb-ellipsis-ui>\n        </div>\n        <div *ngIf=\"payment?.paymentMode === 'RECURRING'\" class=\"bb-inline-stack__item\">\n          <span class=\"sr-only\" i18n=\"screenReader@@upcoming-payments.group.item.paymentMode\"> Payment Mode: </span>\n          <span> - {{ schedule | titlecase }} </span>\n        </div>\n      </div>\n    </div>\n    <div class=\"bb-stack__item bb-text-align-right\">\n      <div class=\"bb-block bb-block--xs bb-text-align-right bb-text-bold\">\n        <span class=\"sr-only\" i18n=\"screenReader@@upcoming-payments.group.item.amount\"> Amount: </span>\n        <bb-amount-ui\n          data-role=\"upcoming-payment-item-amount\"\n          [currency]=\"transactionInformation?.instructedAmount?.currencyCode\"\n          [amount]=\"transactionInformation?.instructedAmount?.amount\"\n          [mapCurrency]=\"config.uiComponentProps?.mapCurrency\"\n        ></bb-amount-ui>\n      </div>\n\n      <ng-container *ngIf=\"this.payment?.status === 'ACCEPTED'\">\n        <button\n          bbButton\n          *ngIf=\"!(payment?.paymentType === p2pPaymentType)\"\n          color=\"link-text\"\n          buttonSize=\"sm\"\n          class=\"bb-stack__item bb-stack__item--spacing-lg\"\n          (click)=\"onEditClick($event)\"\n          (keydown.enter)=\"onEditClick($event)\"\n          (keydown.space)=\"onEditClick($event)\"\n          i18n=\"@@upcoming-payments.group.item.button.edit\"\n        >\n          Edit\n        </button>\n        <button\n          bbButton\n          *ngIf=\"!(payment?.reasonCode === p2pReasonCodes.inProcess)\"\n          color=\"link-text\"\n          buttonSize=\"sm\"\n          class=\"bb-stack__item bb-text-warning bb-text-danger\"\n          (click)=\"onCancelClick($event)\"\n          (keydown.enter)=\"onCancelClick($event)\"\n          (keydown.space)=\"onCancelClick($event)\"\n          i18n=\"@@upcoming-payments.group.item.button.cancel\"\n          data-role=\"upcoming-payment-item-cancel-button\"\n        >\n          Cancel\n        </button>\n      </ng-container>\n      <ng-container *ngIf=\"payment?.reasonCode === p2pReasonCodes.inProcess && payment?.status === 'ACCEPTED'\">\n        <div class=\"bb-inline-stack\">\n          <span\n            class=\"text-muted bb-subtitle bb-stack__item bb-stack__item--spacing-xs\"\n            i18n=\"@@upcoming-payments-journey.payment-item.ready-status.text\"\n            >Accepted</span\n          >\n          <span\n            bbTooltip=\"This payment can\u2019t be cancelled or edited because it has already been accepted by the recipient.\"\n            i18n-bbTooltip=\"@@upcoming-payments-journey.payment-item.ready-status.tooltip\"\n            placement=\"bottom\"\n            triggers=\"hover\"\n          >\n            <bb-icon-ui name=\"info\" class=\"text-muted bb-stack\" size=\"sm\"></bb-icon-ui>\n          </span>\n        </div>\n      </ng-container>\n    </div>\n  </ng-container>\n</div>\n", components: [{ type: i2$1.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i4.BadgeComponent, selector: "bb-badge-ui", inputs: ["color", "text", "abbr", "circle", "wrap", "ariaLabel"] }, { type: i5.EllipsisComponent, selector: "bb-ellipsis-ui", inputs: ["text", "tooltipTriggers", "lineClamp"] }, { type: i3.AmountComponent, selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i7.TooltipDirective, selector: "[bbTooltip]", inputs: ["bbTooltip", "triggers"] }], pipes: { "titlecase": i1$1.TitleCasePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-item',
                    templateUrl: 'upcoming-payments-item.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: CommunicationService, decorators: [{
                    type: Optional
                }] }, { type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }]; }, propDecorators: { payment: [{
                type: Input
            }], cancelPayment: [{
                type: Output
            }] } });

class UpcomingPaymentsItemGroupComponent {
    constructor() {
        /**
         * Changes will be triggered on paymentItemClick event emit.
         */
        this.paymentItemClick = new EventEmitter();
        /**
         *On cancel event emit.
         */
        this.cancelPayment = new EventEmitter();
    }
    onPaymentItemClick(paymentItem) {
        this.paymentItemClick.emit(paymentItem);
    }
    trackPaymentItem(_, payment) {
        return payment ? payment.requestedExecutionDate : undefined;
    }
    formatExecutionDate() {
        var _a;
        let result = (_a = this.paymentsGroup) === null || _a === void 0 ? void 0 : _a.executionDate;
        if (result === getRelativeDate()) {
            result = 'today';
        }
        else if (result === getRelativeDate(1)) {
            result = 'tomorrow';
        }
        return result;
    }
    onCancelPayment(payment) {
        this.cancelPayment.emit(payment);
    }
}
/** @nocollapse */ UpcomingPaymentsItemGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsItemGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsItemGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsItemGroupComponent, selector: "bb-upcoming-payments-item-group", inputs: { paymentsGroup: "paymentsGroup" }, outputs: { paymentItemClick: "paymentItemClick", cancelPayment: "cancelPayment" }, ngImport: i0, template: "<!-- Execution date -->\n<div\n  class=\"bb-stack bb-subheader bb-text-support bb-block bb-block--xl\"\n  i18n=\"@@upcoming-payments.group.header\"\n  data-role=\"group-item-label\"\n>\n  {formatExecutionDate(), select, today {Today} tomorrow {Tomorrow} other\n  {{{ paymentsGroup?.executionDate | date:'longDate'}}} }\n</div>\n<!-- group of payments -->\n<ng-container *ngIf=\"paymentsGroup?.items?.length > 0\">\n  <div class=\"bb-block bb-block--sm\">\n    <ul class=\"bb-list\">\n      <li\n        *ngFor=\"let payment of paymentsGroup?.items; trackBy: trackPaymentItem\"\n        class=\"bb-list__item bb-list__item--no-separator\"\n      >\n        <div\n          data-role=\"group-item-row\"\n          role=\"button\"\n          tabindex=\"0\"\n          (keydown.enter)=\"onPaymentItemClick(payment)\"\n          (click)=\"onPaymentItemClick(payment)\"\n        >\n          <bb-upcoming-payments-item\n            [payment]=\"payment\"\n            (cancelPayment)=\"onCancelPayment(payment)\"\n          ></bb-upcoming-payments-item>\n        </div>\n      </li>\n    </ul>\n  </div>\n</ng-container>\n", components: [{ type: UpcomingPaymentsItemComponent, selector: "bb-upcoming-payments-item", inputs: ["payment"], outputs: ["cancelPayment"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "date": i1$1.DatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsItemGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-item-group',
                    templateUrl: './upcoming-payments-item-group.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { paymentsGroup: [{
                type: Input
            }], paymentItemClick: [{
                type: Output
            }], cancelPayment: [{
                type: Output
            }] } });

class UpcomingPaymentsListComponent {
    constructor() {
        /**
         * The upcoming payment list.
         */
        this.upcomingPayments = [];
        /**
         * Total count for payment.
         * Default value is `0`.
         */
        this.totalCount = 0;
        /**
         * Indicator for load more loading state.
         * Default value is `false`.
         */
        this.loading = false;
        /**
         * From parameter for load more payments request.
         * Default value is `0`.
         */
        this.loadMoreFrom = 0;
        /**
         * Size parameter for load more payments request.
         * Default value is `0`.
         */
        this.loadMoreSize = 0;
        /**
         * changes will be triggered on paymentItemClick event emit.
         */
        this.paymentItemClick = new EventEmitter();
        /**
         * changes will be triggered on loadMoreParam event emit.
         */
        this.loadMoreParam = new EventEmitter();
        /**
         *On cancel event emit.
         */
        this.cancelPayment = new EventEmitter();
    }
    loadMoreParamChange(event) {
        this.loadMoreFrom = event.from;
        this.loadMoreParam.emit(event);
    }
    onPaymentItemClick(paymentItem) {
        this.paymentItemClick.emit(paymentItem);
    }
    trackPaymentsGroup(_, paymentsGroup) {
        return paymentsGroup ? paymentsGroup.executionDate : undefined;
    }
    onCancelPayment(payment) {
        this.cancelPayment.emit(payment);
    }
    get hasMore() {
        const currentCount = this.loadMoreFrom * this.loadMoreSize + this.loadMoreSize;
        return currentCount < this.totalCount;
    }
}
/** @nocollapse */ UpcomingPaymentsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsListComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsListComponent, selector: "bb-upcoming-payments-list", inputs: { upcomingPayments: "upcomingPayments", totalCount: "totalCount", loading: "loading", loadMoreFrom: "loadMoreFrom", loadMoreSize: "loadMoreSize" }, outputs: { paymentItemClick: "paymentItemClick", loadMoreParam: "loadMoreParam", cancelPayment: "cancelPayment" }, ngImport: i0, template: "<ng-container *ngIf=\"upcomingPayments && upcomingPayments?.length > 0; else emptyState\">\n  <div class=\"bb-list bb-block bb-block--xl\">\n    <div class=\"bb-list__item\" *ngFor=\"let paymentsGroup of upcomingPayments; trackBy: trackPaymentsGroup\">\n      <bb-upcoming-payments-item-group\n        (paymentItemClick)=\"onPaymentItemClick($event)\"\n        [paymentsGroup]=\"paymentsGroup\"\n        (cancelPayment)=\"onCancelPayment($event)\"\n        data-role=\"upcoming-payment-group-item\"\n      ></bb-upcoming-payments-item-group>\n    </div>\n  </div>\n  <div class=\"bb-text-align-center\" *ngIf=\"hasMore || loading\">\n    <bb-load-button-ui\n      color=\"link\"\n      i18n=\"Load more payment|Load more button for loading more payments@@upcoming-payments.load.more\"\n      data-role=\"load-more-btn\"\n      [isLoading]=\"loading\"\n      [size]=\"loadMoreSize\"\n      [from]=\"loadMoreFrom\"\n      [totalCount]=\"totalCount\"\n      (paramChange)=\"loadMoreParamChange($event)\"\n    >\n      Load more\n    </bb-load-button-ui>\n  </div>\n</ng-container>\n<ng-template #emptyState>\n  <div class=\"bb-state-container\">\n    <bb-empty-state-ui\n      title=\"No Payments\"\n      i18n-title=\"@@upcoming-payments.no.payments.title\"\n      subtitle=\"You do not have any payments to be displayed.\"\n      i18n-subtitle=\"@@upcoming-payments.no.payments.subTitle\"\n      iconSize=\"xl\"\n      iconModifier=\"loans\"\n    ></bb-empty-state-ui>\n  </div>\n</ng-template>\n", components: [{ type: UpcomingPaymentsItemGroupComponent, selector: "bb-upcoming-payments-item-group", inputs: ["paymentsGroup"], outputs: ["paymentItemClick", "cancelPayment"] }, { type: i2$2.LoadButtonComponent, selector: "bb-load-button-ui", inputs: ["isLoading", "from", "size", "circle", "totalCount"], outputs: ["paramChange"] }, { type: i3$1.EmptyStateComponent, selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-list',
                    templateUrl: 'upcoming-payments-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { upcomingPayments: [{
                type: Input
            }], totalCount: [{
                type: Input
            }], loading: [{
                type: Input
            }], loadMoreFrom: [{
                type: Input
            }], loadMoreSize: [{
                type: Input
            }], paymentItemClick: [{
                type: Output
            }], loadMoreParam: [{
                type: Output
            }], cancelPayment: [{
                type: Output
            }] } });

var PaymentActionsTypes;
(function (PaymentActionsTypes) {
    PaymentActionsTypes["LoadPayments"] = "LoadPayments";
    PaymentActionsTypes["LoadMore"] = "LoadMore";
    PaymentActionsTypes["ReturnCachedData"] = "ReturnCachedPayments";
})(PaymentActionsTypes || (PaymentActionsTypes = {}));

class PaymentService {
    constructor(paymentOrdersService) {
        this.paymentOrdersService = paymentOrdersService;
        this.loadMore$ = new BehaviorSubject(undefined);
        this.loadPayments$ = new ReplaySubject(1);
        this.returnCachedData$ = new Subject();
        this.loadingSub$ = new ReplaySubject(1);
        this.actingSub$ = new ReplaySubject(1);
        this.totalCounts = { withExecutionDate: 0, withNextExecutionDate: 0 };
        /**
         * Observable flag that checks whether a payment is loading
         */
        this.loading$ = this.loadingSub$.pipe(distinctUntilChanged());
        /**
         * Observable to check the payment type
         */
        this.acting$ = this.actingSub$.pipe(distinctUntilChanged());
        this.paymentActions$ = combineLatest([
            this.loadPayments$.pipe(map(params => (Object.assign({ type: PaymentActionsTypes.LoadPayments }, params)))),
            this.loadMore$.pipe(map(from => ({ type: PaymentActionsTypes.LoadMore, from }))),
        ]).pipe(map(([state, loadMore]) => (Object.assign(Object.assign({}, state), (loadMore.from ? loadMore : null)))), filter((action) => action.type !== undefined));
        this.paymentState$ = merge(this.paymentActions$, this.returnCachedData$.pipe(map(() => ({ type: PaymentActionsTypes.ReturnCachedData })))).pipe(switchMap((_a) => {
            var { type } = _a, params = __rest(_a, ["type"]);
            if (type === PaymentActionsTypes.ReturnCachedData) {
                return of(this.payments);
            }
            const isLoadMore = type === PaymentActionsTypes.LoadMore;
            this.loadingSub$.next(true);
            return this.combinePaymentCalls(params).pipe(map(response => this.handlePaymentSuccess(Object.assign(Object.assign({}, response), { isLoadMore }))), finalize(() => this.loadingSub$.next(false)));
        }), shareReplay());
    }
    /**
     * Getter for the payments
     */
    get payments$() {
        return this.paymentState$;
    }
    /**
     * Loads the upcoming payments
     *
     * @returns
     */
    loadPayments(params) {
        this.loadPayments$.next(params);
    }
    /**
     * Loads more payments
     *
     * @param from Loads from value
     * @returns
     */
    loadMore(from) {
        this.loadMore$.next(from);
    }
    /**
     * Cancels a payment order
     *
     * @param paymentOrderId Payment order id
     * @param version Payment version
     */
    cancelPayment(paymentOrderId, version) {
        this.actingSub$.next(true);
        return this.paymentOrdersService
            .postCancelByPaymentOrderId({
            paymentOrderId,
            paymentOrderCancelPostRequest: { version },
        }, 'response')
            .pipe(finalize(() => this.actingSub$.next(false)), tap(() => {
            this.handleCancelPaymentSuccess(paymentOrderId);
        }));
    }
    handleCancelPaymentSuccess(paymentOrderId) {
        if (this.payments) {
            const newItems = this.payments.items.filter(item => item.id !== paymentOrderId);
            this.payments = {
                items: newItems,
                totalCount: this.payments.totalCount,
            };
            this.returnCachedData$.next();
        }
    }
    handlePaymentSuccess(payload) {
        var _a;
        const orders = [];
        if (payload.isLoadMore) {
            const existingPayments = ((_a = this.payments) === null || _a === void 0 ? void 0 : _a.items) || [];
            orders.push(...existingPayments);
        }
        this.payments = {
            items: [...orders, ...payload.items],
            totalCount: payload.totalCount || payload.items.length,
        };
        return this.payments;
    }
    fetchPayments(params) {
        return this.paymentOrdersService.getPaymentOrders(params, 'response').pipe(map(response => {
            const totalCount = response.headers.get('x-total-count');
            return {
                totalCount: Number(totalCount),
                items: response.body || [],
            };
        }));
    }
    combinePaymentCalls(params) {
        /* Payment-order endpoint doesn't allow to make a call with both nextExecutionDateFrom and executionDateFrom parameters.
         * nextExecutionDateFrom is needed for recurring payments, executionDateFrom is needed for both recurring and one-off payments
         */
        if (params.nextExecutionDateFrom && params.executionDateFrom) {
            return this.handleMultipleCalls(params);
        }
        else {
            return this.fetchPayments(params);
        }
    }
    handleMultipleCalls(params) {
        const { nextExecutionDateFrom, executionDateFrom, size } = params, others = __rest(params, ["nextExecutionDateFrom", "executionDateFrom", "size"]);
        const sizePerCall = (size || 0) / 2; // Divide pageSize with 2 because there will be two calls
        let callWithNextExecution = this.fetchPayments(Object.assign(Object.assign({}, others), { nextExecutionDateFrom, size: sizePerCall }));
        let callWithExecution = this.fetchPayments(Object.assign(Object.assign({}, others), { executionDateFrom, size: sizePerCall }));
        const hasMore = (totalCount) => ((params === null || params === void 0 ? void 0 : params.from) || 0) * sizePerCall < totalCount;
        const mapPaymentCalls = (call, totalCount) => {
            return hasMore(totalCount) ? call : of({ items: [], totalCount });
        };
        if (params.from && params.from > 0) {
            callWithNextExecution = mapPaymentCalls(callWithNextExecution, this.totalCounts.withNextExecutionDate);
            callWithExecution = mapPaymentCalls(callWithExecution, this.totalCounts.withExecutionDate);
        }
        return combineLatest([callWithExecution, callWithNextExecution]).pipe(map(([firstCall, secondCall]) => {
            const items = [...firstCall.items, ...secondCall.items];
            this.totalCounts = {
                withExecutionDate: firstCall.totalCount,
                withNextExecutionDate: secondCall.totalCount,
            };
            return {
                // Take highest value by multiplying it in order to produce load-more button logic correctly
                totalCount: Math.max(firstCall.totalCount, secondCall.totalCount) * 2,
                items: unifyItems(sortItems(items, params.direction || 'DESC')),
            };
        }));
    }
}
/** @nocollapse */ PaymentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService, deps: [{ token: i1$2.PaymentOrdersHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ PaymentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.PaymentOrdersHttpService }]; } });

class PaymentsListContainerComponent {
    constructor(journeyDataService, configService, notificationService, communicatonService) {
        this.journeyDataService = journeyDataService;
        this.configService = configService;
        this.notificationService = notificationService;
        this.communicatonService = communicatonService;
        this.openConfirmation = false;
        this.loadMoreFrom = 0;
        this.acting$ = this.journeyDataService.acting$;
        this.loading$ = this.journeyDataService.loading$;
        this.destroy$ = new Subject();
        /**
         * Flag if component is rendering history payments
         */
        this.isHistoryPayments = false;
    }
    get pageSize() {
        return this.isHistoryPayments
            ? this.configService.historyPaymentParams.size
            : this.configService.upcomingPaymentParams.size;
    }
    ngOnInit() {
        var _a;
        this.payments$ = (_a = this.payments$) === null || _a === void 0 ? void 0 : _a.pipe(catchError(error => {
            this.error = error;
            return of(undefined);
        }));
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onPaymentItemClick(selectedPaymentItem) {
        this.selectedPaymentItem = selectedPaymentItem;
    }
    onLoadMoreParam(params) {
        this.journeyDataService.loadMore(params.from);
        this.loadMoreFrom = this.loadMoreFrom + 1;
    }
    onConfirmCancelPayment(confirmed) {
        var _a, _b;
        this.openConfirmation = false;
        const paymentItem = this.paymentItemToCancel;
        this.paymentItemToCancel = undefined;
        if (!confirmed) {
            return;
        }
        this.selectedPaymentItem = undefined;
        if (paymentItem) {
            const creditorName = (_b = (_a = paymentItem.transferTransactionInformation) === null || _a === void 0 ? void 0 : _a.counterparty) === null || _b === void 0 ? void 0 : _b.name;
            const isRecurring = this.isRecurringPayment(paymentItem);
            this.journeyDataService
                .cancelPayment(paymentItem.id, paymentItem.version)
                .pipe(takeUntil(this.destroy$))
                .subscribe(() => {
                this.showNotification(true, {
                    header: $localize `:@@upcoming-payments-cancel-success-header:Payment cancelled`,
                    message: isRecurring
                        ? $localize `:@@upcoming-payments-cancel-success-msg-recurring:Recurring payment to "${creditorName}" has been cancelled successfully.`
                        : $localize `:@@upcoming-payments-cancel-success-msg:Upcoming payment to "${creditorName}" has been cancelled successfully.`,
                });
            }, () => {
                this.showNotification(false, {
                    header: $localize `:@@upcoming-payments-cancel-fail-header:Failed to Cancel Payment!`,
                    message: $localize `:@@upcoming-payments-cancel-fail-msg:Failed to cancel The payment to "${creditorName}".`,
                });
            });
        }
    }
    showNotification(success, notification) {
        this.notificationService.showNotification(Object.assign({ dismissible: true, ttl: this.configService.notificationDismissTime, modifier: success ? 'success' : 'error' }, notification));
    }
    isRecurringPayment(payment) {
        return (payment === null || payment === void 0 ? void 0 : payment.paymentMode) === 'RECURRING';
    }
    onCloseDetails() {
        this.selectedPaymentItem = undefined;
    }
    onCancelPayment(paymentItem) {
        this.paymentItemToCancel = paymentItem;
        this.openConfirmation = true;
    }
    onEditPayment(payment) {
        var _a;
        (_a = this.communicatonService) === null || _a === void 0 ? void 0 : _a.navigateToEditPayment(payment);
    }
}
/** @nocollapse */ PaymentsListContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentsListContainerComponent, deps: [{ token: PaymentService }, { token: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }, { token: i3$2.NotificationService }, { token: CommunicationService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ PaymentsListContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PaymentsListContainerComponent, selector: "bb-payments-list-container", inputs: { payments$: "payments$", isHistoryPayments: "isHistoryPayments" }, ngImport: i0, template: "<ng-container *ngIf=\"!error; else errorState\">\n  <ng-container *ngIf=\"payments$ | async as payments; else loadingPayments\">\n    <bb-upcoming-payments-list\n      *ngIf=\"!(acting$ | async); else acting\"\n      [upcomingPayments]=\"payments?.items\"\n      [totalCount]=\"payments?.totalCount\"\n      [loadMoreSize]=\"pageSize\"\n      [loadMoreFrom]=\"loadMoreFrom\"\n      [loading]=\"loading$ | async\"\n      (paymentItemClick)=\"onPaymentItemClick($event)\"\n      (loadMoreParam)=\"onLoadMoreParam($event)\"\n      (cancelPayment)=\"onCancelPayment($event)\"\n    ></bb-upcoming-payments-list>\n\n    <ng-template #acting>\n      <bb-loading-indicator-ui\n        text=\"updating data...\"\n        i18n-text=\"@@bb-upcoming-and-history-payments-journey.payment-list-container.acting-placeholder\"\n      ></bb-loading-indicator-ui>\n    </ng-template>\n\n    <bb-upcoming-payments-cancel-payment-confirmation\n      *ngIf=\"openConfirmation\"\n      [isOpen]=\"openConfirmation\"\n      [isRecurring]=\"isRecurringPayment(paymentItemToCancel)\"\n      (cancelPayment)=\"onConfirmCancelPayment(true)\"\n      (keepPayment)=\"onConfirmCancelPayment(false)\"\n    ></bb-upcoming-payments-cancel-payment-confirmation>\n\n    <bb-upcoming-payments-details\n      *ngIf=\"selectedPaymentItem\"\n      [isOpen]=\"!!selectedPaymentItem\"\n      (close)=\"onCloseDetails()\"\n      [payment]=\"selectedPaymentItem\"\n      [config]=\"configService\"\n      (cancelPayment)=\"onCancelPayment(selectedPaymentItem)\"\n      (editPayment)=\"onEditPayment(selectedPaymentItem)\"\n    ></bb-upcoming-payments-details>\n  </ng-container>\n</ng-container>\n\n<ng-template #loadingPayments>\n  <bb-loading-indicator-ui\n    text=\"Loading data...\"\n    text-i18n=\"@@bb-upcoming-and-history-payments-journey.payment-list-container.loading-placeholder\"\n  ></bb-loading-indicator-ui>\n</ng-template>\n\n<ng-template #errorState>\n  <div class=\"bb-state-container\">\n    <bb-empty-state-ui\n      i18n-title=\"@@upcoming-payments.history.error.generic.title\"\n      title=\"Page couldn't load\"\n      i18n-subtitle=\"@@upcoming-payments.history.error.generic.subtitle\"\n      subtitle=\"Try to reload the page or contact the system administrator.\"\n      iconSize=\"xxl\"\n      iconModifier=\"error\"\n    ></bb-empty-state-ui>\n  </div>\n</ng-template>\n", components: [{ type: UpcomingPaymentsListComponent, selector: "bb-upcoming-payments-list", inputs: ["upcomingPayments", "totalCount", "loading", "loadMoreFrom", "loadMoreSize"], outputs: ["paymentItemClick", "loadMoreParam", "cancelPayment"] }, { type: i6.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: UpcomingPaymentsCancelPaymentConfirmationComponent, selector: "bb-upcoming-payments-cancel-payment-confirmation", inputs: ["isOpen", "isRecurring"], outputs: ["keepPayment", "cancelPayment"] }, { type: UpcomingPaymentsDetailsComponent, selector: "bb-upcoming-payments-details", inputs: ["isOpen", "payment", "config"], outputs: ["cancelPayment", "close", "editPayment"] }, { type: i3$1.EmptyStateComponent, selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i1$1.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentsListContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-payments-list-container',
                    templateUrl: 'payments-list-container.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: PaymentService }, { type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }, { type: i3$2.NotificationService }, { type: CommunicationService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { payments$: [{
                type: Input
            }], isHistoryPayments: [{
                type: Input
            }] } });

class ManageUpcomingAndHistoricalPaymentsJourneyComponent {
    constructor(configService) {
        this.configService = configService;
    }
    get title() {
        return $localize `:@@upcoming-history-payments-journey-title:${this.configService.journeyTitle}`;
    }
}
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyComponent, deps: [{ token: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: ManageUpcomingAndHistoricalPaymentsJourneyComponent, selector: "bb-manage-upcoming-and-historical-payments-journey", ngImport: i0, template: `
    <ng-container>
      <bb-header-ui
        headingType="h2"
        headingClasses="bb-heading-1 bb-block bb-block--xl"
        [heading]="title"
        i18n-heading="@@upcoming-and-history-payments-journey.header"
      ></bb-header-ui>
      <router-outlet></router-outlet>
    </ng-container>
  `, isInline: true, components: [{ type: i2$3.HeaderComponent, selector: "bb-header-ui", inputs: ["headingClasses", "headingType", "heading"] }], directives: [{ type: i1$3.RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate"], exportAs: ["outlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-manage-upcoming-and-historical-payments-journey',
                    template: `
    <ng-container>
      <bb-header-ui
        headingType="h2"
        headingClasses="bb-heading-1 bb-block bb-block--xl"
        [heading]="title"
        i18n-heading="@@upcoming-and-history-payments-journey.header"
      ></bb-header-ui>
      <router-outlet></router-outlet>
    </ng-container>
  `,
                }]
        }], ctorParameters: function () { return [{ type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }]; } });

class ManageUpcomingAndHistoricalPaymentsNavigationService {
    constructor(router, route) {
        this.router = router;
        this.route = route;
    }
    /**
     * Navigation to history payments view tab
     */
    navigateToHistory(extras) {
        this.router.navigate(['history'], Object.assign({ relativeTo: this.route }, (extras || {})));
    }
    /**
     * Navigation to upcoming payments view tab
     */
    navigateToUpcoming(extras) {
        this.router.navigate(['upcoming'], Object.assign({ relativeTo: this.route }, (extras || {})));
    }
    /**
     * Method to return correct tab index in order to activate it
     */
    mapRouteToTabIndex() {
        const routeSections = this.router.url.split('/');
        return routeSections[routeSections.length - 1] === 'history' ? 1 : 0;
    }
}
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsNavigationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsNavigationService, deps: [{ token: i1$3.Router }, { token: i1$3.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsNavigationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsNavigationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsNavigationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$3.Router }, { type: i1$3.ActivatedRoute }]; } });

class HistoryPaymentsViewComponent {
    constructor(dataService, config) {
        this.dataService = dataService;
        this.config = config;
        this.payments$ = this.dataService.payments$.pipe(map(payload => payload && {
            items: mapPaymentOrdersToUpcomingPayments(payload.items),
            totalCount: payload.totalCount,
        }));
    }
    ngOnInit() {
        this.dataService.loadPayments(this.config.historyPaymentParams);
    }
}
/** @nocollapse */ HistoryPaymentsViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HistoryPaymentsViewComponent, deps: [{ token: PaymentService }, { token: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ HistoryPaymentsViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: HistoryPaymentsViewComponent, selector: "bb-history-payments-view", providers: [PaymentService], ngImport: i0, template: `
    <div class="card card-body">
      <bb-payments-list-container [payments$]="payments$" [isHistoryPayments]="true"> </bb-payments-list-container>
    </div>
  `, isInline: true, components: [{ type: PaymentsListContainerComponent, selector: "bb-payments-list-container", inputs: ["payments$", "isHistoryPayments"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HistoryPaymentsViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-history-payments-view',
                    template: `
    <div class="card card-body">
      <bb-payments-list-container [payments$]="payments$" [isHistoryPayments]="true"> </bb-payments-list-container>
    </div>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [PaymentService],
                }]
        }], ctorParameters: function () { return [{ type: PaymentService }, { type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }]; } });

class UpcomingAndHistoryPaymentsTabContainerViewComponent {
    constructor(navigationService, route) {
        this.navigationService = navigationService;
        this.route = route;
        this.initialTabSelection = 0;
    }
    ngOnInit() {
        this.initialTabSelection = this.navigationService.mapRouteToTabIndex();
    }
    onTabSelect(tabIndex) {
        if (tabIndex === 0) {
            this.navigationService.navigateToUpcoming({ relativeTo: this.route });
        }
        else {
            this.navigationService.navigateToHistory({ relativeTo: this.route });
        }
    }
}
/** @nocollapse */ UpcomingAndHistoryPaymentsTabContainerViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingAndHistoryPaymentsTabContainerViewComponent, deps: [{ token: ManageUpcomingAndHistoricalPaymentsNavigationService }, { token: i1$3.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingAndHistoryPaymentsTabContainerViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingAndHistoryPaymentsTabContainerViewComponent, selector: "bb-upcoming-and-history-payments-tab-container-view", ngImport: i0, template: "<bb-tab-group-ui\n  [initialSelection]=\"initialTabSelection\"\n  (select)=\"onTabSelect($event)\"\n  class=\"bb-upcoming-payments-tab-container\"\n>\n  <bb-tab-ui i18n=\"@@bb-upcoming-and-history-payments-journey.upcoming-tab\">Schedule</bb-tab-ui>\n  <bb-tab-ui i18n=\"@@bb-upcoming-and-history-payments-journey.history-tab\">History</bb-tab-ui>\n</bb-tab-group-ui>\n\n<router-outlet></router-outlet>\n", components: [{ type: i3$3.TabGroupComponent, selector: "bb-tab-group-ui", inputs: ["initialSelection"], outputs: ["select"] }, { type: i3$3.TabComponent, selector: "bb-tab-ui" }], directives: [{ type: i1$3.RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate"], exportAs: ["outlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingAndHistoryPaymentsTabContainerViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-and-history-payments-tab-container-view',
                    templateUrl: 'upcoming-and-history-payments-tab-container-view.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ManageUpcomingAndHistoricalPaymentsNavigationService }, { type: i1$3.ActivatedRoute }]; } });

class UpcomingPaymentsViewComponent {
    constructor(dataService, config) {
        this.dataService = dataService;
        this.config = config;
        this.payments$ = this.dataService.payments$.pipe(map(payload => payload && {
            items: mapPaymentOrdersToUpcomingPayments(payload.items),
            totalCount: payload.totalCount,
        }));
    }
    ngOnInit() {
        this.dataService.loadPayments(this.config.upcomingPaymentParams);
    }
}
/** @nocollapse */ UpcomingPaymentsViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsViewComponent, deps: [{ token: PaymentService }, { token: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ UpcomingPaymentsViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: UpcomingPaymentsViewComponent, selector: "bb-upcoming-payments-view", providers: [PaymentService], ngImport: i0, template: `
    <div class="card card-body">
      <bb-payments-list-container [payments$]="payments$"></bb-payments-list-container>
    </div>
  `, isInline: true, components: [{ type: PaymentsListContainerComponent, selector: "bb-payments-list-container", inputs: ["payments$", "isHistoryPayments"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: UpcomingPaymentsViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-upcoming-payments-view',
                    template: `
    <div class="card card-body">
      <bb-payments-list-container [payments$]="payments$"></bb-payments-list-container>
    </div>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [PaymentService],
                }]
        }], ctorParameters: function () { return [{ type: PaymentService }, { type: ManageUpcomingAndHistoricalPaymentsJourneyConfigService }]; } });

const defaultRoute = {
    path: '',
    component: ManageUpcomingAndHistoricalPaymentsJourneyComponent,
    children: [
        {
            path: '',
            component: UpcomingPaymentsViewComponent,
        },
    ],
};
const components = [
    ManageUpcomingAndHistoricalPaymentsJourneyComponent,
    UpcomingPaymentsViewComponent,
    HistoryPaymentsViewComponent,
    UpcomingAndHistoryPaymentsTabContainerViewComponent,
    PaymentsListContainerComponent,
    UpcomingPaymentsListComponent,
    UpcomingPaymentsItemGroupComponent,
    UpcomingPaymentsItemComponent,
    UpcomingPaymentsDetailsComponent,
    UpcomingPaymentsDetailsListComponent,
    UpcomingPaymentsCancelPaymentConfirmationComponent,
];
const uiModules = [
    TabModule,
    IconModule,
    AmountModule,
    LoadButtonModule,
    EmptyStateModule,
    LoadingIndicatorModule,
    ModalModule,
    ButtonModule,
    HeaderModule,
    PaymentCardNumberModule,
    TooltipModule,
    EllipsisModule,
    BadgeModule,
];
class ManageUpcomingAndHistoricalPaymentsJourneyModule {
    static forRoot(data = { route: defaultRoute }) {
        return {
            ngModule: ManageUpcomingAndHistoricalPaymentsJourneyModule,
            providers: [provideRoutes([data.route])],
        };
    }
}
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyModule, declarations: [ManageUpcomingAndHistoricalPaymentsJourneyComponent,
        UpcomingPaymentsViewComponent,
        HistoryPaymentsViewComponent,
        UpcomingAndHistoryPaymentsTabContainerViewComponent,
        PaymentsListContainerComponent,
        UpcomingPaymentsListComponent,
        UpcomingPaymentsItemGroupComponent,
        UpcomingPaymentsItemComponent,
        UpcomingPaymentsDetailsComponent,
        UpcomingPaymentsDetailsListComponent,
        UpcomingPaymentsCancelPaymentConfirmationComponent], imports: [CommonModule,
        RouterModule, i1$4.BackbaseCoreModule, TabModule,
        IconModule,
        AmountModule,
        LoadButtonModule,
        EmptyStateModule,
        LoadingIndicatorModule,
        ModalModule,
        ButtonModule,
        HeaderModule,
        PaymentCardNumberModule,
        TooltipModule,
        EllipsisModule,
        BadgeModule], exports: [TabModule,
        IconModule,
        AmountModule,
        LoadButtonModule,
        EmptyStateModule,
        LoadingIndicatorModule,
        ModalModule,
        ButtonModule,
        HeaderModule,
        PaymentCardNumberModule,
        TooltipModule,
        EllipsisModule,
        BadgeModule, ManageUpcomingAndHistoricalPaymentsJourneyComponent,
        UpcomingPaymentsViewComponent,
        HistoryPaymentsViewComponent,
        UpcomingAndHistoryPaymentsTabContainerViewComponent,
        PaymentsListContainerComponent,
        UpcomingPaymentsListComponent,
        UpcomingPaymentsItemGroupComponent,
        UpcomingPaymentsItemComponent,
        UpcomingPaymentsDetailsComponent,
        UpcomingPaymentsDetailsListComponent,
        UpcomingPaymentsCancelPaymentConfirmationComponent] });
/** @nocollapse */ ManageUpcomingAndHistoricalPaymentsJourneyModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyModule, providers: [
        ManageUpcomingAndHistoricalPaymentsJourneyConfigService,
        ManageUpcomingAndHistoricalPaymentsNavigationService,
    ], imports: [[
            CommonModule,
            RouterModule,
            BackbaseCoreModule.withConfig({
                classMap: {
                    ManageUpcomingAndHistoricalPaymentsJourneyComponent,
                },
            }),
            ...uiModules,
        ], TabModule,
        IconModule,
        AmountModule,
        LoadButtonModule,
        EmptyStateModule,
        LoadingIndicatorModule,
        ModalModule,
        ButtonModule,
        HeaderModule,
        PaymentCardNumberModule,
        TooltipModule,
        EllipsisModule,
        BadgeModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageUpcomingAndHistoricalPaymentsJourneyModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...components],
                    imports: [
                        CommonModule,
                        RouterModule,
                        BackbaseCoreModule.withConfig({
                            classMap: {
                                ManageUpcomingAndHistoricalPaymentsJourneyComponent,
                            },
                        }),
                        ...uiModules,
                    ],
                    providers: [
                        ManageUpcomingAndHistoricalPaymentsJourneyConfigService,
                        ManageUpcomingAndHistoricalPaymentsNavigationService,
                    ],
                    exports: [...uiModules, ...components],
                }]
        }] });

// Services

/**
 * Generated bundle index. Do not edit.
 */

export { HistoryPaymentsViewComponent, CommunicationService as ManageUpcomingAndHistoricalPaymentsCommunicationService, ManageUpcomingAndHistoricalPaymentsJourneyComponent, ManageUpcomingAndHistoricalPaymentsJourneyConfigService, ManageUpcomingAndHistoricalPaymentsJourneyConfigurationToken, ManageUpcomingAndHistoricalPaymentsJourneyModule, ManageUpcomingAndHistoricalPaymentsNavigationService, PaymentService, UpcomingAndHistoryPaymentsTabContainerViewComponent, UpcomingPaymentsViewComponent, PaymentsListContainerComponent as ӨPaymentsListContainerComponent, UpcomingPaymentsCancelPaymentConfirmationComponent as ӨUpcomingPaymentsCancelPaymentConfirmationComponent, UpcomingPaymentsDetailsComponent as ӨUpcomingPaymentsDetailsComponent, UpcomingPaymentsDetailsListComponent as ӨUpcomingPaymentsDetailsListComponent, UpcomingPaymentsItemComponent as ӨUpcomingPaymentsItemComponent, UpcomingPaymentsItemGroupComponent as ӨUpcomingPaymentsItemGroupComponent, UpcomingPaymentsListComponent as ӨUpcomingPaymentsListComponent };
//# sourceMappingURL=backbase-manage-upcoming-and-historical-payments-journey-ang.js.map
