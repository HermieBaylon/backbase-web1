import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import * as i2 from '@backbase/account-statement-common-ang';
import { LoadingState, DatePeriods, unixZeroDay, today, getTotalCountFromHeaders, AccountStatementCommonModule } from '@backbase/account-statement-common-ang';
import * as i1$1 from '@ngrx/store';
import { createAction, props, createReducer, on, createFeatureSelector, createSelector, StoreModule } from '@ngrx/store';
import { __rest } from 'tslib';
import { of } from 'rxjs';
import { withLatestFrom, switchMap, map, catchError } from 'rxjs/operators';
import { formatDate } from '@angular/common';
import { AccountStatementsPostRequest } from '@backbase/data-ang/account-statements';
import * as i1 from '@ngrx/effects';
import { createEffect, ofType, EffectsModule } from '@ngrx/effects';

const loadAccountStatementsBusinessToRequest = (_a, widgetPreferences) => {
    var { accountIds, filterParams, paginationParams, sortingParams } = _a, actionRequestParams = __rest(_a, ["accountIds", "filterParams", "paginationParams", "sortingParams"]);
    const { dateFrom, dateTo, category } = filterParams || {};
    const { minimalDate, maximumDate } = widgetPreferences || {};
    const params = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (accountIds && { accountIds })), (_hasDate(dateFrom, minimalDate) && {
        dateFrom: _getFormattedDate(dateFrom, minimalDate),
    })), (_hasDate(dateTo, maximumDate) && {
        dateTo: _getFormattedDate(dateTo, maximumDate),
    })), (category && { category })), (paginationParams && Object.assign({}, paginationParams))), (sortingParams &&
        sortingParams.direction && {
        direction: _mapSortingDirection(sortingParams.direction),
        orderBy: sortingParams.column,
    }));
    return { accountStatementsPostRequest: params };
};
/**
 * Check if date or default date exist
 *
 * @param date Optional date string
 * @param defaultDate Default date object if date is not present
 * @returns boolean
 */
const _hasDate = (date, defaultDate) => !!(date || defaultDate);
/**
 * Convert date into yyyy-MM-dd format
 *
 * @param date Optional date string
 * @param defaultDate Default date object if date is not present
 * @returns Date in format of yyyy-MM-dd
 */
const _getFormattedDate = (value, defaultDate) => {
    const date = value || defaultDate;
    return date && formatDate(new Date(date), 'yyyy-MM-dd', 'en-US');
};
/**
 * Convert direction of type 'asc' or 'desc' to 'ASC' or 'DESC'
 *
 * @param direction of type string
 * @returns sortingDirection of type AccountStatementsPostRequest.DirectionEnum
 */
const _mapSortingDirection = (direction) => direction === 'asc'
    ? AccountStatementsPostRequest.DirectionEnum.ASC
    : AccountStatementsPostRequest.DirectionEnum.DESC;

const loadAccountStatementsBusiness = createAction('[AS Account Statements] Load Account Statements for Business', props());
const loadAccountStatementsBusinessSuccess = createAction('[AS Account Statements] Load Account Statements for Business Success', props());
const loadAccountStatementsFailure = createAction('[AS Account Statements] Load Account Statements Failure', props());
const updateWidgetPreferences = createAction('[AS Accounts] Update Widget Preferences', props());

const accountStatementsInitialState = {
    data: [],
    totalCount: 0,
    loading: LoadingState.IDLE,
    error: undefined,
    accountIds: [],
    filterParams: {
        datePeriod: DatePeriods.AllTime,
    },
    widgetPreferences: {
        minimalDate: unixZeroDay(),
        maximumDate: today(),
    },
};
const smartLoadingState = (state, action) => {
    if (action.accountIds && action.accountIds !== state.accountIds)
        return LoadingState.LOADING;
    if (action.filterParams && action.filterParams !== state.filterParams)
        return LoadingState.LOADING_FILTERED;
    if (action.append)
        return LoadingState.LOADING_MORE;
    if ((action.sortingParams && action.sortingParams !== state.sortingParams) ||
        (action.paginationParams && action.paginationParams !== state.paginationParams)) {
        return LoadingState.LOADING_TABLE;
    }
    return LoadingState.LOADING;
};
const reducer$1 = createReducer(accountStatementsInitialState, on(loadAccountStatementsBusiness, (state, action) => (Object.assign(Object.assign({}, state), { loading: smartLoadingState(state, action), error: undefined }))), on(loadAccountStatementsBusinessSuccess, (state, action) => {
    const { accountStatements, accountIds, filterParams, paginationParams, sortingParams, totalCount, append } = action;
    const dataAppendTo = append ? state.data : [];
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, state), { loading: LoadingState.IDLE, data: [...dataAppendTo, ...accountStatements], totalCount }), (accountIds && { accountIds })), (filterParams && { filterParams })), (sortingParams && { sortingParams })), (paginationParams && { paginationParams }));
}), on(loadAccountStatementsFailure, (state, action) => (Object.assign(Object.assign({}, state), { error: action.error, loading: LoadingState.IDLE }))), on(updateWidgetPreferences, (state, action) => (Object.assign(Object.assign({}, state), { widgetPreferences: Object.assign(Object.assign({}, state.widgetPreferences), action.widgetPreferences) }))));
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function accountStatementsReducer(state, action) {
    return reducer$1(state, action);
}

const loadCategories = createAction('[AS Account Statements] Load Categories for Business');
const loadCategoriesSuccess = createAction('[AS Account Statements] Load Categories for Business Success', props());
const loadCategoriesFailure = createAction('[AS Account Statements] Load Categories for Business Failure', props());

const categoriesInitialState = {
    data: [],
    error: undefined,
};
const reducer = createReducer(categoriesInitialState, on(loadCategoriesSuccess, (state, { categories }) => (Object.assign(Object.assign({}, state), { data: categories }))), on(loadCategoriesFailure, (state, { error }) => (Object.assign(Object.assign({}, state), { data: [], error }))));
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function categoriesReducer(state, action) {
    return reducer(state, action);
}

const initialState = {
    accountStatements: accountStatementsInitialState,
    categories: categoriesInitialState,
};
/** Key for feature state used in NgRx StoreModule. */
const ACCOUNT_STATEMENTS_FEATURE_KEY = 'accountStatements';
const accountStatementsReducers = {
    accountStatements: accountStatementsReducer,
    categories: categoriesReducer,
};

const selectAccountStatements = createFeatureSelector(ACCOUNT_STATEMENTS_FEATURE_KEY);

const selectAccountStatementsState = createSelector(selectAccountStatements, accountStatementsState => accountStatementsState.accountStatements);
const accountStatements = createSelector(selectAccountStatementsState, (state) => state.data);
const accountStatementsLoading = createSelector(selectAccountStatementsState, (state) => state.loading);
const accountStatementsError = createSelector(selectAccountStatementsState, state => state.error);
const accountStatementsTotalCount = createSelector(selectAccountStatementsState, state => state.totalCount);
const accountStatementsAccountIds = createSelector(selectAccountStatementsState, state => state.accountIds);
const accountStatementsPaginationParams = createSelector(selectAccountStatementsState, state => state.paginationParams);
const accountStatementsSortingParams = createSelector(selectAccountStatementsState, state => state.sortingParams);
const accountStatementsFilterParams = createSelector(selectAccountStatementsState, state => state.filterParams);
const accountStatementsWidgetPreferences = createSelector(selectAccountStatementsState, state => state.widgetPreferences);

class AccountStatementEffects {
    constructor(actions$, dataService, store) {
        this.actions$ = actions$;
        this.dataService = dataService;
        this.store = store;
        this.accountStatementsBusiness$ = createEffect(() => this.actions$.pipe(ofType(loadAccountStatementsBusiness), withLatestFrom(this.store.select(accountStatementsAccountIds), this.store.select(accountStatementsFilterParams), this.store.select(accountStatementsSortingParams), this.store.select(accountStatementsPaginationParams), this.store.select(accountStatementsWidgetPreferences)), switchMap(([action, accountIds, filterParams, sortingParams, paginationParams, widgetPreferences]) => {
            const { append } = action, actionRequestParams = __rest(action, ["append"]);
            return this.dataService
                .getAccountStatementsBusiness(loadAccountStatementsBusinessToRequest(Object.assign({ accountIds,
                filterParams,
                sortingParams,
                paginationParams }, actionRequestParams), widgetPreferences))
                .pipe(map(response => loadAccountStatementsBusinessSuccess(Object.assign({ accountStatements: response.body, totalCount: getTotalCountFromHeaders(response.headers) }, action))), catchError(error => of(loadAccountStatementsFailure({ error }))));
        })));
    }
}
AccountStatementEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementEffects, deps: [{ token: i1.Actions }, { token: i2.AccountStatementDataService }, { token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Injectable });
AccountStatementEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i2.AccountStatementDataService }, { type: i1$1.Store }]; } });

class CategoriesEffects {
    constructor(actions$, dataService) {
        this.actions$ = actions$;
        this.dataService = dataService;
        this.loadCategories$ = createEffect(() => this.actions$.pipe(ofType(loadCategories), switchMap(() => this.dataService.loadCategories().pipe(map(response => loadCategoriesSuccess({ categories: response })), catchError(error => of(loadCategoriesFailure({ error })))))));
    }
}
CategoriesEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CategoriesEffects, deps: [{ token: i1.Actions }, { token: i2.AccountStatementDataService }], target: i0.ɵɵFactoryTarget.Injectable });
CategoriesEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CategoriesEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CategoriesEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i2.AccountStatementDataService }]; } });

class AccountStatementStoreModule {
}
AccountStatementStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AccountStatementStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModule, imports: [i1$1.StoreFeatureModule, i1.EffectsFeatureModule, AccountStatementCommonModule] });
AccountStatementStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModule, imports: [[
            StoreModule.forFeature(ACCOUNT_STATEMENTS_FEATURE_KEY, accountStatementsReducers),
            EffectsModule.forFeature([AccountStatementEffects, CategoriesEffects]),
            AccountStatementCommonModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        StoreModule.forFeature(ACCOUNT_STATEMENTS_FEATURE_KEY, accountStatementsReducers),
                        EffectsModule.forFeature([AccountStatementEffects, CategoriesEffects]),
                        AccountStatementCommonModule,
                    ],
                }]
        }] });

const selectCategoriesState = createSelector(selectAccountStatements, accountStatementsState => accountStatementsState.categories);
const selectCategories = createSelector(selectCategoriesState, (state) => state.data);
const selectCategoriesError = createSelector(selectCategoriesState, state => state.error);

class AccountStatementStoreModel {
    constructor(store) {
        this.store = store;
        this.accountStatements$ = this.store.select(accountStatements);
        this.accountStatementsLoading$ = this.store.select(accountStatementsLoading);
        this.accountStatementsError$ = this.store.select(accountStatementsError);
        this.accountStatementsTotalCount$ = this.store.select(accountStatementsTotalCount);
        this.accountStatementsPaginationParams$ = this.store.select(accountStatementsPaginationParams);
        this.accountStatementsSortingParams$ = this.store.select(accountStatementsSortingParams);
        this.accountStatementsFilterParams$ = this.store.select(accountStatementsFilterParams);
        this.accountStatementsWidgetPreferences$ = this.store.select(accountStatementsWidgetPreferences);
        this.categories$ = this.store.select(selectCategories);
    }
    dispatchLoadAccountStatementsBusiness(payload = {}) {
        this.store.dispatch(loadAccountStatementsBusiness(payload));
    }
    dispatchUpdateWidgetPreferences(payload) {
        this.store.dispatch(updateWidgetPreferences(payload));
    }
    dispatchLoadCategories() {
        this.store.dispatch(loadCategories());
    }
}
AccountStatementStoreModel.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModel, deps: [{ token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Injectable });
AccountStatementStoreModel.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModel });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AccountStatementStoreModel, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { AccountStatementStoreModel, AccountStatementStoreModule };
//# sourceMappingURL=backbase-account-statement-store-ang.js.map
