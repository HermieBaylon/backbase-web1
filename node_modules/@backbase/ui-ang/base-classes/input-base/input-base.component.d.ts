import { ChangeDetectorRef, EventEmitter, OnInit } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { DeprecationsService } from '@backbase/foundation-ang/future';
import * as i0 from "@angular/core";
export declare function getInputNextId(): string;
export declare const defaultSize = 20;
/**
 * @name InputBaseComponent
 *
 * @description
 * Base component for input fields.
 *
 * @a11y Current component provide option to pass needed accessibility
 * attributes to custom components
 */
export declare class InputBaseComponent implements OnInit, ControlValueAccessor {
    protected readonly cd: ChangeDetectorRef;
    protected readonly deprecationsService: DeprecationsService;
    private _id;
    private _labelClasses;
    onTouched: () => void;
    /**
     * The id for the input. Defaults to unique string.
     * Used to map the label to the input.
     */
    set id(value: string);
    get id(): string;
    /**
     * The label for the input. Defaults to an empty string.
     */
    label: string;
    private _role;
    /**
     * Customize the ARIA role for the HTML input/select/textarea element inside this component.
     *
     * This can be used to improve accessibility for components, for example by configuring `[role]="'combobox'"`
     * for a component that provides an autocomplete list.
     *
     * Values that are valid for the native HTML form elements are allowed.
     */
    set role(value: string | undefined);
    get role(): string | undefined;
    protected _size: number;
    /**
     * Configure the minimum width to fit the specified number of characters that should fit for HTML `<input>`
     */
    get size(): number | string;
    set size(arg: number | string);
    /**
     * Class names that must be included on the `<input>` form control
     */
    inputClassName: string | undefined;
    /**
     * It indicates whether inputting text could trigger display of one or more
     * predictions of the user's intended value for a combobox, searchbox, or textbox.
     */
    ariaAutocomplete: string | undefined;
    /**
     * It identifies the currently active element when focus is on a
     * composite widget, combobox, textbox, group, or application.
     */
    ariaActivedescendant: string | undefined;
    /**
     * When an interactive or input control has an impact on another element in a document or application,
     * the aria-control indicates which element or elements the user interface widget controls.
     */
    ariaControls: string | undefined;
    /**
     * Set aria-describedby  with an element id that contains a detailed decription of the widget.
     * It is used to establish a relationship between widgets or groups and the text that describes them.
     */
    ariaDescribedby: string | undefined;
    /**
     * The aria-expanded attribute is set on an element to indicate if a control is expanded or collapsed,
     * and whether or not its child elements are displayed or hidden.
     */
    ariaExpanded: string | undefined;
    /**
     * The aria-invalid state indicates the entered value is not in a format expected by the application.
     */
    ariaInvalid: string | undefined;
    /**
     * Accessible label when control does not need to render label tag.
     */
    ariaLabel: string | undefined;
    /**
     * The aria-labelledby property enables authors to reference other elements on the page to define an
     * accessible name. This is useful when using elements that don't have native support for associating
     * elements to provide an accessible name.
     */
    ariaLabelledby: string | undefined;
    /**
     * The aria-owns attribute identifies an element (or elements) in order to define a visual, functional, or
     * contextual relationship between a parent and its child elements when the DOM hierarchy cannot be used
     * to represent the relationship.
     */
    ariaOwns: string | undefined;
    /**
     * Whether the input is required. Defaults to false.
     */
    required: boolean;
    /**
     * Whether the input is read only. Defaults to false.
     */
    readonly: boolean;
    /**
     * An event emitter for on blur actions.
     */
    blur: EventEmitter<void | FocusEvent>;
    /**
     * An event emitter for on focus actions.
     */
    focus: EventEmitter<void | FocusEvent>;
    /**
     * Whether the text input should be auto-focused when shown.
     */
    autofocus: boolean;
    protected readonly _valueChange: EventEmitter<any>;
    disabled: boolean;
    value: Object | string | boolean | null;
    constructor(cd: ChangeDetectorRef, deprecationsService: DeprecationsService);
    ngOnInit(): void;
    onBlur($event?: FocusEvent): void;
    onChange: (newValue: Object | string | undefined | null) => void;
    onValueChange(newValue?: Object | string): void;
    onFocus($event?: FocusEvent): void;
    writeValue(inputValue: Object | string | null): void;
    registerOnChange(fn: () => void): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    /**
     * Returns the `input` `size` value for a keyword, such as "xxl".
     * Subclasses can choose to implement a custom mapping, which will be used to configure `size`.
     */
    protected getSizeByKeyword(arg: any): number | undefined;
    static ɵfac: i0.ɵɵFactoryDeclaration<InputBaseComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<InputBaseComponent, "ng-component", never, { "id": "id"; "label": "label"; "role": "role"; "size": "size"; "inputClassName": "inputClassName"; "ariaAutocomplete": "aria-autocomplete"; "ariaActivedescendant": "aria-activedescendant"; "ariaControls": "aria-controls"; "ariaDescribedby": "aria-describedby"; "ariaExpanded": "aria-expanded"; "ariaInvalid": "aria-invalid"; "ariaLabel": "aria-label"; "ariaLabelledby": "aria-labelledby"; "ariaOwns": "aria-owns"; "required": "required"; "readonly": "readonly"; "autofocus": "autofocus"; "disabled": "disabled"; }, { "blur": "blur"; "focus": "focus"; }, never, never>;
}
