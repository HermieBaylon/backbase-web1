(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@backbase/ui-ang/util'), require('@backbase/ui-ang/icon'), require('@backbase/ui-ang/focus'), require('@backbase/ui-ang/keyboard-click-directive'), require('@backbase/ui-ang/button'), require('rxjs'), require('rxjs/operators'), require('@ng-bootstrap/ng-bootstrap')) :
    typeof define === 'function' && define.amd ? define('@backbase/ui-ang/notification', ['exports', '@angular/core', '@angular/common', '@backbase/ui-ang/util', '@backbase/ui-ang/icon', '@backbase/ui-ang/focus', '@backbase/ui-ang/keyboard-click-directive', '@backbase/ui-ang/button', 'rxjs', 'rxjs/operators', '@ng-bootstrap/ng-bootstrap'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.backbase = global.backbase || {}, global.backbase["ui-ang"] = global.backbase["ui-ang"] || {}, global.backbase["ui-ang"].notification = {}), global.ng.core, global.ng.common, global.backbase["ui-ang"].util, global.backbase["ui-ang"].icon, global.backbase["ui-ang"].focus, global.backbase["ui-ang"]["keyboard-click-directive"], global.backbase["ui-ang"].button, global.rxjs, global.rxjs.operators, global.ngBootstrap));
})(this, (function (exports, i0, i3, util, i2, i4, i5, i6, rxjs, operators, ngBootstrap) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);
    var i4__namespace = /*#__PURE__*/_interopNamespace(i4);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);
    var i6__namespace = /*#__PURE__*/_interopNamespace(i6);

    var AppendToDomService = /** @class */ (function () {
        function AppendToDomService(componentFactoryResolver, appRef, injector) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.appRef = appRef;
            this.injector = injector;
        }
        AppendToDomService.prototype.appendComponentToRoot = function (component, autofocus, projectables, root) {
            var _this = this;
            if (autofocus === void 0) { autofocus = true; }
            if (projectables === void 0) { projectables = []; }
            if (root === void 0) { root = document.body; }
            var _a, _b;
            // 1. Create a component reference from the component
            var componentRef = this.componentFactoryResolver
                .resolveComponentFactory(component)
                .create(this.injector, [projectables]);
            // 2. Attach component to the appRef so that it's inside the ng component tree
            this.appRef.attachView(componentRef.hostView);
            // 3. Get DOM element from component
            var domElem = componentRef.hostView.rootNodes[0];
            // 4. Append notification list if missing
            var listElement = this.generateListElement(root);
            // 5. Add item class
            domElem.setAttribute('class', 'bb-notification-list__item');
            // 6. Set role='status' if autofocus is set to true and role='alert' if autofocus is set to false
            if (autofocus) {
                (_a = domElem === null || domElem === void 0 ? void 0 : domElem.firstElementChild) === null || _a === void 0 ? void 0 : _a.setAttribute('role', 'status');
            }
            else {
                componentRef.instance.autofocus = false;
                // For Firefox and NVDA role should be set to list element
                if (navigator.userAgent.indexOf('Firefox') > -1) {
                    listElement.setAttribute('role', 'alert');
                }
                else {
                    (_b = domElem === null || domElem === void 0 ? void 0 : domElem.firstElementChild) === null || _b === void 0 ? void 0 : _b.setAttribute('role', 'alert');
                }
            }
            // 7. Append new element to list of elements and push old ones down.
            if (listElement) {
                listElement.insertBefore(domElem, listElement.firstChild);
            }
            return {
                componentInstance: componentRef.instance,
                unmountComponent: function () {
                    _this.destroyElement(componentRef);
                },
            };
        };
        AppendToDomService.prototype.generateListElement = function (root) {
            var listElement = document.getElementsByClassName('bb-notification-list')[0];
            if (!listElement) {
                listElement = document.createElement('div');
                listElement.setAttribute('class', 'bb-notification-list');
                root.appendChild(listElement);
            }
            return listElement;
        };
        /*
          This method is a hack to make notifications visible to screen readers
          (NVDA and VoiceOver) when a modal window (role="dialog") is opened.
          aria-label="polite" on the list element and role="status" with
          aria-atomic="true" on notification element don't resolve the issue.
          Any better ideas are welcome.
         */
        AppendToDomService.prototype.checkAndDestroyListElement = function () {
            var listElement = document.getElementsByClassName('bb-notification-list')[0];
            // don't remove list element if there are any remaining notifications
            if (!listElement || listElement.childElementCount > 0) {
                return;
            }
            listElement.remove();
        };
        AppendToDomService.prototype.destroyElement = function (componentRef) {
            componentRef.instance.beforeDestroy();
            this.appRef.detachView(componentRef.hostView);
            componentRef.destroy();
            // is required to make notifications visible to screen readers when any modal window is opened
            this.checkAndDestroyListElement();
        };
        return AppendToDomService;
    }());
    AppendToDomService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: AppendToDomService, deps: [{ token: i0__namespace.ComponentFactoryResolver }, { token: i0__namespace.ApplicationRef }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    AppendToDomService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: AppendToDomService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: AppendToDomService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ComponentFactoryResolver }, { type: i0__namespace.ApplicationRef }, { type: i0__namespace.Injector }]; } });

    /**
     * A configuration service for the [NotificationComponent] component.
     *
     * You can inject this service, typically in your root component, and customize its properties
     * to provide default values for all alerts used in the application.
     */
    var BBNotificationConfig = /** @class */ (function () {
        function BBNotificationConfig() {
            this.animation = true;
        }
        return BBNotificationConfig;
    }());
    BBNotificationConfig.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BBNotificationConfig, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    BBNotificationConfig.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BBNotificationConfig, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BBNotificationConfig, decorators: [{
                type: i0.Injectable,
                args: [{ providedIn: 'root' }]
            }] });

    /**
     * @name NotificationComponent
     *
     * @description
     * Component that displays a notification.
     */
    // @dynamic to suppress error with resolving Document type during compilation
    var NotificationComponent = /** @class */ (function () {
        function NotificationComponent(document, elem, config) {
            var _this = this;
            this.document = document;
            this.elem = elem;
            /**
             * The message template for the notification. Defaults to an empty string
             */
            this.message = '';
            /**
             * The type modifier for the notification. Defaults to 'info'
             *
             * This property will be used to add additional class names to the wrapper div of the notification
             * in the following format: `bb-notification--<<modifier>>`
             *
             */
            this.modifier = 'info';
            /**
             * Whether the notification is dismissible. Defaults to `true`.
             *
             *
             * If `true` then an additional class name is added to the wrapper div of the notification in the following format
             * `bb-notification--dismissible`
             */
            this.dismissible = true;
            /**
             * The callback function for the manually close event.
             */
            this.closeAction = undefined;
            /**
             * The callback function for the host click event.
             */
            this.hostAction = undefined;
            /**
             * Notification manually close event stream.
             */
            this.close = new i0.EventEmitter();
            /**
             * Autofocus will cause the component to be focused on the first rendering.
             */
            this.autofocus = true;
            this.bemBlock = 'bb-notification';
            this.bemModifiers = [function () { return (_this.dismissible ? 'dismissible' : ''); }, function () { return _this.modifier; }];
            this.animation = config.animation;
        }
        Object.defineProperty(NotificationComponent.prototype, "dynamicClassNames", {
            get: function () {
                return util.getBemModifiers(this.bemBlock, this.bemModifiers);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NotificationComponent.prototype, "noAnimation", {
            get: function () {
                return !this.animation;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NotificationComponent.prototype, "animated", {
            get: function () {
                return this.animation;
            },
            enumerable: false,
            configurable: true
        });
        NotificationComponent.prototype.onKeyEvent = function (event) {
            switch (event.key) {
                case 'Escape':
                    this.onNotificationClose();
                    break;
                default:
                    return;
            }
            event.preventDefault();
        };
        NotificationComponent.prototype.ngOnInit = function () {
            if (this.hasPrimaryAction() && typeof this.primaryActionText === 'undefined') {
                throw new Error("\"primaryActionText\" input is required when a primaryAction is set in \"" + this.constructor.name + "\"");
            }
            if (this.hasSecondaryAction() && typeof this.secondaryActionText === 'undefined') {
                throw new Error("\"secondaryActionText\" input is required when a secondaryAction is set in \"" + this.constructor.name + "\"");
            }
            this.iconColor = this.modifier === 'error' ? 'danger' : this.modifier;
        };
        NotificationComponent.prototype.ngAfterViewInit = function () {
            if (document.activeElement instanceof HTMLElement) {
                this.previousFocusedElement = document.activeElement;
            }
        };
        Object.defineProperty(NotificationComponent.prototype, "hostTabIndex", {
            get: function () {
                return this.hostAction ? 0 : -1;
            },
            enumerable: false,
            configurable: true
        });
        NotificationComponent.prototype.onNotificationClick = function () {
            if (this.hostAction) {
                this.hostAction();
                this.close.emit();
            }
        };
        NotificationComponent.prototype.onNotificationClose = function () {
            if (this.closeAction) {
                this.closeAction();
            }
            this.close.emit();
        };
        NotificationComponent.prototype.beforeDestroy = function () {
            var _this = this;
            var notificationList = this.document.querySelector('.bb-notification-list');
            var isNotificationListFocused = notificationList && notificationList.contains(this.document.activeElement);
            if (notificationList && isNotificationListFocused) {
                var notificationBtns = notificationList.querySelectorAll('.bb-notification__close');
                var currentIndex = Array.from(notificationList.children).findIndex(function (listElement) { return listElement === _this.elem.nativeElement; });
                var nextElementToFocus = notificationBtns[currentIndex + 1] || notificationBtns[currentIndex - 1] || this.previousFocusedElement;
                if (nextElementToFocus) {
                    nextElementToFocus.focus();
                }
            }
        };
        NotificationComponent.prototype.onPrimaryPress = function () {
            if (this.primaryAction) {
                this.primaryAction();
                this.onNotificationClose();
            }
        };
        NotificationComponent.prototype.onSecondaryPress = function () {
            if (this.secondaryAction) {
                this.secondaryAction();
                this.onNotificationClose();
            }
        };
        NotificationComponent.prototype.getHeaderTemplate = function () {
            if (this.header instanceof i0.TemplateRef) {
                return this.header;
            }
            return this.defaultHeaderTemplate;
        };
        NotificationComponent.prototype.getMessageTemplate = function () {
            if (this.message instanceof i0.TemplateRef) {
                return this.message;
            }
            return this.defaultMessageTemplate;
        };
        NotificationComponent.prototype.hasButtonRow = function () {
            return this.hasPrimaryAction() || this.hasSecondaryAction();
        };
        NotificationComponent.prototype.hasPrimaryAction = function () {
            return this.primaryAction !== undefined;
        };
        NotificationComponent.prototype.hasSecondaryAction = function () {
            return this.secondaryAction !== undefined;
        };
        return NotificationComponent;
    }());
    NotificationComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationComponent, deps: [{ token: i3.DOCUMENT }, { token: i0__namespace.ElementRef }, { token: BBNotificationConfig }], target: i0__namespace.ɵɵFactoryTarget.Component });
    NotificationComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationComponent, selector: "bb-notification-ui", inputs: { header: "header", message: "message", primaryActionTemplate: "primaryActionTemplate", secondaryActionTemplate: "secondaryActionTemplate", modifier: "modifier", dismissible: "dismissible", primaryActionText: "primaryActionText", primaryAction: "primaryAction", secondaryActionText: "secondaryActionText", secondaryAction: "secondaryAction", closeAction: "closeAction", hostAction: "hostAction", headerContext: "headerContext", messageContext: "messageContext", animation: "animation" }, outputs: { close: "close" }, host: { listeners: { "window:keydown": "onKeyEvent($event)" }, properties: { "@.disabled": "this.noAnimation", "@fadeSlideInOut": "this.animated" } }, viewQueries: [{ propertyName: "notificationContent", first: true, predicate: ["notificationContent"], descendants: true }, { propertyName: "defaultHeaderTemplate", first: true, predicate: ["defaultNotificationHeaderTemplate"], descendants: true, static: true }, { propertyName: "defaultMessageTemplate", first: true, predicate: ["defaultNotificationMessageTemplate"], descendants: true, static: true }, { propertyName: "defaultPrimaryActionsTemplate", first: true, predicate: ["defaultPrimaryActionsTemplate"], descendants: true, static: true }, { propertyName: "defaultSecondaryActionsTemplate", first: true, predicate: ["defaultSecondaryActionsTemplate"], descendants: true, static: true }], ngImport: i0__namespace, template: "<div\n  class=\"bb-notification\"\n  [ngClass]=\"dynamicClassNames\"\n  data-role=\"notification-alert\"\n  #notificationContent\n  [bbFocus]=\"autofocus\"\n  [attr.tabindex]=\"hostTabIndex\"\n  (bbKeyboardClick)=\"onNotificationClick()\"\n>\n  <bb-icon-ui\n    [name]=\"modifier\"\n    [color]=\"iconColor\"\n    class=\"bb-notification__icon\"\n    [attr.data-role]=\"'notification-icon'\"\n  ></bb-icon-ui>\n  <div class=\"bb-notification__body\">\n    <div class=\"bb-notification__title\" data-role=\"notification-heading\">\n      <ng-container *ngTemplateOutlet=\"getHeaderTemplate(); context: headerContext\"></ng-container>\n    </div>\n    <div data-role=\"notification-message\" class=\"bb-text-support\">\n      <ng-container *ngTemplateOutlet=\"getMessageTemplate(); context: messageContext\"></ng-container>\n    </div>\n    <div\n      data-role=\"notification-actions\"\n      *ngIf=\"primaryActionTemplate || primaryActionText || secondaryActionTemplate || secondaryActionText\"\n    >\n      <div class=\"bb-button-bar\">\n        <button\n          *ngIf=\"hasPrimaryAction()\"\n          bbButton\n          type=\"button\"\n          data-role=\"notification-primary-button\"\n          class=\"bb-button-bar__button\"\n          (click)=\"onPrimaryPress()\"\n        >\n          <ng-container *ngIf=\"primaryActionTemplate; else defaultPrimaryActionsTemplate\">\n            <ng-container *ngTemplateOutlet=\"primaryActionTemplate; context: this\"></ng-container>\n          </ng-container>\n        </button>\n        <button\n          bbButton\n          color=\"secondary\"\n          *ngIf=\"hasSecondaryAction()\"\n          data-role=\"notification-secondary-button\"\n          class=\"bb-button-bar__button\"\n          (click)=\"onSecondaryPress()\"\n        >\n          <ng-container *ngIf=\"secondaryActionTemplate; else defaultSecondaryActionsTemplate\">\n            <ng-container *ngTemplateOutlet=\"secondaryActionTemplate; context: this\"></ng-container>\n          </ng-container>\n        </button>\n      </div>\n    </div>\n  </div>\n  <button\n    *ngIf=\"dismissible\"\n    (click)=\"onNotificationClose()\"\n    type=\"button\"\n    data-role=\"notification-close-button\"\n    class=\"bb-notification__close close\"\n    aria-label=\"Close\"\n    i18n-aria-label=\"Close notification button| Text for the close notification button @@bb-notification-ui.close\"\n  >\n    <bb-icon-ui name=\"times\"></bb-icon-ui>\n  </button>\n</div>\n\n<ng-template #defaultNotificationHeaderTemplate>\n  <div [ngClass]=\"{ 'bb-block bb-block--sm': !!header }\">\n    {{ header }}\n  </div>\n</ng-template>\n\n<ng-template #defaultNotificationMessageTemplate>\n  {{ message }}\n</ng-template>\n\n<ng-template #defaultPrimaryActionsTemplate>\n  {{ primaryActionText }}\n</ng-template>\n\n<ng-template #defaultSecondaryActionsTemplate>\n  {{ secondaryActionText }}\n</ng-template>\n", components: [{ type: i2__namespace.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i3__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i4__namespace.FocusDirective, selector: "[bbFocus]", inputs: ["bbFocus"], exportAs: ["bbFocus"] }, { type: i5__namespace.KeyboardClickDirective, selector: "[bbKeyboardClick]", outputs: ["bbKeyboardClick"] }, { type: i3__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i3__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6__namespace.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], animations: [util.fadeSlideAnimation] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-notification-ui',
                        templateUrl: './notification.component.html',
                        animations: [util.fadeSlideAnimation],
                    }]
            }], ctorParameters: function () {
            return [{ type: Document, decorators: [{
                            type: i0.Inject,
                            args: [i3.DOCUMENT]
                        }] }, { type: i0__namespace.ElementRef }, { type: BBNotificationConfig }];
        }, propDecorators: { header: [{
                    type: i0.Input
                }], message: [{
                    type: i0.Input
                }], primaryActionTemplate: [{
                    type: i0.Input
                }], secondaryActionTemplate: [{
                    type: i0.Input
                }], modifier: [{
                    type: i0.Input
                }], dismissible: [{
                    type: i0.Input
                }], primaryActionText: [{
                    type: i0.Input
                }], primaryAction: [{
                    type: i0.Input
                }], secondaryActionText: [{
                    type: i0.Input
                }], secondaryAction: [{
                    type: i0.Input
                }], closeAction: [{
                    type: i0.Input
                }], hostAction: [{
                    type: i0.Input
                }], headerContext: [{
                    type: i0.Input
                }], messageContext: [{
                    type: i0.Input
                }], animation: [{
                    type: i0.Input
                }], close: [{
                    type: i0.Output
                }], notificationContent: [{
                    type: i0.ViewChild,
                    args: ['notificationContent']
                }], defaultHeaderTemplate: [{
                    type: i0.ViewChild,
                    args: ['defaultNotificationHeaderTemplate', { static: true }]
                }], defaultMessageTemplate: [{
                    type: i0.ViewChild,
                    args: ['defaultNotificationMessageTemplate', { static: true }]
                }], defaultPrimaryActionsTemplate: [{
                    type: i0.ViewChild,
                    args: ['defaultPrimaryActionsTemplate', { static: true }]
                }], defaultSecondaryActionsTemplate: [{
                    type: i0.ViewChild,
                    args: ['defaultSecondaryActionsTemplate', { static: true }]
                }], noAnimation: [{
                    type: i0.HostBinding,
                    args: ['@.disabled']
                }], animated: [{
                    type: i0.HostBinding,
                    args: ['@fadeSlideInOut']
                }], onKeyEvent: [{
                    type: i0.HostListener,
                    args: ['window:keydown', ['$event']]
                }] } });

    var NotificationService = /** @class */ (function () {
        function NotificationService(appendtoDomService) {
            this.appendtoDomService = appendtoDomService;
        }
        NotificationService.prototype.showNotification = function (_a) {
            var header = _a.header, message = _a.message, _b = _a.dismissible, dismissible = _b === void 0 ? true : _b, _c = _a.ttl, ttl = _c === void 0 ? 3000 : _c, _d = _a.modifier, modifier = _d === void 0 ? 'info' : _d, _e = _a.headerContext, headerContext = _e === void 0 ? {} : _e, _f = _a.messageContext, messageContext = _f === void 0 ? {} : _f, primaryActionText = _a.primaryActionText, primaryAction = _a.primaryAction, secondaryActionText = _a.secondaryActionText, secondaryAction = _a.secondaryAction, closeAction = _a.closeAction, hostAction = _a.hostAction, primaryActionTemplate = _a.primaryActionTemplate, secondaryActionTemplate = _a.secondaryActionTemplate, _g = _a.autofocus, autofocus = _g === void 0 ? true : _g;
            var res = this.appendtoDomService.appendComponentToRoot(NotificationComponent, autofocus);
            var componentInstance = res.componentInstance;
            componentInstance.message = message;
            componentInstance.modifier = modifier;
            componentInstance.dismissible = dismissible;
            componentInstance.header = header;
            componentInstance.primaryActionText = primaryActionText;
            componentInstance.primaryAction = primaryAction;
            componentInstance.secondaryActionText = secondaryActionText;
            componentInstance.secondaryAction = secondaryAction;
            componentInstance.closeAction = closeAction;
            componentInstance.hostAction = hostAction;
            componentInstance.headerContext = headerContext;
            componentInstance.messageContext = messageContext;
            componentInstance.primaryActionTemplate = primaryActionTemplate;
            componentInstance.secondaryActionTemplate = secondaryActionTemplate;
            return this.createHideNotificationFunction(res.unmountComponent, ttl, componentInstance.close);
        };
        NotificationService.prototype.createHideNotificationFunction = function (hideFn, ttl, closeStream) {
            if (ttl === void 0) { ttl = 0; }
            var hideSubject = new rxjs.Subject();
            var hideNotification = function () {
                hideSubject.next();
            };
            var closeSubscription = closeStream.subscribe(hideNotification);
            var hideSubscription = hideSubject.pipe(operators.first()).subscribe(function () {
                hideFn();
                hideSubscription.unsubscribe();
                closeSubscription.unsubscribe();
            });
            if (ttl > 0) {
                setTimeout(hideNotification, ttl);
            }
            return hideNotification;
        };
        return NotificationService;
    }());
    NotificationService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationService, deps: [{ token: AppendToDomService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NotificationService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () { return [{ type: AppendToDomService }]; } });

    var NotificationModule = /** @class */ (function () {
        function NotificationModule() {
        }
        return NotificationModule;
    }());
    NotificationModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    NotificationModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationModule, declarations: [NotificationComponent], imports: [i3.CommonModule, ngBootstrap.NgbAlertModule, i2.IconModule, i6.ButtonModule, i5.KeyboardClickModule, i4.FocusModule], exports: [NotificationComponent] });
    NotificationModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationModule, imports: [[i3.CommonModule, ngBootstrap.NgbAlertModule, i2.IconModule, i6.ButtonModule, i5.KeyboardClickModule, i4.FocusModule]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NotificationModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [i3.CommonModule, ngBootstrap.NgbAlertModule, i2.IconModule, i6.ButtonModule, i5.KeyboardClickModule, i4.FocusModule],
                        declarations: [NotificationComponent],
                        exports: [NotificationComponent],
                        entryComponents: [NotificationComponent],
                    }]
            }] });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AppendToDomService = AppendToDomService;
    exports.BBNotificationConfig = BBNotificationConfig;
    exports.NotificationComponent = NotificationComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=backbase-ui-ang-notification.umd.js.map
