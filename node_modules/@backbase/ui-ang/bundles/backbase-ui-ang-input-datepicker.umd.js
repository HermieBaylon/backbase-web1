(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/forms'), require('@ng-bootstrap/ng-bootstrap'), require('@backbase/ui-ang/base-classes'), require('@backbase/ui-ang/button'), require('@backbase/ui-ang/icon'), require('rxjs'), require('@backbase/foundation-ang/future'), require('@backbase/ui-ang/services'), require('@backbase/ui-ang/util')) :
    typeof define === 'function' && define.amd ? define('@backbase/ui-ang/input-datepicker', ['exports', '@angular/common', '@angular/core', '@angular/forms', '@ng-bootstrap/ng-bootstrap', '@backbase/ui-ang/base-classes', '@backbase/ui-ang/button', '@backbase/ui-ang/icon', 'rxjs', '@backbase/foundation-ang/future', '@backbase/ui-ang/services', '@backbase/ui-ang/util'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.backbase = global.backbase || {}, global.backbase["ui-ang"] = global.backbase["ui-ang"] || {}, global.backbase["ui-ang"]["input-datepicker"] = {}), global.ng.common, global.ng.core, global.ng.forms, global.i3, global.backbase["ui-ang"]["base-classes"], global.backbase["ui-ang"].button, global.backbase["ui-ang"].icon, global.rxjs, global.i2$1, global.backbase["ui-ang"].services, global.backbase["ui-ang"].util));
})(this, (function (exports, i8, i0, i9, i3, baseClasses, i10, i5, rxjs, i2$1, i2, util) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i8__namespace = /*#__PURE__*/_interopNamespace(i8);
    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i9__namespace = /*#__PURE__*/_interopNamespace(i9);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i10__namespace = /*#__PURE__*/_interopNamespace(i10);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);
    var i2__namespace$1 = /*#__PURE__*/_interopNamespace(i2$1);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var DATEPICKER_I18 = new i0.InjectionToken('datepickerI18');
    var NgbDatepickerI18nDefault = /** @class */ (function (_super) {
        __extends(NgbDatepickerI18nDefault, _super);
        function NgbDatepickerI18nDefault(locale, datepickerI18) {
            var _this = _super.call(this) || this;
            _this.datepickerI18 = datepickerI18;
            var weekdaysStartingOnSunday = i8.getLocaleDayNames(locale, i8.FormStyle.Standalone, i8.TranslationWidth.Short);
            _this.weekdaysShort = weekdaysStartingOnSunday.map(function (day, index) { return weekdaysStartingOnSunday[(index + 1) % 7]; });
            _this.monthsShort = i8.getLocaleMonthNames(locale, i8.FormStyle.Standalone, i8.TranslationWidth.Abbreviated);
            _this.monthsFull = i8.getLocaleMonthNames(locale, i8.FormStyle.Standalone, i8.TranslationWidth.Wide);
            return _this;
        }
        NgbDatepickerI18nDefault.prototype.getWeekdayLabel = function (weekday) {
            return this.datepickerI18 ? this.datepickerI18.getWeekdayLabel(weekday) : this.weekdaysShort[weekday - 1];
        };
        NgbDatepickerI18nDefault.prototype.getMonthShortName = function (month) {
            return this.datepickerI18 ? this.datepickerI18.getMonthShortName(month) : this.monthsShort[month - 1];
        };
        NgbDatepickerI18nDefault.prototype.getMonthFullName = function (month) {
            return this.datepickerI18 ? this.datepickerI18.getMonthFullName(month) : this.monthsFull[month - 1];
        };
        NgbDatepickerI18nDefault.prototype.getDayAriaLabel = function (date) {
            // @todo: use i18n date pipes?
            return this.datepickerI18 ? this.datepickerI18.getDayAriaLabel(date) : date.day + "-" + date.month + "-" + date.year;
        };
        return NgbDatepickerI18nDefault;
    }(i3.NgbDatepickerI18n));
    NgbDatepickerI18nDefault.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDatepickerI18nDefault, deps: [{ token: i0.LOCALE_ID }, { token: DATEPICKER_I18, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NgbDatepickerI18nDefault.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDatepickerI18nDefault });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDatepickerI18nDefault, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.LOCALE_ID]
                        }] }, { type: i3__namespace.NgbDatepickerI18n, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [DATEPICKER_I18]
                        }] }];
        } });

    var isValidNgbDateStructProp = function (struct, propName) { return struct ? Object.prototype.hasOwnProperty.call(struct, propName) && typeof struct[propName] === 'number' : false; };
    var isNgbDateStruct = function (value) { return isValidNgbDateStructProp(value, 'day') &&
        isValidNgbDateStructProp(value, 'month') &&
        isValidNgbDateStructProp(value, 'year'); };
    var NgbDateStringAdapter = /** @class */ (function (_super) {
        __extends(NgbDateStringAdapter, _super);
        function NgbDateStringAdapter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NgbDateStringAdapter.prototype.fromModel = function (dateString) {
            if (dateString) {
                var d = new Date(dateString);
                var year = d.getFullYear();
                if (year) {
                    return {
                        year: year,
                        month: d.getMonth() + 1,
                        day: d.getDate(),
                    };
                }
            }
            return null;
        };
        NgbDateStringAdapter.prototype.toModel = function (date) {
            if (!date) {
                return '';
            }
            else if (typeof date === 'string') {
                return date;
            }
            else if (isNgbDateStruct(date)) {
                return new Date(date.year, date.month - 1, date.day).toISOString();
            }
            return Object.prototype.toString.call(date);
        };
        return NgbDateStringAdapter;
    }(i3.NgbDateAdapter));
    NgbDateStringAdapter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDateStringAdapter, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NgbDateStringAdapter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDateStringAdapter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDateStringAdapter, decorators: [{
                type: i0.Injectable
            }] });

    // TODO: get rid of non null assertions. They are added due to problem with NgbDateParserFormatter.
    // It specifies result of parse function as NgbDateStruct, but allows to return null if value can not be parsed.
    // They should have defined parse method with NgbDateStruct | null return, since now compilation
    // fails due to strict null checks.
    var NgbDateLocaleParserFormatter = /** @class */ (function (_super) {
        __extends(NgbDateLocaleParserFormatter, _super);
        function NgbDateLocaleParserFormatter(locale, datePipe) {
            var _this = _super.call(this) || this;
            _this.locale = locale;
            _this.datePipe = datePipe;
            return _this;
        }
        Object.defineProperty(NgbDateLocaleParserFormatter.prototype, "localeDateFormat", {
            get: function () {
                return this._dateFormat || i8.getLocaleDateFormat(this.locale, i8.FormatWidth.Short);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgbDateLocaleParserFormatter.prototype, "dateFormat", {
            set: function (format) {
                this._dateFormat = format;
            },
            enumerable: false,
            configurable: true
        });
        NgbDateLocaleParserFormatter.getAdaptedYear = function (year, month, day, yearValue) {
            var date = new Date(year, month - 1, day);
            year = date.getFullYear();
            if (yearValue && yearValue.length < 3 && year < 1950) {
                year += 100;
            }
            return year;
        };
        NgbDateLocaleParserFormatter.getIndexFromFormat = function (regex, formatArray) {
            var index = formatArray.findIndex(function (item) { return !Boolean(item.replace(regex, '')); });
            return index;
        };
        NgbDateLocaleParserFormatter.prototype.interpretDate = function (value) {
            var date = new Date(value);
            if (isNaN(date.getTime()))
                return;
            var year = date.getFullYear();
            var yearLength = this.getYearLength(value);
            if (yearLength < 3 && // prevent transformation of 1902 to 2002
                year < 1950 &&
                !value.includes(String(year)) &&
                new Date('01/01/00').getFullYear() === 1900) {
                date.setFullYear(year + 100);
            }
            return date;
        };
        NgbDateLocaleParserFormatter.prototype.parse = function (value) {
            if (!value) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return null;
            }
            var dateElementsRegex = /[^GyMLwWdE]/;
            var dateFormatDelimiterMatches = this.localeDateFormat.match(dateElementsRegex);
            var dateFormatDelimiter = dateFormatDelimiterMatches && dateFormatDelimiterMatches[0];
            var dateValueRegex = new RegExp('[\\d' + dateFormatDelimiter + ']+');
            // Try to parse manually the value in case if contains only numbers and the delimiter.
            // If no delimiter found or the value has other than number characters,
            // the the parsing will fallback to the angular date pipe
            if (dateFormatDelimiter && !Boolean(value.replace(dateValueRegex, ''))) {
                var formatParsedDate = this.getFormatParsedDate(value, this.localeDateFormat, dateFormatDelimiter);
                if (formatParsedDate) {
                    // the formatter has all three date elements
                    return formatParsedDate;
                }
            }
            return this.getAngularPipeFormatParseDate(value);
        };
        /**
         *
         * Parse date value with angular date pipe
         *
         * @param value The string date value
         *
         */
        NgbDateLocaleParserFormatter.prototype.getAngularPipeFormatParseDate = function (value) {
            var parsedValue = '';
            try {
                parsedValue = this.datePipe.transform(value, this.localeDateFormat, undefined, this.locale) || '';
            }
            catch (e) {
                // there is no error handling, because transform fails only with temporary and invalid values like '22/'
                //  during manual input to datepicker
            }
            var parsedDate = this.interpretDate(value);
            if (!parsedValue || !parsedDate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return null;
            }
            return {
                year: parsedDate.getFullYear(),
                month: parsedDate.getMonth() + 1,
                day: parsedDate.getDate(),
            };
        };
        /**
         *
         * @description
         * Proprietary parse to be able to use date override in the input field.
         *
         * Parse the string date value if the date format only contains y, M, d with one single format delimiter.
         *
         * @param value The string date value
         * @param format The date format
         * @param delimiter The delimiter character between date elements (e.g. - or /)
         *
         */
        NgbDateLocaleParserFormatter.prototype.getFormatParsedDate = function (value, format, delimiter) {
            var dateValueArr = value.split(delimiter); // split date string value by the delimiter
            var dateFormatArr = format.split(delimiter);
            if (dateFormatArr.length === 3) {
                var dayFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/d{1,2}/, dateFormatArr);
                var monthFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/M{1,5}/, dateFormatArr);
                var yearFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/y{1,4}/, dateFormatArr);
                if (dayFormatIndex > -1 && monthFormatIndex > -1 && yearFormatIndex > -1) {
                    var today = new Date();
                    var year = dateValueArr[yearFormatIndex] ? Number(dateValueArr[yearFormatIndex]) : today.getFullYear();
                    var month = dateValueArr[monthFormatIndex] ? Number(dateValueArr[monthFormatIndex]) : today.getMonth() + 1;
                    var day = dateValueArr[dayFormatIndex] ? Number(dateValueArr[dayFormatIndex]) : today.getDate();
                    return {
                        day: day,
                        month: month,
                        year: NgbDateLocaleParserFormatter.getAdaptedYear(year, month, day, dateValueArr[yearFormatIndex]),
                    };
                }
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return null;
        };
        NgbDateLocaleParserFormatter.prototype.getYearLength = function (value) {
            var separator = String(this.localeDateFormat.match(/[^\w\*]/));
            var dateArray = value.split(separator);
            var yearPosition = this.localeDateFormat.toLocaleLowerCase().split(separator);
            var yearIndex = yearPosition.findIndex(function (val) { return val.includes('y'); });
            return yearIndex >= 0 && yearIndex < dateArray.length ? dateArray[yearIndex].length : 0;
        };
        NgbDateLocaleParserFormatter.prototype.format = function (date, format) {
            if (format === void 0) { format = this.localeDateFormat; }
            var formattedDate = '';
            if (date && isNgbDateStruct(date)) {
                formattedDate =
                    this.datePipe.transform(new Date(date.year, date.month - 1, date.day), format, undefined, this.locale) || '';
            }
            return formattedDate;
        };
        return NgbDateLocaleParserFormatter;
    }(i3.NgbDateParserFormatter));
    NgbDateLocaleParserFormatter.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDateLocaleParserFormatter, deps: [{ token: i0.LOCALE_ID }, { token: i8__namespace.DatePipe }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    NgbDateLocaleParserFormatter.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDateLocaleParserFormatter });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: NgbDateLocaleParserFormatter, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.LOCALE_ID]
                        }] }, { type: i8__namespace.DatePipe }];
        } });

    /* eslint-disable */
    var Key$2;
    (function (Key) {
        Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
        Key[Key["ArrowUp"] = 38] = "ArrowUp";
        Key[Key["ArrowRight"] = 39] = "ArrowRight";
        Key[Key["ArrowDown"] = 40] = "ArrowDown";
    })(Key$2 || (Key$2 = {}));
    var InputDatepickerDayTemplateSingleComponent = /** @class */ (function () {
        function InputDatepickerDayTemplateSingleComponent(formatterHelper, browserService) {
            var _this = this;
            this.formatterHelper = formatterHelper;
            this.browserService = browserService;
            /**
             * Indicates whether the date is selected
             */
            this.selected = false;
            /**
             * When true the date is rendered as disabled
             */
            this.disabled = false;
            /**
             * Hovered date by a user
             */
            this.hoveredDate = null;
            /**
             * Event to trigger on date hover
             */
            this.hovered = new i0.EventEmitter();
            /**
             * Indicates if the date displayed as greyed out
             */
            this.isTextMuted = false;
            /**
             * Indicates if the date is hovered the range
             */
            this.isHovered = false;
            this.format = function (date) { return _this.formatterHelper.format(date); };
            this.isIE = this.browserService.browserIsMSIE();
        }
        InputDatepickerDayTemplateSingleComponent.prototype.ngOnChanges = function (changes) {
            var _a, _b;
            if ((changes === null || changes === void 0 ? void 0 : changes.selected) || (changes === null || changes === void 0 ? void 0 : changes.disabled) || (changes === null || changes === void 0 ? void 0 : changes.date) || (changes === null || changes === void 0 ? void 0 : changes.currentMonth)) {
                this.isTextMuted = !this.selected && (this.disabled || ((_a = this.date) === null || _a === void 0 ? void 0 : _a.month) !== +this.currentMonth);
            }
            this.isHovered = (_b = this.date) === null || _b === void 0 ? void 0 : _b.equals(this.hoveredDate);
        };
        /**
         *
         * @description
         * Handle mouseover. Emit the hovered date with null.
         *
         */
        InputDatepickerDayTemplateSingleComponent.prototype.onMouseOut = function () {
            this.hovered.emit({ date: null, isSelecting: false });
        };
        /**
         *
         * @description
         * Handle mouseover. Emit the hovered date with date.
         *
         */
        InputDatepickerDayTemplateSingleComponent.prototype.onMouseOver = function () {
            this.hovered.emit({ date: this.date, isSelecting: true });
        };
        /**
         * @description
         * Keypress handler
         *
         * @param evt
         * @param curMonth
         * @param curDay
         * @param date
         */
        InputDatepickerDayTemplateSingleComponent.prototype.onKeyUp = function (event) {
            var day = event.target.textContent;
            var matchKey = this.isIE
                ? Object.values(Key$2).includes(event === null || event === void 0 ? void 0 : event.keyCode)
                : InputDatepickerDayTemplateSingleComponent.hangledKeyCodes.includes(event === null || event === void 0 ? void 0 : event.key);
            if (Number(day) === this.date.day && Number(this.currentMonth) === this.date.month && matchKey) {
                this.hovered.emit({ date: this.date, isSelecting: true });
            }
        };
        return InputDatepickerDayTemplateSingleComponent;
    }());
    InputDatepickerDayTemplateSingleComponent.hangledKeyCodes = [util.KEY_CODES.LEFT, util.KEY_CODES.UP, util.KEY_CODES.RIGHT, util.KEY_CODES.DOWN];
    InputDatepickerDayTemplateSingleComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerDayTemplateSingleComponent, deps: [{ token: NgbDateLocaleParserFormatter }, { token: i2__namespace.BrowserService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    InputDatepickerDayTemplateSingleComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerDayTemplateSingleComponent, selector: "bb-input-datepicker-single-day-template-ui", inputs: { date: "date", selected: "selected", disabled: "disabled", currentMonth: "currentMonth", hoveredDate: "hoveredDate" }, outputs: { hovered: "hovered" }, host: { listeners: { "mouseout": "onMouseOut()", "mouseover": "onMouseOver()", "document:keyup": "onKeyUp($event)" } }, providers: [
            i8.DatePipe,
            NgbDateLocaleParserFormatter,
            {
                provide: i3.NgbDateParserFormatter,
                useExisting: NgbDateLocaleParserFormatter,
            },
            i2.BrowserService,
            { provide: i2.NAVIGATOR_TOKEN, useFactory: i2.navigatorFactory },
        ], usesOnChanges: true, ngImport: i0__namespace, template: "<time\n  class=\"custom-day text-center bb-input-datepicker__single-day\"\n  [ngClass]=\"{\n    'is-selected': selected,\n    'text-muted': isTextMuted\n  }\"\n  [attr.data-role]=\"'calendar-date-item'\"\n  [dateTime]=\"format(date)\"\n>\n  {{ date?.day }}\n</time>\n", directives: [{ type: i8__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerDayTemplateSingleComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-input-datepicker-single-day-template-ui',
                        templateUrl: './input-datepicker-day-template-single.component.html',
                        providers: [
                            i8.DatePipe,
                            NgbDateLocaleParserFormatter,
                            {
                                provide: i3.NgbDateParserFormatter,
                                useExisting: NgbDateLocaleParserFormatter,
                            },
                            i2.BrowserService,
                            { provide: i2.NAVIGATOR_TOKEN, useFactory: i2.navigatorFactory },
                        ],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: NgbDateLocaleParserFormatter }, { type: i2__namespace.BrowserService }]; }, propDecorators: { date: [{
                    type: i0.Input
                }], selected: [{
                    type: i0.Input
                }], disabled: [{
                    type: i0.Input
                }], currentMonth: [{
                    type: i0.Input
                }], hoveredDate: [{
                    type: i0.Input
                }], hovered: [{
                    type: i0.Output
                }], onMouseOut: [{
                    type: i0.HostListener,
                    args: ['mouseout']
                }], onMouseOver: [{
                    type: i0.HostListener,
                    args: ['mouseover']
                }], onKeyUp: [{
                    type: i0.HostListener,
                    args: ['document:keyup', ['$event']]
                }] } });

    /* eslint-disable */
    var Key$1;
    (function (Key) {
        Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
        Key[Key["ArrowUp"] = 38] = "ArrowUp";
        Key[Key["ArrowRight"] = 39] = "ArrowRight";
        Key[Key["ArrowDown"] = 40] = "ArrowDown";
    })(Key$1 || (Key$1 = {}));
    var InputDatepickerDayTemplateRangeComponent = /** @class */ (function () {
        function InputDatepickerDayTemplateRangeComponent(formatterHelper, browserService) {
            this.formatterHelper = formatterHelper;
            this.browserService = browserService;
            /**
             * When true the date is rendered as disabled
             */
            this.disabled = false;
            /**
             * Selected "from" date
             */
            this.fromDate = null;
            /**
             * Selected "to" date
             */
            this.toDate = null;
            /**
             * If "true" the datepicker is displayed with two input fields for "from" and "to" dates
             */
            this.splitRange = false;
            /**
             * "true" when "splitRange" is "true" and the parent datepicker belongs to
             * second datepicker input (the one for "to" date)
             */
            this.toDateDatepicker = false;
            /**
             * Hovered date by a user
             */
            this.hoveredDate = null;
            /**
             * Date range
             */
            this.rangeSelect = new i0.EventEmitter();
            /**
             * Event to trigger on date hover
             */
            this.hovered = new i0.EventEmitter();
            /**
             * Prevent keypress to be called on toggle button enter
             */
            this.firstKey = true;
            /**
             * Indicates if the date is between the from-date and the hovered date
             */
            this.isWithinRangeHover = false;
            /**
             * Indicates if the date is between the from-date and the to-date date
             */
            this.isWithinSelectedRange = false;
            /**
             * Indicates if the date displayed as greyed out
             */
            this.isTextMuted = false;
            /**
             * Indicates if the date is hovered the range
             */
            this.isHovered = false;
            /**
             * Indicates if the date is the from-date of the range
             */
            this.isFrom = false;
            /**
             * Indicates if the the date is the to-date of the range
             */
            this.isTo = false;
            /**
             * Formatted date
             */
            this.formattedDate = '';
            this.isIE = this.browserService.browserIsMSIE();
        }
        Object.defineProperty(InputDatepickerDayTemplateRangeComponent.prototype, "withinHoverRangeSingle", {
            get: function () {
                return (!this.toDate &&
                    (this.date.after(this.fromDate) || this.date.equals(this.fromDate)) &&
                    (this.date.before(this.hoveredDate) || this.date.equals(this.hoveredDate)));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerDayTemplateRangeComponent.prototype, "withinHoverRangeSplitTo", {
            get: function () {
                return ((this.date.before(this.hoveredDate) || this.date.equals(this.hoveredDate)) &&
                    (this.date.after(this.toDate) ||
                        this.date.equals(this.toDate) ||
                        (this.date.before(this.toDate) && this.date.after(this.fromDate))) &&
                    this.toDateDatepicker);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerDayTemplateRangeComponent.prototype, "withinHoverRangeSplitFrom", {
            get: function () {
                return ((this.date.after(this.hoveredDate) || this.date.equals(this.hoveredDate)) &&
                    this.date.before(this.toDate) &&
                    !this.toDateDatepicker &&
                    this.toDate);
            },
            enumerable: false,
            configurable: true
        });
        /* eslint-disable complexity */
        InputDatepickerDayTemplateRangeComponent.prototype.ngOnChanges = function (changes) {
            var _a, _b, _c, _d;
            if (changes === null || changes === void 0 ? void 0 : changes.hoveredDate) {
                this.isWithinRangeHover = !!(this.isValidRange() &&
                    this.date &&
                    this.hoveredDate &&
                    (((this.withinHoverRangeSplitTo || this.withinHoverRangeSplitFrom) && this.splitRange) ||
                        (this.withinHoverRangeSingle && this.toDateDatepicker && this.splitRange) ||
                        (this.withinHoverRangeSingle && !this.splitRange)));
                this.isHovered = (_a = this.date) === null || _a === void 0 ? void 0 : _a.equals(this.hoveredDate);
            }
            if ((changes === null || changes === void 0 ? void 0 : changes.fromDate) || (changes === null || changes === void 0 ? void 0 : changes.toDate) || (changes === null || changes === void 0 ? void 0 : changes.date)) {
                this.isWithinSelectedRange = this.date && this.date.before(this.toDate) && this.date.after(this.fromDate);
                this.isTo = (_b = this.date) === null || _b === void 0 ? void 0 : _b.equals(this.toDate);
                this.formattedDate = this.formatterHelper.format(this.date);
                this.isFrom = (_c = this.date) === null || _c === void 0 ? void 0 : _c.equals(this.fromDate);
            }
            this.isTextMuted =
                !this.isWithinRangeHover &&
                    !this.isWithinSelectedRange &&
                    !this.isFrom &&
                    !this.isTo &&
                    (this.disabled || ((_d = this.date) === null || _d === void 0 ? void 0 : _d.month) !== +this.currentMonth);
        };
        /**
         *
         * @description
         * Handle mouseover. Emit the hovered date with null.
         *
         */
        InputDatepickerDayTemplateRangeComponent.prototype.onMouseOut = function () {
            this.hovered.emit({ date: null, isTo: this.toDateDatepicker, isSelecting: false });
        };
        /**
         *
         * @description
         * Handle mouseover. Emit the hovered date with date.
         *
         */
        InputDatepickerDayTemplateRangeComponent.prototype.onMouseOver = function () {
            this.hovered.emit({ date: this.date, isTo: this.toDateDatepicker, isSelecting: true });
        };
        /**
         * @description
         * Keypress handler
         *
         * @param evt
         * @param curMonth
         * @param curDay
         * @param date
         */
        InputDatepickerDayTemplateRangeComponent.prototype.onKeyUp = function (event) {
            var day = event.target.textContent;
            var matchKey = this.isIE
                ? Object.values(Key$1).includes(event === null || event === void 0 ? void 0 : event.keyCode)
                : InputDatepickerDayTemplateRangeComponent.hangledKeyCodes.includes(event === null || event === void 0 ? void 0 : event.key);
            if (Number(day) === this.date.day && Number(this.currentMonth) === this.date.month && matchKey) {
                this.hovered.emit({ date: this.date, isTo: this.toDateDatepicker, isSelecting: true });
            }
        };
        InputDatepickerDayTemplateRangeComponent.prototype.isValidRange = function () {
            return (!this.fromDate ||
                !this.toDate ||
                new i3.NgbDate(this.fromDate.year, this.fromDate.month, this.fromDate.day).before(this.toDate));
        };
        return InputDatepickerDayTemplateRangeComponent;
    }());
    InputDatepickerDayTemplateRangeComponent.hangledKeyCodes = [util.KEY_CODES.LEFT, util.KEY_CODES.UP, util.KEY_CODES.RIGHT, util.KEY_CODES.DOWN];
    InputDatepickerDayTemplateRangeComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerDayTemplateRangeComponent, deps: [{ token: NgbDateLocaleParserFormatter }, { token: i2__namespace.BrowserService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    InputDatepickerDayTemplateRangeComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerDayTemplateRangeComponent, selector: "bb-input-datepicker-range-day-template-ui", inputs: { date: "date", disabled: "disabled", currentMonth: "currentMonth", fromDate: "fromDate", toDate: "toDate", splitRange: "splitRange", toDateDatepicker: "toDateDatepicker", hoveredDate: "hoveredDate" }, outputs: { rangeSelect: "rangeSelect", hovered: "hovered" }, host: { listeners: { "mouseout": "onMouseOut()", "mouseover": "onMouseOver()", "document:keyup": "onKeyUp($event)" } }, providers: [
            i8.DatePipe,
            NgbDateLocaleParserFormatter,
            {
                provide: i3.NgbDateParserFormatter,
                useExisting: NgbDateLocaleParserFormatter,
            },
            i2.BrowserService,
            { provide: i2.NAVIGATOR_TOKEN, useFactory: i2.navigatorFactory },
        ], usesOnChanges: true, ngImport: i0__namespace, template: "<time\n  class=\"custom-day text-center bb-input-datepicker__custom-day\"\n  [ngClass]=\"{\n    'is-range-selected': isWithinSelectedRange,\n    'is-faded': isWithinRangeHover,\n    'is-faded-from-date': isWithinRangeHover && !toDateDatepicker && splitRange,\n    'is-hovered': isHovered,\n    'text-muted': isTextMuted,\n    'from-date': isFrom,\n    'to-date': isTo\n  }\"\n  [attr.data-role]=\"'calendar-date-item'\"\n  [dateTime]=\"formattedDate\"\n>\n  {{ date?.day }}\n</time>\n", directives: [{ type: i8__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerDayTemplateRangeComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-input-datepicker-range-day-template-ui',
                        templateUrl: './input-datepicker-day-template-range.component.html',
                        providers: [
                            i8.DatePipe,
                            NgbDateLocaleParserFormatter,
                            {
                                provide: i3.NgbDateParserFormatter,
                                useExisting: NgbDateLocaleParserFormatter,
                            },
                            i2.BrowserService,
                            { provide: i2.NAVIGATOR_TOKEN, useFactory: i2.navigatorFactory },
                        ],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: NgbDateLocaleParserFormatter }, { type: i2__namespace.BrowserService }]; }, propDecorators: { date: [{
                    type: i0.Input
                }], disabled: [{
                    type: i0.Input
                }], currentMonth: [{
                    type: i0.Input
                }], fromDate: [{
                    type: i0.Input
                }], toDate: [{
                    type: i0.Input
                }], splitRange: [{
                    type: i0.Input
                }], toDateDatepicker: [{
                    type: i0.Input
                }], hoveredDate: [{
                    type: i0.Input
                }], rangeSelect: [{
                    type: i0.Output
                }], hovered: [{
                    type: i0.Output
                }], onMouseOut: [{
                    type: i0.HostListener,
                    args: ['mouseout']
                }], onMouseOver: [{
                    type: i0.HostListener,
                    args: ['mouseover']
                }], onKeyUp: [{
                    type: i0.HostListener,
                    args: ['document:keyup', ['$event']]
                }] } });

    // Oleksii depricate
    /* eslint-disable */
    var Key;
    (function (Key) {
        Key[Key["Tab"] = 9] = "Tab";
        Key[Key["Enter"] = 13] = "Enter";
        Key[Key["Escape"] = 27] = "Escape";
        Key[Key["Space"] = 32] = "Space";
        Key[Key["PageUp"] = 33] = "PageUp";
        Key[Key["PageDown"] = 34] = "PageDown";
        Key[Key["End"] = 35] = "End";
        Key[Key["Home"] = 36] = "Home";
        Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
        Key[Key["ArrowUp"] = 38] = "ArrowUp";
        Key[Key["ArrowRight"] = 39] = "ArrowRight";
        Key[Key["ArrowDown"] = 40] = "ArrowDown";
    })(Key || (Key = {}));
    var isDateRangeModelType = function (value) { return Object.prototype.hasOwnProperty.call(value || {}, 'from') && Object.prototype.hasOwnProperty.call(value || {}, 'to'); };
    /**
     * @name InputDatepickerComponent
     *
     * @description
     * Component that displays a datepicker
     *
     * ### Custom internalization
     * It is possible to provide a custom internalisation. To do this, a `DATEPICKER_I18` token from `@backbase/ui-ang/input-datepicker` should be provided on the module level.
     * The token should implement the [NgbDatepickerI18n](https://ng-bootstrap.github.io/#/components/datepicker/api#NgbDatepickerI18n) interface.
     *
     * ### Setting and reading the  date
     * *Note* Datepicker uses the date *with the timezone* inside its model. And hence to make it work properly in all cases there are some recommendations for setting and reading the date to and from the datepicker.
     * #### Setting the date
     * When setting the date to the datepicker the date must be provided in the format that assumes zero hours and zero minutes in the local timezone. Here are some examples of what the date setting should looks like:
     * ```
       this.minDate = new Date(2021,11,15, 0, 0).toISOString();
       ```
     *
     * or
     * ```
       this.minDate = new Date('2021-12-15T00:00').toISOString();
       ```
     *
     * Note that
     * ```
       new Date('2021-12-15').toISOString();
       ```
     *
     * generates a date in GMT0 format and that is not correct for the datepicker input date.
     * #### Reading the date
     * When a date is selected via UI (the datepicker's popup window or browser's input field) its display date is transformed to the ISO string date with the assumption that it’s zero hours and zero minutes in the current time zone. Which leads to the different ISO string values for different time zones for the same date. F.e. "Dec 15 2021" is going to be transformed to "2021-12-14T23:00:00.000Z" for the "GMT+0100 (Central European Standard Time)" time zone and to "2021-12-15T03:00:00.000Z" for "GMT-0300 (West Greenland Standard Time)" time zone. As you can see the _day_ value is different in ISO string based on the timezone. It’s going to be either 14 or 15 in the example above.
     *
     * The recommendation here is to convert the ISO string, that the datepicker returns, into the Date object and read it's day value. Here is an example:
     * ```
      private formatDate(stringDate: string): string {
        const date = new Date(stringDate);
        if (stringDate && !isNaN(date.valueOf())) {
          return `${date.getFullYear()}-${this.appendLeadingZeroes(date.getMonth() + 1)}-${this.appendLeadingZeroes(date.getDate())}`;
        }
        return '';
      }

      private appendLeadingZeroes(value: number) {
        return value > 9 ? value : `0${value}`;
      }
       ```
     *
     * @a11y Current component provide option to pass needed accessibility
     * attributes. You need to take care of properties that are required in your case :
     *  - role
     *  - aria-activedescendant
     *  - aria-describedby
     *  - aria-expanded
     *  - aria-invalid
     *  - aria-label
     *  - aria-labelledby
     *  - aria-owns
     *
     * `ariaLabel` is discernible text for datepicker
     */
    var InputDatepickerComponent = /** @class */ (function (_super) {
        __extends(InputDatepickerComponent, _super);
        function InputDatepickerComponent(formatterHelper, el, cd, deprecationsService, adapter, renderer2, domAttrService) {
            var _this = _super.call(this, cd, deprecationsService) || this;
            _this.formatterHelper = formatterHelper;
            _this.el = el;
            _this.cd = cd;
            _this.deprecationsService = deprecationsService;
            _this.adapter = adapter;
            _this.renderer2 = renderer2;
            _this.domAttrService = domAttrService;
            /**
             * Event to trigger on date hover
             */
            _this.focusedDate = new i0.EventEmitter();
            /**
             * Indicates if the datepicker should select a date range with single input (from - to).
             * Defaults to false
             */
            _this.rangeSelection = false;
            /**
             * Indicates if the datepicker should a date range with split input. One for the from date and one for the to date.
             * Defaults to false
             */
            _this.rangeSelectionSplit = false;
            /**
             * Indicates if the datepicker is opened when clicking input.
             * Defaults to false
             */
            _this.clickOpen = false;
            /**
             * Indicates if the datepicker is opened when focusing input.
             * Defaults to false
             */
            _this.focusOpen = false;
            _this._placement = 'bottom-left';
            /**
             * Accessible description for datepicker date selection popup.
             */
            _this.datepickerDescribedby = 'defaultDatepickerDescribedbyLabel';
            /**
             * Accessible label for Datepicker button.
             */
            _this.ariaLabelForButton = 'Toggle Date popup';
            /**
             * Icon that is dispayed in the button.
             * Defaults to calendar
             */
            _this.icon = 'calendar-today';
            /**
             * The size of the icon to be displayed.
             * Defaults to md
             */
            _this.iconSize = 'md';
            /**
             * Color of the button.
             * Defaults to link
             */
            _this.btnColor = 'link';
            /**
             * Aria label for the datepicker
             */
            _this.ariaLabel = 'Datepicker';
            /**
             * Navigation pattern through dates.
             * Default to arrows
             */
            _this.navigation = 'arrows';
            /**
             * Indicates how many month will be shown in the picker
             */
            _this.displayMonths = 1;
            _this.hoveredDate$ = new rxjs.BehaviorSubject({ date: null });
            _this.pickerHoveredDayDateTo = null;
            _this.fromDate$ = new rxjs.BehaviorSubject(null);
            _this.toDate$ = new rxjs.BehaviorSubject(null);
            _this.inputDateRangeSeparator = '-';
            _this.cssClass = 'bb-input-datepicker-ui';
            /**
             * @description
             * Passing template date to the range template to identify when it is used in the "to" date
             * (the second HTML date input of the split datepicker).
             * Check https://ng-bootstrap.github.io/#/components/datepicker/api "dayTemplateData" for details
             */
            _this.rangeTemplateData = function () { return ({
                isTo: true,
            }); };
            /***************************************8
             *
             *  CONTROLVALUEACCESSOR OVERRIDES
             *
             **************************************/
            /**
             * Implements custom validation for the control
             *
             * @param control
             */
            _this.validate = function (control) {
                var value = control.value;
                if (!_this.parentFormControl) {
                    _this.parentFormControl = control;
                }
                if (!value) {
                    /* eslint-disable-next-line  no-null/no-null */
                    return null;
                }
                if (_this.rangeSelection || _this.rangeSelectionSplit) {
                    return _this.validateDateRange(value);
                }
                return _this.validateSingleDate(value);
            };
            _this.dateInput = new i9.FormControl(null);
            _this.dateInputTo = new i9.FormControl(null);
            return _this;
        }
        Object.defineProperty(InputDatepickerComponent.prototype, "placement", {
            get: function () {
                return document.documentElement.clientWidth > 320 ? this._placement : 'bottom';
            },
            /**
             * Placement of a popup window
             */
            set: function (value) {
                if (value) {
                    this._placement = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerComponent.prototype, "minDate", {
            /**
             * Min date for the navigation. If not provided, 'year' select box will display 10 years
             * before current month
             */
            set: function (date) {
                this._minDate = typeof date === 'string' ? this.adapter.fromModel(date) : date;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerComponent.prototype, "maxDate", {
            /**
             * Max date for the navigation. If not provided, 'year' select box will display 10 years
             * after current month
             */
            set: function (date) {
                this._maxDate = typeof date === 'string' ? this.adapter.fromModel(date) : date;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerComponent.prototype, "placeholder", {
            get: function () {
                if (typeof this._placeholder === 'undefined') {
                    var pattern = this.dateFormat.toUpperCase();
                    return this.rangeSelection ? pattern + " " + this.inputDateRangeSeparator + " " + pattern : pattern;
                }
                return this._placeholder;
            },
            /**
             * The placeholder for the datepicker input. Default is Locale Date Format;
             */
            set: function (value) {
                this._placeholder = typeof value !== 'undefined' ? String(value) : undefined;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerComponent.prototype, "overrideDateFormat", {
            get: function () {
                return this._overrideDateFormat;
            },
            /**
             * Override date format (optional). Supported formats are `yyyy/MM/dd`, `MM/dd/yyyy`, `MMMM dd, yyyy`.
             * Note, other formats might work inconsistent in different browsers.
             */
            set: function (value) {
                this._overrideDateFormat = value;
                this.formatterHelper.dateFormat = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(InputDatepickerComponent.prototype, "dateFormat", {
            /**
             * The custom or locale date format that is used to display dates and placeholders
             */
            get: function () {
                return this.formatterHelper.localeDateFormat;
            },
            enumerable: false,
            configurable: true
        });
        InputDatepickerComponent.prototype.ngOnChanges = function (changes) {
            var disabled = changes.disabled;
            if (disabled && disabled.currentValue !== disabled.previousValue) {
                if (this.disabled) {
                    this.dateInput.disable();
                }
                else {
                    this.dateInput.enable();
                }
            }
        };
        // todo: do we need this?
        InputDatepickerComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            var datepickerInput = this.rangeSelection ? this.datePickerRangeInput : this.datePickerInput;
            this.domAttrService.moveAriaAttributes(this.el.nativeElement, datepickerInput === null || datepickerInput === void 0 ? void 0 : datepickerInput.nativeElement, this.renderer2);
            setTimeout(function () {
                // internal validators are not used
                _this.dateInput.setValidators([]);
                _this.dateInput.updateValueAndValidity();
                _this.cd.markForCheck();
            });
        };
        InputDatepickerComponent.prototype.dateEqual = function (xDate, yDate) {
            var a = new Date(xDate.year, xDate.month - 1, xDate.day).getTime();
            var b = new Date(yDate.year, yDate.month - 1, yDate.day).getTime();
            return a === b ? 0 : a > b ? 1 : -1;
        };
        /****************************************
         *
         *        EVENT HANDLERS
         *
         ***************************************/
        /**
         * @description
         * Input change handler for single date
         *
         * @param element
         */
        InputDatepickerComponent.prototype.onInputChange = function (element) {
            // Checking for "browser bug", for example,
            // In IE `new Date()` for short date format YY gives 19YY, for modern browser in looks like 20YY
            // for this reason we're adding 100 years to browser understand that it is 21st century
            var dateInputToUpdate = element.name === 'date' ? this.dateInput : this.dateInputTo;
            var value = element.value;
            var browserDate = new Date(value);
            var parsedDate = this.formatterHelper.interpretDate(value);
            if (parsedDate && parsedDate.getTime() !== browserDate.getTime()) {
                dateInputToUpdate.setValue(parsedDate);
            }
        };
        /**
         * Update datepicker value on input value change for same input date range selection
         *
         * @param value
         */
        InputDatepickerComponent.prototype.onInputChangeRange = function (element) {
            var value = element.value;
            var _c = __read(value.split(this.inputDateRangeSeparator).slice(0, 2), 2), dateFrom = _c[0], dateTo = _c[1];
            this.fromDate$.next(this.formatterHelper.parse(dateFrom === null || dateFrom === void 0 ? void 0 : dateFrom.trim()));
            this.toDate$.next(this.formatterHelper.parse(dateTo === null || dateTo === void 0 ? void 0 : dateTo.trim()));
            if (this.fromDate$.getValue() || this.toDate$.getValue()) {
                this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
            }
            else {
                this.onChange(value);
            }
        };
        /**
         * Update datepicker value on input value change for split input date range selection, from date
         *
         * @param value
         */
        InputDatepickerComponent.prototype.onInputChangeSplitRange = function (element) {
            var value = element.value;
            this.fromDate$.next(this.formatterHelper.parse(value && value.trim()));
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        };
        /**
         * Update datepicker value on input value change for split input date range selection, to date
         *
         * @param value
         */
        InputDatepickerComponent.prototype.onInputChangeSplitRangeTo = function (element) {
            var value = element.value;
            this.toDate$.next(this.formatterHelper.parse(value && value.trim()));
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        };
        /**
         * Event handler for the native input
         */
        InputDatepickerComponent.prototype.onInputFocus = function (open) {
            _super.prototype.onFocus.call(this);
            if (open && this.datePicker) {
                this.bindDocumentEvents();
                this.datePicker.open();
                if (this.rangeSelection || this.rangeSelectionSplit) {
                    this.datePicker.startDate = this.toDate$.getValue();
                }
            }
        };
        /**
         * Event handler for the native input
         */
        InputDatepickerComponent.prototype.onInputFocusTo = function (open) {
            _super.prototype.onFocus.call(this);
            if (open && this.datePickerTo) {
                this.datePickerTo.open();
            }
        };
        /**
         * Event handler for the picker toggle button to
         */
        InputDatepickerComponent.prototype.onPickerTogglerClick = function (event) {
            if (!this.disabled && this.datePicker) {
                this.bindDocumentEvents();
                this.setStartDateOnPicker(this.datePicker);
                this.datePicker.toggle();
            }
        };
        /**
         * Event handler for the picker toggle button to (split range selection)
         */
        InputDatepickerComponent.prototype.onPickerTogglerClickTo = function (event) {
            if (!this.disabled && this.datePickerTo) {
                this.bindDocumentEvents();
                this.setStartDateOnPicker(this.datePickerTo);
                this.datePickerTo.toggle();
            }
        };
        /**
         *
         * Set disable state for the host control
         *
         * @param isDisabled
         */
        InputDatepickerComponent.prototype.setDisabledState = function (isDisabled) {
            if (isDisabled) {
                this.dateInput.disable();
            }
            else {
                this.dateInput.enable();
            }
            _super.prototype.setDisabledState.call(this, isDisabled);
        };
        /**
         * Event handler blur on internal inputs and buttons
         *
         * @param $event
         */
        InputDatepickerComponent.prototype.onControlBlur = function ($event) {
            if (!$event.relatedTarget || !this.el.nativeElement.contains($event.relatedTarget)) {
                this.onBlur($event);
            }
            if (this.rangeSelection) {
                if (!this.toDate$.getValue() || !this.fromDate$.getValue()) {
                    this.setDatesTheSame();
                }
                else {
                    this.setRangeInput();
                }
            }
        };
        /**
         * Event handler for blur on the host control
         *
         * @param $event
         */
        InputDatepickerComponent.prototype.onBlur = function ($event) {
            this.blur.emit($event);
            this.onTouched();
        };
        /**
         * @description
         *
         * Event handler for closing `from` or single date picker
         *
         */
        InputDatepickerComponent.prototype.onClosed = function () {
            var hoveredDateClosedValue = this.hoveredDate$.getValue();
            var hoveredDate = hoveredDateClosedValue === null || hoveredDateClosedValue === void 0 ? void 0 : hoveredDateClosedValue.date;
            if (hoveredDate) {
                this.setSelectedDate({ date: hoveredDate, isSelecting: false });
            }
            if (this.rangeSelection && this.datePickerButton) {
                this.datePickerButton.nativeElement.focus();
            }
            else if (this.rangeSelectionSplit && this.datePickerTo && this.datePickerInputTo) {
                this.datePickerInputTo.nativeElement.focus();
            }
        };
        /**
         * Event handler for closing picker for `to` date
         */
        InputDatepickerComponent.prototype.onClosedTo = function () {
            if (this.datePickerButtonTo !== undefined && this.datePicker && !this.datePicker.isOpen()) {
                this.datePickerButtonTo.nativeElement.focus();
            }
        };
        /**
         * Event handler for date setting from picker for `to` date when split input range selection
         *
         * @param date
         */
        InputDatepickerComponent.prototype.onRangeDateSelectSplitTo = function (date) {
            this.toDate$.next(this.copyDateElement(date));
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
            this.onTouched();
        };
        /**
         * Event handler for date setting from picker for `from` date when split input range selection
         *
         * @param date
         */
        InputDatepickerComponent.prototype.onRangeDateSelectSplit = function (date) {
            this.fromDate$.next(this.copyDateElement(date));
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
            this.onTouched();
        };
        /**
         *  Event handler for date setting from picker when single input range selection
         *
         * @param date
         */
        InputDatepickerComponent.prototype.onRangeDateSelect = function (date) {
            var _this = this;
            if (!this.fromDate$.getValue() && !this.toDate$.getValue()) {
                this.fromDate$.next(this.copyDateElement(date));
            }
            else if (this.fromDate$.getValue() &&
                !this.toDate$.getValue() &&
                date &&
                (date.after(this.fromDate$.getValue()) || date.equals(this.fromDate$.getValue()))) {
                this.toDate$.next(this.copyDateElement(date));
                setTimeout(function () { return _this.closeDatePicker(); }, 0);
            }
            else {
                /* eslint-disable-next-line no-null/no-null */
                this.toDate$.next(null);
                this.fromDate$.next(this.copyDateElement(date));
            }
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
            this.setRangeInput();
        };
        /**
         *
         * Handling day-hover from day-template on range selection.
         *
         * @param event
         */
        InputDatepickerComponent.prototype.onDayHover = function (event) {
            if (event.isTo) {
                this.pickerHoveredDayDateTo = event.date;
            }
            else {
                this.setSelectedDate({ date: event.date, isSelecting: event.isSelecting });
            }
        };
        /**
         *
         * Implements the value update for the control
         *
         * @param model
         */
        /* eslint-disable-next-line complexity */
        InputDatepickerComponent.prototype.writeValue = function (model) {
            if (!this.rangeSelection && !this.rangeSelectionSplit) {
                this.dateInput.setValue(typeof model === 'string' ? model : null);
            }
            else {
                if (isDateRangeModelType(model)) {
                    if (model.from && this.validateSingleDate(model.from) === null) {
                        this.fromDate$.next(this.adapter.fromModel(model.from));
                    }
                    else {
                        this.fromDate$.next(model.from);
                    }
                    if (model.to && this.validateSingleDate(model.to) === null) {
                        this.toDate$.next(this.adapter.fromModel(model.to));
                    }
                    else {
                        this.toDate$.next(model.to);
                    }
                }
                else {
                    this.fromDate$.next(null);
                    this.toDate$.next(null);
                }
                if (this.rangeSelection) {
                    this.setRangeInput();
                }
                else if (this.rangeSelectionSplit) {
                    this.dateInput.setValue(this.fromDate$.getValue() ? this.adapter.toModel(this.fromDate$.getValue()) : null);
                    this.dateInputTo.setValue(this.toDate$.getValue() ? this.adapter.toModel(this.toDate$.getValue()) : null);
                }
            }
        };
        /*********************************
         *
         *        PRIVATE UTILS
         *
         **********************************/
        InputDatepickerComponent.prototype.setSelectedDate = function (date) {
            this.hoveredDate$.next(date);
            this.focusedDate.emit(date);
        };
        InputDatepickerComponent.prototype.setDatesTheSame = function () {
            var fromDate = this.fromDate$.getValue();
            if (fromDate) {
                this.toDate$.next(fromDate);
                this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
                this.setRangeInput();
            }
        };
        InputDatepickerComponent.prototype.closeDatePicker = function () {
            var _a;
            if (this.datePicker) {
                this.datePicker.close();
                if (this.rangeSelection) {
                    (_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.updateValueAndValidity();
                }
                this.onBlur();
            }
            if (this.datePickerTo) {
                this.datePickerTo.close();
                this.onBlur();
            }
            // Unbind the global document events once the date picker is closed
            if (this.unListenDocumentClick) {
                this.unListenDocumentClick();
            }
            if (this.unListenDocumentEsc) {
                this.unListenDocumentEsc();
            }
        };
        InputDatepickerComponent.prototype.isValidRange = function (from, to) {
            if (new Date(from).getTime() > new Date(to).getTime()) {
                return { invalidDateFormat: true };
            }
            return null;
        };
        InputDatepickerComponent.prototype.validateSingleDate = function (value) {
            var date = typeof value === 'string' ? value : value.toISOString();
            // check if value is in ISO format
            // this means that it has passed parsing and that it is in date format for current locale
            // This check is for IE11
            var ISODateRegExp = /^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)$/g;
            return ISODateRegExp.test(date) ? null : { invalidDateFormat: true };
        };
        /**
         * Document Event handler
         */
        InputDatepickerComponent.prototype.handleDocumentEvent = function (event) {
            if (event.target && (!this.el.nativeElement.contains(event.target) || event.type === 'keyup')) {
                this.closeDatePicker();
            }
        };
        /**
         * Binds event on the global document when the datepicker is not opened
         */
        InputDatepickerComponent.prototype.bindDocumentEvents = function () {
            if (this.datePicker && !this.datePicker.isOpen()) {
                this.unListenDocumentClick = this.renderer2.listen('document', 'click', this.handleDocumentEvent.bind(this));
                this.unListenDocumentEsc = this.renderer2.listen('document', 'keyup.escape', this.handleDocumentEvent.bind(this));
            }
        };
        /* eslint-disable-next-line complexity */
        InputDatepickerComponent.prototype.validateDateRange = function (value) {
            var validateTo = null;
            var validateFrom = null;
            var validateRange = null;
            if (!isDateRangeModelType(value)) {
                return { invalidDateFormat: true };
            }
            if (!value.from && !value.to && !this.isRequired()) {
                return null;
            }
            if ((!value.to && value.from) || (value.to && !value.from) || (!value.from && !value.to && this.isRequired())) {
                return { required: true };
            }
            if (value.from) {
                validateFrom = this.validateSingleDate(value.from);
            }
            if (value.to) {
                validateTo = this.validateSingleDate(value.to);
            }
            if (!validateFrom && !validateTo && value.from && value.to) {
                validateRange = this.isValidRange(value.from, value.to);
            }
            return validateTo || validateFrom || validateRange;
        };
        InputDatepickerComponent.prototype.setRangeInput = function () {
            var _a;
            if (this.fromDate$.getValue() || this.toDate$.getValue()) {
                var formattedFrom = this.formatterHelper.format(this.fromDate$.getValue());
                var formattedTo = this.formatterHelper.format(this.toDate$.getValue());
                this.dateInput.setValue((formattedFrom === null ? this.fromDate$.getValue() : formattedFrom) + " " + this.inputDateRangeSeparator + " " + (formattedTo === null ? this.toDate$.getValue() : formattedTo));
            }
            else {
                /* eslint-disable-next-line no-null/no-null */
                this.dateInput.setValue(null);
            }
            if ((_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.touched) {
                this.onTouched();
            }
        };
        InputDatepickerComponent.prototype.copyDateElement = function (sourceDate) {
            return { year: sourceDate.year, month: sourceDate.month, day: sourceDate.day };
        };
        InputDatepickerComponent.prototype.updateRangeModel = function (from, to) {
            this.onChange({
                from: from ? this.adapter.toModel(from) : null,
                to: to ? this.adapter.toModel(to) : null,
            });
        };
        InputDatepickerComponent.prototype.isRequired = function () {
            var _a, _b;
            if ((_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.validator) {
                var validator = (_b = this.parentFormControl) === null || _b === void 0 ? void 0 : _b.validator({});
                if (validator && validator.required) {
                    return true;
                }
            }
            return false;
        };
        InputDatepickerComponent.prototype.setStartDateOnPicker = function (picker) {
            var _a, _b;
            var startDate = null;
            if (this.rangeSelection) {
                startDate = this.fromDate$.getValue();
            }
            else if (this.rangeSelectionSplit && ((_a = this.fromDate$.getValue()) === null || _a === void 0 ? void 0 : _a.year)) {
                startDate = this.fromDate$.getValue();
            }
            else if (this.rangeSelectionSplit && ((_b = this.toDate$.getValue()) === null || _b === void 0 ? void 0 : _b.year)) {
                startDate = this.toDate$.getValue();
            }
            if (!!startDate) {
                picker.startDate = startDate;
            }
        };
        return InputDatepickerComponent;
    }(baseClasses.InputBaseComponent));
    InputDatepickerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerComponent, deps: [{ token: NgbDateLocaleParserFormatter }, { token: i0__namespace.ElementRef }, { token: i0__namespace.ChangeDetectorRef }, { token: i2__namespace$1.DeprecationsService }, { token: i3__namespace.NgbDateAdapter }, { token: i0__namespace.Renderer2 }, { token: i2__namespace.DomAttributesService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    InputDatepickerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerComponent, selector: "bb-input-datepicker-ui", inputs: { rangeSelection: "rangeSelection", rangeSelectionSplit: "rangeSelectionSplit", clickOpen: "clickOpen", focusOpen: "focusOpen", placement: "placement", datepickerDescribedby: "datepickerDescribedby", ariaLabelForButton: "ariaLabelForButton", minDate: "minDate", maxDate: "maxDate", markDisabled: "markDisabled", icon: "icon", iconSize: "iconSize", iconColor: "iconColor", btnColor: "btnColor", ariaLabel: "ariaLabel", navigation: "navigation", autocomplete: "autocomplete", firstDayOfWeek: "firstDayOfWeek", displayMonths: "displayMonths", placeholder: "placeholder", overrideDateFormat: "overrideDateFormat" }, outputs: { focusedDate: "focusedDate" }, host: { properties: { "attr.class": "this.cssClass" } }, providers: [
            i8.DatePipe,
            NgbDateLocaleParserFormatter,
            {
                provide: i3.NgbDateAdapter,
                useClass: NgbDateStringAdapter,
            },
            {
                provide: i3.NgbDatepickerI18n,
                useClass: NgbDatepickerI18nDefault,
            },
            {
                provide: i3.NgbDateParserFormatter,
                useExisting: NgbDateLocaleParserFormatter,
            },
            {
                provide: i9.NG_VALUE_ACCESSOR,
                useExisting: i0.forwardRef(function () { return InputDatepickerComponent; }),
                multi: true,
            },
            {
                provide: i9.NG_VALIDATORS,
                useExisting: i0.forwardRef(function () { return InputDatepickerComponent; }),
                multi: true,
            },
        ], viewQueries: [{ propertyName: "datePicker", first: true, predicate: ["datePicker"], descendants: true }, { propertyName: "datePickerTo", first: true, predicate: ["datePickerTo"], descendants: true }, { propertyName: "datePickerInput", first: true, predicate: ["datePickerInput"], descendants: true }, { propertyName: "datePickerRangeInput", first: true, predicate: ["datePickerRangeInput"], descendants: true }, { propertyName: "datePickerInputTo", first: true, predicate: ["datePickerInputTo"], descendants: true }, { propertyName: "datePickerButton", first: true, predicate: ["datePickerButton"], descendants: true }, { propertyName: "datePickerButtonTo", first: true, predicate: ["datePickerButtonTo"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0__namespace, template: "<div\n  class=\"bb-input-datepicker__wrapper\"\n  [ngClass]=\"{\n    'ng-invalid': parentFormControl?.invalid,\n    'ng-touched': parentFormControl?.touched,\n    'bb-input-datepicker__range-split-wrapper': rangeSelectionSplit\n  }\"\n>\n  <label *ngIf=\"label\" class=\"bb-input-datepicker__label\" for=\"{{ id }}\">{{ label }}</label>\n  <div class=\"input-group bb-input-datepicker\" #positionTarget>\n    <ng-container *ngIf=\"!rangeSelection; else dateRangeInput\">\n      <input\n        type=\"text\"\n        id=\"{{ id }}\"\n        name=\"date\"\n        class=\"form-control bb-input-datepicker__input\"\n        [attr.placeholder]=\"placeholder\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"datepickerDescribedby\"\n        [attr.aria-expanded]=\"ariaExpanded\"\n        [attr.role]=\"role\"\n        [attr.aria-invalid]=\"ariaInvalid\"\n        [attr.aria-owns]=\"ariaOwns\"\n        [attr.aria-activedescendant]=\"ariaActivedescendant\"\n        [attr.aria-label]=\"(!label && ariaLabel) || null\"\n        ngbDatepicker\n        [minDate]=\"_minDate\"\n        [maxDate]=\"_maxDate\"\n        [markDisabled]=\"markDisabled\"\n        [readOnly]=\"readonly\"\n        [required]=\"required\"\n        [navigation]=\"navigation\"\n        [dayTemplate]=\"rangeSelectionSplit ? rangeDay : singleDay\"\n        [displayMonths]=\"displayMonths\"\n        [formControl]=\"dateInput\"\n        [placement]=\"placement\"\n        [positionTarget]=\"positionTarget\"\n        [restoreFocus]=\"!rangeSelectionSplit\"\n        (ngModelChange)=\"!rangeSelectionSplit ? onChange($event) : null\"\n        (click)=\"onInputFocus(clickOpen)\"\n        (focus)=\"onInputFocus(focusOpen)\"\n        (blur)=\"onControlBlur($event)\"\n        (input)=\"rangeSelectionSplit ? onInputChangeSplitRange(datePickerInput) : onInputChange(datePickerInput)\"\n        (closed)=\"onClosed()\"\n        #datePicker=\"ngbDatepicker\"\n        #datePickerInput\n        [attr.data-role]=\"'input-date-single'\"\n        [attr.autocomplete]=\"autocomplete\"\n        [firstDayOfWeek]=\"firstDayOfWeek\"\n        (dateSelect)=\"rangeSelectionSplit ? onRangeDateSelectSplit($event) : null\"\n        [autoClose]=\"!rangeSelectionSplit\"\n      />\n    </ng-container>\n\n    <div\n      *ngIf=\"datepickerDescribedby === 'defaultDatepickerDescribedbyLabel'\"\n      class=\"sr-only\"\n      aria-live=\"polite\"\n      id=\"defaultDatepickerDescribedbyLabel\"\n    >\n      <ng-container *ngIf=\"hoveredDate$ | async as hoveredDate\">\n        <span\n          *ngIf=\"hoveredDate.isSelecting; else selectedDate\"\n          i18n=\"Default selecting date state i18n message@@defaultSelectingState.with.i18n.support\"\n          >Selecting date:\n          {{\n            hoveredDate.date.year + '-' + hoveredDate.date.month + '-' + hoveredDate.date.day | date: 'longDate'\n          }}</span\n        >\n        <ng-template #selectedDate>\n          <ng-container\n            i18n=\"Default selected date state i18n message@@defaultSelectedState.with.i18n.support\"\n            *ngIf=\"hoveredDate.date\"\n            >Selected date is{{\n              hoveredDate.date.year + '-' + hoveredDate.date.month + '-' + hoveredDate.date.day | date: 'longDate'\n            }}.</ng-container\n          >\n        </ng-template>\n      </ng-container>\n    </div>\n\n    <div class=\"input-group-append\">\n      <button\n        #datePickerButton\n        bbButton\n        class=\"bb-input-datepicker__calendar-opener-button\"\n        [color]=\"btnColor\"\n        [disabled]=\"disabled || readonly\"\n        (blur)=\"onControlBlur($event)\"\n        [attr.aria-label]=\"ariaLabelForButton\"\n        (click)=\"onPickerTogglerClick($event)\"\n        [attr.data-role]=\"'toggle-calendar-button'\"\n      >\n        <bb-icon-ui [color]=\"iconColor\" [name]=\"icon\" [size]=\"iconSize\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n\n  <div class=\"input-group bb-input-datepicker\" *ngIf=\"rangeSelectionSplit\">\n    <input\n      type=\"text\"\n      id=\"to_{{ id }}\"\n      name=\"dateTo\"\n      class=\"form-control bb-input-datepicker__input\"\n      [attr.placeholder]=\"placeholder\"\n      [attr.aria-labelledby]=\"ariaLabelledby\"\n      [attr.aria-describedby]=\"datepickerDescribedby\"\n      [attr.aria-expanded]=\"ariaExpanded\"\n      [attr.role]=\"role\"\n      [attr.aria-invalid]=\"ariaInvalid\"\n      [attr.aria-owns]=\"ariaOwns\"\n      [attr.aria-activedescendant]=\"ariaActivedescendant\"\n      [attr.aria-label]=\"(!label && ariaLabel) || null\"\n      ngbDatepicker\n      [minDate]=\"_minDate\"\n      [maxDate]=\"_maxDate\"\n      [markDisabled]=\"markDisabled\"\n      [readOnly]=\"readonly\"\n      [required]=\"required\"\n      [displayMonths]=\"displayMonths\"\n      [navigation]=\"navigation\"\n      [restoreFocus]=\"false\"\n      [dayTemplate]=\"rangeDay\"\n      [dayTemplateData]=\"rangeTemplateData\"\n      [formControl]=\"dateInputTo\"\n      [placement]=\"placement\"\n      (click)=\"onInputFocusTo(clickOpen)\"\n      (focus)=\"onInputFocusTo(focusOpen)\"\n      (blur)=\"onControlBlur($event)\"\n      (input)=\"rangeSelectionSplit ? onInputChangeSplitRangeTo(datePickerInputTo) : onInputChange(datePickerInputTo)\"\n      (closed)=\"onClosedTo()\"\n      #datePickerTo=\"ngbDatepicker\"\n      #datePickerInputTo\n      [attr.data-role]=\"'input-date-single'\"\n      [attr.autocomplete]=\"autocomplete\"\n      [firstDayOfWeek]=\"firstDayOfWeek\"\n      (dateSelect)=\"rangeSelectionSplit ? onRangeDateSelectSplitTo($event) : null\"\n      [autoClose]=\"!rangeSelectionSplit\"\n    />\n    <div class=\"input-group-append\">\n      <button\n        #datePickerButtonTo\n        bbButton\n        class=\"bb-input-datepicker__calendar-opener-button\"\n        [color]=\"btnColor\"\n        [disabled]=\"disabled || readonly\"\n        [attr.aria-label]=\"ariaLabelForButton\"\n        (blur)=\"onControlBlur($event)\"\n        (click)=\"onPickerTogglerClickTo($event)\"\n        [attr.data-role]=\"'toggle-calendar-button'\"\n      >\n        <bb-icon-ui [color]=\"iconColor\" [name]=\"icon\" [size]=\"iconSize\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n</div>\n\n<!-- Single input date range template -->\n\n<ng-template #dateRangeInput>\n  <input\n    type=\"text\"\n    name=\"date\"\n    id=\"{{ id }}\"\n    class=\"form-control bb-input-datepicker__range\"\n    [formControl]=\"dateInput\"\n    [readOnly]=\"readonly\"\n    [required]=\"required\"\n    #datePickerRangeInput\n    [attr.placeholder]=\"placeholder\"\n    [attr.aria-label]=\"(!label && ariaLabel) || null\"\n    [attr.aria-describedby]=\"datepickerDescribedby\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-expanded]=\"ariaExpanded\"\n    [attr.role]=\"role\"\n    [attr.aria-invalid]=\"ariaInvalid\"\n    [attr.aria-owns]=\"ariaOwns\"\n    [attr.aria-activedescendant]=\"ariaActivedescendant\"\n    (click)=\"onInputFocus(clickOpen)\"\n    (focus)=\"onInputFocus(focusOpen)\"\n    (blur)=\"onControlBlur($event)\"\n    (input)=\"onInputChangeRange(datePickerRangeInput)\"\n    [attr.data-role]=\"'input-date-range'\"\n  />\n\n  <input\n    type=\"text\"\n    class=\"datepicker-input-hidden bb-input-datepicker__range-input-hidden\"\n    ngbDatepicker\n    (closed)=\"onClosed()\"\n    [minDate]=\"_minDate\"\n    [maxDate]=\"_maxDate\"\n    [markDisabled]=\"markDisabled\"\n    [autoClose]=\"false\"\n    [attr.aria-label]=\"label || ariaLabel || null\"\n    [attr.aria-describedby]=\"datepickerDescribedby\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-expanded]=\"ariaExpanded\"\n    [attr.role]=\"role\"\n    [attr.aria-invalid]=\"ariaInvalid\"\n    [attr.aria-owns]=\"ariaOwns\"\n    [attr.aria-activedescendant]=\"ariaActivedescendant\"\n    [readOnly]=\"readonly\"\n    [required]=\"required\"\n    [firstDayOfWeek]=\"firstDayOfWeek\"\n    [positionTarget]=\"positionTarget\"\n    [placement]=\"placement\"\n    #datePicker=\"ngbDatepicker\"\n    [dayTemplate]=\"rangeDay\"\n    navigation=\"arrows\"\n    [attr.data-role]=\"'input-datepicker'\"\n    (dateSelect)=\"onRangeDateSelect($event)\"\n  />\n</ng-template>\n\n<!-- template end -->\n\n<!-- Single Date day template -->\n<ng-template\n  #singleDay\n  let-date=\"date\"\n  let-disabled=\"disabled\"\n  let-selected=\"selected\"\n  let-currentMonth=\"currentMonth\"\n  let-data=\"data\"\n>\n  <bb-input-datepicker-single-day-template-ui\n    [disabled]=\"disabled\"\n    [selected]=\"selected\"\n    [currentMonth]=\"currentMonth\"\n    [date]=\"date\"\n    (hovered)=\"onDayHover($event)\"\n    [hoveredDate]=\"data?.isTo ? pickerHoveredDayDateTo : hoveredDate$.getValue().date\"\n  >\n  </bb-input-datepicker-single-day-template-ui>\n</ng-template>\n\n<!-- template end -->\n\n<!-- Date range day template -->\n<ng-template\n  #rangeDay\n  let-date=\"date\"\n  let-disabled=\"disabled\"\n  let-selected=\"selected\"\n  let-currentMonth=\"currentMonth\"\n  let-data=\"data\"\n>\n  <bb-input-datepicker-range-day-template-ui\n    [date]=\"date\"\n    [fromDate]=\"fromDate$.getValue()\"\n    [toDate]=\"toDate$.getValue()\"\n    [splitRange]=\"rangeSelectionSplit\"\n    [toDateDatepicker]=\"data?.isTo\"\n    [disabled]=\"disabled\"\n    [currentMonth]=\"currentMonth\"\n    (hovered)=\"onDayHover($event)\"\n    [hoveredDate]=\"data?.isTo ? pickerHoveredDayDateTo : hoveredDate$.getValue().date\"\n  >\n  </bb-input-datepicker-range-day-template-ui>\n</ng-template>\n", components: [{ type: i5__namespace.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: InputDatepickerDayTemplateSingleComponent, selector: "bb-input-datepicker-single-day-template-ui", inputs: ["date", "selected", "disabled", "currentMonth", "hoveredDate"], outputs: ["hovered"] }, { type: InputDatepickerDayTemplateRangeComponent, selector: "bb-input-datepicker-range-day-template-ui", inputs: ["date", "disabled", "currentMonth", "fromDate", "toDate", "splitRange", "toDateDatepicker", "hoveredDate"], outputs: ["rangeSelect", "hovered"] }], directives: [{ type: i8__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i8__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3__namespace.NgbInputDatepicker, selector: "input[ngbDatepicker]", inputs: ["disabled", "autoClose", "datepickerClass", "dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "placement", "restoreFocus", "showWeekNumbers", "startDate", "container", "positionTarget", "weekdays"], outputs: ["dateSelect", "navigate", "closed"], exportAs: ["ngbDatepicker"] }, { type: i9__namespace.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i9__namespace.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i9__namespace.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i9__namespace.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i10__namespace.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], pipes: { "async": i8__namespace.AsyncPipe, "date": i8__namespace.DatePipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-input-datepicker-ui',
                        templateUrl: './input-datepicker.component.html',
                        providers: [
                            i8.DatePipe,
                            NgbDateLocaleParserFormatter,
                            {
                                provide: i3.NgbDateAdapter,
                                useClass: NgbDateStringAdapter,
                            },
                            {
                                provide: i3.NgbDatepickerI18n,
                                useClass: NgbDatepickerI18nDefault,
                            },
                            {
                                provide: i3.NgbDateParserFormatter,
                                useExisting: NgbDateLocaleParserFormatter,
                            },
                            {
                                provide: i9.NG_VALUE_ACCESSOR,
                                useExisting: i0.forwardRef(function () { return InputDatepickerComponent; }),
                                multi: true,
                            },
                            {
                                provide: i9.NG_VALIDATORS,
                                useExisting: i0.forwardRef(function () { return InputDatepickerComponent; }),
                                multi: true,
                            },
                        ],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: NgbDateLocaleParserFormatter }, { type: i0__namespace.ElementRef }, { type: i0__namespace.ChangeDetectorRef }, { type: i2__namespace$1.DeprecationsService }, { type: i3__namespace.NgbDateAdapter }, { type: i0__namespace.Renderer2 }, { type: i2__namespace.DomAttributesService }]; }, propDecorators: { focusedDate: [{
                    type: i0.Output
                }], rangeSelection: [{
                    type: i0.Input
                }], rangeSelectionSplit: [{
                    type: i0.Input
                }], clickOpen: [{
                    type: i0.Input
                }], focusOpen: [{
                    type: i0.Input
                }], placement: [{
                    type: i0.Input
                }], datepickerDescribedby: [{
                    type: i0.Input
                }], ariaLabelForButton: [{
                    type: i0.Input
                }], minDate: [{
                    type: i0.Input
                }], maxDate: [{
                    type: i0.Input
                }], markDisabled: [{
                    type: i0.Input
                }], icon: [{
                    type: i0.Input
                }], iconSize: [{
                    type: i0.Input
                }], iconColor: [{
                    type: i0.Input
                }], btnColor: [{
                    type: i0.Input
                }], ariaLabel: [{
                    type: i0.Input
                }], navigation: [{
                    type: i0.Input
                }], autocomplete: [{
                    type: i0.Input
                }], firstDayOfWeek: [{
                    type: i0.Input
                }], displayMonths: [{
                    type: i0.Input
                }], placeholder: [{
                    type: i0.Input,
                    args: ['placeholder']
                }], overrideDateFormat: [{
                    type: i0.Input,
                    args: ['overrideDateFormat']
                }], datePicker: [{
                    type: i0.ViewChild,
                    args: ['datePicker']
                }], datePickerTo: [{
                    type: i0.ViewChild,
                    args: ['datePickerTo']
                }], datePickerInput: [{
                    type: i0.ViewChild,
                    args: ['datePickerInput']
                }], datePickerRangeInput: [{
                    type: i0.ViewChild,
                    args: ['datePickerRangeInput']
                }], datePickerInputTo: [{
                    type: i0.ViewChild,
                    args: ['datePickerInputTo']
                }], datePickerButton: [{
                    type: i0.ViewChild,
                    args: ['datePickerButton']
                }], datePickerButtonTo: [{
                    type: i0.ViewChild,
                    args: ['datePickerButtonTo']
                }], cssClass: [{
                    type: i0.HostBinding,
                    args: ['attr.class']
                }] } });

    var MinDateValidatorDirective = /** @class */ (function () {
        function MinDateValidatorDirective() {
            this._minDate = -Number.MAX_VALUE;
            this.onValidatorChange = function () { };
        }
        Object.defineProperty(MinDateValidatorDirective.prototype, "minDate", {
            set: function (date) {
                if (!date) {
                    this._minDate = -Number.MAX_VALUE;
                }
                else {
                    var minDate = typeof date === 'string' ? new Date(date) : new Date(date.year, date.month - 1, date.day);
                    this._minDate = minDate.getTime();
                }
                this.onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        MinDateValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onValidatorChange = fn;
        };
        MinDateValidatorDirective.prototype.validate = function (control) {
            var value = control.value && control.value.from ? control.value.from : control.value;
            if (!value) {
                return null;
            }
            return new Date(value).getTime() >= this._minDate
                ? // eslint-disable-next-line no-null/no-null
                    null
                : { dateLessThanMinDate: true };
        };
        MinDateValidatorDirective.prototype.ngOnDestroy = function () {
            this.minDate = undefined;
        };
        return MinDateValidatorDirective;
    }());
    MinDateValidatorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: MinDateValidatorDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    MinDateValidatorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: MinDateValidatorDirective, selector: "bb-input-datepicker-ui[minDate]", inputs: { minDate: "minDate" }, providers: [
            {
                provide: i9.NG_VALIDATORS,
                multi: true,
                useExisting: i0.forwardRef(function () { return MinDateValidatorDirective; }),
            },
        ], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: MinDateValidatorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // eslint-disable-next-line @angular-eslint/directive-selector
                        selector: 'bb-input-datepicker-ui[minDate]',
                        providers: [
                            {
                                provide: i9.NG_VALIDATORS,
                                multi: true,
                                useExisting: i0.forwardRef(function () { return MinDateValidatorDirective; }),
                            },
                        ],
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { minDate: [{
                    type: i0.Input
                }] } });

    var MaxDateValidatorDirective = /** @class */ (function () {
        function MaxDateValidatorDirective() {
            this._maxDate = Number.MAX_VALUE;
            this.onValidatorChange = function () { };
        }
        Object.defineProperty(MaxDateValidatorDirective.prototype, "maxDate", {
            set: function (date) {
                if (!date) {
                    this._maxDate = Number.MAX_VALUE;
                }
                else {
                    var maxDate = typeof date === 'string' ? new Date(date) : new Date(date.year, date.month - 1, date.day);
                    this._maxDate = maxDate.getTime();
                }
                this.onValidatorChange();
            },
            enumerable: false,
            configurable: true
        });
        MaxDateValidatorDirective.prototype.registerOnValidatorChange = function (fn) {
            this.onValidatorChange = fn;
        };
        MaxDateValidatorDirective.prototype.validate = function (control) {
            var value = control.value && control.value.to ? control.value.to : control.value;
            if (!value) {
                return null;
            }
            return new Date(value).getTime() <= this._maxDate
                ? // eslint-disable-next-line no-null/no-null
                    null
                : { dateGreaterThanMaxDate: true };
        };
        MaxDateValidatorDirective.prototype.ngOnDestroy = function () {
            this.maxDate = undefined;
        };
        return MaxDateValidatorDirective;
    }());
    MaxDateValidatorDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: MaxDateValidatorDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    MaxDateValidatorDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: MaxDateValidatorDirective, selector: "bb-input-datepicker-ui[maxDate]", inputs: { maxDate: "maxDate" }, providers: [
            {
                provide: i9.NG_VALIDATORS,
                multi: true,
                useExisting: i0.forwardRef(function () { return MaxDateValidatorDirective; }),
            },
        ], ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: MaxDateValidatorDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        // eslint-disable-next-line @angular-eslint/directive-selector
                        selector: 'bb-input-datepicker-ui[maxDate]',
                        providers: [
                            {
                                provide: i9.NG_VALIDATORS,
                                multi: true,
                                useExisting: i0.forwardRef(function () { return MaxDateValidatorDirective; }),
                            },
                        ],
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { maxDate: [{
                    type: i0.Input
                }] } });

    var InputDatepickerModule = /** @class */ (function () {
        function InputDatepickerModule() {
        }
        return InputDatepickerModule;
    }());
    InputDatepickerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    InputDatepickerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerModule, declarations: [InputDatepickerComponent,
            MinDateValidatorDirective,
            MaxDateValidatorDirective,
            InputDatepickerDayTemplateSingleComponent,
            InputDatepickerDayTemplateRangeComponent], imports: [i8.CommonModule,
            i9.ReactiveFormsModule,
            i9.FormsModule,
            i3.NgbDatepickerModule,
            i10.ButtonModule,
            i5.IconModule,
            baseClasses.BaseClassesModule], exports: [InputDatepickerComponent,
            MinDateValidatorDirective,
            MaxDateValidatorDirective,
            /**
             * @deprecated
             * Exporting `FormsModule` is deprecated
             **/
            i9.FormsModule] });
    InputDatepickerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerModule, imports: [[
                i8.CommonModule,
                i9.ReactiveFormsModule,
                i9.FormsModule,
                i3.NgbDatepickerModule,
                i10.ButtonModule,
                i5.IconModule,
                baseClasses.BaseClassesModule,
            ],
            /**
             * @deprecated
             * Exporting `FormsModule` is deprecated
             **/
            i9.FormsModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: InputDatepickerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i8.CommonModule,
                            i9.ReactiveFormsModule,
                            i9.FormsModule,
                            i3.NgbDatepickerModule,
                            i10.ButtonModule,
                            i5.IconModule,
                            baseClasses.BaseClassesModule,
                        ],
                        declarations: [
                            InputDatepickerComponent,
                            MinDateValidatorDirective,
                            MaxDateValidatorDirective,
                            InputDatepickerDayTemplateSingleComponent,
                            InputDatepickerDayTemplateRangeComponent,
                        ],
                        exports: [
                            InputDatepickerComponent,
                            MinDateValidatorDirective,
                            MaxDateValidatorDirective,
                            /**
                             * @deprecated
                             * Exporting `FormsModule` is deprecated
                             **/
                            i9.FormsModule,
                        ],
                    }]
            }] });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CalendarPopupComponent = InputDatepickerComponent;
    exports.CalendarPopupModule = InputDatepickerModule;
    exports.DATEPICKER_I18 = DATEPICKER_I18;
    exports.InputDatepickerComponent = InputDatepickerComponent;
    exports.InputDatepickerModule = InputDatepickerModule;
    exports.MaxDateValidatorDirective = MaxDateValidatorDirective;
    exports.MinDateValidatorDirective = MinDateValidatorDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=backbase-ui-ang-input-datepicker.umd.js.map
