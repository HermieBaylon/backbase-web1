import { Component, ChangeDetectionStrategy, forwardRef, } from '@angular/core';
import { FormGroup, NG_VALUE_ACCESSOR } from '@angular/forms';
import { filter, takeUntil } from 'rxjs/operators';
import { InputBaseComponent } from '@backbase/ui-ang/base-classes';
import { BehaviorSubject, combineLatest, Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/foundation-ang/future";
import * as i2 from "@angular/forms";
import * as i3 from "@backbase/ui-ang/input-checkbox";
import * as i4 from "@angular/common";
/**
 * @name CheckboxGroupComponent
 *
 * @description
 * Stores a state, determines it and displays a parent checkbox for a checkboxes group.
 * Required module(s): FormsModule
 */
export class CheckboxGroupComponent extends InputBaseComponent {
    constructor(cd, deprecationsService, controlContainer) {
        super(cd, deprecationsService);
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        this.controlContainer = controlContainer;
        this.indeterminate = false;
        this.skip$ = new BehaviorSubject(false);
        this.unsubscribe$ = new Subject();
    }
    ngAfterContentChecked() {
        if (this.controlContainer.control && this.control !== this.controlContainer.control) {
            this.control = this.controlContainer.control;
            this.checkState(this.control.value);
            combineLatest(this.control.valueChanges, this.skip$)
                .pipe(filter(([state, skip]) => !skip), takeUntil(this.unsubscribe$))
                .subscribe(([state]) => this.checkState(state));
        }
    }
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    onValueChange() {
        const setValue = (control) => {
            Object.keys(control.value).forEach((key) => control.controls[key] instanceof FormGroup
                ? setValue(control.controls[key])
                : control.controls[key].setValue(this.value));
        };
        if (this.control) {
            this.skip$.next(true);
            setValue(this.control);
            this.skip$.next(false);
        }
        super.onValueChange();
    }
    isDisabled() {
        return (!!this.control &&
            Object.keys(this.control.controls).every((key) => (this.control &&
                this.control.controls &&
                this.control.controls[key] &&
                this.control.controls[key].disabled) ||
                false));
    }
    checkState(state) {
        /**
         * @param arrayHandler - a function to iterate over a tree
         * @description iterates over a tree using an arrayHandler function
         * @return a function which recursively calls arrayHandler over a tree
         */
        const checkGroup = (arrayHandler) => {
            /**
             * @param value - primitive or tree data structure
             * @return
             * if input value is a primitive - returns value, casted to boolean,
             * if input value is a tree - returns result of recursively calling arrayHandler function over a tree
             */
            const checkValue = (value) => typeof value === 'object' && value !== null
                ? arrayHandler.call(Object.keys(value).map((key) => value[key]), checkValue)
                : !!value;
            return (value) => arrayHandler.call(Object.keys(value).map((key) => value[key]), checkValue);
        };
        const isAllChecked = checkGroup(Array.prototype.every)(state);
        const isSomeChecked = checkGroup(Array.prototype.some)(state);
        this.indeterminate = isSomeChecked && !isAllChecked;
        this.writeValue(isAllChecked);
    }
}
CheckboxGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CheckboxGroupComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.DeprecationsService }, { token: i2.ControlContainer }], target: i0.ɵɵFactoryTarget.Component });
CheckboxGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: CheckboxGroupComponent, selector: "bb-checkbox-group-ui", providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => CheckboxGroupComponent),
            multi: true,
        },
    ], usesInheritance: true, ngImport: i0, template: "<bb-input-checkbox-ui\n  [label]=\"label\"\n  [aria-label]=\"(!label && ariaLabel) || null\"\n  [(indeterminate)]=\"indeterminate\"\n  [(ngModel)]=\"value\"\n  [disabled]=\"isDisabled()\"\n  (change)=\"onValueChange()\"\n>\n  <ng-content *ngIf=\"!label\"></ng-content>\n</bb-input-checkbox-ui>\n", components: [{ type: i3.InputCheckboxComponent, selector: "bb-input-checkbox-ui", inputs: ["indeterminate"], outputs: ["indeterminateChange"] }], directives: [{ type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CheckboxGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-checkbox-group-ui',
                    templateUrl: './checkbox-group.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => CheckboxGroupComponent),
                            multi: true,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.DeprecationsService }, { type: i2.ControlContainer }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3gtZ3JvdXAuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvY2hlY2tib3gtZ3JvdXAvY2hlY2tib3gtZ3JvdXAuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvY2hlY2tib3gtZ3JvdXAvY2hlY2tib3gtZ3JvdXAuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCx1QkFBdUIsRUFDdkIsVUFBVSxHQUlYLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBb0IsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDaEYsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7Ozs7OztBQUcvRDs7Ozs7O0dBTUc7QUFhSCxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsa0JBQWtCO0lBTTVELFlBQ3FCLEVBQXFCLEVBQ3JCLG1CQUF3QyxFQUMxQyxnQkFBa0M7UUFFbkQsS0FBSyxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBSlosT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUFDckIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUMxQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBUnJELGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBRUwsVUFBSyxHQUFHLElBQUksZUFBZSxDQUFVLEtBQUssQ0FBQyxDQUFDO1FBQzVDLGlCQUFZLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztJQVFwRCxDQUFDO0lBRUQscUJBQXFCO1FBQ25CLElBQUks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OzRCQUNyRCxLQUFLLEVBQUUsSUFBSTt5QkFDWjtxQkFDRjtpQkFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIGZvcndhcmRSZWYsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBBZnRlckNvbnRlbnRDaGVja2VkLFxuICBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbENvbnRhaW5lciwgRm9ybUdyb3VwLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSW5wdXRCYXNlQ29tcG9uZW50IH0gZnJvbSAnQGJhY2tiYXNlL3VpLWFuZy9iYXNlLWNsYXNzZXMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBEZXByZWNhdGlvbnNTZXJ2aWNlIH0gZnJvbSAnQGJhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2Z1dHVyZSc7XG5cbi8qKlxuICogQG5hbWUgQ2hlY2tib3hHcm91cENvbXBvbmVudFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogU3RvcmVzIGEgc3RhdGUsIGRldGVybWluZXMgaXQgYW5kIGRpc3BsYXlzIGEgcGFyZW50IGNoZWNrYm94IGZvciBhIGNoZWNrYm94ZXMgZ3JvdXAuXG4gKiBSZXF1aXJlZCBtb2R1bGUocyk6IEZvcm1zTW9kdWxlXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWNoZWNrYm94LWdyb3VwLXVpJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2NoZWNrYm94LWdyb3VwLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHByb3ZpZGVyczogW1xuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hHcm91cENvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDaGVja2JveEdyb3VwQ29tcG9uZW50IGV4dGVuZHMgSW5wdXRCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICBwcml2YXRlIGNvbnRyb2w/OiBGb3JtR3JvdXA7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2tpcCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgcHJpdmF0ZSByZWFkb25seSB1bnN1YnNjcmliZSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCByZWFkb25seSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGRlcHJlY2F0aW9uc1NlcnZpY2U6IERlcHJlY2F0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb250cm9sQ29udGFpbmVyOiBDb250cm9sQ29udGFpbmVyLFxuICApIHtcbiAgICBzdXBlcihjZCwgZGVwcmVjYXRpb25zU2VydmljZSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbENvbnRhaW5lci5jb250cm9sICYmIHRoaXMuY29udHJvbCAhPT0gdGhpcy5jb250cm9sQ29udGFpbmVyLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMuY29udHJvbENvbnRhaW5lci5jb250cm9sIGFzIEZvcm1Hcm91cDtcbiAgICAgIHRoaXMuY2hlY2tTdGF0ZSh0aGlzLmNvbnRyb2wudmFsdWUpO1xuICAgICAgY29tYmluZUxhdGVzdCh0aGlzLmNvbnRyb2wudmFsdWVDaGFuZ2VzLCB0aGlzLnNraXAkKVxuICAgICAgICAucGlwZShcbiAgICAgICAgICBmaWx0ZXIoKFtzdGF0ZSwgc2tpcF0pID0+ICFza2lwKSxcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy51bnN1YnNjcmliZSQpLFxuICAgICAgICApXG4gICAgICAgIC5zdWJzY3JpYmUoKFtzdGF0ZV0pID0+IHRoaXMuY2hlY2tTdGF0ZShzdGF0ZSkpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmUkLm5leHQoKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlJC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgb25WYWx1ZUNoYW5nZSgpIHtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IChjb250cm9sOiBGb3JtR3JvdXApID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2wudmFsdWUpLmZvckVhY2goKGtleSkgPT5cbiAgICAgICAgY29udHJvbC5jb250cm9sc1trZXldIGluc3RhbmNlb2YgRm9ybUdyb3VwXG4gICAgICAgICAgPyBzZXRWYWx1ZShjb250cm9sLmNvbnRyb2xzW2tleV0gYXMgRm9ybUdyb3VwKVxuICAgICAgICAgIDogY29udHJvbC5jb250cm9sc1trZXldLnNldFZhbHVlKHRoaXMudmFsdWUpLFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY29udHJvbCkge1xuICAgICAgdGhpcy5za2lwJC5uZXh0KHRydWUpO1xuICAgICAgc2V0VmFsdWUodGhpcy5jb250cm9sKTtcbiAgICAgIHRoaXMuc2tpcCQubmV4dChmYWxzZSk7XG4gICAgfVxuICAgIHN1cGVyLm9uVmFsdWVDaGFuZ2UoKTtcbiAgfVxuXG4gIGlzRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgICEhdGhpcy5jb250cm9sICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2wuY29udHJvbHMpLmV2ZXJ5KFxuICAgICAgICAoa2V5KSA9PlxuICAgICAgICAgICh0aGlzLmNvbnRyb2wgJiZcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5jb250cm9scyAmJlxuICAgICAgICAgICAgdGhpcy5jb250cm9sLmNvbnRyb2xzW2tleV0gJiZcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5jb250cm9sc1trZXldLmRpc2FibGVkKSB8fFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrU3RhdGUoc3RhdGU6IHsgW3M6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQgfSkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhcnJheUhhbmRsZXIgLSBhIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIHRyZWVcbiAgICAgKiBAZGVzY3JpcHRpb24gaXRlcmF0ZXMgb3ZlciBhIHRyZWUgdXNpbmcgYW4gYXJyYXlIYW5kbGVyIGZ1bmN0aW9uXG4gICAgICogQHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIHJlY3Vyc2l2ZWx5IGNhbGxzIGFycmF5SGFuZGxlciBvdmVyIGEgdHJlZVxuICAgICAqL1xuICAgIGNvbnN0IGNoZWNrR3JvdXAgPSAoYXJyYXlIYW5kbGVyOiBGdW5jdGlvbikgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gdmFsdWUgLSBwcmltaXRpdmUgb3IgdHJlZSBkYXRhIHN0cnVjdHVyZVxuICAgICAgICogQHJldHVyblxuICAgICAgICogaWYgaW5wdXQgdmFsdWUgaXMgYSBwcmltaXRpdmUgLSByZXR1cm5zIHZhbHVlLCBjYXN0ZWQgdG8gYm9vbGVhbixcbiAgICAgICAqIGlmIGlucHV0IHZhbHVlIGlzIGEgdHJlZSAtIHJldHVybnMgcmVzdWx0IG9mIHJlY3Vyc2l2ZWx5IGNhbGxpbmcgYXJyYXlIYW5kbGVyIGZ1bmN0aW9uIG92ZXIgYSB0cmVlXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNoZWNrVmFsdWUgPSAodmFsdWU/OiB7IFtzOiBzdHJpbmddOiBib29sZWFuIHwgdW5kZWZpbmVkIH0gfCBib29sZWFuKTogYm9vbGVhbiA9PlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsXG4gICAgICAgICAgPyBhcnJheUhhbmRsZXIuY2FsbChcbiAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2V5KSA9PiB2YWx1ZVtrZXldKSxcbiAgICAgICAgICAgICAgY2hlY2tWYWx1ZSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6ICEhdmFsdWU7XG5cbiAgICAgIHJldHVybiAodmFsdWU6IHsgW3M6IHN0cmluZ106IGJvb2xlYW4gfCB1bmRlZmluZWQgfSkgPT5cbiAgICAgICAgYXJyYXlIYW5kbGVyLmNhbGwoXG4gICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2V5KSA9PiB2YWx1ZVtrZXldKSxcbiAgICAgICAgICBjaGVja1ZhbHVlLFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICBjb25zdCBpc0FsbENoZWNrZWQgPSBjaGVja0dyb3VwKEFycmF5LnByb3RvdHlwZS5ldmVyeSkoc3RhdGUpO1xuICAgIGNvbnN0IGlzU29tZUNoZWNrZWQgPSBjaGVja0dyb3VwKEFycmF5LnByb3RvdHlwZS5zb21lKShzdGF0ZSk7XG4gICAgdGhpcy5pbmRldGVybWluYXRlID0gaXNTb21lQ2hlY2tlZCAmJiAhaXNBbGxDaGVja2VkO1xuICAgIHRoaXMud3JpdGVWYWx1ZShpc0FsbENoZWNrZWQpO1xuICB9XG59XG4iLCI8YmItaW5wdXQtY2hlY2tib3gtdWlcbiAgW2xhYmVsXT1cImxhYmVsXCJcbiAgW2FyaWEtbGFiZWxdPVwiKCFsYWJlbCAmJiBhcmlhTGFiZWwpIHx8IG51bGxcIlxuICBbKGluZGV0ZXJtaW5hdGUpXT1cImluZGV0ZXJtaW5hdGVcIlxuICBbKG5nTW9kZWwpXT1cInZhbHVlXCJcbiAgW2Rpc2FibGVkXT1cImlzRGlzYWJsZWQoKVwiXG4gIChjaGFuZ2UpPVwib25WYWx1ZUNoYW5nZSgpXCJcbj5cbiAgPG5nLWNvbnRlbnQgKm5nSWY9XCIhbGFiZWxcIj48L25nLWNvbnRlbnQ+XG48L2JiLWlucHV0LWNoZWNrYm94LXVpPlxuIl19