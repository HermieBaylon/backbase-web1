import { ChangeDetectionStrategy, Component, forwardRef, Input, Output, ViewChild, } from '@angular/core';
import { InputBaseComponent } from '@backbase/ui-ang/base-classes';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { idListAttr } from '@backbase/ui-ang/util';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/ui-ang/services";
import * as i2 from "@backbase/foundation-ang/future";
import * as i3 from "@backbase/ui-ang/char-counter";
import * as i4 from "@angular/common";
import * as i5 from "@angular/forms";
import * as i6 from "ngx-mask";
import * as i7 from "@backbase/ui-ang/focus";
/**
 * @name InputTextComponent
 *
 * @a11y Current component provide option to pass needed accessibility
 * attributes. You need to take care of properties that are required in your case :
 *  - role
 *  - aria-activedescendant
 *  - aria-describedby
 *  - aria-expanded
 *  - aria-invalid
 *  - aria-label
 *  - aria-labelledby
 *  - aria-owns
 *
 * @description
 * Component that displays a text input.
 */
export class InputTextComponent extends InputBaseComponent {
    constructor(domAttrService, elem, renderer2, cd, deprecationsService) {
        super(cd, deprecationsService);
        this.domAttrService = domAttrService;
        this.elem = elem;
        this.renderer2 = renderer2;
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        /**
         * The placeholder for the text input. Defaults to an empty string;
         */
        this.placeholder = '';
        /**
         * Whether the text input is readonly.
         */
        this.readonly = false;
        /**
         * ngx-mask related; default value imply no mask is used
         */
        this.mask = '';
        /**
         * ngx-mask related; default value imply validation is applied on mask pattern
         */
        this.maskValidator = true;
        /**
         * Shows character counter based on `maxLength`
         */
        this.showCharCounter = false;
        this.valueChange = this._valueChange;
        /**
         * Utility function for use in template
         */
        this.idListAttr = idListAttr;
        this.charCounterId = this.domAttrService.generateId();
    }
    ngAfterViewInit() {
        if (!this.ariaLabel) {
            this.domAttrService.moveAriaAttributes(this.elem.nativeElement, this.inputEl && this.inputEl.nativeElement, this.renderer2);
        }
    }
    focusEditableElement() {
        if (this.inputEl) {
            this.inputEl.nativeElement.focus();
        }
    }
}
InputTextComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputTextComponent, deps: [{ token: i1.DomAttributesService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i2.DeprecationsService }], target: i0.ɵɵFactoryTarget.Component });
InputTextComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputTextComponent, selector: "bb-input-text-ui", inputs: { placeholder: "placeholder", maxLength: "maxLength", minLength: "minLength", autocomplete: "autocomplete", readonly: "readonly", mask: "mask", maskValidator: "maskValidator", showCharCounter: "showCharCounter" }, outputs: { valueChange: "valueChange" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => InputTextComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "inputEl", first: true, predicate: ["inputText"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<label *ngIf=\"label\" for=\"{{ id }}\" [attr.data-role]=\"'label'\">{{ label }}</label>\n<input\n  id=\"{{ id }}\"\n  #inputText\n  [attr.aria-autocomplete]=\"ariaAutocomplete\"\n  [attr.aria-controls]=\"ariaControls\"\n  [attr.aria-describedby]=\"idListAttr(ariaDescribedby, maxLength && showCharCounter ? charCounterId : null)\"\n  [attr.aria-labelledby]=\"ariaLabelledby || null\"\n  [attr.aria-expanded]=\"ariaExpanded\"\n  [attr.role]=\"role\"\n  [attr.aria-invalid]=\"ariaInvalid\"\n  [attr.aria-owns]=\"ariaOwns\"\n  [attr.aria-label]=\"(!label && ariaLabel) || null\"\n  [ngModel]=\"value\"\n  (ngModelChange)=\"onValueChange($event)\"\n  (blur)=\"onBlur($event)\"\n  type=\"text\"\n  class=\"form-control\"\n  (focus)=\"onFocus($event)\"\n  [mask]=\"mask\"\n  [validation]=\"maskValidator\"\n  [disabled]=\"disabled\"\n  [readOnly]=\"readonly\"\n  [placeholder]=\"placeholder\"\n  [required]=\"required\"\n  [attr.size]=\"size\"\n  [attr.maxlength]=\"maxLength\"\n  [attr.minlength]=\"minLength\"\n  [attr.autocomplete]=\"autocomplete\"\n  [bbFocus]=\"autofocus\"\n  [ngClass]=\"inputClassName\"\n  [attr.data-role]=\"'input'\"\n/>\n<bb-char-counter-ui\n  [attr.id]=\"charCounterId\"\n  *ngIf=\"maxLength && showCharCounter\"\n  [element]=\"inputText\"\n  [inputValue]=\"value\"\n  [maxLength]=\"maxLength\"\n  [attr.data-role]=\"'text-input-char-counter'\"\n>\n</bb-char-counter-ui>\n", components: [{ type: i3.CharCounterComponent, selector: "bb-char-counter-ui", inputs: ["inputValue", "element", "maxLength", "blockTyping"] }], directives: [{ type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i6.MaskDirective, selector: "input[mask], textarea[mask]", inputs: ["mask", "specialCharacters", "patterns", "prefix", "suffix", "thousandSeparator", "decimalMarker", "dropSpecialCharacters", "hiddenInput", "showMaskTyped", "placeHolderCharacter", "shownMaskExpression", "showTemplate", "clearIfNotMatch", "validation", "separatorLimit", "allowNegativeNumbers", "leadZeroDateTime"] }, { type: i5.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i5.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i5.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i5.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { type: i5.MinLengthValidator, selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]", inputs: ["minlength"] }, { type: i7.FocusDirective, selector: "[bbFocus]", inputs: ["bbFocus"], exportAs: ["bbFocus"] }, { type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputTextComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-text-ui',
                    templateUrl: './input-text.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => InputTextComponent),
                            multi: true,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.DomAttributesService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i2.DeprecationsService }]; }, propDecorators: { placeholder: [{
                type: Input
            }], maxLength: [{
                type: Input
            }], minLength: [{
                type: Input
            }], autocomplete: [{
                type: Input
            }], readonly: [{
                type: Input
            }], mask: [{
                type: Input
            }], maskValidator: [{
                type: Input
            }], showCharCounter: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], inputEl: [{
                type: ViewChild,
                args: ['inputText']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtdGV4dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3VpLWFuZy9pbnB1dC10ZXh0L2lucHV0LXRleHQuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvaW5wdXQtdGV4dC9pbnB1dC10ZXh0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUdULFVBQVUsRUFDVixLQUFLLEVBQ0wsTUFBTSxFQUVOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVuRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7Ozs7OztBQUduRDs7Ozs7Ozs7Ozs7Ozs7OztHQWdCRztBQWFILE1BQU0sT0FBTyxrQkFBbUIsU0FBUSxrQkFBa0I7SUE4Q3hELFlBQ21CLGNBQW9DLEVBQ3BDLElBQWdCLEVBQ2hCLFNBQW9CLEVBQ2xCLEVBQXFCLEVBQ3JCLG1CQUF3QztRQUUzRCxLQUFLLENBQUMsRUFBRSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFOZCxtQkFBYyxHQUFkLGNBQWMsQ0FBc0I7UUFDcEMsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUNoQixjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ2xCLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBQ3JCLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFsRDdEOztXQUVHO1FBQ00sZ0JBQVcsR0FBRyxFQUFFLENBQUM7UUFZMUI7O1dBRUc7UUFFTSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRTFCOztXQUVHO1FBQ00sU0FBSSxHQUFHLEVBQUUsQ0FBQztRQUNuQjs7V0FFRztRQUNNLGtCQUFhLEdBQUcsSUFBSSxDQUFDO1FBRTlCOztXQUVHO1FBQ00sb0JBQWUsR0FBRyxLQUFLLENBQUM7UUFFdkIsZ0JBQVcsR0FBc0IsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUk3RDs7V0FFRztRQUNJLGVBQVUsR0FBRyxVQUFVLENBQUM7UUFXN0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3hELENBQUM7SUFFRCxlQUFlO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQ3ZCLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQzFDLElBQUksQ0FBQyxTQUFTLENBQ2YsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVELG9CQUFvQjtRQUNsQixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDcEM7SUFDSCxDQUFDOztnSEF2RVUsa0JBQWtCO29HQUFsQixrQkFBa0Isa1RBUmxCO1FBQ1Q7WUFDRSxPQUFPLEVBQUUsaUJBQWlCO1lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsa0JBQWtCLENBQUM7WUFDakQsS0FBSyxFQUFFLElBQUk7U0FDWjtLQUNGLHVKQzlDSCxxM0NBMENBOzRGRE1hLGtCQUFrQjtrQkFaOUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsa0JBQWtCO29CQUM1QixXQUFXLEVBQUUsNkJBQTZCO29CQUMxQyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtvQkFDL0MsU0FBUyxFQUFFO3dCQUNUOzRCQUNFLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLG1CQUFtQixDQUFDOzRCQUNqRCxLQUFLLEVBQUUsSUFBSTt5QkFDWjtxQkFDRjtpQkFDRjs4TkFLVSxXQUFXO3NCQUFuQixLQUFLO2dCQUlHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBSUcsU0FBUztzQkFBakIsS0FBSztnQkFFRyxZQUFZO3NCQUFwQixLQUFLO2dCQU1HLFFBQVE7c0JBQWhCLEtBQUs7Z0JBS0csSUFBSTtzQkFBWixLQUFLO2dCQUlHLGFBQWE7c0JBQXJCLEtBQUs7Z0JBS0csZUFBZTtzQkFBdkIsS0FBSztnQkFFSSxXQUFXO3NCQUFwQixNQUFNO2dCQVNpQixPQUFPO3NCQUE5QixTQUFTO3VCQUFDLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbnB1dEJhc2VDb21wb25lbnQgfSBmcm9tICdAYmFja2Jhc2UvdWktYW5nL2Jhc2UtY2xhc3Nlcyc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IERvbUF0dHJpYnV0ZXNTZXJ2aWNlIH0gZnJvbSAnQGJhY2tiYXNlL3VpLWFuZy9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBpZExpc3RBdHRyIH0gZnJvbSAnQGJhY2tiYXNlL3VpLWFuZy91dGlsJztcbmltcG9ydCB7IERlcHJlY2F0aW9uc1NlcnZpY2UgfSBmcm9tICdAYmFja2Jhc2UvZm91bmRhdGlvbi1hbmcvZnV0dXJlJztcblxuLyoqXG4gKiBAbmFtZSBJbnB1dFRleHRDb21wb25lbnRcbiAqXG4gKiBAYTExeSBDdXJyZW50IGNvbXBvbmVudCBwcm92aWRlIG9wdGlvbiB0byBwYXNzIG5lZWRlZCBhY2Nlc3NpYmlsaXR5XG4gKiBhdHRyaWJ1dGVzLiBZb3UgbmVlZCB0byB0YWtlIGNhcmUgb2YgcHJvcGVydGllcyB0aGF0IGFyZSByZXF1aXJlZCBpbiB5b3VyIGNhc2UgOlxuICogIC0gcm9sZVxuICogIC0gYXJpYS1hY3RpdmVkZXNjZW5kYW50XG4gKiAgLSBhcmlhLWRlc2NyaWJlZGJ5XG4gKiAgLSBhcmlhLWV4cGFuZGVkXG4gKiAgLSBhcmlhLWludmFsaWRcbiAqICAtIGFyaWEtbGFiZWxcbiAqICAtIGFyaWEtbGFiZWxsZWRieVxuICogIC0gYXJpYS1vd25zXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHRleHQgaW5wdXQuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWlucHV0LXRleHQtdWknLFxuICB0ZW1wbGF0ZVVybDogJy4vaW5wdXQtdGV4dC5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0VGV4dENvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dFRleHRDb21wb25lbnQgZXh0ZW5kcyBJbnB1dEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIFRoZSBwbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuIERlZmF1bHRzIHRvIGFuIGVtcHR5IHN0cmluZztcbiAgICovXG4gIEBJbnB1dCgpIHBsYWNlaG9sZGVyID0gJyc7XG4gIC8qKlxuICAgKiBUaGUgbWF4TGVuZ3RoIGZvciB0aGUgdGV4dCBpbnB1dC5cbiAgICovXG4gIEBJbnB1dCgpIG1heExlbmd0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogVGhlIG1pbkxlbmd0aCBmb3IgdGhlIHRleHQgaW5wdXQuXG4gICAqL1xuICBASW5wdXQoKSBtaW5MZW5ndGg6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBASW5wdXQoKSBhdXRvY29tcGxldGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgdGV4dCBpbnB1dCBpcyByZWFkb25seS5cbiAgICovXG5cbiAgQElucHV0KCkgcmVhZG9ubHkgPSBmYWxzZTtcblxuICAvKipcbiAgICogbmd4LW1hc2sgcmVsYXRlZDsgZGVmYXVsdCB2YWx1ZSBpbXBseSBubyBtYXNrIGlzIHVzZWRcbiAgICovXG4gIEBJbnB1dCgpIG1hc2sgPSAnJztcbiAgLyoqXG4gICAqIG5neC1tYXNrIHJlbGF0ZWQ7IGRlZmF1bHQgdmFsdWUgaW1wbHkgdmFsaWRhdGlvbiBpcyBhcHBsaWVkIG9uIG1hc2sgcGF0dGVyblxuICAgKi9cbiAgQElucHV0KCkgbWFza1ZhbGlkYXRvciA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFNob3dzIGNoYXJhY3RlciBjb3VudGVyIGJhc2VkIG9uIGBtYXhMZW5ndGhgXG4gICAqL1xuICBASW5wdXQoKSBzaG93Q2hhckNvdW50ZXIgPSBmYWxzZTtcblxuICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gdGhpcy5fdmFsdWVDaGFuZ2U7XG5cbiAgcHVibGljIGNoYXJDb3VudGVySWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgdXNlIGluIHRlbXBsYXRlXG4gICAqL1xuICBwdWJsaWMgaWRMaXN0QXR0ciA9IGlkTGlzdEF0dHI7XG5cbiAgQFZpZXdDaGlsZCgnaW5wdXRUZXh0JykgaW5wdXRFbDogRWxlbWVudFJlZiB8IHVuZGVmaW5lZDtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBkb21BdHRyU2VydmljZTogRG9tQXR0cmlidXRlc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBlbGVtOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVuZGVyZXIyOiBSZW5kZXJlcjIsXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVwcmVjYXRpb25zU2VydmljZTogRGVwcmVjYXRpb25zU2VydmljZSxcbiAgKSB7XG4gICAgc3VwZXIoY2QsIGRlcHJlY2F0aW9uc1NlcnZpY2UpO1xuICAgIHRoaXMuY2hhckNvdW50ZXJJZCA9IHRoaXMuZG9tQXR0clNlcnZpY2UuZ2VuZXJhdGVJZCgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hcmlhTGFiZWwpIHtcbiAgICAgIHRoaXMuZG9tQXR0clNlcnZpY2UubW92ZUFyaWFBdHRyaWJ1dGVzKFxuICAgICAgICB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudCxcbiAgICAgICAgdGhpcy5pbnB1dEVsICYmIHRoaXMuaW5wdXRFbC5uYXRpdmVFbGVtZW50LFxuICAgICAgICB0aGlzLnJlbmRlcmVyMixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZm9jdXNFZGl0YWJsZUVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRFbCkge1xuICAgICAgdGhpcy5pbnB1dEVsLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cbiIsIjxsYWJlbCAqbmdJZj1cImxhYmVsXCIgZm9yPVwie3sgaWQgfX1cIiBbYXR0ci5kYXRhLXJvbGVdPVwiJ2xhYmVsJ1wiPnt7IGxhYmVsIH19PC9sYWJlbD5cbjxpbnB1dFxuICBpZD1cInt7IGlkIH19XCJcbiAgI2lucHV0VGV4dFxuICBbYXR0ci5hcmlhLWF1dG9jb21wbGV0ZV09XCJhcmlhQXV0b2NvbXBsZXRlXCJcbiAgW2F0dHIuYXJpYS1jb250cm9sc109XCJhcmlhQ29udHJvbHNcIlxuICBbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XT1cImlkTGlzdEF0dHIoYXJpYURlc2NyaWJlZGJ5LCBtYXhMZW5ndGggJiYgc2hvd0NoYXJDb3VudGVyID8gY2hhckNvdW50ZXJJZCA6IG51bGwpXCJcbiAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5IHx8IG51bGxcIlxuICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImFyaWFFeHBhbmRlZFwiXG4gIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gIFthdHRyLmFyaWEtaW52YWxpZF09XCJhcmlhSW52YWxpZFwiXG4gIFthdHRyLmFyaWEtb3duc109XCJhcmlhT3duc1wiXG4gIFthdHRyLmFyaWEtbGFiZWxdPVwiKCFsYWJlbCAmJiBhcmlhTGFiZWwpIHx8IG51bGxcIlxuICBbbmdNb2RlbF09XCJ2YWx1ZVwiXG4gIChuZ01vZGVsQ2hhbmdlKT1cIm9uVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gIChibHVyKT1cIm9uQmx1cigkZXZlbnQpXCJcbiAgdHlwZT1cInRleHRcIlxuICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gIChmb2N1cyk9XCJvbkZvY3VzKCRldmVudClcIlxuICBbbWFza109XCJtYXNrXCJcbiAgW3ZhbGlkYXRpb25dPVwibWFza1ZhbGlkYXRvclwiXG4gIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gIFtyZWFkT25seV09XCJyZWFkb25seVwiXG4gIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gIFtyZXF1aXJlZF09XCJyZXF1aXJlZFwiXG4gIFthdHRyLnNpemVdPVwic2l6ZVwiXG4gIFthdHRyLm1heGxlbmd0aF09XCJtYXhMZW5ndGhcIlxuICBbYXR0ci5taW5sZW5ndGhdPVwibWluTGVuZ3RoXCJcbiAgW2F0dHIuYXV0b2NvbXBsZXRlXT1cImF1dG9jb21wbGV0ZVwiXG4gIFtiYkZvY3VzXT1cImF1dG9mb2N1c1wiXG4gIFtuZ0NsYXNzXT1cImlucHV0Q2xhc3NOYW1lXCJcbiAgW2F0dHIuZGF0YS1yb2xlXT1cIidpbnB1dCdcIlxuLz5cbjxiYi1jaGFyLWNvdW50ZXItdWlcbiAgW2F0dHIuaWRdPVwiY2hhckNvdW50ZXJJZFwiXG4gICpuZ0lmPVwibWF4TGVuZ3RoICYmIHNob3dDaGFyQ291bnRlclwiXG4gIFtlbGVtZW50XT1cImlucHV0VGV4dFwiXG4gIFtpbnB1dFZhbHVlXT1cInZhbHVlXCJcbiAgW21heExlbmd0aF09XCJtYXhMZW5ndGhcIlxuICBbYXR0ci5kYXRhLXJvbGVdPVwiJ3RleHQtaW5wdXQtY2hhci1jb3VudGVyJ1wiXG4+XG48L2JiLWNoYXItY291bnRlci11aT5cbiJdfQ==