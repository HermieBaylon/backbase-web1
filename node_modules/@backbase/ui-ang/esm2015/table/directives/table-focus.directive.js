import { ContentChildren, Directive, ElementRef, HostListener, Input, } from '@angular/core';
import { TableRowDirective } from './table-row.directive';
import { getKeyCode, KEY_CODES } from '@backbase/ui-ang/util';
import { takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
export class TableFocusDirective {
    constructor(renderer) {
        this.renderer = renderer;
        this.focusedItemIndex = -1;
        this.focusFirstRowOnChanges = false;
        this.destroy$ = new Subject();
    }
    onKeyEvent(event) {
        switch (getKeyCode(event)) {
            case KEY_CODES.DOWN:
                this.focusedItemIndex = Math.min(this.focusedItemIndex + 1, this.listItems.length - 1);
                this.focusItem();
                event.preventDefault();
                break;
            case KEY_CODES.UP:
                this.focusedItemIndex = Math.max(this.focusedItemIndex - 1, 0);
                this.focusItem();
                event.preventDefault();
                break;
            case KEY_CODES.ENTER:
                const currentActiveItem = this.listItems.find((item, index) => index === this.focusedItemIndex);
                if (currentActiveItem) {
                    currentActiveItem.nativeElement.click();
                    event.preventDefault();
                }
                break;
        }
    }
    focusItem(focusNativeElement = true) {
        this.listItems.forEach((el, index) => {
            if (index === this.focusedItemIndex) {
                this.renderer.addClass(el.nativeElement, 'active');
                this.renderer.setAttribute(el.nativeElement, 'tabIndex', '0');
                if (focusNativeElement) {
                    el.nativeElement.focus();
                }
            }
            else {
                this.renderer.removeClass(el.nativeElement, 'active');
                this.renderer.setAttribute(el.nativeElement, 'tabIndex', '-1');
            }
        });
    }
    /**
     * @internal
     */
    ngAfterViewInit() {
        // make first row in a table focusable
        this.listItems.changes.pipe(takeUntil(this.destroy$)).subscribe((items) => {
            var _a;
            if ((_a = items.first) === null || _a === void 0 ? void 0 : _a.nativeElement) {
                this.focusedItemIndex = 0;
                this.focusItem(this.focusFirstRowOnChanges);
            }
        });
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TableFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableFocusDirective, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
TableFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TableFocusDirective, selector: "[bbTableFocus]", inputs: { focusFirstRowOnChanges: "focusFirstRowOnChanges" }, host: { listeners: { "keydown": "onKeyEvent($event)" } }, queries: [{ propertyName: "listItems", predicate: TableRowDirective, emitDistinctChangesOnly: false, descendants: true, read: ElementRef }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableFocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTableFocus]',
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { listItems: [{
                type: ContentChildren,
                args: [TableRowDirective, { read: ElementRef, descendants: true, emitDistinctChangesOnly: false }]
            }], focusFirstRowOnChanges: [{
                type: Input
            }], onKeyEvent: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtZm9jdXMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvdGFibGUvZGlyZWN0aXZlcy90YWJsZS1mb2N1cy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLGVBQWUsRUFDZixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEdBSU4sTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFLL0IsTUFBTSxPQUFPLG1CQUFtQjtJQVM5QixZQUE2QixRQUFtQjtRQUFuQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBUnhDLHFCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDO1FBSXJCLDJCQUFzQixHQUFHLEtBQUssQ0FBQztRQUVoQyxhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUVrQixDQUFDO0lBR3BELFVBQVUsQ0FBQyxLQUFvQjtRQUM3QixRQUFRLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN6QixLQUFLLFNBQVMsQ0FBQyxJQUFJO2dCQUNqQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUN2RixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ2pCLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDdkIsTUFBTTtZQUNS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IjpbImltcG9ydCB7XG4gIEFmdGVyVmlld0luaXQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVGFibGVSb3dEaXJlY3RpdmUgfSBmcm9tICcuL3RhYmxlLXJvdy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgZ2V0S2V5Q29kZSwgS0VZX0NPREVTIH0gZnJvbSAnQGJhY2tiYXNlL3VpLWFuZy91dGlsJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2JiVGFibGVGb2N1c10nLFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZUZvY3VzRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBmb2N1c2VkSXRlbUluZGV4ID0gLTE7XG4gIEBDb250ZW50Q2hpbGRyZW4oVGFibGVSb3dEaXJlY3RpdmUsIHsgcmVhZDogRWxlbWVudFJlZiwgZGVzY2VuZGFudHM6IHRydWUsIGVtaXREaXN0aW5jdENoYW5nZXNPbmx5OiBmYWxzZSB9KVxuICBsaXN0SXRlbXMhOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cbiAgQElucHV0KCkgZm9jdXNGaXJzdFJvd09uQ2hhbmdlcyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXlFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIHN3aXRjaCAoZ2V0S2V5Q29kZShldmVudCkpIHtcbiAgICAgIGNhc2UgS0VZX0NPREVTLkRPV046XG4gICAgICAgIHRoaXMuZm9jdXNlZEl0ZW1JbmRleCA9IE1hdGgubWluKHRoaXMuZm9jdXNlZEl0ZW1JbmRleCArIDEsIHRoaXMubGlzdEl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmZvY3VzSXRlbSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0NPREVTLlVQOlxuICAgICAgICB0aGlzLmZvY3VzZWRJdGVtSW5kZXggPSBNYXRoLm1heCh0aGlzLmZvY3VzZWRJdGVtSW5kZXggLSAxLCAwKTtcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtFWV9DT0RFUy5FTlRFUjpcbiAgICAgICAgY29uc3QgY3VycmVudEFjdGl2ZUl0ZW0gPSB0aGlzLmxpc3RJdGVtcy5maW5kKChpdGVtLCBpbmRleCkgPT4gaW5kZXggPT09IHRoaXMuZm9jdXNlZEl0ZW1JbmRleCk7XG4gICAgICAgIGlmIChjdXJyZW50QWN0aXZlSXRlbSkge1xuICAgICAgICAgIGN1cnJlbnRBY3RpdmVJdGVtLm5hdGl2ZUVsZW1lbnQuY2xpY2soKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZm9jdXNJdGVtKGZvY3VzTmF0aXZlRWxlbWVudCA9IHRydWUpIHtcbiAgICB0aGlzLmxpc3RJdGVtcy5mb3JFYWNoKChlbCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5mb2N1c2VkSXRlbUluZGV4KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWwubmF0aXZlRWxlbWVudCwgJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZShlbC5uYXRpdmVFbGVtZW50LCAndGFiSW5kZXgnLCAnMCcpO1xuICAgICAgICBpZiAoZm9jdXNOYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgZWwubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsLm5hdGl2ZUVsZW1lbnQsICdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZWwubmF0aXZlRWxlbWVudCwgJ3RhYkluZGV4JywgJy0xJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgLy8gbWFrZSBmaXJzdCByb3cgaW4gYSB0YWJsZSBmb2N1c2FibGVcbiAgICB0aGlzLmxpc3RJdGVtcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGl0ZW1zKSA9PiB7XG4gICAgICBpZiAoaXRlbXMuZmlyc3Q/Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkSXRlbUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0odGhpcy5mb2N1c0ZpcnN0Um93T25DaGFuZ2VzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgfVxufVxuIl19