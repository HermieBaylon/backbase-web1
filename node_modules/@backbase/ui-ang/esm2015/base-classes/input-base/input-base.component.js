import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, } from '@angular/core';
import { noop } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/foundation-ang/future";
let _nextId = 0;
export function getInputNextId() {
    return `bb_input_${_nextId++}`;
}
export const defaultSize = 20;
/**
 * Widget roles specified in ARIA 1.1
 */
const VALID_WIDGET_ROLES = [
    'button',
    'checkbox',
    'combobox',
    'grid',
    'gridcell',
    'link',
    'listbox',
    'menu',
    'menubar',
    'menuitem',
    'menuitemcheckbox',
    'menuitemradio',
    'option',
    'progressbar',
    'radio',
    'radiogroup',
    'scrollbar',
    'searchbox',
    'separator',
    'slider',
    'spinbutton',
    'switch',
    'tab',
    'tablist',
    'tabpanel',
    'textbox',
    'tree',
    'treegrid',
    'treeitem',
];
/**
 * @name InputBaseComponent
 *
 * @description
 * Base component for input fields.
 *
 * @a11y Current component provide option to pass needed accessibility
 * attributes to custom components
 */
export class InputBaseComponent {
    constructor(cd, deprecationsService) {
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        this._id = getInputNextId();
        this.onTouched = noop;
        /**
         * The label for the input. Defaults to an empty string.
         */
        this.label = '';
        this._size = defaultSize;
        // `aria-readonly` is not needed, use `readonly` instead
        // `aria-required` is not needed, use `required` instead
        /**
         * Whether the input is required. Defaults to false.
         */
        this.required = false;
        /**
         * Whether the input is read only. Defaults to false.
         */
        this.readonly = false;
        /**
         * An event emitter for on blur actions.
         */
        this.blur = new EventEmitter();
        /**
         * An event emitter for on focus actions.
         */
        this.focus = new EventEmitter();
        /**
         * Whether the text input should be auto-focused when shown.
         */
        this.autofocus = false;
        this._valueChange = new EventEmitter();
        this.disabled = false;
        this.value = '';
        this.onChange = () => { };
    }
    /**
     * The id for the input. Defaults to unique string.
     * Used to map the label to the input.
     */
    set id(value) {
        this._id = value;
    }
    get id() {
        return this._id;
    }
    /**
     * Customize the ARIA role for the HTML input/select/textarea element inside this component.
     *
     * This can be used to improve accessibility for components, for example by configuring `[role]="'combobox'"`
     * for a component that provides an autocomplete list.
     *
     * Values that are valid for the native HTML form elements are allowed.
     */
    set role(value) {
        if (typeof value === 'string' && VALID_WIDGET_ROLES.indexOf(value) === -1) {
            // Prevent setting invalid roles
            // TODO: Log a warning about the invalid role
            value = undefined;
        }
        this._role = value;
    }
    get role() {
        return this._role;
    }
    /**
     * Configure the minimum width to fit the specified number of characters that should fit for HTML `<input>`
     */
    get size() {
        return this._size;
    }
    set size(arg) {
        const size = this.getSizeByKeyword(arg);
        // Optionally convert a `size` keyword to an integer value.
        // This can be supported by subclasses of `InputBaseComponent`
        arg = typeof size !== 'undefined' ? size : arg;
        const int = parseInt(String(arg), 10);
        if (int >= 1 && !isNaN(int)) {
            this._size = int;
        }
    }
    ngOnInit() {
        if (!(this.label || this.ariaLabel || this.ariaLabelledby)) {
            console.warn(`Found an input from '${this.constructor.name}' without label, please provide it.`);
        }
    }
    onBlur($event) {
        this.blur.emit($event);
        this.onTouched();
    }
    onValueChange(newValue) {
        if (newValue === undefined) {
            this.onChange(this.value);
        }
        else {
            this.onChange(newValue);
            this.value = newValue;
            this._valueChange.emit(this.value);
        }
    }
    onFocus($event) {
        this.focus.emit($event);
    }
    writeValue(inputValue) {
        this.value = inputValue === null ? '' : inputValue;
        this.cd.markForCheck();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cd.markForCheck();
    }
    /**
     * Returns the `input` `size` value for a keyword, such as "xxl".
     * Subclasses can choose to implement a custom mapping, which will be used to configure `size`.
     */
    getSizeByKeyword(arg) {
        return undefined;
    }
}
InputBaseComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputBaseComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.DeprecationsService }], target: i0.ɵɵFactoryTarget.Component });
InputBaseComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputBaseComponent, selector: "ng-component", inputs: { id: "id", label: "label", role: "role", size: "size", inputClassName: "inputClassName", ariaAutocomplete: ["aria-autocomplete", "ariaAutocomplete"], ariaActivedescendant: ["aria-activedescendant", "ariaActivedescendant"], ariaControls: ["aria-controls", "ariaControls"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], ariaExpanded: ["aria-expanded", "ariaExpanded"], ariaInvalid: ["aria-invalid", "ariaInvalid"], ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaOwns: ["aria-owns", "ariaOwns"], required: "required", readonly: "readonly", autofocus: "autofocus", disabled: "disabled" }, outputs: { blur: "blur", focus: "focus" }, ngImport: i0, template: '', isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputBaseComponent, decorators: [{
            type: Component,
            args: [{
                    template: '',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.DeprecationsService }]; }, propDecorators: { id: [{
                type: Input
            }], label: [{
                type: Input
            }], role: [{
                type: Input
            }], size: [{
                type: Input
            }], inputClassName: [{
                type: Input
            }], ariaAutocomplete: [{
                type: Input,
                args: ['aria-autocomplete']
            }], ariaActivedescendant: [{
                type: Input,
                args: ['aria-activedescendant']
            }], ariaControls: [{
                type: Input,
                args: ['aria-controls']
            }], ariaDescribedby: [{
                type: Input,
                args: ['aria-describedby']
            }], ariaExpanded: [{
                type: Input,
                args: ['aria-expanded']
            }], ariaInvalid: [{
                type: Input,
                args: ['aria-invalid']
            }], ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }], ariaLabelledby: [{
                type: Input,
                args: ['aria-labelledby']
            }], ariaOwns: [{
                type: Input,
                args: ['aria-owns']
            }], required: [{
                type: Input
            }], readonly: [{
                type: Input
            }], blur: [{
                type: Output
            }], focus: [{
                type: Output
            }], autofocus: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtYmFzZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL3VpLWFuZy9iYXNlLWNsYXNzZXMvaW5wdXQtYmFzZS9pbnB1dC1iYXNlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUVMLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7QUFFNUIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBRWhCLE1BQU0sVUFBVSxjQUFjO0lBQzVCLE9BQU8sWUFBWSxPQUFPLEVBQUUsRUFBRSxDQUFDO0FBQ2pDLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBRTlCOztHQUVHO0FBQ0gsTUFBTSxrQkFBa0IsR0FBRztJQUN6QixRQUFRO0lBQ1IsVUFBVTtJQUNWLFVBQVU7SUFDVixNQUFNO0lBQ04sVUFBVTtJQUNWLE1BQU07SUFDTixTQUFTO0lBQ1QsTUFBTTtJQUNOLFNBQVM7SUFDVCxVQUFVO0lBQ1Ysa0JBQWtCO0lBQ2xCLGVBQWU7SUFDZixRQUFRO0lBQ1IsYUFBYTtJQUNiLE9BQU87SUFDUCxZQUFZO0lBQ1osV0FBVztJQUNYLFdBQVc7SUFDWCxXQUFXO0lBQ1gsUUFBUTtJQUNSLFlBQVk7SUFDWixRQUFRO0lBQ1IsS0FBSztJQUNMLFNBQVM7SUFDVCxVQUFVO0lBQ1YsU0FBUztJQUNULE1BQU07SUFDTixVQUFVO0lBQ1YsVUFBVTtDQUNYLENBQUM7QUFFRjs7Ozs7Ozs7R0FRRztBQUtILE1BQU0sT0FBTyxrQkFBa0I7SUF1SzdCLFlBQStCLEVBQXFCLEVBQXFCLG1CQUF3QztRQUFsRixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUFxQix3QkFBbUIsR0FBbkIsbUJB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LEtBQUs7Z0JBb0JPLElBQUk7c0JBQWhCLEtBQUs7Z0JBcUJHLGNBQWM7c0JBQXRCLEtBQUs7Z0JBTXNCLGdCQUFnQjtzQkFBM0MsS0FBSzt1QkFBQyxtQkFBbUI7Z0JBT00sb0JBQW9CO3NCQUFuRCxLQUFLO3VCQUFDLHVCQUF1QjtnQkFPTixZQUFZO3NCQUFuQyxLQUFLO3VCQUFDLGVBQWU7Z0JBT0ssZUFBZTtzQkFBekMsS0FBSzt1QkFBQyxrQkFBa0I7Z0JBT0QsWUFBWTtzQkFBbkMsS0FBSzt1QkFBQyxlQUFlO2dCQU1DLFdBQVc7c0JBQWpDLEtBQUs7dUJBQUMsY0FBYztnQkFNQSxTQUFTO3NCQUE3QixLQUFLO3VCQUFDLFlBQVk7Z0JBUU8sY0FBYztzQkFBdkMsS0FBSzt1QkFBQyxpQkFBaUI7Z0JBUUosUUFBUTtzQkFBM0IsS0FBSzt1QkFBQyxXQUFXO2dCQVFULFFBQVE7c0JBQWhCLEtBQUs7Z0JBSUcsUUFBUTtzQkFBaEIsS0FBSztnQkFJSSxJQUFJO3NCQUFiLE1BQU07Z0JBSUcsS0FBSztzQkFBZCxNQUFNO2dCQUlFLFNBQVM7c0JBQWpCLEtBQUs7Z0JBSUcsUUFBUTtzQkFBaEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IERlcHJlY2F0aW9uc1NlcnZpY2UgfSBmcm9tICdAYmFja2Jhc2UvZm91bmRhdGlvbi1hbmcvZnV0dXJlJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICdyeGpzJztcblxubGV0IF9uZXh0SWQgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5wdXROZXh0SWQoKSB7XG4gIHJldHVybiBgYmJfaW5wdXRfJHtfbmV4dElkKyt9YDtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRTaXplID0gMjA7XG5cbi8qKlxuICogV2lkZ2V0IHJvbGVzIHNwZWNpZmllZCBpbiBBUklBIDEuMVxuICovXG5jb25zdCBWQUxJRF9XSURHRVRfUk9MRVMgPSBbXG4gICdidXR0b24nLFxuICAnY2hlY2tib3gnLFxuICAnY29tYm9ib3gnLFxuICAnZ3JpZCcsXG4gICdncmlkY2VsbCcsXG4gICdsaW5rJyxcbiAgJ2xpc3Rib3gnLFxuICAnbWVudScsXG4gICdtZW51YmFyJyxcbiAgJ21lbnVpdGVtJyxcbiAgJ21lbnVpdGVtY2hlY2tib3gnLFxuICAnbWVudWl0ZW1yYWRpbycsXG4gICdvcHRpb24nLFxuICAncHJvZ3Jlc3NiYXInLFxuICAncmFkaW8nLFxuICAncmFkaW9ncm91cCcsXG4gICdzY3JvbGxiYXInLFxuICAnc2VhcmNoYm94JyxcbiAgJ3NlcGFyYXRvcicsXG4gICdzbGlkZXInLFxuICAnc3BpbmJ1dHRvbicsXG4gICdzd2l0Y2gnLFxuICAndGFiJyxcbiAgJ3RhYmxpc3QnLFxuICAndGFicGFuZWwnLFxuICAndGV4dGJveCcsXG4gICd0cmVlJyxcbiAgJ3RyZWVncmlkJyxcbiAgJ3RyZWVpdGVtJyxcbl07XG5cbi8qKlxuICogQG5hbWUgSW5wdXRCYXNlQ29tcG9uZW50XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBCYXNlIGNvbXBvbmVudCBmb3IgaW5wdXQgZmllbGRzLlxuICpcbiAqIEBhMTF5IEN1cnJlbnQgY29tcG9uZW50IHByb3ZpZGUgb3B0aW9uIHRvIHBhc3MgbmVlZGVkIGFjY2Vzc2liaWxpdHlcbiAqIGF0dHJpYnV0ZXMgdG8gY3VzdG9tIGNvbXBvbmVudHNcbiAqL1xuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiAnJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIElucHV0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICBwcml2YXRlIF9pZCA9IGdldElucHV0TmV4dElkKCk7XG4gIHByaXZhdGUgX2xhYmVsQ2xhc3Nlczogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIG9uVG91Y2hlZDogKCkgPT4gdm9pZCA9IG5vb3A7XG4gIC8qKlxuICAgKiBUaGUgaWQgZm9yIHRoZSBpbnB1dC4gRGVmYXVsdHMgdG8gdW5pcXVlIHN0cmluZy5cbiAgICogVXNlZCB0byBtYXAgdGhlIGxhYmVsIHRvIHRoZSBpbnB1dC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5faWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwgZm9yIHRoZSBpbnB1dC4gRGVmYXVsdHMgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICAgKi9cbiAgQElucHV0KCkgbGFiZWwgPSAnJztcblxuICBwcml2YXRlIF9yb2xlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEN1c3RvbWl6ZSB0aGUgQVJJQSByb2xlIGZvciB0aGUgSFRNTCBpbnB1dC9zZWxlY3QvdGV4dGFyZWEgZWxlbWVudCBpbnNpZGUgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wcm92ZSBhY2Nlc3NpYmlsaXR5IGZvciBjb21wb25lbnRzLCBmb3IgZXhhbXBsZSBieSBjb25maWd1cmluZyBgW3JvbGVdPVwiJ2NvbWJvYm94J1wiYFxuICAgKiBmb3IgYSBjb21wb25lbnQgdGhhdCBwcm92aWRlcyBhbiBhdXRvY29tcGxldGUgbGlzdC5cbiAgICpcbiAgICogVmFsdWVzIHRoYXQgYXJlIHZhbGlkIGZvciB0aGUgbmF0aXZlIEhUTUwgZm9ybSBlbGVtZW50cyBhcmUgYWxsb3dlZC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCByb2xlKHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBWQUxJRF9XSURHRVRfUk9MRVMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAvLyBQcmV2ZW50IHNldHRpbmcgaW52YWxpZCByb2xlc1xuICAgICAgLy8gVE9ETzogTG9nIGEgd2FybmluZyBhYm91dCB0aGUgaW52YWxpZCByb2xlXG4gICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl9yb2xlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcm9sZSgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9yb2xlO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zaXplOiBudW1iZXIgPSBkZWZhdWx0U2l6ZTtcblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSBtaW5pbXVtIHdpZHRoIHRvIGZpdCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGZpdCBmb3IgSFRNTCBgPGlucHV0PmBcbiAgICovXG4gIEBJbnB1dCgpIGdldCBzaXplKCk6IG51bWJlciB8IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBzZXQgc2l6ZShhcmc6IG51bWJlciB8IHN0cmluZykge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemVCeUtleXdvcmQoYXJnKTtcblxuICAgIC8vIE9wdGlvbmFsbHkgY29udmVydCBhIGBzaXplYCBrZXl3b3JkIHRvIGFuIGludGVnZXIgdmFsdWUuXG4gICAgLy8gVGhpcyBjYW4gYmUgc3VwcG9ydGVkIGJ5IHN1YmNsYXNzZXMgb2YgYElucHV0QmFzZUNvbXBvbmVudGBcbiAgICBhcmcgPSB0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzaXplIDogYXJnO1xuXG4gICAgY29uc3QgaW50ID0gcGFyc2VJbnQoU3RyaW5nKGFyZyksIDEwKTtcblxuICAgIGlmIChpbnQgPj0gMSAmJiAhaXNOYU4oaW50KSkge1xuICAgICAgdGhpcy5fc2l6ZSA9IGludDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xhc3MgbmFtZXMgdGhhdCBtdXN0IGJlIGluY2x1ZGVkIG9uIHRoZSBgPGlucHV0PmAgZm9ybSBjb250cm9sXG4gICAqL1xuICBASW5wdXQoKSBpbnB1dENsYXNzTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogSXQgaW5kaWNhdGVzIHdoZXRoZXIgaW5wdXR0aW5nIHRleHQgY291bGQgdHJpZ2dlciBkaXNwbGF5IG9mIG9uZSBvciBtb3JlXG4gICAqIHByZWRpY3Rpb25zIG9mIHRoZSB1c2VyJ3MgaW50ZW5kZWQgdmFsdWUgZm9yIGEgY29tYm9ib3gsIHNlYXJjaGJveCwgb3IgdGV4dGJveC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dCgnYXJpYS1hdXRvY29tcGxldGUnKSBhcmlhQXV0b2NvbXBsZXRlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEl0IGlkZW50aWZpZXMgdGhlIGN1cnJlbnRseSBhY3RpdmUgZWxlbWVudCB3aGVuIGZvY3VzIGlzIG9uIGFcbiAgICogY29tcG9zaXRlIHdpZGdldCwgY29tYm9ib3gsIHRleHRib3gsIGdyb3VwLCBvciBhcHBsaWNhdGlvbi5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dCgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JykgYXJpYUFjdGl2ZWRlc2NlbmRhbnQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogV2hlbiBhbiBpbnRlcmFjdGl2ZSBvciBpbnB1dCBjb250cm9sIGhhcyBhbiBpbXBhY3Qgb24gYW5vdGhlciBlbGVtZW50IGluIGEgZG9jdW1lbnQgb3IgYXBwbGljYXRpb24sXG4gICAqIHRoZSBhcmlhLWNvbnRyb2wgaW5kaWNhdGVzIHdoaWNoIGVsZW1lbnQgb3IgZWxlbWVudHMgdGhlIHVzZXIgaW50ZXJmYWNlIHdpZGdldCBjb250cm9scy5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dCgnYXJpYS1jb250cm9scycpIGFyaWFDb250cm9sczogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBTZXQgYXJpYS1kZXNjcmliZWRieSAgd2l0aCBhbiBlbGVtZW50IGlkIHRoYXQgY29udGFpbnMgYSBkZXRhaWxlZCBkZWNyaXB0aW9uIG9mIHRoZSB3aWRnZXQuXG4gICAqIEl0IGlzIHVzZWQgdG8gZXN0YWJsaXNoIGEgcmVsYXRpb25zaGlwIGJldHdlZW4gd2lkZ2V0cyBvciBncm91cHMgYW5kIHRoZSB0ZXh0IHRoYXQgZGVzY3JpYmVzIHRoZW0uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L25vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoJ2FyaWEtZGVzY3JpYmVkYnknKSBhcmlhRGVzY3JpYmVkYnk6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGFyaWEtZXhwYW5kZWQgYXR0cmlidXRlIGlzIHNldCBvbiBhbiBlbGVtZW50IHRvIGluZGljYXRlIGlmIGEgY29udHJvbCBpcyBleHBhbmRlZCBvciBjb2xsYXBzZWQsXG4gICAqIGFuZCB3aGV0aGVyIG9yIG5vdCBpdHMgY2hpbGQgZWxlbWVudHMgYXJlIGRpc3BsYXllZCBvciBoaWRkZW4uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L25vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoJ2FyaWEtZXhwYW5kZWQnKSBhcmlhRXhwYW5kZWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGFyaWEtaW52YWxpZCBzdGF0ZSBpbmRpY2F0ZXMgdGhlIGVudGVyZWQgdmFsdWUgaXMgbm90IGluIGEgZm9ybWF0IGV4cGVjdGVkIGJ5IHRoZSBhcHBsaWNhdGlvbi5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dCgnYXJpYS1pbnZhbGlkJykgYXJpYUludmFsaWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQWNjZXNzaWJsZSBsYWJlbCB3aGVuIGNvbnRyb2wgZG9lcyBub3QgbmVlZCB0byByZW5kZXIgbGFiZWwgdGFnLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1pbnB1dC1yZW5hbWVcbiAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBhcmlhLWxhYmVsbGVkYnkgcHJvcGVydHkgZW5hYmxlcyBhdXRob3JzIHRvIHJlZmVyZW5jZSBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZSB0byBkZWZpbmUgYW5cbiAgICogYWNjZXNzaWJsZSBuYW1lLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGVsZW1lbnRzIHRoYXQgZG9uJ3QgaGF2ZSBuYXRpdmUgc3VwcG9ydCBmb3IgYXNzb2NpYXRpbmdcbiAgICogZWxlbWVudHMgdG8gcHJvdmlkZSBhbiBhY2Nlc3NpYmxlIG5hbWUuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L25vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpIGFyaWFMYWJlbGxlZGJ5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBhcmlhLW93bnMgYXR0cmlidXRlIGlkZW50aWZpZXMgYW4gZWxlbWVudCAob3IgZWxlbWVudHMpIGluIG9yZGVyIHRvIGRlZmluZSBhIHZpc3VhbCwgZnVuY3Rpb25hbCwgb3JcbiAgICogY29udGV4dHVhbCByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIHBhcmVudCBhbmQgaXRzIGNoaWxkIGVsZW1lbnRzIHdoZW4gdGhlIERPTSBoaWVyYXJjaHkgY2Fubm90IGJlIHVzZWRcbiAgICogdG8gcmVwcmVzZW50IHRoZSByZWxhdGlvbnNoaXAuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGFuZ3VsYXItZXNsaW50L25vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoJ2FyaWEtb3ducycpIGFyaWFPd25zOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLy8gYGFyaWEtcmVhZG9ubHlgIGlzIG5vdCBuZWVkZWQsIHVzZSBgcmVhZG9ubHlgIGluc3RlYWRcbiAgLy8gYGFyaWEtcmVxdWlyZWRgIGlzIG5vdCBuZWVkZWQsIHVzZSBgcmVxdWlyZWRgIGluc3RlYWRcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgaW5wdXQgaXMgcmVxdWlyZWQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgQElucHV0KCkgcmVxdWlyZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIHJlYWQgb25seS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xuICAvKipcbiAgICogQW4gZXZlbnQgZW1pdHRlciBmb3Igb24gYmx1ciBhY3Rpb25zLlxuICAgKi9cbiAgQE91dHB1dCgpIGJsdXIgPSBuZXcgRXZlbnRFbWl0dGVyPEZvY3VzRXZlbnQgfCB2b2lkPigpO1xuICAvKipcbiAgICogQW4gZXZlbnQgZW1pdHRlciBmb3Igb24gZm9jdXMgYWN0aW9ucy5cbiAgICovXG4gIEBPdXRwdXQoKSBmb2N1cyA9IG5ldyBFdmVudEVtaXR0ZXI8Rm9jdXNFdmVudCB8IHZvaWQ+KCk7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB0ZXh0IGlucHV0IHNob3VsZCBiZSBhdXRvLWZvY3VzZWQgd2hlbiBzaG93bi5cbiAgICovXG4gIEBJbnB1dCgpIGF1dG9mb2N1cyA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBfdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICBASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xuICB2YWx1ZTogT2JqZWN0IHwgc3RyaW5nIHwgYm9vbGVhbiB8IG51bGwgPSAnJztcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgY2Q6IENoYW5nZURldGVjdG9yUmVmLCBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVwcmVjYXRpb25zU2VydmljZTogRGVwcmVjYXRpb25zU2VydmljZSkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoISh0aGlzLmxhYmVsIHx8IHRoaXMuYXJpYUxhYmVsIHx8IHRoaXMuYXJpYUxhYmVsbGVkYnkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEZvdW5kIGFuIGlucHV0IGZyb20gJyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfScgd2l0aG91dCBsYWJlbCwgcGxlYXNlIHByb3ZpZGUgaXQuYCk7XG4gICAgfVxuICB9XG5cbiAgb25CbHVyKCRldmVudD86IEZvY3VzRXZlbnQpIHtcbiAgICB0aGlzLmJsdXIuZW1pdCgkZXZlbnQpO1xuICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gIH1cblxuICBvbkNoYW5nZTogKG5ld1ZhbHVlOiBPYmplY3QgfCBzdHJpbmcgfCB1bmRlZmluZWQgfCBudWxsKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgb25WYWx1ZUNoYW5nZShuZXdWYWx1ZT86IE9iamVjdCB8IHN0cmluZykge1xuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKG5ld1ZhbHVlKTtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgb25Gb2N1cygkZXZlbnQ/OiBGb2N1c0V2ZW50KSB7XG4gICAgdGhpcy5mb2N1cy5lbWl0KCRldmVudCk7XG4gIH1cblxuICB3cml0ZVZhbHVlKGlucHV0VmFsdWU6IE9iamVjdCB8IHN0cmluZyB8IG51bGwpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gaW5wdXRWYWx1ZSA9PT0gbnVsbCA/ICcnIDogaW5wdXRWYWx1ZTtcbiAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgfVxuXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYGlucHV0YCBgc2l6ZWAgdmFsdWUgZm9yIGEga2V5d29yZCwgc3VjaCBhcyBcInh4bFwiLlxuICAgKiBTdWJjbGFzc2VzIGNhbiBjaG9vc2UgdG8gaW1wbGVtZW50IGEgY3VzdG9tIG1hcHBpbmcsIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBjb25maWd1cmUgYHNpemVgLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFNpemVCeUtleXdvcmQoYXJnOiBhbnkpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbiJdfQ==