import { ChangeDetectionStrategy, Component, Inject, Input, LOCALE_ID } from '@angular/core';
import { getCurrencySymbol, getLocaleNumberFormat, getLocaleNumberSymbol, getNumberOfCurrencyDigits, NumberFormatStyle, NumberSymbol, } from '@angular/common';
import BigNumber from 'bignumber.js';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * @name AmountComponent
 *
 * @description
 * Component for representing amount in currency format .
 *
 * @dynamic (to suppress error with resolving statics declarations during compilation)
 *
 * @a11y
 * The amount component doesn't provide any specific properties for accessibility. But handles accessibility internally.
 *
 */
export class AmountComponent {
    constructor(locale) {
        this.locale = locale;
        /**
         * Determines currency type.
         * If nothing provided, wouldn't be displayed.
         */
        this.currency = '';
        /**
         * If "true" and amount is positive adds plus sign at the beginning.
         * Default value false.
         */
        this.showPlusSign = false;
        /**
         * Whether currency local should be transformed to symbol.
         * Default value true.
         */
        this.mapCurrency = true;
        /**
         * Whether percent symbol should be shown.
         * Default value false.
         */
        this.showPercent = false;
        /**
         * Whether abbreviation should be applied.
         * Default value false.
         */
        this.abbreviate = false;
        /**
         * Whether to display trailing zeroes.
         * Default value true
         */
        this.trailingZeroes = true;
        this._amountValue = new BigNumber(NaN);
        this.setupConfiguration();
    }
    ngOnChanges() {
        if (this.isUnsafeAmount) {
            console.warn('[bb-amount]: the amount was passed as a non safe number, the display can be wrong');
        }
        this.updateNumberFormat();
        this._amountValue = new BigNumber(this.amount);
        this.amountTemplate = this.getAmountTemplate(this.transformedAmount);
    }
    get isNumeric() {
        return !this._amountValue.isNaN();
    }
    get isPositive() {
        return this._amountValue.isPositive();
    }
    get isZero() {
        return this._amountValue.isZero();
    }
    get isUnsafeAmount() {
        return (typeof this.amount === 'number' &&
            (this.amount > Number.MAX_SAFE_INTEGER ||
                this.amount.toString().replace(/\D/, '').length > AmountComponent.maxSafeIntegerLength));
    }
    get configDecimalPlaces() {
        return this.decimalPlaces === undefined ? getNumberOfCurrencyDigits(this.currency) : this.decimalPlaces;
    }
    /**
     * Currency format depends on locale and could be represented for negative and
     * positive values differently (separated by `;` symbol).
     * See more http://cldr.unicode.org/translation/numbers-currency/number-patterns
     *
     * Example:
     * en-NL locale: '¤ #,##0.00;¤ -#,##0.00'
     */
    get amountFormat() {
        const { currencyFormat, decimalFormat, percentFormat, minusSymbol, plusSymbol } = AmountComponent.localeConfig;
        let formatPattern = decimalFormat;
        if (this.showPercent) {
            formatPattern = percentFormat;
        }
        if (this.currency) {
            if (this.showPercent) {
                console.warn('[bb-amount]: wrong configuration, `currency` and `showPercent` were set at the same time, therefore showPercent format will be ignored');
            }
            formatPattern = currencyFormat;
        }
        const [generalPattern, negativePattern] = formatPattern.split(';');
        if (this.isZero) {
            return generalPattern;
        }
        else if (this.isPositive) {
            return this.showPlusSign ? plusSymbol + generalPattern : generalPattern;
        }
        else {
            return negativePattern || minusSymbol + generalPattern;
        }
    }
    get transformedAmount() {
        const positiveAmount = this._amountValue.abs();
        const configDecimalPlaces = this.configDecimalPlaces;
        const shouldAbbreviate = this.abbreviate && positiveAmount.isGreaterThanOrEqualTo(AmountComponent.abbreviationConfig.minAmount);
        /**
         * Example:
         *
         * {@link groupSymbol} = ','
         * {@link decimalSymbol} = '.'
         * {@link configDecimalPlaces} = '2'
         *
         * Here how regexp source looks line with config above: ([\d,]+[.]\d{2}).*
         * This regexp has two selections:
         * - selection for the group `([\d,]+[.]\d{2})` to match the decimal precision (no rounding)
         * - and full string selection `.*` (used to replace full string with the group)
         *
         * REGEXP GROUP MATCHES ONLY THE AMOUNTS THAT HAVE TO BE UPDATED (TRIMMED)
         *
         * There are the cases when it does not have an effect, and it means that amount is already in appropriate format
         */
        const regexp = new RegExp(`([\\d${this.groupSymbol}]+[${this.decimalSymbol}]\\d{${configDecimalPlaces}}).*`, 'g');
        const amount = shouldAbbreviate ? this.getAbbreviatedAmount(positiveAmount) : positiveAmount;
        const amountDecimalPlaces = amount.decimalPlaces();
        // In order to keep the precision keeping the original decimal places and replace with regexp
        const formattedAmount = amount
            .toFormat(amountDecimalPlaces, BigNumber.ROUND_CEIL, this.numberFormat)
            .replace(regexp, '$1');
        return this.getAmountWithZeroPaddings(formattedAmount, configDecimalPlaces, amountDecimalPlaces);
    }
    getAmountWithZeroPaddings(formattedAmount, configDecimalPlaces, amountDecimalPlaces) {
        if (!this.trailingZeroes || amountDecimalPlaces >= configDecimalPlaces) {
            return formattedAmount;
        }
        const amountOfZeros = configDecimalPlaces - amountDecimalPlaces;
        let stringToAppend = '0'.repeat(amountOfZeros);
        if (!formattedAmount.includes(this.decimalSymbol)) {
            stringToAppend = this.decimalSymbol + stringToAppend;
        }
        return formattedAmount + stringToAppend;
    }
    setupConfiguration() {
        if (!AmountComponent.localeConfig) {
            AmountComponent.localeConfig = {
                currencyFormat: getLocaleNumberFormat(this.locale, NumberFormatStyle.Currency),
                decimalFormat: getLocaleNumberFormat(this.locale, NumberFormatStyle.Decimal),
                percentFormat: getLocaleNumberFormat(this.locale, NumberFormatStyle.Percent),
                decimalSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.Decimal),
                groupSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.Group),
                currencyGroupSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.CurrencyGroup),
                currencyDecimalSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.CurrencyDecimal),
                minusSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.MinusSign),
                plusSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.PlusSign),
                percentSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.PercentSign),
            };
        }
    }
    updateNumberFormat() {
        const { decimalSymbol, currencyDecimalSymbol, groupSymbol, currencyGroupSymbol } = AmountComponent.localeConfig;
        this.groupSymbol = this.currency ? currencyGroupSymbol : groupSymbol;
        this.decimalSymbol = this.currency ? currencyDecimalSymbol : decimalSymbol;
        this.numberFormat = {
            groupSeparator: this.groupSymbol,
            decimalSeparator: this.decimalSymbol,
            groupSize: 3,
        };
    }
    /**
     * Converts original amount to abbreviated
     * Max abbreviated suffix value is 'T' (trillion) see {@link AmountComponent.abbreviationConfig}
     */
    getAbbreviatedAmount(positiveAmount) {
        const suffixes = AmountComponent.abbreviationConfig.suffixes;
        const config = { suffix: suffixes[0], amount: positiveAmount.shiftedBy(-3) };
        for (let i = 1; i < suffixes.length; i++) {
            if (!config.amount.isGreaterThanOrEqualTo(1000)) {
                break;
            }
            config.suffix = suffixes[i];
            config.amount = config.amount.shiftedBy(-3);
        }
        this.abbreviationSuffix = config.suffix;
        return config.amount;
    }
    getAmountTemplate(amount) {
        const { percentSymbol, minusSymbol, plusSymbol } = AmountComponent.localeConfig;
        const signSymbol = this.isPositive ? plusSymbol : minusSymbol;
        const currencySymbol = this.mapCurrency ? getCurrencySymbol(this.currency, 'wide', this.locale) : this.currency;
        return this.amountFormat
            .replace(signSymbol, this.fillTemplate('sign', signSymbol))
            .replace('¤', this.fillTemplate('currency', currencySymbol))
            .replace('%', this.fillTemplate('percent', percentSymbol))
            .replace(/[#0,.]+/g, this.wrapAmount(amount));
    }
    wrapAmount(amount) {
        const [integer, decimals] = amount.split(this.decimalSymbol);
        return (this.fillTemplate('integer', integer) +
            (decimals ? this.fillTemplate('separator', this.decimalSymbol) + this.fillTemplate('decimals', decimals) : ''));
    }
    fillTemplate(templateKey, value) {
        return AmountComponent.templates[templateKey].replace(AmountComponent.placeholder, value);
    }
}
AmountComponent.placeholder = '{{}}';
AmountComponent.templates = {
    sign: `<span class="sign">${AmountComponent.placeholder}</span>`,
    currency: `<span class="symbol">${AmountComponent.placeholder}</span>`,
    integer: `<span class="integer">${AmountComponent.placeholder}</span>`,
    separator: `<span class="decimal-separator">${AmountComponent.placeholder}</span>`,
    decimals: `<span class="decimals">${AmountComponent.placeholder}</span>`,
    percent: `<span class="percent">${AmountComponent.placeholder}</span>`,
};
AmountComponent.abbreviationConfig = {
    minAmount: 100000,
    suffixes: ['K', 'M', 'B', 'T'],
};
AmountComponent.maxSafeIntegerLength = Number.MAX_SAFE_INTEGER.toString().length;
AmountComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountComponent, deps: [{ token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
AmountComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: AmountComponent, selector: "bb-amount-ui", inputs: { currency: "currency", showPlusSign: "showPlusSign", mapCurrency: "mapCurrency", showPercent: "showPercent", abbreviate: "abbreviate", decimalPlaces: "decimalPlaces", trailingZeroes: "trailingZeroes", amount: "amount" }, usesOnChanges: true, ngImport: i0, template: "<span *ngIf=\"isNumeric\" data-role=\"bb-amount-value\" class=\"bb-amount\">\n  <span [innerHtml]=\"amountTemplate\" class=\"amount bb-amount__value\" data-role=\"bb-amount-value__amount\"></span>\n  <ng-container *ngIf=\"abbreviationSuffix\"\n    >&nbsp;<span class=\"sr-only\" i18n=\"Amount abbreviation long suffix@@bb-amount-ui.abbr.long\" #abbrTitle\n      >{ abbreviationSuffix, select, K {Thousand} M {Million} B {Billion} T {Trillion} }</span\n    ><abbr\n      [title]=\"abbrTitle.textContent\"\n      aria-hidden=\"true\"\n      data-role=\"bb-amount-value__abbreviation\"\n      i18n=\"Amount abbreviation short suffix@@bb-amount-ui.abbr.short\"\n      class=\"abbreviation bb-amount__abbreviation\"\n      >{ abbreviationSuffix, select, K {K} M {M} B {B} T {T} }</abbr\n    >\n  </ng-container>\n</span>\n", directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-amount-ui',
                    templateUrl: './amount.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; }, propDecorators: { currency: [{
                type: Input
            }], showPlusSign: [{
                type: Input
            }], mapCurrency: [{
                type: Input
            }], showPercent: [{
                type: Input
            }], abbreviate: [{
                type: Input
            }], decimalPlaces: [{
                type: Input
            }], trailingZeroes: [{
                type: Input
            }], amount: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1vdW50LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvdWktYW5nL2Ftb3VudC9hbW91bnQuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvYW1vdW50L2Ftb3VudC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ3hHLE9BQU8sRUFDTCxpQkFBaUIsRUFDakIscUJBQXFCLEVBQ3JCLHFCQUFxQixFQUNyQix5QkFBeUIsRUFDekIsaUJBQWlCLEVBQ2pCLFlBQVksR0FDYixNQUFNLGlCQUFpQixDQUFDO0FBRXpCLE9BQU8sU0FBUyxNQUFNLGNBQWMsQ0FBQzs7O0FBZXJDOzs7Ozs7Ozs7OztHQVdHO0FBTUgsTUFBTSxPQUFPLGVBQWU7SUF3RTFCLFlBQWdELE1BQWM7UUFBZCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBdkQ5RDs7O1dBR0c7UUFDTSxhQUFRLEdBQUcsRUFBRSxDQUFDO1FBRXZCOzs7V0FHRztRQUNNLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBRTlCOzs7V0FHRztRQUNNLGdCQUFXLEdBQUcsSUFBSSxDQUFDO1FBRTVCOzs7V0FHRztRQUNNLGdCQUFXLEdBQUcsS0FBSyxDQUFDO1FBRTdCOzs7V0FHRztRQUNNLGVBQVUsR0FBRyxLQUFLLENBQUM7UUFRNUI7OztXQUdHO1FBQ00sbUJBQWMsR0FBRyxJQUFJLENBQUM7UUFVdkIsaUJBQVksR0FBRyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQU14QyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBRUQsV0FBVztRQUNULElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN2QixPQUFPLENBQUMsSUFBSSxD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QixLQUFLO2dCQU1HLGFBQWE7c0JBQXJCLEtBQUs7Z0JBTUcsY0FBYztzQkFBdEIsS0FBSztnQkFLRyxNQUFNO3NCQUFkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbmplY3QsIElucHV0LCBMT0NBTEVfSUQsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgZ2V0Q3VycmVuY3lTeW1ib2wsXG4gIGdldExvY2FsZU51bWJlckZvcm1hdCxcbiAgZ2V0TG9jYWxlTnVtYmVyU3ltYm9sLFxuICBnZXROdW1iZXJPZkN1cnJlbmN5RGlnaXRzLFxuICBOdW1iZXJGb3JtYXRTdHlsZSxcbiAgTnVtYmVyU3ltYm9sLFxufSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbmludGVyZmFjZSBBbW91bnRDb25maWd1cmF0aW9uIHtcbiAgY3VycmVuY3lGb3JtYXQ6IHN0cmluZztcbiAgZGVjaW1hbEZvcm1hdDogc3RyaW5nO1xuICBwZXJjZW50Rm9ybWF0OiBzdHJpbmc7XG4gIGRlY2ltYWxTeW1ib2w6IHN0cmluZztcbiAgZ3JvdXBTeW1ib2w6IHN0cmluZztcbiAgbWludXNTeW1ib2w6IHN0cmluZztcbiAgcGx1c1N5bWJvbDogc3RyaW5nO1xuICBwZXJjZW50U3ltYm9sOiBzdHJpbmc7XG4gIGN1cnJlbmN5R3JvdXBTeW1ib2w6IHN0cmluZztcbiAgY3VycmVuY3lEZWNpbWFsU3ltYm9sOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQG5hbWUgQW1vdW50Q29tcG9uZW50XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb21wb25lbnQgZm9yIHJlcHJlc2VudGluZyBhbW91bnQgaW4gY3VycmVuY3kgZm9ybWF0IC5cbiAqXG4gKiBAZHluYW1pYyAodG8gc3VwcHJlc3MgZXJyb3Igd2l0aCByZXNvbHZpbmcgc3RhdGljcyBkZWNsYXJhdGlvbnMgZHVyaW5nIGNvbXBpbGF0aW9uKVxuICpcbiAqIEBhMTF5XG4gKiBUaGUgYW1vdW50IGNvbXBvbmVudCBkb2Vzbid0IHByb3ZpZGUgYW55IHNwZWNpZmljIHByb3BlcnRpZXMgZm9yIGFjY2Vzc2liaWxpdHkuIEJ1dCBoYW5kbGVzIGFjY2Vzc2liaWxpdHkgaW50ZXJuYWxseS5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWFtb3VudC11aScsXG4gIHRlbXBsYXRlVXJsOiAnLi9hbW91bnQuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgQW1vdW50Q29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgcGxhY2Vob2xkZXIgPSAne3t9fSc7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IHRlbXBsYXRlcyA9IHtcbiAgICBzaWduOiBgPHNwYW4gY2xhc3M9XCJzaWduXCI+JHtBbW91bnRDb21wb25lbnQucGxhY2Vob2xkZXJ9PC9zcGFuPmAsXG4gICAgY3VycmVuY3k6IGA8c3BhbiBjbGFzcz1cInN5bWJvbFwiPiR7QW1vdW50Q29tcG9uZW50LnBsYWNlaG9sZGVyfTwvc3Bhbj5gLFxuICAgIGludGVnZXI6IGA8c3BhbiBjbGFzcz1cImludGVnZXJcIj4ke0Ftb3VudENvbXBvbmVudC5wbGFjZWhvbGRlcn08L3NwYW4+YCxcbiAgICBzZXBhcmF0b3I6IGA8c3BhbiBjbGFzcz1cImRlY2ltYWwtc2VwYXJhdG9yXCI+JHtBbW91bnRDb21wb25lbnQucGxhY2Vob2xkZXJ9PC9zcGFuPmAsXG4gICAgZGVjaW1hbHM6IGA8c3BhbiBjbGFzcz1cImRlY2ltYWxzXCI+JHtBbW91bnRDb21wb25lbnQucGxhY2Vob2xkZXJ9PC9zcGFuPmAsXG4gICAgcGVyY2VudDogYDxzcGFuIGNsYXNzPVwicGVyY2VudFwiPiR7QW1vdW50Q29tcG9uZW50LnBsYWNlaG9sZGVyfTwvc3Bhbj5gLFxuICB9O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBhYmJyZXZpYXRpb25Db25maWcgPSB7XG4gICAgbWluQW1vdW50OiAxMDAwMDAsXG4gICAgc3VmZml4ZXM6IFsnSycsICdNJywgJ0InLCAnVCddLFxuICB9O1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBtYXhTYWZlSW50ZWdlckxlbmd0aCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLnRvU3RyaW5nKCkubGVuZ3RoO1xuICBwcml2YXRlIHN0YXRpYyBsb2NhbGVDb25maWc6IEFtb3VudENvbmZpZ3VyYXRpb247XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgY3VycmVuY3kgdHlwZS5cbiAgICogSWYgbm90aGluZyBwcm92aWRlZCwgd291bGRuJ3QgYmUgZGlzcGxheWVkLlxuICAgKi9cbiAgQElucHV0KCkgY3VycmVuY3kgPSAnJztcblxuICAvKipcbiAgICogSWYgXCJ0cnVlXCIgYW5kIGFtb3VudCBpcyBwb3NpdGl2ZSBhZGRzIHBsdXMgc2lnbiBhdCB0aGUgYmVnaW5uaW5nLlxuICAgKiBEZWZhdWx0IHZhbHVlIGZhbHNlLlxuICAgKi9cbiAgQElucHV0KCkgc2hvd1BsdXNTaWduID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgY3VycmVuY3kgbG9jYWwgc2hvdWxkIGJlIHRyYW5zZm9ybWVkIHRvIHN5bWJvbC5cbiAgICogRGVmYXVsdCB2YWx1ZSB0cnVlLlxuICAgKi9cbiAgQElucHV0KCkgbWFwQ3VycmVuY3kgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHBlcmNlbnQgc3ltYm9sIHNob3VsZCBiZSBzaG93bi5cbiAgICogRGVmYXVsdCB2YWx1ZSBmYWxzZS5cbiAgICovXG4gIEBJbnB1dCgpIHNob3dQZXJjZW50ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgYWJicmV2aWF0aW9uIHNob3VsZCBiZSBhcHBsaWVkLlxuICAgKiBEZWZhdWx0IHZhbHVlIGZhbHNlLlxuICAgKi9cbiAgQElucHV0KCkgYWJicmV2aWF0ZSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYW1vdW50IG9mIGRlY2ltYWxzIHBsYWNlcyB0byBkaXNwbGF5LlxuICAgKiBEZWZhdWx0IHZhbHVlIHVuZGVmaW5lZCwgd2hpY2ggd2lsbCB1c2UgY3VycmVuY3kgZGVmYXVsdCBhbW91bnQgb2YgZGVjaW1hbHNcbiAgICovXG4gIEBJbnB1dCgpIGRlY2ltYWxQbGFjZXM6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogV2hldGhlciB0byBkaXNwbGF5IHRyYWlsaW5nIHplcm9lcy5cbiAgICogRGVmYXVsdCB2YWx1ZSB0cnVlXG4gICAqL1xuICBASW5wdXQoKSB0cmFpbGluZ1plcm9lcyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFJlY2VpdmUgYW1vdW50IGluIHN0cmluZyBmb3JtYXQgYW5kIGNvbnZlcnRzIGludG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAqL1xuICBASW5wdXQoKSBhbW91bnQhOiBzdHJpbmcgfCBudW1iZXI7XG5cbiAgYWJicmV2aWF0aW9uU3VmZml4Pzogc3RyaW5nO1xuICBhbW91bnRUZW1wbGF0ZT86IHN0cmluZztcblxuICBwcml2YXRlIF9hbW91bnRWYWx1ZSA9IG5ldyBCaWdOdW1iZXIoTmFOKTtcbiAgcHJpdmF0ZSBncm91cFN5bWJvbCE6IHN0cmluZztcbiAgcHJpdmF0ZSBkZWNpbWFsU3ltYm9sITogc3RyaW5nO1xuICBwcml2YXRlIG51bWJlckZvcm1hdCE6IEJpZ051bWJlci5Gb3JtYXQ7XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnNldHVwQ29uZmlndXJhdGlvbigpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKHRoaXMuaXNVbnNhZmVBbW91bnQpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2JiLWFtb3VudF06IHRoZSBhbW91bnQgd2FzIHBhc3NlZCBhcyBhIG5vbiBzYWZlIG51bWJlciwgdGhlIGRpc3BsYXkgY2FuIGJlIHdyb25nJyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVOdW1iZXJGb3JtYXQoKTtcblxuICAgIHRoaXMuX2Ftb3VudFZhbHVlID0gbmV3IEJpZ051bWJlcih0aGlzLmFtb3VudCk7XG4gICAgdGhpcy5hbW91bnRUZW1wbGF0ZSA9IHRoaXMuZ2V0QW1vdW50VGVtcGxhdGUodGhpcy50cmFuc2Zvcm1lZEFtb3VudCk7XG4gIH1cblxuICBnZXQgaXNOdW1lcmljKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5fYW1vdW50VmFsdWUuaXNOYU4oKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzUG9zaXRpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Ftb3VudFZhbHVlLmlzUG9zaXRpdmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzWmVybygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fYW1vdW50VmFsdWUuaXNaZXJvKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc1Vuc2FmZUFtb3VudCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHRoaXMuYW1vdW50ID09PSAnbnVtYmVyJyAmJlxuICAgICAgKHRoaXMuYW1vdW50ID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHxcbiAgICAgICAgdGhpcy5hbW91bnQudG9TdHJpbmcoKS5yZXBsYWNlKC9cXEQvLCAnJykubGVuZ3RoID4gQW1vdW50Q29tcG9uZW50Lm1heFNhZmVJbnRlZ2VyTGVuZ3RoKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGdldCBjb25maWdEZWNpbWFsUGxhY2VzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGVjaW1hbFBsYWNlcyA9PT0gdW5kZWZpbmVkID8gZ2V0TnVtYmVyT2ZDdXJyZW5jeURpZ2l0cyh0aGlzLmN1cnJlbmN5KSA6IHRoaXMuZGVjaW1hbFBsYWNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW5jeSBmb3JtYXQgZGVwZW5kcyBvbiBsb2NhbGUgYW5kIGNvdWxkIGJlIHJlcHJlc2VudGVkIGZvciBuZWdhdGl2ZSBhbmRcbiAgICogcG9zaXRpdmUgdmFsdWVzIGRpZmZlcmVudGx5IChzZXBhcmF0ZWQgYnkgYDtgIHN5bWJvbCkuXG4gICAqIFNlZSBtb3JlIGh0dHA6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL251bWJlcnMtY3VycmVuY3kvbnVtYmVyLXBhdHRlcm5zXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGVuLU5MIGxvY2FsZTogJ8KkwqAjLCMjMC4wMDvCpMKgLSMsIyMwLjAwJ1xuICAgKi9cbiAgcHJpdmF0ZSBnZXQgYW1vdW50Rm9ybWF0KCk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBjdXJyZW5jeUZvcm1hdCwgZGVjaW1hbEZvcm1hdCwgcGVyY2VudEZvcm1hdCwgbWludXNTeW1ib2wsIHBsdXNTeW1ib2wgfSA9IEFtb3VudENvbXBvbmVudC5sb2NhbGVDb25maWc7XG4gICAgbGV0IGZvcm1hdFBhdHRlcm4gPSBkZWNpbWFsRm9ybWF0O1xuXG4gICAgaWYgKHRoaXMuc2hvd1BlcmNlbnQpIHtcbiAgICAgIGZvcm1hdFBhdHRlcm4gPSBwZXJjZW50Rm9ybWF0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmN1cnJlbmN5KSB7XG4gICAgICBpZiAodGhpcy5zaG93UGVyY2VudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1tiYi1hbW91bnRdOiB3cm9uZyBjb25maWd1cmF0aW9uLCBgY3VycmVuY3lgIGFuZCBgc2hvd1BlcmNlbnRgIHdlcmUgc2V0IGF0IHRoZSBzYW1lIHRpbWUsIHRoZXJlZm9yZSBzaG93UGVyY2VudCBmb3JtYXQgd2lsbCBiZSBpZ25vcmVkJyxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZm9ybWF0UGF0dGVybiA9IGN1cnJlbmN5Rm9ybWF0O1xuICAgIH1cblxuICAgIGNvbnN0IFtnZW5lcmFsUGF0dGVybiwgbmVnYXRpdmVQYXR0ZXJuXSA9IGZvcm1hdFBhdHRlcm4uc3BsaXQoJzsnKTtcblxuICAgIGlmICh0aGlzLmlzWmVybykge1xuICAgICAgcmV0dXJuIGdlbmVyYWxQYXR0ZXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Bvc2l0aXZlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93UGx1c1NpZ24gPyBwbHVzU3ltYm9sICsgZ2VuZXJhbFBhdHRlcm4gOiBnZW5lcmFsUGF0dGVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5lZ2F0aXZlUGF0dGVybiB8fCBtaW51c1N5bWJvbCArIGdlbmVyYWxQYXR0ZXJuO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHRyYW5zZm9ybWVkQW1vdW50KCk6IHN0cmluZyB7XG4gICAgY29uc3QgcG9zaXRpdmVBbW91bnQgPSB0aGlzLl9hbW91bnRWYWx1ZS5hYnMoKTtcbiAgICBjb25zdCBjb25maWdEZWNpbWFsUGxhY2VzID0gdGhpcy5jb25maWdEZWNpbWFsUGxhY2VzO1xuICAgIGNvbnN0IHNob3VsZEFiYnJldmlhdGUgPVxuICAgICAgdGhpcy5hYmJyZXZpYXRlICYmIHBvc2l0aXZlQW1vdW50LmlzR3JlYXRlclRoYW5PckVxdWFsVG8oQW1vdW50Q29tcG9uZW50LmFiYnJldmlhdGlvbkNvbmZpZy5taW5BbW91bnQpO1xuXG4gICAgLyoqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIHtAbGluayBncm91cFN5bWJvbH0gPSAnLCdcbiAgICAgKiB7QGxpbmsgZGVjaW1hbFN5bWJvbH0gPSAnLidcbiAgICAgKiB7QGxpbmsgY29uZmlnRGVjaW1hbFBsYWNlc30gPSAnMidcbiAgICAgKlxuICAgICAqIEhlcmUgaG93IHJlZ2V4cCBzb3VyY2UgbG9va3MgbGluZSB3aXRoIGNvbmZpZyBhYm92ZTogKFtcXGQsXStbLl1cXGR7Mn0pLipcbiAgICAgKiBUaGlzIHJlZ2V4cCBoYXMgdHdvIHNlbGVjdGlvbnM6XG4gICAgICogLSBzZWxlY3Rpb24gZm9yIHRoZSBncm91cCBgKFtcXGQsXStbLl1cXGR7Mn0pYCB0byBtYXRjaCB0aGUgZGVjaW1hbCBwcmVjaXNpb24gKG5vIHJvdW5kaW5nKVxuICAgICAqIC0gYW5kIGZ1bGwgc3RyaW5nIHNlbGVjdGlvbiBgLipgICh1c2VkIHRvIHJlcGxhY2UgZnVsbCBzdHJpbmcgd2l0aCB0aGUgZ3JvdXApXG4gICAgICpcbiAgICAgKiBSRUdFWFAgR1JPVVAgTUFUQ0hFUyBPTkxZIFRIRSBBTU9VTlRTIFRIQVQgSEFWRSBUTyBCRSBVUERBVEVEIChUUklNTUVEKVxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHRoZSBjYXNlcyB3aGVuIGl0IGRvZXMgbm90IGhhdmUgYW4gZWZmZWN0LCBhbmQgaXQgbWVhbnMgdGhhdCBhbW91bnQgaXMgYWxyZWFkeSBpbiBhcHByb3ByaWF0ZSBmb3JtYXRcbiAgICAgKi9cbiAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGAoW1xcXFxkJHt0aGlzLmdyb3VwU3ltYm9sfV0rWyR7dGhpcy5kZWNpbWFsU3ltYm9sfV1cXFxcZHske2NvbmZpZ0RlY2ltYWxQbGFjZXN9fSkuKmAsICdnJyk7XG4gICAgY29uc3QgYW1vdW50ID0gc2hvdWxkQWJicmV2aWF0ZSA/IHRoaXMuZ2V0QWJicmV2aWF0ZWRBbW91bnQocG9zaXRpdmVBbW91bnQpIDogcG9zaXRpdmVBbW91bnQ7XG4gICAgY29uc3QgYW1vdW50RGVjaW1hbFBsYWNlcyA9IGFtb3VudC5kZWNpbWFsUGxhY2VzKCk7XG4gICAgLy8gSW4gb3JkZXIgdG8ga2VlcCB0aGUgcHJlY2lzaW9uIGtlZXBpbmcgdGhlIG9yaWdpbmFsIGRlY2ltYWwgcGxhY2VzIGFuZCByZXBsYWNlIHdpdGggcmVnZXhwXG4gICAgY29uc3QgZm9ybWF0dGVkQW1vdW50ID0gYW1vdW50XG4gICAgICAudG9Gb3JtYXQoYW1vdW50RGVjaW1hbFBsYWNlcywgQmlnTnVtYmVyLlJPVU5EX0NFSUwsIHRoaXMubnVtYmVyRm9ybWF0KVxuICAgICAgLnJlcGxhY2UocmVnZXhwLCAnJDEnKTtcblxuICAgIHJldHVybiB0aGlzLmdldEFtb3VudFdpdGhaZXJvUGFkZGluZ3MoZm9ybWF0dGVkQW1vdW50LCBjb25maWdEZWNpbWFsUGxhY2VzLCBhbW91bnREZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QW1vdW50V2l0aFplcm9QYWRkaW5ncyhcbiAgICBmb3JtYXR0ZWRBbW91bnQ6IHN0cmluZyxcbiAgICBjb25maWdEZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gICAgYW1vdW50RGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICApOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy50cmFpbGluZ1plcm9lcyB8fCBhbW91bnREZWNpbWFsUGxhY2VzID49IGNvbmZpZ0RlY2ltYWxQbGFjZXMpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZWRBbW91bnQ7XG4gICAgfVxuXG4gICAgY29uc3QgYW1vdW50T2ZaZXJvcyA9IGNvbmZpZ0RlY2ltYWxQbGFjZXMgLSBhbW91bnREZWNpbWFsUGxhY2VzO1xuICAgIGxldCBzdHJpbmdUb0FwcGVuZCA9ICcwJy5yZXBlYXQoYW1vdW50T2ZaZXJvcyk7XG5cbiAgICBpZiAoIWZvcm1hdHRlZEFtb3VudC5pbmNsdWRlcyh0aGlzLmRlY2ltYWxTeW1ib2wpKSB7XG4gICAgICBzdHJpbmdUb0FwcGVuZCA9IHRoaXMuZGVjaW1hbFN5bWJvbCArIHN0cmluZ1RvQXBwZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JtYXR0ZWRBbW91bnQgKyBzdHJpbmdUb0FwcGVuZDtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBDb25maWd1cmF0aW9uKCkge1xuICAgIGlmICghQW1vdW50Q29tcG9uZW50LmxvY2FsZUNvbmZpZykge1xuICAgICAgQW1vdW50Q29tcG9uZW50LmxvY2FsZUNvbmZpZyA9IHtcbiAgICAgICAgY3VycmVuY3lGb3JtYXQ6IGdldExvY2FsZU51bWJlckZvcm1hdCh0aGlzLmxvY2FsZSwgTnVtYmVyRm9ybWF0U3R5bGUuQ3VycmVuY3kpLFxuICAgICAgICBkZWNpbWFsRm9ybWF0OiBnZXRMb2NhbGVOdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUsIE51bWJlckZvcm1hdFN0eWxlLkRlY2ltYWwpLFxuICAgICAgICBwZXJjZW50Rm9ybWF0OiBnZXRMb2NhbGVOdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUsIE51bWJlckZvcm1hdFN0eWxlLlBlcmNlbnQpLFxuICAgICAgICBkZWNpbWFsU3ltYm9sOiBnZXRMb2NhbGVOdW1iZXJTeW1ib2wodGhpcy5sb2NhbGUsIE51bWJlclN5bWJvbC5EZWNpbWFsKSxcbiAgICAgICAgZ3JvdXBTeW1ib2w6IGdldExvY2FsZU51bWJlclN5bWJvbCh0aGlzLmxvY2FsZSwgTnVtYmVyU3ltYm9sLkdyb3VwKSxcbiAgICAgICAgY3VycmVuY3lHcm91cFN5bWJvbDogZ2V0TG9jYWxlTnVtYmVyU3ltYm9sKHRoaXMubG9jYWxlLCBOdW1iZXJTeW1ib2wuQ3VycmVuY3lHcm91cCksXG4gICAgICAgIGN1cnJlbmN5RGVjaW1hbFN5bWJvbDogZ2V0TG9jYWxlTnVtYmVyU3ltYm9sKHRoaXMubG9jYWxlLCBOdW1iZXJTeW1ib2wuQ3VycmVuY3lEZWNpbWFsKSxcbiAgICAgICAgbWludXNTeW1ib2w6IGdldExvY2FsZU51bWJlclN5bWJvbCh0aGlzLmxvY2FsZSwgTnVtYmVyU3ltYm9sLk1pbnVzU2lnbiksXG4gICAgICAgIHBsdXNTeW1ib2w6IGdldExvY2FsZU51bWJlclN5bWJvbCh0aGlzLmxvY2FsZSwgTnVtYmVyU3ltYm9sLlBsdXNTaWduKSxcbiAgICAgICAgcGVyY2VudFN5bWJvbDogZ2V0TG9jYWxlTnVtYmVyU3ltYm9sKHRoaXMubG9jYWxlLCBOdW1iZXJTeW1ib2wuUGVyY2VudFNpZ24pLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZU51bWJlckZvcm1hdCgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGRlY2ltYWxTeW1ib2wsIGN1cnJlbmN5RGVjaW1hbFN5bWJvbCwgZ3JvdXBTeW1ib2wsIGN1cnJlbmN5R3JvdXBTeW1ib2wgfSA9IEFtb3VudENvbXBvbmVudC5sb2NhbGVDb25maWc7XG5cbiAgICB0aGlzLmdyb3VwU3ltYm9sID0gdGhpcy5jdXJyZW5jeSA/IGN1cnJlbmN5R3JvdXBTeW1ib2wgOiBncm91cFN5bWJvbDtcbiAgICB0aGlzLmRlY2ltYWxTeW1ib2wgPSB0aGlzLmN1cnJlbmN5ID8gY3VycmVuY3lEZWNpbWFsU3ltYm9sIDogZGVjaW1hbFN5bWJvbDtcbiAgICB0aGlzLm51bWJlckZvcm1hdCA9IHtcbiAgICAgIGdyb3VwU2VwYXJhdG9yOiB0aGlzLmdyb3VwU3ltYm9sLFxuICAgICAgZGVjaW1hbFNlcGFyYXRvcjogdGhpcy5kZWNpbWFsU3ltYm9sLFxuICAgICAgZ3JvdXBTaXplOiAzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgb3JpZ2luYWwgYW1vdW50IHRvIGFiYnJldmlhdGVkXG4gICAqIE1heCBhYmJyZXZpYXRlZCBzdWZmaXggdmFsdWUgaXMgJ1QnICh0cmlsbGlvbikgc2VlIHtAbGluayBBbW91bnRDb21wb25lbnQuYWJicmV2aWF0aW9uQ29uZmlnfVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRBYmJyZXZpYXRlZEFtb3VudChwb3NpdGl2ZUFtb3VudDogQmlnTnVtYmVyKTogQmlnTnVtYmVyIHtcbiAgICBjb25zdCBzdWZmaXhlcyA9IEFtb3VudENvbXBvbmVudC5hYmJyZXZpYXRpb25Db25maWcuc3VmZml4ZXM7XG4gICAgY29uc3QgY29uZmlnID0geyBzdWZmaXg6IHN1ZmZpeGVzWzBdLCBhbW91bnQ6IHBvc2l0aXZlQW1vdW50LnNoaWZ0ZWRCeSgtMykgfTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3VmZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY29uZmlnLmFtb3VudC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKDEwMDApKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjb25maWcuc3VmZml4ID0gc3VmZml4ZXNbaV07XG4gICAgICBjb25maWcuYW1vdW50ID0gY29uZmlnLmFtb3VudC5zaGlmdGVkQnkoLTMpO1xuICAgIH1cblxuICAgIHRoaXMuYWJicmV2aWF0aW9uU3VmZml4ID0gY29uZmlnLnN1ZmZpeDtcblxuICAgIHJldHVybiBjb25maWcuYW1vdW50O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBbW91bnRUZW1wbGF0ZShhbW91bnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBwZXJjZW50U3ltYm9sLCBtaW51c1N5bWJvbCwgcGx1c1N5bWJvbCB9ID0gQW1vdW50Q29tcG9uZW50LmxvY2FsZUNvbmZpZztcbiAgICBjb25zdCBzaWduU3ltYm9sID0gdGhpcy5pc1Bvc2l0aXZlID8gcGx1c1N5bWJvbCA6IG1pbnVzU3ltYm9sO1xuICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sID0gdGhpcy5tYXBDdXJyZW5jeSA/IGdldEN1cnJlbmN5U3ltYm9sKHRoaXMuY3VycmVuY3ksICd3aWRlJywgdGhpcy5sb2NhbGUpIDogdGhpcy5jdXJyZW5jeTtcblxuICAgIHJldHVybiB0aGlzLmFtb3VudEZvcm1hdFxuICAgICAgLnJlcGxhY2Uoc2lnblN5bWJvbCwgdGhpcy5maWxsVGVtcGxhdGUoJ3NpZ24nLCBzaWduU3ltYm9sKSlcbiAgICAgIC5yZXBsYWNlKCfCpCcsIHRoaXMuZmlsbFRlbXBsYXRlKCdjdXJyZW5jeScsIGN1cnJlbmN5U3ltYm9sKSlcbiAgICAgIC5yZXBsYWNlKCclJywgdGhpcy5maWxsVGVtcGxhdGUoJ3BlcmNlbnQnLCBwZXJjZW50U3ltYm9sKSlcbiAgICAgIC5yZXBsYWNlKC9bIzAsLl0rL2csIHRoaXMud3JhcEFtb3VudChhbW91bnQpKTtcbiAgfVxuXG4gIHByaXZhdGUgd3JhcEFtb3VudChhbW91bnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgW2ludGVnZXIsIGRlY2ltYWxzXSA9IGFtb3VudC5zcGxpdCh0aGlzLmRlY2ltYWxTeW1ib2wpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZmlsbFRlbXBsYXRlKCdpbnRlZ2VyJywgaW50ZWdlcikgK1xuICAgICAgKGRlY2ltYWxzID8gdGhpcy5maWxsVGVtcGxhdGUoJ3NlcGFyYXRvcicsIHRoaXMuZGVjaW1hbFN5bWJvbCkgKyB0aGlzLmZpbGxUZW1wbGF0ZSgnZGVjaW1hbHMnLCBkZWNpbWFscykgOiAnJylcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBmaWxsVGVtcGxhdGUodGVtcGxhdGVLZXk6IGtleW9mIHR5cGVvZiBBbW91bnRDb21wb25lbnQudGVtcGxhdGVzLCB2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gQW1vdW50Q29tcG9uZW50LnRlbXBsYXRlc1t0ZW1wbGF0ZUtleV0ucmVwbGFjZShBbW91bnRDb21wb25lbnQucGxhY2Vob2xkZXIsIHZhbHVlKTtcbiAgfVxufVxuIiwiPHNwYW4gKm5nSWY9XCJpc051bWVyaWNcIiBkYXRhLXJvbGU9XCJiYi1hbW91bnQtdmFsdWVcIiBjbGFzcz1cImJiLWFtb3VudFwiPlxuICA8c3BhbiBbaW5uZXJIdG1sXT1cImFtb3VudFRlbXBsYXRlXCIgY2xhc3M9XCJhbW91bnQgYmItYW1vdW50X192YWx1ZVwiIGRhdGEtcm9sZT1cImJiLWFtb3VudC12YWx1ZV9fYW1vdW50XCI+PC9zcGFuPlxuICA8bmctY29udGFpbmVyICpuZ0lmPVwiYWJicmV2aWF0aW9uU3VmZml4XCJcbiAgICA+Jm5ic3A7PHNwYW4gY2xhc3M9XCJzci1vbmx5XCIgaTE4bj1cIkFtb3VudCBhYmJyZXZpYXRpb24gbG9uZyBzdWZmaXhAQGJiLWFtb3VudC11aS5hYmJyLmxvbmdcIiAjYWJiclRpdGxlXG4gICAgICA+eyBhYmJyZXZpYXRpb25TdWZmaXgsIHNlbGVjdCwgSyB7VGhvdXNhbmR9IE0ge01pbGxpb259IEIge0JpbGxpb259IFQge1RyaWxsaW9ufSB9PC9zcGFuXG4gICAgPjxhYmJyXG4gICAgICBbdGl0bGVdPVwiYWJiclRpdGxlLnRleHRDb250ZW50XCJcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICBkYXRhLXJvbGU9XCJiYi1hbW91bnQtdmFsdWVfX2FiYnJldmlhdGlvblwiXG4gICAgICBpMThuPVwiQW1vdW50IGFiYnJldmlhdGlvbiBzaG9ydCBzdWZmaXhAQGJiLWFtb3VudC11aS5hYmJyLnNob3J0XCJcbiAgICAgIGNsYXNzPVwiYWJicmV2aWF0aW9uIGJiLWFtb3VudF9fYWJicmV2aWF0aW9uXCJcbiAgICAgID57IGFiYnJldmlhdGlvblN1ZmZpeCwgc2VsZWN0LCBLIHtLfSBNIHtNfSBCIHtCfSBUIHtUfSB9PC9hYmJyXG4gICAgPlxuICA8L25nLWNvbnRhaW5lcj5cbjwvc3Bhbj5cbiJdfQ==