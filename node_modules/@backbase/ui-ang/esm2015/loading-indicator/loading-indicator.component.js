import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
/**
 * @name LoadingIndicatorComponent
 *
 * @description
 * Component that displays a loading spinner and message.
 */
export class LoadingIndicatorComponent {
    constructor(ref) {
        this.ref = ref;
        /**
         * The size of the loading indicator.
         * Defaults to 'md'.
         */
        this.loaderSize = 'md';
        /**
         * Delay in milliseconds before the loading indicator display.
         * Default to 0.
         */
        this.showDelay = 0;
        /**
         * Defines whether gray background should be displayed.
         * Default to false (background hidden).
         */
        this.hasBackground = false;
        /**
         * Define if spinner should be shown inline without any default padding and margin.
         * Default to false (show default padding and margin).
         */
        this.inline = false;
        this.showLoadingState = false;
    }
    ngOnInit() {
        setTimeout(() => {
            this.showLoadingState = true;
            this.ref.markForCheck();
        }, this.showDelay);
    }
}
LoadingIndicatorComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LoadingIndicatorComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
LoadingIndicatorComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: { text: "text", loaderSize: "loaderSize", showDelay: "showDelay", hasBackground: "hasBackground", inline: "inline" }, ngImport: i0, template: "<ng-container *ngIf=\"!inline; else inlineLoading\">\n  <div\n    *ngIf=\"showLoadingState\"\n    [ngClass]=\"{ jumbotron: hasBackground }\"\n    data-role=\"loading-indicator\"\n    class=\"bb-state-container\"\n  >\n    <ng-container *ngTemplateOutlet=\"loadingIndicator\"></ng-container>\n  </div>\n</ng-container>\n\n<ng-template #inlineLoading>\n  <ng-container *ngIf=\"showLoadingState\">\n    <ng-container *ngTemplateOutlet=\"loadingIndicator\"></ng-container>\n  </ng-container>\n</ng-template>\n\n<ng-template #loadingIndicator>\n  <div\n    data-role=\"loading-indicator-wrapper\"\n    class=\"bb-loading-indicator bb-loading-indicator--{{ loaderSize }}\"\n    [ngClass]=\"{ 'bb-loading-indicator--inline': inline }\"\n  >\n    <svg\n      aria-label=\"Loading indicator\"\n      i18n-aria-label=\"Loading indicator| Label for the loading indicator @@bb-loading-indicator-ui.indicator\"\n      class=\"bb-loading-indicator__circle\"\n      preserveAspectRatio=\"xMinYMin meet\"\n    >\n      <circle class=\"bb-loading-indicator__path\" r=\"40%\" cx=\"50%\" cy=\"50%\" fill=\"none\" stroke=\"currentColor\"></circle>\n    </svg>\n    <div *ngIf=\"text\" data-role=\"loading-indicator-text\" class=\"bb-loading-indicator__text\">{{ text }}</div>\n  </div>\n</ng-template>\n", directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LoadingIndicatorComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-loading-indicator-ui',
                    templateUrl: './loading-indicator.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { text: [{
                type: Input
            }], loaderSize: [{
                type: Input
            }], showDelay: [{
                type: Input
            }], hasBackground: [{
                type: Input
            }], inline: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZGluZy1pbmRpY2F0b3IuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvbG9hZGluZy1pbmRpY2F0b3IvbG9hZGluZy1pbmRpY2F0b3IuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvbG9hZGluZy1pbmRpY2F0b3IvbG9hZGluZy1pbmRpY2F0b3IuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQTZCLE1BQU0sZUFBZSxDQUFDOzs7QUFJckc7Ozs7O0dBS0c7QUFNSCxNQUFNLE9BQU8seUJBQXlCO0lBNEJwQyxZQUE2QixHQUFzQjtRQUF0QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQXZCbkQ7OztXQUdHO1FBQ00sZUFBVSxHQUF5QixJQUFJLENBQUM7UUFDakQ7OztXQUdHO1FBQ00sY0FBUyxHQUFHLENBQUMsQ0FBQztRQUN2Qjs7O1dBR0c7UUFDTSxrQkFBYSxHQUFHLEtBQUssQ0FBQztRQUMvQjs7O1dBR0c7UUFDTSxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBRXhCLHFCQUFnQixHQUFHLEtBQUssQ0FBQztJQUU2QixDQUFDO0lBRXZELFFBQVE7UUFDTixVQUFVLENBQUMsR0FBRyxFQUFFO1lBQ2QsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztZQUM3QixJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksRUFBRSxDQUFDO1FBQzFCLENBQUMsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDckIsQ0FBQzs7dUhBbkNVLHlCQUF5QjsyR0FBekIseUJBQXlCLDZMQ2Z0Qyxxd0NBa0NBOzRGRG5CYSx5QkFBeUI7a0JBTHJDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHlCQUF5QjtvQkFDbkMsV0FBVyxFQUFFLG9DQUFvQztvQkFDakQsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEO3dHQUtVLElBQUk7c0JBQVosS0FBSztnQkFLRyxVQUFVO3NCQUFsQixLQUFLO2dCQUtHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBS0csYUFBYTtzQkFBckIsS0FBSztnQkFLRyxNQUFNO3NCQUFkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgdHlwZSBMb2FkaW5nSW5kaWNhdG9yU2l6ZSA9ICdsZycgfCAnbWQnIHwgJ3NtJztcblxuLyoqXG4gKiBAbmFtZSBMb2FkaW5nSW5kaWNhdG9yQ29tcG9uZW50XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIGxvYWRpbmcgc3Bpbm5lciBhbmQgbWVzc2FnZS5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYmItbG9hZGluZy1pbmRpY2F0b3ItdWknLFxuICB0ZW1wbGF0ZVVybDogJy4vbG9hZGluZy1pbmRpY2F0b3IuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbn0pXG5leHBvcnQgY2xhc3MgTG9hZGluZ0luZGljYXRvckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8qKlxuICAgKiBUaGUgdGV4dCB0byBkaXNwbGF5IHVuZGVyIHRoZSBsb2FkaW5nIGluZGljYXRvci5cbiAgICovXG4gIEBJbnB1dCgpIHRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBsb2FkaW5nIGluZGljYXRvci5cbiAgICogRGVmYXVsdHMgdG8gJ21kJy5cbiAgICovXG4gIEBJbnB1dCgpIGxvYWRlclNpemU6IExvYWRpbmdJbmRpY2F0b3JTaXplID0gJ21kJztcbiAgLyoqXG4gICAqIERlbGF5IGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIGRpc3BsYXkuXG4gICAqIERlZmF1bHQgdG8gMC5cbiAgICovXG4gIEBJbnB1dCgpIHNob3dEZWxheSA9IDA7XG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoZXRoZXIgZ3JheSBiYWNrZ3JvdW5kIHNob3VsZCBiZSBkaXNwbGF5ZWQuXG4gICAqIERlZmF1bHQgdG8gZmFsc2UgKGJhY2tncm91bmQgaGlkZGVuKS5cbiAgICovXG4gIEBJbnB1dCgpIGhhc0JhY2tncm91bmQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIERlZmluZSBpZiBzcGlubmVyIHNob3VsZCBiZSBzaG93biBpbmxpbmUgd2l0aG91dCBhbnkgZGVmYXVsdCBwYWRkaW5nIGFuZCBtYXJnaW4uXG4gICAqIERlZmF1bHQgdG8gZmFsc2UgKHNob3cgZGVmYXVsdCBwYWRkaW5nIGFuZCBtYXJnaW4pLlxuICAgKi9cbiAgQElucHV0KCkgaW5saW5lID0gZmFsc2U7XG5cbiAgc2hvd0xvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuc2hvd0xvYWRpbmdTdGF0ZSA9IHRydWU7XG4gICAgICB0aGlzLnJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9LCB0aGlzLnNob3dEZWxheSk7XG4gIH1cbn1cbiIsIjxuZy1jb250YWluZXIgKm5nSWY9XCIhaW5saW5lOyBlbHNlIGlubGluZUxvYWRpbmdcIj5cbiAgPGRpdlxuICAgICpuZ0lmPVwic2hvd0xvYWRpbmdTdGF0ZVwiXG4gICAgW25nQ2xhc3NdPVwieyBqdW1ib3Ryb246IGhhc0JhY2tncm91bmQgfVwiXG4gICAgZGF0YS1yb2xlPVwibG9hZGluZy1pbmRpY2F0b3JcIlxuICAgIGNsYXNzPVwiYmItc3RhdGUtY29udGFpbmVyXCJcbiAgPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJsb2FkaW5nSW5kaWNhdG9yXCI+PC9uZy1jb250YWluZXI+XG4gIDwvZGl2PlxuPC9uZy1jb250YWluZXI+XG5cbjxuZy10ZW1wbGF0ZSAjaW5saW5lTG9hZGluZz5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInNob3dMb2FkaW5nU3RhdGVcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibG9hZGluZ0luZGljYXRvclwiPjwvbmctY29udGFpbmVyPlxuICA8L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjbG9hZGluZ0luZGljYXRvcj5cbiAgPGRpdlxuICAgIGRhdGEtcm9sZT1cImxvYWRpbmctaW5kaWNhdG9yLXdyYXBwZXJcIlxuICAgIGNsYXNzPVwiYmItbG9hZGluZy1pbmRpY2F0b3IgYmItbG9hZGluZy1pbmRpY2F0b3ItLXt7IGxvYWRlclNpemUgfX1cIlxuICAgIFtuZ0NsYXNzXT1cInsgJ2JiLWxvYWRpbmctaW5kaWNhdG9yLS1pbmxpbmUnOiBpbmxpbmUgfVwiXG4gID5cbiAgICA8c3ZnXG4gICAgICBhcmlhLWxhYmVsPVwiTG9hZGluZyBpbmRpY2F0b3JcIlxuICAgICAgaTE4bi1hcmlhLWxhYmVsPVwiTG9hZGluZyBpbmRpY2F0b3J8IExhYmVsIGZvciB0aGUgbG9hZGluZyBpbmRpY2F0b3IgQEBiYi1sb2FkaW5nLWluZGljYXRvci11aS5pbmRpY2F0b3JcIlxuICAgICAgY2xhc3M9XCJiYi1sb2FkaW5nLWluZGljYXRvcl9fY2lyY2xlXCJcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWluWU1pbiBtZWV0XCJcbiAgICA+XG4gICAgICA8Y2lyY2xlIGNsYXNzPVwiYmItbG9hZGluZy1pbmRpY2F0b3JfX3BhdGhcIiByPVwiNDAlXCIgY3g9XCI1MCVcIiBjeT1cIjUwJVwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCI+PC9jaXJjbGU+XG4gICAgPC9zdmc+XG4gICAgPGRpdiAqbmdJZj1cInRleHRcIiBkYXRhLXJvbGU9XCJsb2FkaW5nLWluZGljYXRvci10ZXh0XCIgY2xhc3M9XCJiYi1sb2FkaW5nLWluZGljYXRvcl9fdGV4dFwiPnt7IHRleHQgfX08L2Rpdj5cbiAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuIl19