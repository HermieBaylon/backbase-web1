import { ChangeDetectionStrategy, Component, Input, Optional, Self, ViewChild, } from '@angular/core';
import { InputBaseComponent } from '@backbase/ui-ang/base-classes';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/ui-ang/services";
import * as i2 from "@backbase/foundation-ang/future";
import * as i3 from "@angular/forms";
import * as i4 from "@angular/common";
import * as i5 from "./digit-only.directive";
import * as i6 from "@backbase/ui-ang/focus";
/**
 * @name InputNumberComponent
 *
 * @description
 * Component that displays a text input.
 *
 * @a11y Current component provide option to pass needed accessibility
 * attributes. You need to take care of properties that are required in your case :
 *  - role
 *  - aria-activedescendant
 *  - aria-describedby
 *  - aria-expanded
 *  - aria-invalid
 *  - aria-label
 *  - aria-labelledby
 *  - aria-owns
 *
 */
export class InputNumberComponent extends InputBaseComponent {
    constructor(domAttrService, elem, renderer2, cd, deprecationsService, parentFormControl) {
        super(cd, deprecationsService);
        this.domAttrService = domAttrService;
        this.elem = elem;
        this.renderer2 = renderer2;
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        this.parentFormControl = parentFormControl;
        /**
         * The placeholder for the number input. Defaults to an empty string;
         */
        this.placeholder = '';
        /**
         * Whether the number input is readonly.
         */
        this.readonly = false;
        /**
         * Aria label for the number input
         */
        this.ariaLabel = 'Number Input';
        /**
         * If `true` then the under-laying input control will behave as a default number input
         */
        this.allowNonDigits = false;
        /**
         * If `true` then the under-laying input control will allow negative sign as well.
         * Known issue is that it is possible to insert the negative sign anywhere in the field, not only at the beginning.
         * Inserting the negative sign after a digit will render the value empty.
         */
        this.allowNegativeSign = false;
        /* eslint-disable-next-line no-null/no-null */
        this.oldInputValue = null;
        if (this.parentFormControl) {
            this.parentFormControl.valueAccessor = this;
        }
    }
    onInput(inputNumber) {
        if (!inputNumber.value && this.oldInputValue !== null) {
            inputNumber.value = this.oldInputValue;
            this.onValueChange(inputNumber.value);
        }
        /* eslint-disable-next-line no-null/no-null */
        this.oldInputValue = null;
    }
    onPaste(inputNumber) {
        this.oldInputValue = inputNumber.value;
    }
    ngAfterViewInit() {
        if (!this.ariaLabel) {
            this.domAttrService.moveAriaAttributes(this.elem.nativeElement, this.inputEl && this.inputEl.nativeElement, this.renderer2);
        }
    }
}
InputNumberComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputNumberComponent, deps: [{ token: i1.DomAttributesService }, { token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i2.DeprecationsService }, { token: i3.NgControl, optional: true, self: true }], target: i0.ɵɵFactoryTarget.Component });
InputNumberComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputNumberComponent, selector: "bb-input-number-ui", inputs: { placeholder: "placeholder", max: "max", min: "min", step: "step", readonly: "readonly", autocomplete: "autocomplete", ariaLabel: "ariaLabel", allowNonDigits: "allowNonDigits", allowNegativeSign: "allowNegativeSign" }, viewQueries: [{ propertyName: "inputEl", first: true, predicate: ["inputNumber"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<label *ngIf=\"label\" for=\"{{ id }}\">{{ label }}</label>\n<input\n  #inputNumber\n  [bbDigitOnly]=\"!allowNonDigits || allowNegativeSign\"\n  [allowNegativeSign]=\"allowNegativeSign\"\n  id=\"{{ id }}\"\n  [attr.aria-autocomplete]=\"ariaAutocomplete\"\n  [attr.aria-controls]=\"ariaControls\"\n  [attr.aria-labelledby]=\"ariaLabelledby\"\n  [attr.aria-describedby]=\"ariaDescribedby\"\n  [attr.aria-expanded]=\"ariaExpanded\"\n  [attr.role]=\"role\"\n  [attr.aria-invalid]=\"ariaInvalid\"\n  [attr.aria-owns]=\"ariaOwns\"\n  [attr.aria-label]=\"(!label && ariaLabel) || null\"\n  [ngModel]=\"value\"\n  (ngModelChange)=\"onValueChange($event)\"\n  (blur)=\"onBlur()\"\n  type=\"number\"\n  class=\"form-control\"\n  (focus)=\"onFocus()\"\n  (input)=\"onInput(inputNumber)\"\n  (paste)=\"onPaste(inputNumber)\"\n  [disabled]=\"disabled\"\n  [readOnly]=\"readonly\"\n  [placeholder]=\"placeholder\"\n  [required]=\"required\"\n  [attr.min]=\"min\"\n  [attr.max]=\"max\"\n  [attr.size]=\"size\"\n  [attr.step]=\"step\"\n  [bbFocus]=\"autofocus\"\n  [attr.autocomplete]=\"autocomplete\"\n/>\n", directives: [{ type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { type: i3.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { type: i3.MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: ["max"] }, { type: i3.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i5.DigitOnlyDirective, selector: "[bbDigitOnly]", inputs: ["bbDigitOnly", "allowNegativeSign"] }, { type: i3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i6.FocusDirective, selector: "[bbFocus]", inputs: ["bbFocus"], exportAs: ["bbFocus"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputNumberComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-number-ui',
                    templateUrl: './input-number.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.DomAttributesService }, { type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i2.DeprecationsService }, { type: i3.NgControl, decorators: [{
                    type: Self
                }, {
                    type: Optional
                }] }]; }, propDecorators: { placeholder: [{
                type: Input
            }], max: [{
                type: Input
            }], min: [{
                type: Input
            }], step: [{
                type: Input
            }], readonly: [{
                type: Input
            }], autocomplete: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], inputEl: [{
                type: ViewChild,
                args: ['inputNumber']
            }], allowNonDigits: [{
                type: Input
            }], allowNegativeSign: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtbnVtYmVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvdWktYW5nL2lucHV0LW51bWJlci9pbnB1dC1udW1iZXIuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvaW5wdXQtbnVtYmVyL2lucHV0LW51bWJlci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBRXZCLFNBQVMsRUFFVCxLQUFLLEVBQ0wsUUFBUSxFQUVSLElBQUksRUFDSixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sK0JBQStCLENBQUM7Ozs7Ozs7O0FBS25FOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQU1ILE1BQU0sT0FBTyxvQkFBcUIsU0FBUSxrQkFBa0I7SUE4QzFELFlBQ21CLGNBQW9DLEVBQ3BDLElBQWdCLEVBQ2hCLFNBQW9CLEVBQ2xCLEVBQXFCLEVBQ3JCLG1CQUF3QyxFQUNoQyxpQkFBNEI7UUFFdkQsS0FBSyxDQUFDLEVBQUUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBUGQsbUJBQWMsR0FBZCxjQUFjLENBQXNCO1FBQ3BDLFNBQUksR0FBSixJQUFJLENBQVk7UUFDaEIsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNsQixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUNyQix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBQ2hDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBVztRQW5EekQ7O1dBRUc7UUFDTSxnQkFBVyxHQUFHLEVBQUUsQ0FBQztRQWExQjs7V0FFRztRQUNNLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFPMUI7O1dBRUc7UUFFSCxjQUFTLEdBQUcsY0FBYyxDQUFDO1FBRzNCOztXQUVHO1FBQ00sbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFFaEM7Ozs7V0FJRztRQUNNLHNCQUFpQixHQUFHLEtBQUssQ0FBQztRQWlCbkMsOENBQThDO1FBQ3RDLGtCQUFhLEdBQWtCLElBQUksQ0FBQztRQU4xQyxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUMxQixJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztTQUM3QztJQUNILENBQUM7SUFLRCxPQUFPLENBQUMsV0FBNkI7UUFDbkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLEVBQUU7WUFDckQsV0FBVyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1lBQ3ZDLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3ZDO1FBQ0QsOENBQThDO1FBQzlDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0lBQzVCLENBQUM7SUFFRCxPQUFPLENBQUMsV0FBNkI7UUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxlQUFlO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDbkIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQ3ZCLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQzFDLElBQUksQ0FBQyxTQUFTLENBQ2YsQ0FBQztTQUNIO0lBQ0gsQ0FBQzs7a0hBckZVLG9CQUFvQjtzR0FBcEIsb0JBQW9CLDZaQ3hDakMscWtDQWtDQTs0RkRNYSxvQkFBb0I7a0JBTGhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtvQkFDOUIsV0FBVyxFQUFFLCtCQUErQjtvQkFDNUMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEOzswQkFxREksSUFBSTs7MEJBQUksUUFBUTs0Q0FoRFYsV0FBVztzQkFBbkIsS0FBSztnQkFJRyxHQUFHO3NCQUFYLEtBQUs7Z0JBSUcsR0FBRztzQkFBWCxLQUFLO2dCQUlHLElBQUk7c0JBQVosS0FBSztnQkFJRyxRQUFRO3NCQUFoQixLQUFLO2dCQUtHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBTU4sU0FBUztzQkFEUixLQUFLO2dCQUVvQixPQUFPO3NCQUFoQyxTQUFTO3VCQUFDLGFBQWE7Z0JBS2YsY0FBYztzQkFBdEIsS0FBSztnQkFPRyxpQkFBaUI7c0JBQXpCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgSW5wdXQsXG4gIE9wdGlvbmFsLFxuICBSZW5kZXJlcjIsXG4gIFNlbGYsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbnB1dEJhc2VDb21wb25lbnQgfSBmcm9tICdAYmFja2Jhc2UvdWktYW5nL2Jhc2UtY2xhc3Nlcyc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEb21BdHRyaWJ1dGVzU2VydmljZSB9IGZyb20gJ0BiYWNrYmFzZS91aS1hbmcvc2VydmljZXMnO1xuaW1wb3J0IHsgRGVwcmVjYXRpb25zU2VydmljZSB9IGZyb20gJ0BiYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9mdXR1cmUnO1xuXG4vKipcbiAqIEBuYW1lIElucHV0TnVtYmVyQ29tcG9uZW50XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHRleHQgaW5wdXQuXG4gKlxuICogQGExMXkgQ3VycmVudCBjb21wb25lbnQgcHJvdmlkZSBvcHRpb24gdG8gcGFzcyBuZWVkZWQgYWNjZXNzaWJpbGl0eVxuICogYXR0cmlidXRlcy4gWW91IG5lZWQgdG8gdGFrZSBjYXJlIG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgcmVxdWlyZWQgaW4geW91ciBjYXNlIDpcbiAqICAtIHJvbGVcbiAqICAtIGFyaWEtYWN0aXZlZGVzY2VuZGFudFxuICogIC0gYXJpYS1kZXNjcmliZWRieVxuICogIC0gYXJpYS1leHBhbmRlZFxuICogIC0gYXJpYS1pbnZhbGlkXG4gKiAgLSBhcmlhLWxhYmVsXG4gKiAgLSBhcmlhLWxhYmVsbGVkYnlcbiAqICAtIGFyaWEtb3duc1xuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYmItaW5wdXQtbnVtYmVyLXVpJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2lucHV0LW51bWJlci5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dE51bWJlckNvbXBvbmVudCBleHRlbmRzIElucHV0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICAvKipcbiAgICogVGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgbnVtYmVyIGlucHV0LiBEZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmc7XG4gICAqL1xuICBASW5wdXQoKSBwbGFjZWhvbGRlciA9ICcnO1xuICAvKipcbiAgICogVGhlIG1heGltdW0gdmFsdWUgdG8gYWNjZXB0XG4gICAqL1xuICBASW5wdXQoKSBtYXg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIHZhbHVlIHRvIGFjY2VwdCBmb3IgdGhpcyBpbnB1dFxuICAgKi9cbiAgQElucHV0KCkgbWluOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBBIHN0ZXBwaW5nIGludGVydmFsIHRvIHVzZSB3aGVuIHVzaW5nIHVwIGFuZCBkb3duIGFycm93cyB0byBhZGp1c3QgdGhlIHZhbHVlXG4gICAqL1xuICBASW5wdXQoKSBzdGVwOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBudW1iZXIgaW5wdXQgaXMgcmVhZG9ubHkuXG4gICAqL1xuICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUgYXV0b2NvbXBsZXRlIHZhbHVlIG9mIHRoZSBlbmNsb3NlZCBpbnB1dCBjb250cm9sLlxuICAgKi9cbiAgQElucHV0KCkgYXV0b2NvbXBsZXRlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEFyaWEgbGFiZWwgZm9yIHRoZSBudW1iZXIgaW5wdXRcbiAgICovXG4gIEBJbnB1dCgpXG4gIGFyaWFMYWJlbCA9ICdOdW1iZXIgSW5wdXQnO1xuICBAVmlld0NoaWxkKCdpbnB1dE51bWJlcicpIGlucHV0RWw6IEVsZW1lbnRSZWYgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCB0aGVuIHRoZSB1bmRlci1sYXlpbmcgaW5wdXQgY29udHJvbCB3aWxsIGJlaGF2ZSBhcyBhIGRlZmF1bHQgbnVtYmVyIGlucHV0XG4gICAqL1xuICBASW5wdXQoKSBhbGxvd05vbkRpZ2l0cyA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAgdGhlbiB0aGUgdW5kZXItbGF5aW5nIGlucHV0IGNvbnRyb2wgd2lsbCBhbGxvdyBuZWdhdGl2ZSBzaWduIGFzIHdlbGwuXG4gICAqIEtub3duIGlzc3VlIGlzIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gaW5zZXJ0IHRoZSBuZWdhdGl2ZSBzaWduIGFueXdoZXJlIGluIHRoZSBmaWVsZCwgbm90IG9ubHkgYXQgdGhlIGJlZ2lubmluZy5cbiAgICogSW5zZXJ0aW5nIHRoZSBuZWdhdGl2ZSBzaWduIGFmdGVyIGEgZGlnaXQgd2lsbCByZW5kZXIgdGhlIHZhbHVlIGVtcHR5LlxuICAgKi9cbiAgQElucHV0KCkgYWxsb3dOZWdhdGl2ZVNpZ24gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRvbUF0dHJTZXJ2aWNlOiBEb21BdHRyaWJ1dGVzU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGVsZW06IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZWFkb25seSByZW5kZXJlcjI6IFJlbmRlcmVyMixcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByb3RlY3RlZCByZWFkb25seSBkZXByZWNhdGlvbnNTZXJ2aWNlOiBEZXByZWNhdGlvbnNTZXJ2aWNlLFxuICAgIEBTZWxmKCkgQE9wdGlvbmFsKCkgcHVibGljIHBhcmVudEZvcm1Db250cm9sOiBOZ0NvbnRyb2wsXG4gICkge1xuICAgIHN1cGVyKGNkLCBkZXByZWNhdGlvbnNTZXJ2aWNlKTtcblxuICAgIGlmICh0aGlzLnBhcmVudEZvcm1Db250cm9sKSB7XG4gICAgICB0aGlzLnBhcmVudEZvcm1Db250cm9sLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1udWxsL25vLW51bGwgKi9cbiAgcHJpdmF0ZSBvbGRJbnB1dFZhbHVlOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcblxuICBvbklucHV0KGlucHV0TnVtYmVyOiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgaWYgKCFpbnB1dE51bWJlci52YWx1ZSAmJiB0aGlzLm9sZElucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGlucHV0TnVtYmVyLnZhbHVlID0gdGhpcy5vbGRJbnB1dFZhbHVlO1xuICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlKGlucHV0TnVtYmVyLnZhbHVlKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW51bGwvbm8tbnVsbCAqL1xuICAgIHRoaXMub2xkSW5wdXRWYWx1ZSA9IG51bGw7XG4gIH1cblxuICBvblBhc3RlKGlucHV0TnVtYmVyOiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgdGhpcy5vbGRJbnB1dFZhbHVlID0gaW5wdXROdW1iZXIudmFsdWU7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmFyaWFMYWJlbCkge1xuICAgICAgdGhpcy5kb21BdHRyU2VydmljZS5tb3ZlQXJpYUF0dHJpYnV0ZXMoXG4gICAgICAgIHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LFxuICAgICAgICB0aGlzLmlucHV0RWwgJiYgdGhpcy5pbnB1dEVsLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgIHRoaXMucmVuZGVyZXIyLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIjxsYWJlbCAqbmdJZj1cImxhYmVsXCIgZm9yPVwie3sgaWQgfX1cIj57eyBsYWJlbCB9fTwvbGFiZWw+XG48aW5wdXRcbiAgI2lucHV0TnVtYmVyXG4gIFtiYkRpZ2l0T25seV09XCIhYWxsb3dOb25EaWdpdHMgfHwgYWxsb3dOZWdhdGl2ZVNpZ25cIlxuICBbYWxsb3dOZWdhdGl2ZVNpZ25dPVwiYWxsb3dOZWdhdGl2ZVNpZ25cIlxuICBpZD1cInt7IGlkIH19XCJcbiAgW2F0dHIuYXJpYS1hdXRvY29tcGxldGVdPVwiYXJpYUF1dG9jb21wbGV0ZVwiXG4gIFthdHRyLmFyaWEtY29udHJvbHNdPVwiYXJpYUNvbnRyb2xzXCJcbiAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcbiAgW2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJhcmlhRGVzY3JpYmVkYnlcIlxuICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImFyaWFFeHBhbmRlZFwiXG4gIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gIFthdHRyLmFyaWEtaW52YWxpZF09XCJhcmlhSW52YWxpZFwiXG4gIFthdHRyLmFyaWEtb3duc109XCJhcmlhT3duc1wiXG4gIFthdHRyLmFyaWEtbGFiZWxdPVwiKCFsYWJlbCAmJiBhcmlhTGFiZWwpIHx8IG51bGxcIlxuICBbbmdNb2RlbF09XCJ2YWx1ZVwiXG4gIChuZ01vZGVsQ2hhbmdlKT1cIm9uVmFsdWVDaGFuZ2UoJGV2ZW50KVwiXG4gIChibHVyKT1cIm9uQmx1cigpXCJcbiAgdHlwZT1cIm51bWJlclwiXG4gIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgKGZvY3VzKT1cIm9uRm9jdXMoKVwiXG4gIChpbnB1dCk9XCJvbklucHV0KGlucHV0TnVtYmVyKVwiXG4gIChwYXN0ZSk9XCJvblBhc3RlKGlucHV0TnVtYmVyKVwiXG4gIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gIFtyZWFkT25seV09XCJyZWFkb25seVwiXG4gIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gIFtyZXF1aXJlZF09XCJyZXF1aXJlZFwiXG4gIFthdHRyLm1pbl09XCJtaW5cIlxuICBbYXR0ci5tYXhdPVwibWF4XCJcbiAgW2F0dHIuc2l6ZV09XCJzaXplXCJcbiAgW2F0dHIuc3RlcF09XCJzdGVwXCJcbiAgW2JiRm9jdXNdPVwiYXV0b2ZvY3VzXCJcbiAgW2F0dHIuYXV0b2NvbXBsZXRlXT1cImF1dG9jb21wbGV0ZVwiXG4vPlxuIl19