import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, forwardRef, Input, } from '@angular/core';
import { InputBaseComponent } from '@backbase/ui-ang/base-classes';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { BB_DROPDOWN_CHANGE_DETECTION_REF_TOKEN, DropdownSingleSelectOptionComponent, } from './dropdown-single-select-option.component';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/foundation-ang/future";
import * as i2 from "@backbase/ui-ang/icon";
import * as i3 from "@angular/common";
import * as i4 from "@angular/forms";
import * as i5 from "@backbase/ui-ang/focus";
/**
 * @name DropdownSingleSelectComponent
 *
 * @description
 * Component that displays a dropdown with a single select option.
 *
 * @a11y Current component provides option to pass needed accessibility
 * attributes. You need to take care of properties that are required in your case :
 *  - aria-label will be linked to the single select dropdown with label
 *  - set aria-labelledby with ID of another element in the DOM as dropdown's label.
 *  - set aria-describedby with ID of another element in the DOM with descriptive text about the dropdown
 *  - set aria-expanded with a boolean value based on the listbox display.
 *  - set aria-invalid to true when a selected option is not valid ans vice versa
 *  - aria-owns handles contextual relationship between a parent and its child elements,
 *    in this case between dropdown menu and dropdown items, use the id from the input binding.
 *
 */
export class DropdownSingleSelectComponent extends InputBaseComponent {
    constructor(cd, deprecationsService) {
        super(cd, deprecationsService);
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        /**
         * The placeholder for the select. Defaults to an empty string;
         */
        this.placeholder = '';
        /**
         * This Boolean attribute determine if default option as placeholder is displayed. Defaults to false.
         */
        this.defaultOptionAsPlaceholder = false;
        /**
         * The value for the input field. It can be a list of strings or list of objects.
         * If the value is a list of objects, you have to provide the `displayAttributePath` property.
         */
        this.options = [];
        // TODO: after backbase-theme-v2 released. Change default value to 'corner-down'.
        /**
         * Right corner icon name.
         * Default name 'toggle-down'
         */
        this.iconName = 'toggle-down';
        /**
         * Allowing override the option comparison algorithm for tracking identities when
         * checking for change
         */
        this.compareWithFn = (a, b) => a === b;
    }
    getOptionDisplayText(option) {
        return this.displayAttributePath && typeof option === 'object' && option !== null
            ? this.resolvePath(this.displayAttributePath, option)
            : option;
    }
    resolvePath(path, object) {
        if (!object && !path) {
            return '';
        }
        let paths;
        let propName;
        if (path.match(/^\[\d\]/) !== null) {
            paths = path.replace(/^[\[\]]/g, '').split(/\./);
            propName = paths[0].replace(/\]/, '')[0];
        }
        else {
            paths = path.split(/[\.\[]/);
            propName = paths[0];
        }
        const remainingPath = paths
            .slice(1)
            .reduce((result, item) => {
            if (item) {
                if (item.match(/^\d\]/)) {
                    item = '[' + item;
                }
                result.push(item);
            }
            return result;
        }, [])
            .join('.');
        if (!remainingPath) {
            const propValue = object[propName];
            return typeof propValue === 'string' ? propValue : propValue ? String(propValue) : '';
        }
        else if (object.hasOwnProperty(propName)) {
            return this.resolvePath(remainingPath, object[propName]);
        }
        else {
            return '';
        }
    }
    trackByFn(index, item) {
        return item.value;
    }
}
DropdownSingleSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DropdownSingleSelectComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.DeprecationsService }], target: i0.ɵɵFactoryTarget.Component });
DropdownSingleSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: DropdownSingleSelectComponent, selector: "bb-dropdown-single-select-ui", inputs: { placeholder: "placeholder", defaultOptionAsPlaceholder: "defaultOptionAsPlaceholder", options: "options", displayAttributePath: "displayAttributePath", iconName: "iconName", compareWithFn: "compareWithFn" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => DropdownSingleSelectComponent),
            multi: true,
        },
        {
            provide: BB_DROPDOWN_CHANGE_DETECTION_REF_TOKEN,
            useExisting: ChangeDetectorRef,
        },
    ], queries: [{ propertyName: "contentOptions", predicate: DropdownSingleSelectOptionComponent }], usesInheritance: true, ngImport: i0, template: "<label *ngIf=\"label\" class=\"bb-dropdown-single-select__label\" for=\"{{ id }}\" [attr.data-role]=\"'label'\">{{\n  label\n}}</label>\n<!-- Note: in HTML readonly is not supported for <select> like it is for <input> elements -->\n<select\n  [(ngModel)]=\"value\"\n  class=\"form-control bb-dropdown__select\"\n  (blur)=\"onBlur()\"\n  (change)=\"onValueChange()\"\n  (focus)=\"onFocus()\"\n  [compareWith]=\"compareWithFn\"\n  [attr.aria-label]=\"ariaLabel\"\n  [attr.aria-labelledby]=\"ariaLabelledby\"\n  [attr.aria-describedby]=\"ariaDescribedby\"\n  [attr.aria-expanded]=\"ariaExpanded\"\n  [attr.role]=\"role\"\n  [attr.aria-invalid]=\"ariaInvalid\"\n  [attr.aria-owns]=\"ariaOwns\"\n  [disabled]=\"disabled\"\n  [required]=\"required\"\n  id=\"{{ id }}\"\n  [bbFocus]=\"autofocus\"\n  [attr.data-role]=\"'dropdown'\"\n>\n  <option *ngIf=\"defaultOptionAsPlaceholder && placeholder\" value=\"\">\n    {{ placeholder }}\n  </option>\n  <option\n    class=\"bb-dropdown-single-select__option-hidden\"\n    *ngIf=\"!defaultOptionAsPlaceholder && placeholder\"\n    value=\"\"\n    disabled\n    hidden\n  >\n    {{ placeholder }}\n  </option>\n  <option *ngFor=\"let option of options\" [ngValue]=\"option\">\n    {{ getOptionDisplayText(option) }}\n  </option>\n  <option *ngFor=\"let option of contentOptions; trackBy: trackByFn\" [ngValue]=\"option.value\">\n    {{ option.label }}\n  </option>\n</select>\n<div class=\"bb-dropdown__icon\">\n  <bb-icon-ui color=\"muted\" [name]=\"iconName\" size=\"md\"></bb-icon-ui>\n</div>\n", components: [{ type: i2.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i4.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i4.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i5.FocusDirective, selector: "[bbFocus]", inputs: ["bbFocus"], exportAs: ["bbFocus"] }, { type: i4.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { type: i4.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DropdownSingleSelectComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-dropdown-single-select-ui',
                    templateUrl: './dropdown-single-select.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => DropdownSingleSelectComponent),
                            multi: true,
                        },
                        {
                            provide: BB_DROPDOWN_CHANGE_DETECTION_REF_TOKEN,
                            useExisting: ChangeDetectorRef,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.DeprecationsService }]; }, propDecorators: { placeholder: [{
                type: Input
            }], defaultOptionAsPlaceholder: [{
                type: Input
            }], options: [{
                type: Input
            }], contentOptions: [{
                type: ContentChildren,
                args: [DropdownSingleSelectOptionComponent]
            }], displayAttributePath: [{
                type: Input
            }], iconName: [{
                type: Input
            }], compareWithFn: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24tc2luZ2xlLXNlbGVjdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3VpLWFuZy9kcm9wZG93bi1zaW5nbGUtc2VsZWN0L2Ryb3Bkb3duLXNpbmdsZS1zZWxlY3QuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvZHJvcGRvd24tc2luZ2xlLXNlbGVjdC9kcm9wZG93bi1zaW5nbGUtc2VsZWN0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLEtBQUssR0FFTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQ0wsc0NBQXNDLEVBQ3RDLG1DQUFtQyxHQUNwQyxNQUFNLDJDQUEyQyxDQUFDOzs7Ozs7O0FBT25EOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBaUJILE1BQU0sT0FBTyw2QkFBOEIsU0FBUSxrQkFBa0I7SUEyQ25FLFlBQStCLEVBQXFCLEVBQXFCLG1CQUF3QztRQUMvRyxLQUFLLENBQUMsRUFBRSxFQUFFLG1CQUFtQixDQUFDLENBQUM7UUFERixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUFxQix3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO1FBMUNqSDs7V0FFRztRQUNNLGdCQUFXLEdBQUcsRUFBRSxDQUFDO1FBQzFCOztXQUVHO1FBQ00sK0JBQTBCLEdBQUcsS0FBSyxDQUFDO1FBRTVDOzs7V0FHRztRQUNNLFlBQU8sR0FBMkIsRUFBRSxDQUFDO1FBZ0I5QyxpRkFBaUY7UUFDakY7OztXQUdHO1FBQ00sYUFBUSxHQUFHLGFBQWEsQ0FB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QkFoQnpDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLDhCQUE4QjtvQkFDeEMsV0FBVyxFQUFFLHlDQUF5QztvQkFDdEQsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLFNBQVMsRUFBRTt3QkFDVDs0QkFDRSxPQUFPLEVBQUUsaUJBQWlCOzRCQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSw4QkFBOEIsQ0FBQzs0QkFDNUQsS0FBSyxFQUFFLElBQUk7eUJBQ1o7d0JBQ0Q7NEJBQ0UsT0FBTyxFQUFFLHNDQUFzQzs0QkFDL0MsV0FBVyxFQUFFLGlCQUFpQjt5QkFDL0I7cUJBQ0Y7aUJBQ0Y7MElBS1UsV0FBVztzQkFBbkIsS0FBSztnQkFJRywwQkFBMEI7c0JBQWxDLEtBQUs7Z0JBTUcsT0FBTztzQkFBZixLQUFLO2dCQU1OLGNBQWM7c0JBRGIsZUFBZTt1QkFBQyxtQ0FBbUM7Z0JBUzNDLG9CQUFvQjtzQkFBNUIsS0FBSztnQkFPRyxRQUFRO3NCQUFoQixLQUFLO2dCQU1HLGFBQWE7c0JBQXJCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBmb3J3YXJkUmVmLFxuICBJbnB1dCxcbiAgUXVlcnlMaXN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElucHV0QmFzZUNvbXBvbmVudCB9IGZyb20gJ0BiYWNrYmFzZS91aS1hbmcvYmFzZS1jbGFzc2VzJztcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgQkJfRFJPUERPV05fQ0hBTkdFX0RFVEVDVElPTl9SRUZfVE9LRU4sXG4gIERyb3Bkb3duU2luZ2xlU2VsZWN0T3B0aW9uQ29tcG9uZW50LFxufSBmcm9tICcuL2Ryb3Bkb3duLXNpbmdsZS1zZWxlY3Qtb3B0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEZXByZWNhdGlvbnNTZXJ2aWNlIH0gZnJvbSAnQGJhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2Z1dHVyZSc7XG5cbmludGVyZmFjZSBPcHRpb24ge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbi8qKlxuICogQG5hbWUgRHJvcGRvd25TaW5nbGVTZWxlY3RDb21wb25lbnRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbXBvbmVudCB0aGF0IGRpc3BsYXlzIGEgZHJvcGRvd24gd2l0aCBhIHNpbmdsZSBzZWxlY3Qgb3B0aW9uLlxuICpcbiAqIEBhMTF5IEN1cnJlbnQgY29tcG9uZW50IHByb3ZpZGVzIG9wdGlvbiB0byBwYXNzIG5lZWRlZCBhY2Nlc3NpYmlsaXR5XG4gKiBhdHRyaWJ1dGVzLiBZb3UgbmVlZCB0byB0YWtlIGNhcmUgb2YgcHJvcGVydGllcyB0aGF0IGFyZSByZXF1aXJlZCBpbiB5b3VyIGNhc2UgOlxuICogIC0gYXJpYS1sYWJlbCB3aWxsIGJlIGxpbmtlZCB0byB0aGUgc2luZ2xlIHNlbGVjdCBkcm9wZG93biB3aXRoIGxhYmVsXG4gKiAgLSBzZXQgYXJpYS1sYWJlbGxlZGJ5IHdpdGggSUQgb2YgYW5vdGhlciBlbGVtZW50IGluIHRoZSBET00gYXMgZHJvcGRvd24ncyBsYWJlbC5cbiAqICAtIHNldCBhcmlhLWRlc2NyaWJlZGJ5IHdpdGggSUQgb2YgYW5vdGhlciBlbGVtZW50IGluIHRoZSBET00gd2l0aCBkZXNjcmlwdGl2ZSB0ZXh0IGFib3V0IHRoZSBkcm9wZG93blxuICogIC0gc2V0IGFyaWEtZXhwYW5kZWQgd2l0aCBhIGJvb2xlYW4gdmFsdWUgYmFzZWQgb24gdGhlIGxpc3Rib3ggZGlzcGxheS5cbiAqICAtIHNldCBhcmlhLWludmFsaWQgdG8gdHJ1ZSB3aGVuIGEgc2VsZWN0ZWQgb3B0aW9uIGlzIG5vdCB2YWxpZCBhbnMgdmljZSB2ZXJzYVxuICogIC0gYXJpYS1vd25zIGhhbmRsZXMgY29udGV4dHVhbCByZWxhdGlvbnNoaXAgYmV0d2VlbiBhIHBhcmVudCBhbmQgaXRzIGNoaWxkIGVsZW1lbnRzLFxuICogICAgaW4gdGhpcyBjYXNlIGJldHdlZW4gZHJvcGRvd24gbWVudSBhbmQgZHJvcGRvd24gaXRlbXMsIHVzZSB0aGUgaWQgZnJvbSB0aGUgaW5wdXQgYmluZGluZy5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWRyb3Bkb3duLXNpbmdsZS1zZWxlY3QtdWknLFxuICB0ZW1wbGF0ZVVybDogJy4vZHJvcGRvd24tc2luZ2xlLXNlbGVjdC5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERyb3Bkb3duU2luZ2xlU2VsZWN0Q29tcG9uZW50KSxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgIH0sXG4gICAge1xuICAgICAgcHJvdmlkZTogQkJfRFJPUERPV05fQ0hBTkdFX0RFVEVDVElPTl9SRUZfVE9LRU4sXG4gICAgICB1c2VFeGlzdGluZzogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd25TaW5nbGVTZWxlY3RDb21wb25lbnQgZXh0ZW5kcyBJbnB1dEJhc2VDb21wb25lbnQge1xuICAvKipcbiAgICogVGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgc2VsZWN0LiBEZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmc7XG4gICAqL1xuICBASW5wdXQoKSBwbGFjZWhvbGRlciA9ICcnO1xuICAvKipcbiAgICogVGhpcyBCb29sZWFuIGF0dHJpYnV0ZSBkZXRlcm1pbmUgaWYgZGVmYXVsdCBvcHRpb24gYXMgcGxhY2Vob2xkZXIgaXMgZGlzcGxheWVkLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICovXG4gIEBJbnB1dCgpIGRlZmF1bHRPcHRpb25Bc1BsYWNlaG9sZGVyID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBmb3IgdGhlIGlucHV0IGZpZWxkLiBJdCBjYW4gYmUgYSBsaXN0IG9mIHN0cmluZ3Mgb3IgbGlzdCBvZiBvYmplY3RzLlxuICAgKiBJZiB0aGUgdmFsdWUgaXMgYSBsaXN0IG9mIG9iamVjdHMsIHlvdSBoYXZlIHRvIHByb3ZpZGUgdGhlIGBkaXNwbGF5QXR0cmlidXRlUGF0aGAgcHJvcGVydHkuXG4gICAqL1xuICBASW5wdXQoKSBvcHRpb25zOiBBcnJheTxPYmplY3QgfCBzdHJpbmc+ID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBjaGlsZCBvcHRpb24gY29tcG9uZW50cyBvZiB0eXBlIERyb3Bkb3duU2luZ2xlU2VsZWN0T3B0aW9uQ29tcG9uZW50XG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKERyb3Bkb3duU2luZ2xlU2VsZWN0T3B0aW9uQ29tcG9uZW50KVxuICBjb250ZW50T3B0aW9uczogUXVlcnlMaXN0PERyb3Bkb3duU2luZ2xlU2VsZWN0T3B0aW9uQ29tcG9uZW50PiB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogSW4gY2FzZSB0aGUgbGlzdCBvZiBvcHRpb25zIGlzIGEgbGlzdCBvZiBvYmplY3RzLFxuICAgKiB0aGlzIHByb3BlcnR5IHdpbGwgc2V0IHRoZSBwYXRoIHRvIHRoZSBvYmplY3QgcHJvcGVydHkgd2hpY2ggdmFsdWUgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIG9wdGlvbi5cbiAgICogVW5kZWZpbmVkIHdpbGwgYXNzdW1lIHRoZSBvcHRpb25zIGFyZSBzdHJpbmdzLlxuICAgKiBDaGlsZCBOb2RlcyBzaG91bGQgYmUgc2VwZXJhdGVkIGJ5ICcuJ1xuICAgKi9cbiAgQElucHV0KCkgZGlzcGxheUF0dHJpYnV0ZVBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvLyBUT0RPOiBhZnRlciBiYWNrYmFzZS10aGVtZS12MiByZWxlYXNlZC4gQ2hhbmdlIGRlZmF1bHQgdmFsdWUgdG8gJ2Nvcm5lci1kb3duJy5cbiAgLyoqXG4gICAqIFJpZ2h0IGNvcm5lciBpY29uIG5hbWUuXG4gICAqIERlZmF1bHQgbmFtZSAndG9nZ2xlLWRvd24nXG4gICAqL1xuICBASW5wdXQoKSBpY29uTmFtZSA9ICd0b2dnbGUtZG93bic7XG5cbiAgLyoqXG4gICAqIEFsbG93aW5nIG92ZXJyaWRlIHRoZSBvcHRpb24gY29tcGFyaXNvbiBhbGdvcml0aG0gZm9yIHRyYWNraW5nIGlkZW50aXRpZXMgd2hlblxuICAgKiBjaGVja2luZyBmb3IgY2hhbmdlXG4gICAqL1xuICBASW5wdXQoKSBjb21wYXJlV2l0aEZuOiAoYTogYW55LCBiOiBhbnkpID0+IGJvb2xlYW4gPSAoYSwgYikgPT4gYSA9PT0gYjtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgY2Q6IENoYW5nZURldGVjdG9yUmVmLCBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVwcmVjYXRpb25zU2VydmljZTogRGVwcmVjYXRpb25zU2VydmljZSkge1xuICAgIHN1cGVyKGNkLCBkZXByZWNhdGlvbnNTZXJ2aWNlKTtcbiAgfVxuXG4gIGdldE9wdGlvbkRpc3BsYXlUZXh0KG9wdGlvbjogT2JqZWN0IHwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGxheUF0dHJpYnV0ZVBhdGggJiYgdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uICE9PSBudWxsXG4gICAgICA/IHRoaXMucmVzb2x2ZVBhdGgodGhpcy5kaXNwbGF5QXR0cmlidXRlUGF0aCwgb3B0aW9uIGFzIE9wdGlvbilcbiAgICAgIDogb3B0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlUGF0aChwYXRoOiBzdHJpbmcsIG9iamVjdDogT3B0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAoIW9iamVjdCAmJiAhcGF0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBsZXQgcGF0aHM7XG4gICAgbGV0IHByb3BOYW1lOiBzdHJpbmc7XG4gICAgaWYgKHBhdGgubWF0Y2goL15cXFtcXGRcXF0vKSAhPT0gbnVsbCkge1xuICAgICAgcGF0aHMgPSBwYXRoLnJlcGxhY2UoL15bXFxbXFxdXS9nLCAnJykuc3BsaXQoL1xcLi8pO1xuICAgICAgcHJvcE5hbWUgPSBwYXRoc1swXS5yZXBsYWNlKC9cXF0vLCAnJylbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aC5zcGxpdCgvW1xcLlxcW10vKTtcbiAgICAgIHByb3BOYW1lID0gcGF0aHNbMF07XG4gICAgfVxuXG4gICAgY29uc3QgcmVtYWluaW5nUGF0aCA9IHBhdGhzXG4gICAgICAuc2xpY2UoMSlcbiAgICAgIC5yZWR1Y2UoKHJlc3VsdDogc3RyaW5nW10sIGl0ZW06IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtLm1hdGNoKC9eXFxkXFxdLykpIHtcbiAgICAgICAgICAgIGl0ZW0gPSAnWycgKyBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSlcbiAgICAgIC5qb2luKCcuJyk7XG5cbiAgICBpZiAoIXJlbWFpbmluZ1BhdGgpIHtcbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IG9iamVjdFtwcm9wTmFtZV07XG5cbiAgICAgIHJldHVybiB0eXBlb2YgcHJvcFZhbHVlID09PSAnc3RyaW5nJyA/IHByb3BWYWx1ZSA6IHByb3BWYWx1ZSA/IFN0cmluZyhwcm9wVmFsdWUpIDogJyc7XG4gICAgfSBlbHNlIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUGF0aChyZW1haW5pbmdQYXRoLCBvYmplY3RbcHJvcE5hbWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIHRyYWNrQnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBEcm9wZG93blNpbmdsZVNlbGVjdE9wdGlvbkNvbXBvbmVudCkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xuICB9XG59XG4iLCI8bGFiZWwgKm5nSWY9XCJsYWJlbFwiIGNsYXNzPVwiYmItZHJvcGRvd24tc2luZ2xlLXNlbGVjdF9fbGFiZWxcIiBmb3I9XCJ7eyBpZCB9fVwiIFthdHRyLmRhdGEtcm9sZV09XCInbGFiZWwnXCI+e3tcbiAgbGFiZWxcbn19PC9sYWJlbD5cbjwhLS0gTm90ZTogaW4gSFRNTCByZWFkb25seSBpcyBub3Qgc3VwcG9ydGVkIGZvciA8c2VsZWN0PiBsaWtlIGl0IGlzIGZvciA8aW5wdXQ+IGVsZW1lbnRzIC0tPlxuPHNlbGVjdFxuICBbKG5nTW9kZWwpXT1cInZhbHVlXCJcbiAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgYmItZHJvcGRvd25fX3NlbGVjdFwiXG4gIChibHVyKT1cIm9uQmx1cigpXCJcbiAgKGNoYW5nZSk9XCJvblZhbHVlQ2hhbmdlKClcIlxuICAoZm9jdXMpPVwib25Gb2N1cygpXCJcbiAgW2NvbXBhcmVXaXRoXT1cImNvbXBhcmVXaXRoRm5cIlxuICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG4gIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG4gIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiYXJpYURlc2NyaWJlZGJ5XCJcbiAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJhcmlhRXhwYW5kZWRcIlxuICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICBbYXR0ci5hcmlhLWludmFsaWRdPVwiYXJpYUludmFsaWRcIlxuICBbYXR0ci5hcmlhLW93bnNdPVwiYXJpYU93bnNcIlxuICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICBpZD1cInt7IGlkIH19XCJcbiAgW2JiRm9jdXNdPVwiYXV0b2ZvY3VzXCJcbiAgW2F0dHIuZGF0YS1yb2xlXT1cIidkcm9wZG93bidcIlxuPlxuICA8b3B0aW9uICpuZ0lmPVwiZGVmYXVsdE9wdGlvbkFzUGxhY2Vob2xkZXIgJiYgcGxhY2Vob2xkZXJcIiB2YWx1ZT1cIlwiPlxuICAgIHt7IHBsYWNlaG9sZGVyIH19XG4gIDwvb3B0aW9uPlxuICA8b3B0aW9uXG4gICAgY2xhc3M9XCJiYi1kcm9wZG93bi1zaW5nbGUtc2VsZWN0X19vcHRpb24taGlkZGVuXCJcbiAgICAqbmdJZj1cIiFkZWZhdWx0T3B0aW9uQXNQbGFjZWhvbGRlciAmJiBwbGFjZWhvbGRlclwiXG4gICAgdmFsdWU9XCJcIlxuICAgIGRpc2FibGVkXG4gICAgaGlkZGVuXG4gID5cbiAgICB7eyBwbGFjZWhvbGRlciB9fVxuICA8L29wdGlvbj5cbiAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIG9wdGlvbnNcIiBbbmdWYWx1ZV09XCJvcHRpb25cIj5cbiAgICB7eyBnZXRPcHRpb25EaXNwbGF5VGV4dChvcHRpb24pIH19XG4gIDwvb3B0aW9uPlxuICA8b3B0aW9uICpuZ0Zvcj1cImxldCBvcHRpb24gb2YgY29udGVudE9wdGlvbnM7IHRyYWNrQnk6IHRyYWNrQnlGblwiIFtuZ1ZhbHVlXT1cIm9wdGlvbi52YWx1ZVwiPlxuICAgIHt7IG9wdGlvbi5sYWJlbCB9fVxuICA8L29wdGlvbj5cbjwvc2VsZWN0PlxuPGRpdiBjbGFzcz1cImJiLWRyb3Bkb3duX19pY29uXCI+XG4gIDxiYi1pY29uLXVpIGNvbG9yPVwibXV0ZWRcIiBbbmFtZV09XCJpY29uTmFtZVwiIHNpemU9XCJtZFwiPjwvYmItaWNvbi11aT5cbjwvZGl2PlxuIl19