import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import * as i0 from "@angular/core";
export class MinDateValidatorDirective {
    constructor() {
        this._minDate = -Number.MAX_VALUE;
        this.onValidatorChange = () => { };
    }
    set minDate(date) {
        if (!date) {
            this._minDate = -Number.MAX_VALUE;
        }
        else {
            const minDate = typeof date === 'string' ? new Date(date) : new Date(date.year, date.month - 1, date.day);
            this._minDate = minDate.getTime();
        }
        this.onValidatorChange();
    }
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    validate(control) {
        const value = control.value && control.value.from ? control.value.from : control.value;
        if (!value) {
            return null;
        }
        return new Date(value).getTime() >= this._minDate
            ? // eslint-disable-next-line no-null/no-null
                null
            : { dateLessThanMinDate: true };
    }
    ngOnDestroy() {
        this.minDate = undefined;
    }
}
MinDateValidatorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MinDateValidatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
MinDateValidatorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: MinDateValidatorDirective, selector: "bb-input-datepicker-ui[minDate]", inputs: { minDate: "minDate" }, providers: [
        {
            provide: NG_VALIDATORS,
            multi: true,
            useExisting: forwardRef(() => MinDateValidatorDirective),
        },
    ], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MinDateValidatorDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'bb-input-datepicker-ui[minDate]',
                    providers: [
                        {
                            provide: NG_VALIDATORS,
                            multi: true,
                            useExisting: forwardRef(() => MinDateValidatorDirective),
                        },
                    ],
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { minDate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWluLWRhdGUtdmFsaWRhdG9yLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvdWktYW5nL2lucHV0LWRhdGVwaWNrZXIvdmFsaWRhdGlvbi9taW4tZGF0ZS12YWxpZGF0b3IvbWluLWRhdGUtdmFsaWRhdG9yLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFtQixhQUFhLEVBQStCLE1BQU0sZ0JBQWdCLENBQUM7O0FBYzdGLE1BQU0sT0FBTyx5QkFBeUI7SUFLcEM7UUFKUSxhQUFRLEdBQVcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDO1FBRTdDLHNCQUFpQixHQUFlLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztJQUUxQixDQUFDO0lBRWhCLElBQ0ksT0FBTyxDQUFDLElBQXdDO1FBQ2xELElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztTQUNuQzthQUFNO1lBQ0wsTUFBTSxPQUFPLEdBQUcsT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDMUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDbkM7UUFFRCxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRUQseUJBQXlCLENBQUMsRUFBYztRQUN0QyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRCxRQUFRLENBQUMsT0FBd0I7UUFDL0IsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEtBQUssSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUM7UUFDdkYsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRSxJQUFJLElBQUksQ0FBQyxRQUFRO1lBQy9DLENBQUMsQ0FBQywyQ0FBMkM7Z0JBQzNDLElBQUk7WUFDTixDQUFDLENBQUMsRUFBRSxtQkFBbUIsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUNwQyxDQUFDO0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0lBQzNCLENBQUM7O3VIQXJDVSx5QkFBeUI7MkdBQXpCLHlCQUF5QiwwRkFSekI7UUFDVDtZQUNFLE9BQU8sRUFBRSxhQUFhO1lBQ3RCLEtBQUssRUFBRSxJQUFJO1lBQ1gsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyx5QkFBeUIsQ0FBQztTQUN6RDtLQUNGOzRGQUVVLHlCQUF5QjtrQkFYckMsU0FBUzttQkFBQztvQkFDVCw4REFBOEQ7b0JBQzlELFFBQVEsRUFBRSxpQ0FBaUM7b0JBQzNDLFNBQVMsRUFBRTt3QkFDVDs0QkFDRSxPQUFPLEVBQUUsYUFBYTs0QkFDdEIsS0FBSyxFQUFFLElBQUk7NEJBQ1gsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsMEJBQTBCLENBQUM7eUJBQ3pEO3FCQUNGO2lCQUNGOzBFQVNLLE9BQU87c0JBRFYsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBOR19WQUxJREFUT1JTLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBOZ2JEYXRlU3RydWN0IH0gZnJvbSAnQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAnO1xuXG5ARGlyZWN0aXZlKHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9kaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6ICdiYi1pbnB1dC1kYXRlcGlja2VyLXVpW21pbkRhdGVdJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWluRGF0ZVZhbGlkYXRvckRpcmVjdGl2ZSksXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTWluRGF0ZVZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfbWluRGF0ZTogbnVtYmVyID0gLU51bWJlci5NQVhfVkFMVUU7XG5cbiAgb25WYWxpZGF0b3JDaGFuZ2U6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcblxuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgQElucHV0KClcbiAgc2V0IG1pbkRhdGUoZGF0ZTogc3RyaW5nIHwgTmdiRGF0ZVN0cnVjdCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICghZGF0ZSkge1xuICAgICAgdGhpcy5fbWluRGF0ZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtaW5EYXRlID0gdHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnID8gbmV3IERhdGUoZGF0ZSkgOiBuZXcgRGF0ZShkYXRlLnllYXIsIGRhdGUubW9udGggLSAxLCBkYXRlLmRheSk7XG4gICAgICB0aGlzLl9taW5EYXRlID0gbWluRGF0ZS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5vblZhbGlkYXRvckNoYW5nZSgpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMub25WYWxpZGF0b3JDaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICBjb25zdCB2YWx1ZSA9IGNvbnRyb2wudmFsdWUgJiYgY29udHJvbC52YWx1ZS5mcm9tID8gY29udHJvbC52YWx1ZS5mcm9tIDogY29udHJvbC52YWx1ZTtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKSA+PSB0aGlzLl9taW5EYXRlXG4gICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1udWxsL25vLW51bGxcbiAgICAgICAgbnVsbFxuICAgICAgOiB7IGRhdGVMZXNzVGhhbk1pbkRhdGU6IHRydWUgfTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMubWluRGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxufVxuIl19