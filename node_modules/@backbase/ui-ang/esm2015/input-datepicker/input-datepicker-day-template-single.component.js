import { ChangeDetectionStrategy, Component, Input, HostListener, Output, EventEmitter, } from '@angular/core';
import { NgbDateParserFormatter } from '@ng-bootstrap/ng-bootstrap';
import { NgbDateLocaleParserFormatter } from './input-datepicker-formatter';
import { DatePipe } from '@angular/common';
import { KEY_CODES } from '@backbase/ui-ang/util';
import { BrowserService, NAVIGATOR_TOKEN, navigatorFactory } from '@backbase/ui-ang/services';
import * as i0 from "@angular/core";
import * as i1 from "./input-datepicker-formatter";
import * as i2 from "@backbase/ui-ang/services";
import * as i3 from "@angular/common";
/* eslint-disable */
export var Key;
(function (Key) {
    Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowRight"] = 39] = "ArrowRight";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key || (Key = {}));
export class InputDatepickerDayTemplateSingleComponent {
    constructor(formatterHelper, browserService) {
        this.formatterHelper = formatterHelper;
        this.browserService = browserService;
        /**
         * Indicates whether the date is selected
         */
        this.selected = false;
        /**
         * When true the date is rendered as disabled
         */
        this.disabled = false;
        /**
         * Hovered date by a user
         */
        this.hoveredDate = null;
        /**
         * Event to trigger on date hover
         */
        this.hovered = new EventEmitter();
        /**
         * Indicates if the date displayed as greyed out
         */
        this.isTextMuted = false;
        /**
         * Indicates if the date is hovered the range
         */
        this.isHovered = false;
        this.format = (date) => this.formatterHelper.format(date);
        this.isIE = this.browserService.browserIsMSIE();
    }
    ngOnChanges(changes) {
        var _a, _b;
        if ((changes === null || changes === void 0 ? void 0 : changes.selected) || (changes === null || changes === void 0 ? void 0 : changes.disabled) || (changes === null || changes === void 0 ? void 0 : changes.date) || (changes === null || changes === void 0 ? void 0 : changes.currentMonth)) {
            this.isTextMuted = !this.selected && (this.disabled || ((_a = this.date) === null || _a === void 0 ? void 0 : _a.month) !== +this.currentMonth);
        }
        this.isHovered = (_b = this.date) === null || _b === void 0 ? void 0 : _b.equals(this.hoveredDate);
    }
    /**
     *
     * @description
     * Handle mouseover. Emit the hovered date with null.
     *
     */
    onMouseOut() {
        this.hovered.emit({ date: null, isSelecting: false });
    }
    /**
     *
     * @description
     * Handle mouseover. Emit the hovered date with date.
     *
     */
    onMouseOver() {
        this.hovered.emit({ date: this.date, isSelecting: true });
    }
    /**
     * @description
     * Keypress handler
     *
     * @param evt
     * @param curMonth
     * @param curDay
     * @param date
     */
    onKeyUp(event) {
        const day = event.target.textContent;
        const matchKey = this.isIE
            ? Object.values(Key).includes(event === null || event === void 0 ? void 0 : event.keyCode)
            : InputDatepickerDayTemplateSingleComponent.hangledKeyCodes.includes(event === null || event === void 0 ? void 0 : event.key);
        if (Number(day) === this.date.day && Number(this.currentMonth) === this.date.month && matchKey) {
            this.hovered.emit({ date: this.date, isSelecting: true });
        }
    }
}
InputDatepickerDayTemplateSingleComponent.hangledKeyCodes = [KEY_CODES.LEFT, KEY_CODES.UP, KEY_CODES.RIGHT, KEY_CODES.DOWN];
InputDatepickerDayTemplateSingleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerDayTemplateSingleComponent, deps: [{ token: i1.NgbDateLocaleParserFormatter }, { token: i2.BrowserService }], target: i0.ɵɵFactoryTarget.Component });
InputDatepickerDayTemplateSingleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerDayTemplateSingleComponent, selector: "bb-input-datepicker-single-day-template-ui", inputs: { date: "date", selected: "selected", disabled: "disabled", currentMonth: "currentMonth", hoveredDate: "hoveredDate" }, outputs: { hovered: "hovered" }, host: { listeners: { "mouseout": "onMouseOut()", "mouseover": "onMouseOver()", "document:keyup": "onKeyUp($event)" } }, providers: [
        DatePipe,
        NgbDateLocaleParserFormatter,
        {
            provide: NgbDateParserFormatter,
            useExisting: NgbDateLocaleParserFormatter,
        },
        BrowserService,
        { provide: NAVIGATOR_TOKEN, useFactory: navigatorFactory },
    ], usesOnChanges: true, ngImport: i0, template: "<time\n  class=\"custom-day text-center bb-input-datepicker__single-day\"\n  [ngClass]=\"{\n    'is-selected': selected,\n    'text-muted': isTextMuted\n  }\"\n  [attr.data-role]=\"'calendar-date-item'\"\n  [dateTime]=\"format(date)\"\n>\n  {{ date?.day }}\n</time>\n", directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerDayTemplateSingleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-datepicker-single-day-template-ui',
                    templateUrl: './input-datepicker-day-template-single.component.html',
                    providers: [
                        DatePipe,
                        NgbDateLocaleParserFormatter,
                        {
                            provide: NgbDateParserFormatter,
                            useExisting: NgbDateLocaleParserFormatter,
                        },
                        BrowserService,
                        { provide: NAVIGATOR_TOKEN, useFactory: navigatorFactory },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgbDateLocaleParserFormatter }, { type: i2.BrowserService }]; }, propDecorators: { date: [{
                type: Input
            }], selected: [{
                type: Input
            }], disabled: [{
                type: Input
            }], currentMonth: [{
                type: Input
            }], hoveredDate: [{
                type: Input
            }], hovered: [{
                type: Output
            }], onMouseOut: [{
                type: HostListener,
                args: ['mouseout']
            }], onMouseOver: [{
                type: HostListener,
                args: ['mouseover']
            }], onKeyUp: [{
                type: HostListener,
                args: ['document:keyup', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZGF0ZXBpY2tlci1kYXktdGVtcGxhdGUtc2luZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvdWktYW5nL2lucHV0LWRhdGVwaWNrZXIvaW5wdXQtZGF0ZXBpY2tlci1kYXktdGVtcGxhdGUtc2luZ2xlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL2xpYnMvdWktYW5nL2lucHV0LWRhdGVwaWNrZXIvaW5wdXQtZGF0ZXBpY2tlci1kYXktdGVtcGxhdGUtc2luZ2xlLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULEtBQUssRUFHTCxZQUFZLEVBQ1osTUFBTSxFQUNOLFlBQVksR0FDYixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQVcsc0JBQXNCLEVBQWlCLE1BQU0sNEJBQTRCLENBQUM7QUFDNUYsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTNDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDOzs7OztBQUc5RixvQkFBb0I7QUFDcEIsTUFBTSxDQUFOLElBQVksR0FLWDtBQUxELFdBQVksR0FBRztJQUNiLHdDQUFjLENBQUE7SUFDZCxvQ0FBWSxDQUFBO0lBQ1osMENBQWUsQ0FBQTtJQUNmLHdDQUFjLENBQUE7QUFDaEIsQ0FBQyxFQUxXLEdBQUcsS0FBSCxHQUFHLFFBS2Q7QUFpQkQsTUFBTSxPQUFPLHlDQUF5QztJQUNwRCxZQUNtQixlQUE2QyxFQUM3QyxjQUE4QjtRQUQ5QixvQkFBZSxHQUFmLGVBQWUsQ0FBOEI7UUFDN0MsbUJB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SyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQzt1SUFSekcseUNBQXlDOzJIQUF6Qyx5Q0FBeUMsOFZBWnpDO1FBQ1QsUUFBUTtRQUNSLDRCQUE0QjtRQUM1QjtZQUNFLE9BQU8sRUFBRSxzQkFBc0I7WUFDL0IsV0FBVyxFQUFFLDRCQUE0QjtTQUMxQztRQUNELGNBQWM7UUFDZCxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixFQUFFO0tBQzNELCtDQ3RDSCw2UUFXQTs0RkQ4QmEseUNBQXlDO2tCQWZyRCxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSw0Q0FBNEM7b0JBQ3RELFdBQVcsRUFBRSx1REFBdUQ7b0JBQ3BFLFNBQVMsRUFBRTt3QkFDVCxRQUFRO3dCQUNSLDRCQUE0Qjt3QkFDNUI7NEJBQ0UsT0FBTyxFQUFFLHNCQUFzQjs0QkFDL0IsV0FBVyxFQUFFLDRCQUE0Qjt5QkFDMUM7d0JBQ0QsY0FBYzt3QkFDZCxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixFQUFFO3FCQUMzRDtvQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtpQkFDaEQ7Z0pBY1UsSUFBSTtzQkFBWixLQUFLO2dCQUtHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBS0csUUFBUTtzQkFBaEIsS0FBSztnQkFLRyxZQUFZO3NCQUFwQixLQUFLO2dCQUtHLFdBQVc7c0JBQW5CLEtBQUs7Z0JBS0ksT0FBTztzQkFBaEIsTUFBTTtnQkFpQ1AsVUFBVTtzQkFEVCxZQUFZO3VCQUFDLFVBQVU7Z0JBWXhCLFdBQVc7c0JBRFYsWUFBWTt1QkFBQyxXQUFXO2dCQWV6QixPQUFPO3NCQUROLFlBQVk7dUJBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgT25DaGFuZ2VzLFxuICBIb3N0TGlzdGVuZXIsXG4gIE91dHB1dCxcbiAgRXZlbnRFbWl0dGVyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nYkRhdGUsIE5nYkRhdGVQYXJzZXJGb3JtYXR0ZXIsIE5nYkRhdGVTdHJ1Y3QgfSBmcm9tICdAbmctYm9vdHN0cmFwL25nLWJvb3RzdHJhcCc7XG5pbXBvcnQgeyBOZ2JEYXRlTG9jYWxlUGFyc2VyRm9ybWF0dGVyIH0gZnJvbSAnLi9pbnB1dC1kYXRlcGlja2VyLWZvcm1hdHRlcic7XG5pbXBvcnQgeyBEYXRlUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ0RhdGVTdHJ1Y3ROdWxsYWJsZSB9IGZyb20gJy4vaW5wdXQtZGF0ZXBpY2tlci5tb2RlbCc7XG5pbXBvcnQgeyBLRVlfQ09ERVMgfSBmcm9tICdAYmFja2Jhc2UvdWktYW5nL3V0aWwnO1xuaW1wb3J0IHsgQnJvd3NlclNlcnZpY2UsIE5BVklHQVRPUl9UT0tFTiwgbmF2aWdhdG9yRmFjdG9yeSB9IGZyb20gJ0BiYWNrYmFzZS91aS1hbmcvc2VydmljZXMnO1xuaW1wb3J0IHsgRGF0ZVNlbGVjdGlvbk1vZGVsIH0gZnJvbSAnLi9pbnB1dC1kYXRlcGlja2VyLm1vZGVsJztcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBlbnVtIEtleSB7XG4gIEFycm93TGVmdCA9IDM3LFxuICBBcnJvd1VwID0gMzgsXG4gIEFycm93UmlnaHQgPSAzOSxcbiAgQXJyb3dEb3duID0gNDAsXG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWlucHV0LWRhdGVwaWNrZXItc2luZ2xlLWRheS10ZW1wbGF0ZS11aScsXG4gIHRlbXBsYXRlVXJsOiAnLi9pbnB1dC1kYXRlcGlja2VyLWRheS10ZW1wbGF0ZS1zaW5nbGUuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBEYXRlUGlwZSxcbiAgICBOZ2JEYXRlTG9jYWxlUGFyc2VyRm9ybWF0dGVyLFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5nYkRhdGVQYXJzZXJGb3JtYXR0ZXIsXG4gICAgICB1c2VFeGlzdGluZzogTmdiRGF0ZUxvY2FsZVBhcnNlckZvcm1hdHRlcixcbiAgICB9LFxuICAgIEJyb3dzZXJTZXJ2aWNlLFxuICAgIHsgcHJvdmlkZTogTkFWSUdBVE9SX1RPS0VOLCB1c2VGYWN0b3J5OiBuYXZpZ2F0b3JGYWN0b3J5IH0sXG4gIF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dERhdGVwaWNrZXJEYXlUZW1wbGF0ZVNpbmdsZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZm9ybWF0dGVySGVscGVyOiBOZ2JEYXRlTG9jYWxlUGFyc2VyRm9ybWF0dGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYnJvd3NlclNlcnZpY2U6IEJyb3dzZXJTZXJ2aWNlLFxuICApIHtcbiAgICB0aGlzLmlzSUUgPSB0aGlzLmJyb3dzZXJTZXJ2aWNlLmJyb3dzZXJJc01TSUUoKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IGhhbmdsZWRLZXlDb2Rlczogc3RyaW5nW10gPSBbS0VZX0NPREVTLkxFRlQsIEtFWV9DT0RFUy5VUCwgS0VZX0NPREVTLlJJR0hULCBLRVlfQ09ERVMuRE9XTl07XG5cbiAgLyoqXG4gICAqIERhdGUgdG8gcmVuZGVyXG4gICAqL1xuICBASW5wdXQoKSBkYXRlITogTmdiRGF0ZTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgc2VsZWN0ZWRcbiAgICovXG4gIEBJbnB1dCgpIHNlbGVjdGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSB0aGUgZGF0ZSBpcyByZW5kZXJlZCBhcyBkaXNhYmxlZFxuICAgKi9cbiAgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQ3VycmVudE1vbnRoIG9uIHRoZSBkYXRlcGlja2VyIHdpbmRvd1xuICAgKi9cbiAgQElucHV0KCkgY3VycmVudE1vbnRoITogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIb3ZlcmVkIGRhdGUgYnkgYSB1c2VyXG4gICAqL1xuICBASW5wdXQoKSBob3ZlcmVkRGF0ZTogTmdEYXRlU3RydWN0TnVsbGFibGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBFdmVudCB0byB0cmlnZ2VyIG9uIGRhdGUgaG92ZXJcbiAgICovXG4gIEBPdXRwdXQoKSBob3ZlcmVkID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlU2VsZWN0aW9uTW9kZWw+KCk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZGF0ZSBkaXNwbGF5ZWQgYXMgZ3JleWVkIG91dFxuICAgKi9cbiAgaXNUZXh0TXV0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBkYXRlIGlzIGhvdmVyZWQgdGhlIHJhbmdlXG4gICAqL1xuICBpc0hvdmVyZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBicm93c2VyIGlzIElFXG4gICAqL1xuICBpc0lFOiBib29sZWFuO1xuXG4gIGZvcm1hdCA9IChkYXRlOiBOZ2JEYXRlU3RydWN0IHwgdW5kZWZpbmVkIHwgbnVsbCkgPT4gdGhpcy5mb3JtYXR0ZXJIZWxwZXIuZm9ybWF0KGRhdGUpO1xuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoY2hhbmdlcz8uc2VsZWN0ZWQgfHwgY2hhbmdlcz8uZGlzYWJsZWQgfHwgY2hhbmdlcz8uZGF0ZSB8fCBjaGFuZ2VzPy5jdXJyZW50TW9udGgpIHtcbiAgICAgIHRoaXMuaXNUZXh0TXV0ZWQgPSAhdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRhdGU/Lm1vbnRoICE9PSArdGhpcy5jdXJyZW50TW9udGgpO1xuICAgIH1cbiAgICB0aGlzLmlzSG92ZXJlZCA9IHRoaXMuZGF0ZT8uZXF1YWxzKHRoaXMuaG92ZXJlZERhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBIYW5kbGUgbW91c2VvdmVyLiBFbWl0IHRoZSBob3ZlcmVkIGRhdGUgd2l0aCBudWxsLlxuICAgKlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignbW91c2VvdXQnKVxuICBvbk1vdXNlT3V0KCkge1xuICAgIHRoaXMuaG92ZXJlZC5lbWl0KHsgZGF0ZTogbnVsbCwgaXNTZWxlY3Rpbmc6IGZhbHNlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBIYW5kbGUgbW91c2VvdmVyLiBFbWl0IHRoZSBob3ZlcmVkIGRhdGUgd2l0aCBkYXRlLlxuICAgKlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignbW91c2VvdmVyJylcbiAgb25Nb3VzZU92ZXIoKSB7XG4gICAgdGhpcy5ob3ZlcmVkLmVtaXQoeyBkYXRlOiB0aGlzLmRhdGUsIGlzU2VsZWN0aW5nOiB0cnVlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBLZXlwcmVzcyBoYW5kbGVyXG4gICAqXG4gICAqIEBwYXJhbSBldnRcbiAgICogQHBhcmFtIGN1ck1vbnRoXG4gICAqIEBwYXJhbSBjdXJEYXlcbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmtleXVwJywgWyckZXZlbnQnXSlcbiAgb25LZXlVcChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGRheSA9IChldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnRleHRDb250ZW50O1xuICAgIGNvbnN0IG1hdGNoS2V5ID0gdGhpcy5pc0lFXG4gICAgICA/IE9iamVjdC52YWx1ZXMoS2V5KS5pbmNsdWRlcyhldmVudD8ua2V5Q29kZSlcbiAgICAgIDogSW5wdXREYXRlcGlja2VyRGF5VGVtcGxhdGVTaW5nbGVDb21wb25lbnQuaGFuZ2xlZEtleUNvZGVzLmluY2x1ZGVzKGV2ZW50Py5rZXkpO1xuXG4gICAgaWYgKE51bWJlcihkYXkpID09PSB0aGlzLmRhdGUuZGF5ICYmIE51bWJlcih0aGlzLmN1cnJlbnRNb250aCkgPT09IHRoaXMuZGF0ZS5tb250aCAmJiBtYXRjaEtleSkge1xuICAgICAgdGhpcy5ob3ZlcmVkLmVtaXQoeyBkYXRlOiB0aGlzLmRhdGUsIGlzU2VsZWN0aW5nOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiPHRpbWVcbiAgY2xhc3M9XCJjdXN0b20tZGF5IHRleHQtY2VudGVyIGJiLWlucHV0LWRhdGVwaWNrZXJfX3NpbmdsZS1kYXlcIlxuICBbbmdDbGFzc109XCJ7XG4gICAgJ2lzLXNlbGVjdGVkJzogc2VsZWN0ZWQsXG4gICAgJ3RleHQtbXV0ZWQnOiBpc1RleHRNdXRlZFxuICB9XCJcbiAgW2F0dHIuZGF0YS1yb2xlXT1cIidjYWxlbmRhci1kYXRlLWl0ZW0nXCJcbiAgW2RhdGVUaW1lXT1cImZvcm1hdChkYXRlKVwiXG4+XG4gIHt7IGRhdGU/LmRheSB9fVxuPC90aW1lPlxuIl19