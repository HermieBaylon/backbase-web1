import { Injectable } from '@angular/core';
import { NgbDateAdapter } from '@ng-bootstrap/ng-bootstrap';
import * as i0 from "@angular/core";
const isValidNgbDateStructProp = (struct, propName) => struct ? Object.prototype.hasOwnProperty.call(struct, propName) && typeof struct[propName] === 'number' : false;
export const isNgbDateStruct = (value) => isValidNgbDateStructProp(value, 'day') &&
    isValidNgbDateStructProp(value, 'month') &&
    isValidNgbDateStructProp(value, 'year');
export class NgbDateStringAdapter extends NgbDateAdapter {
    fromModel(dateString) {
        if (dateString) {
            const d = new Date(dateString);
            const year = d.getFullYear();
            if (year) {
                return {
                    year: year,
                    month: d.getMonth() + 1,
                    day: d.getDate(),
                };
            }
        }
        return null;
    }
    toModel(date) {
        if (!date) {
            return '';
        }
        else if (typeof date === 'string') {
            return date;
        }
        else if (isNgbDateStruct(date)) {
            return new Date(date.year, date.month - 1, date.day).toISOString();
        }
        return Object.prototype.toString.call(date);
    }
}
NgbDateStringAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateStringAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
NgbDateStringAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateStringAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateStringAdapter, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZGF0ZXBpY2tlci1hZGFwdGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvaW5wdXQtZGF0ZXBpY2tlci9pbnB1dC1kYXRlcGlja2VyLWFkYXB0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsY0FBYyxFQUFpQixNQUFNLDRCQUE0QixDQUFDOztBQUczRSxNQUFNLHdCQUF3QixHQUFHLENBQUMsTUFBVyxFQUFFLFFBQWdCLEVBQVcsRUFBRSxDQUMxRSxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLElBQUksT0FBTyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFFbEgsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLENBQUMsS0FBVSxFQUEwQixFQUFFLENBQ3BFLHdCQUF3QixDQUFDLEtBQUssRUFBRSxLQUFLLENBQUM7SUFDdEMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQztJQUN4Qyx3QkFBd0IsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFHMUMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGNBQXNCO0lBQzlELFNBQVMsQ0FBQyxVQUFrQjtRQUMxQixJQUFJLFVBQVUsRUFBRTtZQUNkLE1BQU0sQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUU3QixJQUFJLElBQUksRUFBRTtnQkFDUixPQUFPO29CQUNMLElBQUksRUFBRSxJQUFJO29CQUNWLEtBQUssRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQztvQkFDdkIsR0FBRyxFQUFFLENBQUMsQ0FBQyxPQUFPLEVBQUU7aUJBQ2pCLENBQUM7YUFDSDtTQUNGO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsT0FBTyxDQUFDLElBQStDO1FBQ3JELElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCxPQUFPLEVBQUUsQ0FBQztTQUNYO2FBQU0sSUFBSSxPQUFPLElBQUksS0FBSyxRQUFRLEVBQUU7WUFDbkMsT0FBTyxJQUFJLENBQUM7U0FDYjthQUFNLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDcEU7UUFFRCxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QyxDQUFDOztrSEE1QlUsb0JBQW9CO3NIQUFwQixvQkFBb0I7NEZBQXBCLG9CQUFvQjtrQkFEaEMsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nYkRhdGVBZGFwdGVyLCBOZ2JEYXRlU3RydWN0IH0gZnJvbSAnQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAnO1xuaW1wb3J0IHsgTmdEYXRlU3RydWN0TnVsbGFibGUgfSBmcm9tICcuL2lucHV0LWRhdGVwaWNrZXIubW9kZWwnO1xuXG5jb25zdCBpc1ZhbGlkTmdiRGF0ZVN0cnVjdFByb3AgPSAoc3RydWN0OiBhbnksIHByb3BOYW1lOiBzdHJpbmcpOiBib29sZWFuID0+XG4gIHN0cnVjdCA/IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzdHJ1Y3QsIHByb3BOYW1lKSAmJiB0eXBlb2Ygc3RydWN0W3Byb3BOYW1lXSA9PT0gJ251bWJlcicgOiBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGlzTmdiRGF0ZVN0cnVjdCA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgTmdiRGF0ZVN0cnVjdCA9PlxuICBpc1ZhbGlkTmdiRGF0ZVN0cnVjdFByb3AodmFsdWUsICdkYXknKSAmJlxuICBpc1ZhbGlkTmdiRGF0ZVN0cnVjdFByb3AodmFsdWUsICdtb250aCcpICYmXG4gIGlzVmFsaWROZ2JEYXRlU3RydWN0UHJvcCh2YWx1ZSwgJ3llYXInKTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5nYkRhdGVTdHJpbmdBZGFwdGVyIGV4dGVuZHMgTmdiRGF0ZUFkYXB0ZXI8c3RyaW5nPiB7XG4gIGZyb21Nb2RlbChkYXRlU3RyaW5nOiBzdHJpbmcpOiBOZ0RhdGVTdHJ1Y3ROdWxsYWJsZSB7XG4gICAgaWYgKGRhdGVTdHJpbmcpIHtcbiAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgICAgIGNvbnN0IHllYXIgPSBkLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgIGlmICh5ZWFyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeWVhcjogeWVhcixcbiAgICAgICAgICBtb250aDogZC5nZXRNb250aCgpICsgMSxcbiAgICAgICAgICBkYXk6IGQuZ2V0RGF0ZSgpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdG9Nb2RlbChkYXRlOiBOZ2JEYXRlU3RydWN0IHwgc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH0gZWxzZSBpZiAoaXNOZ2JEYXRlU3RydWN0KGRhdGUpKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS55ZWFyLCBkYXRlLm1vbnRoIC0gMSwgZGF0ZS5kYXkpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRlKTtcbiAgfVxufVxuIl19