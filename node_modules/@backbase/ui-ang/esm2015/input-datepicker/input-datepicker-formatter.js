import { Inject, Injectable, LOCALE_ID } from '@angular/core';
import { FormatWidth, getLocaleDateFormat } from '@angular/common';
import { NgbDateParserFormatter } from '@ng-bootstrap/ng-bootstrap';
import { isNgbDateStruct } from './input-datepicker-adapter';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
// TODO: get rid of non null assertions. They are added due to problem with NgbDateParserFormatter.
// It specifies result of parse function as NgbDateStruct, but allows to return null if value can not be parsed.
// They should have defined parse method with NgbDateStruct | null return, since now compilation
// fails due to strict null checks.
export class NgbDateLocaleParserFormatter extends NgbDateParserFormatter {
    constructor(locale, datePipe) {
        super();
        this.locale = locale;
        this.datePipe = datePipe;
    }
    get localeDateFormat() {
        return this._dateFormat || getLocaleDateFormat(this.locale, FormatWidth.Short);
    }
    set dateFormat(format) {
        this._dateFormat = format;
    }
    static getAdaptedYear(year, month, day, yearValue) {
        const date = new Date(year, month - 1, day);
        year = date.getFullYear();
        if (yearValue && yearValue.length < 3 && year < 1950) {
            year += 100;
        }
        return year;
    }
    static getIndexFromFormat(regex, formatArray) {
        const index = formatArray.findIndex((item) => !Boolean(item.replace(regex, '')));
        return index;
    }
    interpretDate(value) {
        const date = new Date(value);
        if (isNaN(date.getTime()))
            return;
        const year = date.getFullYear();
        const yearLength = this.getYearLength(value);
        if (yearLength < 3 && // prevent transformation of 1902 to 2002
            year < 1950 &&
            !value.includes(String(year)) &&
            new Date('01/01/00').getFullYear() === 1900) {
            date.setFullYear(year + 100);
        }
        return date;
    }
    parse(value) {
        if (!value) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return null;
        }
        const dateElementsRegex = /[^GyMLwWdE]/;
        const dateFormatDelimiterMatches = this.localeDateFormat.match(dateElementsRegex);
        const dateFormatDelimiter = dateFormatDelimiterMatches && dateFormatDelimiterMatches[0];
        const dateValueRegex = new RegExp('[\\d' + dateFormatDelimiter + ']+');
        // Try to parse manually the value in case if contains only numbers and the delimiter.
        // If no delimiter found or the value has other than number characters,
        // the the parsing will fallback to the angular date pipe
        if (dateFormatDelimiter && !Boolean(value.replace(dateValueRegex, ''))) {
            const formatParsedDate = this.getFormatParsedDate(value, this.localeDateFormat, dateFormatDelimiter);
            if (formatParsedDate) {
                // the formatter has all three date elements
                return formatParsedDate;
            }
        }
        return this.getAngularPipeFormatParseDate(value);
    }
    /**
     *
     * Parse date value with angular date pipe
     *
     * @param value The string date value
     *
     */
    getAngularPipeFormatParseDate(value) {
        let parsedValue = '';
        try {
            parsedValue = this.datePipe.transform(value, this.localeDateFormat, undefined, this.locale) || '';
        }
        catch (e) {
            // there is no error handling, because transform fails only with temporary and invalid values like '22/'
            //  during manual input to datepicker
        }
        const parsedDate = this.interpretDate(value);
        if (!parsedValue || !parsedDate) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return null;
        }
        return {
            year: parsedDate.getFullYear(),
            month: parsedDate.getMonth() + 1,
            day: parsedDate.getDate(),
        };
    }
    /**
     *
     * @description
     * Proprietary parse to be able to use date override in the input field.
     *
     * Parse the string date value if the date format only contains y, M, d with one single format delimiter.
     *
     * @param value The string date value
     * @param format The date format
     * @param delimiter The delimiter character between date elements (e.g. - or /)
     *
     */
    getFormatParsedDate(value, format, delimiter) {
        const dateValueArr = value.split(delimiter); // split date string value by the delimiter
        const dateFormatArr = format.split(delimiter);
        if (dateFormatArr.length === 3) {
            const dayFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/d{1,2}/, dateFormatArr);
            const monthFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/M{1,5}/, dateFormatArr);
            const yearFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/y{1,4}/, dateFormatArr);
            if (dayFormatIndex > -1 && monthFormatIndex > -1 && yearFormatIndex > -1) {
                const today = new Date();
                const year = dateValueArr[yearFormatIndex] ? Number(dateValueArr[yearFormatIndex]) : today.getFullYear();
                const month = dateValueArr[monthFormatIndex] ? Number(dateValueArr[monthFormatIndex]) : today.getMonth() + 1;
                const day = dateValueArr[dayFormatIndex] ? Number(dateValueArr[dayFormatIndex]) : today.getDate();
                return {
                    day,
                    month,
                    year: NgbDateLocaleParserFormatter.getAdaptedYear(year, month, day, dateValueArr[yearFormatIndex]),
                };
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return null;
    }
    getYearLength(value) {
        const separator = String(this.localeDateFormat.match(/[^\w\*]/));
        const dateArray = value.split(separator);
        const yearPosition = this.localeDateFormat.toLocaleLowerCase().split(separator);
        const yearIndex = yearPosition.findIndex((val) => val.includes('y'));
        return yearIndex >= 0 && yearIndex < dateArray.length ? dateArray[yearIndex].length : 0;
    }
    format(date, format = this.localeDateFormat) {
        let formattedDate = '';
        if (date && isNgbDateStruct(date)) {
            formattedDate =
                this.datePipe.transform(new Date(date.year, date.month - 1, date.day), format, undefined, this.locale) || '';
        }
        return formattedDate;
    }
}
NgbDateLocaleParserFormatter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateLocaleParserFormatter, deps: [{ token: LOCALE_ID }, { token: i1.DatePipe }], target: i0.ɵɵFactoryTarget.Injectable });
NgbDateLocaleParserFormatter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateLocaleParserFormatter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateLocaleParserFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i1.DatePipe }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZGF0ZXBpY2tlci1mb3JtYXR0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3VpLWFuZy9pbnB1dC1kYXRlcGlja2VyL2lucHV0LWRhdGVwaWNrZXItZm9ybWF0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RCxPQUFPLEVBQVksV0FBVyxFQUFFLG1CQUFtQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDN0UsT0FBTyxFQUFFLHNCQUFzQixFQUFpQixNQUFNLDRCQUE0QixDQUFDO0FBQ25GLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQzs7O0FBRTdELG1HQUFtRztBQUNuRyxnSEFBZ0g7QUFDaEgsZ0dBQWdHO0FBQ2hHLG1DQUFtQztBQUVuQyxNQUFNLE9BQU8sNEJBQTZCLFNBQVEsc0JBQXNCO0lBQ3RFLFlBQWdELE1BQWMsRUFBbUIsUUFBa0I7UUFDakcsS0FBSyxFQUFFLENBQUM7UUFEc0MsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUFtQixhQUFRLEdBQVIsUUFBUSxDQUFVO0lBRW5HLENBQUM7SUFJRCxJQUFJLGdCQUFnQjtRQUNsQixPQUFPLElBQUksQ0FBQyxXQUFXLElBQUksbUJBQW1CLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakYsQ0FBQztJQUVELElBQUksVUFBVSxDQUFDLE1BQTBCO1FBQ3ZDLElBQUksQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDO0lBQzVCLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLElBQVksRUFBRSxLQUFhLEVBQUUsR0FBVyxFQUFFLFNBQWlCO1FBQy9FLE1BQU0sSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFF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QVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRTdFLE9BQU8sU0FBUyxJQUFJLENBQUMsSUFBSSxTQUFTLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFGLENBQUM7SUFFRCxNQUFNLENBQUMsSUFBc0MsRUFBRSxNQUFNLEdBQUcsSUFBSSxDQUFDLGdCQUFnQjtRQUMzRSxJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUM7UUFDdkIsSUFBSSxJQUFJLElBQUksZUFBZSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2pDLGFBQWE7Z0JBQ1gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2hIO1FBRUQsT0FBTyxhQUFhLENBQUM7SUFDdkIsQ0FBQzs7MEhBcEtVLDRCQUE0QixrQkFDbkIsU0FBUzs4SEFEbEIsNEJBQTRCOzRGQUE1Qiw0QkFBNEI7a0JBRHhDLFVBQVU7OzBCQUVJLE1BQU07MkJBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgTE9DQUxFX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlUGlwZSwgRm9ybWF0V2lkdGgsIGdldExvY2FsZURhdGVGb3JtYXQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdiRGF0ZVBhcnNlckZvcm1hdHRlciwgTmdiRGF0ZVN0cnVjdCB9IGZyb20gJ0BuZy1ib290c3RyYXAvbmctYm9vdHN0cmFwJztcbmltcG9ydCB7IGlzTmdiRGF0ZVN0cnVjdCB9IGZyb20gJy4vaW5wdXQtZGF0ZXBpY2tlci1hZGFwdGVyJztcblxuLy8gVE9ETzogZ2V0IHJpZCBvZiBub24gbnVsbCBhc3NlcnRpb25zLiBUaGV5IGFyZSBhZGRlZCBkdWUgdG8gcHJvYmxlbSB3aXRoIE5nYkRhdGVQYXJzZXJGb3JtYXR0ZXIuXG4vLyBJdCBzcGVjaWZpZXMgcmVzdWx0IG9mIHBhcnNlIGZ1bmN0aW9uIGFzIE5nYkRhdGVTdHJ1Y3QsIGJ1dCBhbGxvd3MgdG8gcmV0dXJuIG51bGwgaWYgdmFsdWUgY2FuIG5vdCBiZSBwYXJzZWQuXG4vLyBUaGV5IHNob3VsZCBoYXZlIGRlZmluZWQgcGFyc2UgbWV0aG9kIHdpdGggTmdiRGF0ZVN0cnVjdCB8IG51bGwgcmV0dXJuLCBzaW5jZSBub3cgY29tcGlsYXRpb25cbi8vIGZhaWxzIGR1ZSB0byBzdHJpY3QgbnVsbCBjaGVja3MuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmdiRGF0ZUxvY2FsZVBhcnNlckZvcm1hdHRlciBleHRlbmRzIE5nYkRhdGVQYXJzZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KExPQ0FMRV9JRCkgcHJpdmF0ZSByZWFkb25seSBsb2NhbGU6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBkYXRlUGlwZTogRGF0ZVBpcGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGF0ZUZvcm1hdDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIGdldCBsb2NhbGVEYXRlRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRlRm9ybWF0IHx8IGdldExvY2FsZURhdGVGb3JtYXQodGhpcy5sb2NhbGUsIEZvcm1hdFdpZHRoLlNob3J0KTtcbiAgfVxuXG4gIHNldCBkYXRlRm9ybWF0KGZvcm1hdDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fZGF0ZUZvcm1hdCA9IGZvcm1hdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXRBZGFwdGVkWWVhcih5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCB5ZWFyVmFsdWU6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5KTtcbiAgICB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXG4gICAgaWYgKHllYXJWYWx1ZSAmJiB5ZWFyVmFsdWUubGVuZ3RoIDwgMyAmJiB5ZWFyIDwgMTk1MCkge1xuICAgICAgeWVhciArPSAxMDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHllYXI7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5kZXhGcm9tRm9ybWF0KHJlZ2V4OiBSZWdFeHAsIGZvcm1hdEFycmF5OiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IGluZGV4ID0gZm9ybWF0QXJyYXkuZmluZEluZGV4KChpdGVtOiBzdHJpbmcpID0+ICFCb29sZWFuKGl0ZW0ucmVwbGFjZShyZWdleCwgJycpKSk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBpbnRlcnByZXREYXRlKHZhbHVlOiBzdHJpbmcpOiBEYXRlIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodmFsdWUpO1xuICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHJldHVybjtcblxuICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgeWVhckxlbmd0aCA9IHRoaXMuZ2V0WWVhckxlbmd0aCh2YWx1ZSk7XG5cbiAgICBpZiAoXG4gICAgICB5ZWFyTGVuZ3RoIDwgMyAmJiAvLyBwcmV2ZW50IHRyYW5zZm9ybWF0aW9uIG9mIDE5MDIgdG8gMjAwMlxuICAgICAgeWVhciA8IDE5NTAgJiZcbiAgICAgICF2YWx1ZS5pbmNsdWRlcyhTdHJpbmcoeWVhcikpICYmXG4gICAgICBuZXcgRGF0ZSgnMDEvMDEvMDAnKS5nZXRGdWxsWWVhcigpID09PSAxOTAwXG4gICAgKSB7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIgKyAxMDApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgcGFyc2UodmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IE5nYkRhdGVTdHJ1Y3Qge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICByZXR1cm4gbnVsbCE7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0ZUVsZW1lbnRzUmVnZXggPSAvW15HeU1Md1dkRV0vO1xuICAgIGNvbnN0IGRhdGVGb3JtYXREZWxpbWl0ZXJNYXRjaGVzID0gdGhpcy5sb2NhbGVEYXRlRm9ybWF0Lm1hdGNoKGRhdGVFbGVtZW50c1JlZ2V4KTtcbiAgICBjb25zdCBkYXRlRm9ybWF0RGVsaW1pdGVyID0gZGF0ZUZvcm1hdERlbGltaXRlck1hdGNoZXMgJiYgZGF0ZUZvcm1hdERlbGltaXRlck1hdGNoZXNbMF07XG4gICAgY29uc3QgZGF0ZVZhbHVlUmVnZXggPSBuZXcgUmVnRXhwKCdbXFxcXGQnICsgZGF0ZUZvcm1hdERlbGltaXRlciArICddKycpO1xuXG4gICAgLy8gVHJ5IHRvIHBhcnNlIG1hbnVhbGx5IHRoZSB2YWx1ZSBpbiBjYXNlIGlmIGNvbnRhaW5zIG9ubHkgbnVtYmVycyBhbmQgdGhlIGRlbGltaXRlci5cbiAgICAvLyBJZiBubyBkZWxpbWl0ZXIgZm91bmQgb3IgdGhlIHZhbHVlIGhhcyBvdGhlciB0aGFuIG51bWJlciBjaGFyYWN0ZXJzLFxuICAgIC8vIHRoZSB0aGUgcGFyc2luZyB3aWxsIGZhbGxiYWNrIHRvIHRoZSBhbmd1bGFyIGRhdGUgcGlwZVxuICAgIGlmIChkYXRlRm9ybWF0RGVsaW1pdGVyICYmICFCb29sZWFuKHZhbHVlLnJlcGxhY2UoZGF0ZVZhbHVlUmVnZXgsICcnKSkpIHtcbiAgICAgIGNvbnN0IGZvcm1hdFBhcnNlZERhdGUgPSB0aGlzLmdldEZvcm1hdFBhcnNlZERhdGUodmFsdWUsIHRoaXMubG9jYWxlRGF0ZUZvcm1hdCwgZGF0ZUZvcm1hdERlbGltaXRlcik7XG5cbiAgICAgIGlmIChmb3JtYXRQYXJzZWREYXRlKSB7XG4gICAgICAgIC8vIHRoZSBmb3JtYXR0ZXIgaGFzIGFsbCB0aHJlZSBkYXRlIGVsZW1lbnRzXG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdFBhcnNlZERhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0QW5ndWxhclBpcGVGb3JtYXRQYXJzZURhdGUodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIFBhcnNlIGRhdGUgdmFsdWUgd2l0aCBhbmd1bGFyIGRhdGUgcGlwZVxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyBkYXRlIHZhbHVlXG4gICAqXG4gICAqL1xuICBnZXRBbmd1bGFyUGlwZUZvcm1hdFBhcnNlRGF0ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgbGV0IHBhcnNlZFZhbHVlID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFZhbHVlID0gdGhpcy5kYXRlUGlwZS50cmFuc2Zvcm0odmFsdWUsIHRoaXMubG9jYWxlRGF0ZUZvcm1hdCwgdW5kZWZpbmVkLCB0aGlzLmxvY2FsZSkgfHwgJyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gdGhlcmUgaXMgbm8gZXJyb3IgaGFuZGxpbmcsIGJlY2F1c2UgdHJhbnNmb3JtIGZhaWxzIG9ubHkgd2l0aCB0ZW1wb3JhcnkgYW5kIGludmFsaWQgdmFsdWVzIGxpa2UgJzIyLydcbiAgICAgIC8vICBkdXJpbmcgbWFudWFsIGlucHV0IHRvIGRhdGVwaWNrZXJcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IHRoaXMuaW50ZXJwcmV0RGF0ZSh2YWx1ZSk7XG5cbiAgICBpZiAoIXBhcnNlZFZhbHVlIHx8ICFwYXJzZWREYXRlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgcmV0dXJuIG51bGwhO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB5ZWFyOiBwYXJzZWREYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICBtb250aDogcGFyc2VkRGF0ZS5nZXRNb250aCgpICsgMSxcbiAgICAgIGRheTogcGFyc2VkRGF0ZS5nZXREYXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHJvcHJpZXRhcnkgcGFyc2UgdG8gYmUgYWJsZSB0byB1c2UgZGF0ZSBvdmVycmlkZSBpbiB0aGUgaW5wdXQgZmllbGQuXG4gICAqXG4gICAqIFBhcnNlIHRoZSBzdHJpbmcgZGF0ZSB2YWx1ZSBpZiB0aGUgZGF0ZSBmb3JtYXQgb25seSBjb250YWlucyB5LCBNLCBkIHdpdGggb25lIHNpbmdsZSBmb3JtYXQgZGVsaW1pdGVyLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyBkYXRlIHZhbHVlXG4gICAqIEBwYXJhbSBmb3JtYXQgVGhlIGRhdGUgZm9ybWF0XG4gICAqIEBwYXJhbSBkZWxpbWl0ZXIgVGhlIGRlbGltaXRlciBjaGFyYWN0ZXIgYmV0d2VlbiBkYXRlIGVsZW1lbnRzIChlLmcuIC0gb3IgLylcbiAgICpcbiAgICovXG4gIGdldEZvcm1hdFBhcnNlZERhdGUodmFsdWU6IHN0cmluZywgZm9ybWF0OiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nKTogTmdiRGF0ZVN0cnVjdCB7XG4gICAgY29uc3QgZGF0ZVZhbHVlQXJyID0gdmFsdWUuc3BsaXQoZGVsaW1pdGVyKTsgLy8gc3BsaXQgZGF0ZSBzdHJpbmcgdmFsdWUgYnkgdGhlIGRlbGltaXRlclxuICAgIGNvbnN0IGRhdGVGb3JtYXRBcnIgPSBmb3JtYXQuc3BsaXQoZGVsaW1pdGVyKTtcblxuICAgIGlmIChkYXRlRm9ybWF0QXJyLmxlbmd0aCA9PT0gMykge1xuICAgICAgY29uc3QgZGF5Rm9ybWF0SW5kZXggPSBOZ2JEYXRlTG9jYWxlUGFyc2VyRm9ybWF0dGVyLmdldEluZGV4RnJvbUZvcm1hdCgvZHsxLDJ9LywgZGF0ZUZvcm1hdEFycik7XG4gICAgICBjb25zdCBtb250aEZvcm1hdEluZGV4ID0gTmdiRGF0ZUxvY2FsZVBhcnNlckZvcm1hdHRlci5nZXRJbmRleEZyb21Gb3JtYXQoL017MSw1fS8sIGRhdGVGb3JtYXRBcnIpO1xuICAgICAgY29uc3QgeWVhckZvcm1hdEluZGV4ID0gTmdiRGF0ZUxvY2FsZVBhcnNlckZvcm1hdHRlci5nZXRJbmRleEZyb21Gb3JtYXQoL3l7MSw0fS8sIGRhdGVGb3JtYXRBcnIpO1xuXG4gICAgICBpZiAoZGF5Rm9ybWF0SW5kZXggPiAtMSAmJiBtb250aEZvcm1hdEluZGV4ID4gLTEgJiYgeWVhckZvcm1hdEluZGV4ID4gLTEpIHtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHllYXIgPSBkYXRlVmFsdWVBcnJbeWVhckZvcm1hdEluZGV4XSA/IE51bWJlcihkYXRlVmFsdWVBcnJbeWVhckZvcm1hdEluZGV4XSkgOiB0b2RheS5nZXRGdWxsWWVhcigpO1xuICAgICAgICBjb25zdCBtb250aCA9IGRhdGVWYWx1ZUFyclttb250aEZvcm1hdEluZGV4XSA/IE51bWJlcihkYXRlVmFsdWVBcnJbbW9udGhGb3JtYXRJbmRleF0pIDogdG9kYXkuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgIGNvbnN0IGRheSA9IGRhdGVWYWx1ZUFycltkYXlGb3JtYXRJbmRleF0gPyBOdW1iZXIoZGF0ZVZhbHVlQXJyW2RheUZvcm1hdEluZGV4XSkgOiB0b2RheS5nZXREYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXksXG4gICAgICAgICAgbW9udGgsXG4gICAgICAgICAgeWVhcjogTmdiRGF0ZUxvY2FsZVBhcnNlckZvcm1hdHRlci5nZXRBZGFwdGVkWWVhcih5ZWFyLCBtb250aCwgZGF5LCBkYXRlVmFsdWVBcnJbeWVhckZvcm1hdEluZGV4XSksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICByZXR1cm4gbnVsbCE7XG4gIH1cblxuICBnZXRZZWFyTGVuZ3RoKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IFN0cmluZyh0aGlzLmxvY2FsZURhdGVGb3JtYXQubWF0Y2goL1teXFx3XFwqXS8pKTtcbiAgICBjb25zdCBkYXRlQXJyYXkgPSB2YWx1ZS5zcGxpdChzZXBhcmF0b3IpO1xuICAgIGNvbnN0IHllYXJQb3NpdGlvbiA9IHRoaXMubG9jYWxlRGF0ZUZvcm1hdC50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgY29uc3QgeWVhckluZGV4ID0geWVhclBvc2l0aW9uLmZpbmRJbmRleCgodmFsOiBzdHJpbmcpID0+IHZhbC5pbmNsdWRlcygneScpKTtcblxuICAgIHJldHVybiB5ZWFySW5kZXggPj0gMCAmJiB5ZWFySW5kZXggPCBkYXRlQXJyYXkubGVuZ3RoID8gZGF0ZUFycmF5W3llYXJJbmRleF0ubGVuZ3RoIDogMDtcbiAgfVxuXG4gIGZvcm1hdChkYXRlOiBOZ2JEYXRlU3RydWN0IHwgdW5kZWZpbmVkIHwgbnVsbCwgZm9ybWF0ID0gdGhpcy5sb2NhbGVEYXRlRm9ybWF0KTogc3RyaW5nIHtcbiAgICBsZXQgZm9ybWF0dGVkRGF0ZSA9ICcnO1xuICAgIGlmIChkYXRlICYmIGlzTmdiRGF0ZVN0cnVjdChkYXRlKSkge1xuICAgICAgZm9ybWF0dGVkRGF0ZSA9XG4gICAgICAgIHRoaXMuZGF0ZVBpcGUudHJhbnNmb3JtKG5ldyBEYXRlKGRhdGUueWVhciwgZGF0ZS5tb250aCAtIDEsIGRhdGUuZGF5KSwgZm9ybWF0LCB1bmRlZmluZWQsIHRoaXMubG9jYWxlKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkRGF0ZTtcbiAgfVxufVxuIl19