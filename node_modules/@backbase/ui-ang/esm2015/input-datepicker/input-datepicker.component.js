import { ChangeDetectionStrategy, Component, EventEmitter, forwardRef, HostBinding, Input, Output, ViewChild, } from '@angular/core';
import { DatePipe } from '@angular/common';
import { FormControl, NG_VALIDATORS, NG_VALUE_ACCESSOR, } from '@angular/forms';
import { NgbDateAdapter, NgbDateParserFormatter, NgbDatepickerI18n, } from '@ng-bootstrap/ng-bootstrap';
import { InputBaseComponent } from '@backbase/ui-ang/base-classes';
import { NgbDatepickerI18nDefault } from './input-datepicker-i18n';
import { NgbDateStringAdapter } from './input-datepicker-adapter';
import { NgbDateLocaleParserFormatter } from './input-datepicker-formatter';
import { BehaviorSubject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "./input-datepicker-formatter";
import * as i2 from "@backbase/foundation-ang/future";
import * as i3 from "@ng-bootstrap/ng-bootstrap";
import * as i4 from "@backbase/ui-ang/services";
import * as i5 from "@backbase/ui-ang/icon";
import * as i6 from "./input-datepicker-day-template-single.component";
import * as i7 from "./input-datepicker-day-template-range.component";
import * as i8 from "@angular/common";
import * as i9 from "@angular/forms";
import * as i10 from "@backbase/ui-ang/button";
// Oleksii depricate
/* eslint-disable */
export var Key;
(function (Key) {
    Key[Key["Tab"] = 9] = "Tab";
    Key[Key["Enter"] = 13] = "Enter";
    Key[Key["Escape"] = 27] = "Escape";
    Key[Key["Space"] = 32] = "Space";
    Key[Key["PageUp"] = 33] = "PageUp";
    Key[Key["PageDown"] = 34] = "PageDown";
    Key[Key["End"] = 35] = "End";
    Key[Key["Home"] = 36] = "Home";
    Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowRight"] = 39] = "ArrowRight";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key || (Key = {}));
export const isDateRangeModelType = (value) => Object.prototype.hasOwnProperty.call(value || {}, 'from') && Object.prototype.hasOwnProperty.call(value || {}, 'to');
/**
 * @name InputDatepickerComponent
 *
 * @description
 * Component that displays a datepicker
 *
 * ### Custom internalization
 * It is possible to provide a custom internalisation. To do this, a `DATEPICKER_I18` token from `@backbase/ui-ang/input-datepicker` should be provided on the module level.
 * The token should implement the [NgbDatepickerI18n](https://ng-bootstrap.github.io/#/components/datepicker/api#NgbDatepickerI18n) interface.
 *
 * ### Setting and reading the  date
 * *Note* Datepicker uses the date *with the timezone* inside its model. And hence to make it work properly in all cases there are some recommendations for setting and reading the date to and from the datepicker.
 * #### Setting the date
 * When setting the date to the datepicker the date must be provided in the format that assumes zero hours and zero minutes in the local timezone. Here are some examples of what the date setting should looks like:
 * ```
   this.minDate = new Date(2021,11,15, 0, 0).toISOString();
   ```
 *
 * or
 * ```
   this.minDate = new Date('2021-12-15T00:00').toISOString();
   ```
 *
 * Note that
 * ```
   new Date('2021-12-15').toISOString();
   ```
 *
 * generates a date in GMT0 format and that is not correct for the datepicker input date.
 * #### Reading the date
 * When a date is selected via UI (the datepicker's popup window or browser's input field) its display date is transformed to the ISO string date with the assumption that it’s zero hours and zero minutes in the current time zone. Which leads to the different ISO string values for different time zones for the same date. F.e. "Dec 15 2021" is going to be transformed to "2021-12-14T23:00:00.000Z" for the "GMT+0100 (Central European Standard Time)" time zone and to "2021-12-15T03:00:00.000Z" for "GMT-0300 (West Greenland Standard Time)" time zone. As you can see the _day_ value is different in ISO string based on the timezone. It’s going to be either 14 or 15 in the example above.
 *
 * The recommendation here is to convert the ISO string, that the datepicker returns, into the Date object and read it's day value. Here is an example:
 * ```
  private formatDate(stringDate: string): string {
    const date = new Date(stringDate);
    if (stringDate && !isNaN(date.valueOf())) {
      return `${date.getFullYear()}-${this.appendLeadingZeroes(date.getMonth() + 1)}-${this.appendLeadingZeroes(date.getDate())}`;
    }
    return '';
  }

  private appendLeadingZeroes(value: number) {
    return value > 9 ? value : `0${value}`;
  }
   ```
 *
 * @a11y Current component provide option to pass needed accessibility
 * attributes. You need to take care of properties that are required in your case :
 *  - role
 *  - aria-activedescendant
 *  - aria-describedby
 *  - aria-expanded
 *  - aria-invalid
 *  - aria-label
 *  - aria-labelledby
 *  - aria-owns
 *
 * `ariaLabel` is discernible text for datepicker
 */
export class InputDatepickerComponent extends InputBaseComponent {
    constructor(formatterHelper, el, cd, deprecationsService, adapter, renderer2, domAttrService) {
        super(cd, deprecationsService);
        this.formatterHelper = formatterHelper;
        this.el = el;
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        this.adapter = adapter;
        this.renderer2 = renderer2;
        this.domAttrService = domAttrService;
        /**
         * Event to trigger on date hover
         */
        this.focusedDate = new EventEmitter();
        /**
         * Indicates if the datepicker should select a date range with single input (from - to).
         * Defaults to false
         */
        this.rangeSelection = false;
        /**
         * Indicates if the datepicker should a date range with split input. One for the from date and one for the to date.
         * Defaults to false
         */
        this.rangeSelectionSplit = false;
        /**
         * Indicates if the datepicker is opened when clicking input.
         * Defaults to false
         */
        this.clickOpen = false;
        /**
         * Indicates if the datepicker is opened when focusing input.
         * Defaults to false
         */
        this.focusOpen = false;
        this._placement = 'bottom-left';
        /**
         * Accessible description for datepicker date selection popup.
         */
        this.datepickerDescribedby = 'defaultDatepickerDescribedbyLabel';
        /**
         * Accessible label for Datepicker button.
         */
        this.ariaLabelForButton = 'Toggle Date popup';
        /**
         * Icon that is dispayed in the button.
         * Defaults to calendar
         */
        this.icon = 'calendar-today';
        /**
         * The size of the icon to be displayed.
         * Defaults to md
         */
        this.iconSize = 'md';
        /**
         * Color of the button.
         * Defaults to link
         */
        this.btnColor = 'link';
        /**
         * Aria label for the datepicker
         */
        this.ariaLabel = 'Datepicker';
        /**
         * Navigation pattern through dates.
         * Default to arrows
         */
        this.navigation = 'arrows';
        /**
         * Indicates how many month will be shown in the picker
         */
        this.displayMonths = 1;
        this.hoveredDate$ = new BehaviorSubject({ date: null });
        this.pickerHoveredDayDateTo = null;
        this.fromDate$ = new BehaviorSubject(null);
        this.toDate$ = new BehaviorSubject(null);
        this.inputDateRangeSeparator = '-';
        this.cssClass = 'bb-input-datepicker-ui';
        /**
         * @description
         * Passing template date to the range template to identify when it is used in the "to" date
         * (the second HTML date input of the split datepicker).
         * Check https://ng-bootstrap.github.io/#/components/datepicker/api "dayTemplateData" for details
         */
        this.rangeTemplateData = () => ({
            isTo: true,
        });
        /***************************************8
         *
         *  CONTROLVALUEACCESSOR OVERRIDES
         *
         **************************************/
        /**
         * Implements custom validation for the control
         *
         * @param control
         */
        this.validate = (control) => {
            const value = control.value;
            if (!this.parentFormControl) {
                this.parentFormControl = control;
            }
            if (!value) {
                /* eslint-disable-next-line  no-null/no-null */
                return null;
            }
            if (this.rangeSelection || this.rangeSelectionSplit) {
                return this.validateDateRange(value);
            }
            return this.validateSingleDate(value);
        };
        this.dateInput = new FormControl(null);
        this.dateInputTo = new FormControl(null);
    }
    get placement() {
        return document.documentElement.clientWidth > 320 ? this._placement : 'bottom';
    }
    /**
     * Placement of a popup window
     */
    set placement(value) {
        if (value) {
            this._placement = value;
        }
    }
    /**
     * Min date for the navigation. If not provided, 'year' select box will display 10 years
     * before current month
     */
    set minDate(date) {
        this._minDate = typeof date === 'string' ? this.adapter.fromModel(date) : date;
    }
    /**
     * Max date for the navigation. If not provided, 'year' select box will display 10 years
     * after current month
     */
    set maxDate(date) {
        this._maxDate = typeof date === 'string' ? this.adapter.fromModel(date) : date;
    }
    get placeholder() {
        if (typeof this._placeholder === 'undefined') {
            const pattern = this.dateFormat.toUpperCase();
            return this.rangeSelection ? `${pattern} ${this.inputDateRangeSeparator} ${pattern}` : pattern;
        }
        return this._placeholder;
    }
    /**
     * The placeholder for the datepicker input. Default is Locale Date Format;
     */
    set placeholder(value) {
        this._placeholder = typeof value !== 'undefined' ? String(value) : undefined;
    }
    /**
     * Override date format (optional). Supported formats are `yyyy/MM/dd`, `MM/dd/yyyy`, `MMMM dd, yyyy`.
     * Note, other formats might work inconsistent in different browsers.
     */
    set overrideDateFormat(value) {
        this._overrideDateFormat = value;
        this.formatterHelper.dateFormat = value;
    }
    get overrideDateFormat() {
        return this._overrideDateFormat;
    }
    /**
     * The custom or locale date format that is used to display dates and placeholders
     */
    get dateFormat() {
        return this.formatterHelper.localeDateFormat;
    }
    ngOnChanges(changes) {
        const { disabled } = changes;
        if (disabled && disabled.currentValue !== disabled.previousValue) {
            if (this.disabled) {
                this.dateInput.disable();
            }
            else {
                this.dateInput.enable();
            }
        }
    }
    // todo: do we need this?
    ngAfterViewInit() {
        const datepickerInput = this.rangeSelection ? this.datePickerRangeInput : this.datePickerInput;
        this.domAttrService.moveAriaAttributes(this.el.nativeElement, datepickerInput === null || datepickerInput === void 0 ? void 0 : datepickerInput.nativeElement, this.renderer2);
        setTimeout(() => {
            // internal validators are not used
            this.dateInput.setValidators([]);
            this.dateInput.updateValueAndValidity();
            this.cd.markForCheck();
        });
    }
    dateEqual(xDate, yDate) {
        const a = new Date(xDate.year, xDate.month - 1, xDate.day).getTime();
        const b = new Date(yDate.year, yDate.month - 1, yDate.day).getTime();
        return a === b ? 0 : a > b ? 1 : -1;
    }
    /****************************************
     *
     *        EVENT HANDLERS
     *
     ***************************************/
    /**
     * @description
     * Input change handler for single date
     *
     * @param element
     */
    onInputChange(element) {
        // Checking for "browser bug", for example,
        // In IE `new Date()` for short date format YY gives 19YY, for modern browser in looks like 20YY
        // for this reason we're adding 100 years to browser understand that it is 21st century
        const dateInputToUpdate = element.name === 'date' ? this.dateInput : this.dateInputTo;
        const { value } = element;
        const browserDate = new Date(value);
        const parsedDate = this.formatterHelper.interpretDate(value);
        if (parsedDate && parsedDate.getTime() !== browserDate.getTime()) {
            dateInputToUpdate.setValue(parsedDate);
        }
    }
    /**
     * Update datepicker value on input value change for same input date range selection
     *
     * @param value
     */
    onInputChangeRange(element) {
        const { value } = element;
        const [dateFrom, dateTo] = value.split(this.inputDateRangeSeparator).slice(0, 2);
        this.fromDate$.next(this.formatterHelper.parse(dateFrom === null || dateFrom === void 0 ? void 0 : dateFrom.trim()));
        this.toDate$.next(this.formatterHelper.parse(dateTo === null || dateTo === void 0 ? void 0 : dateTo.trim()));
        if (this.fromDate$.getValue() || this.toDate$.getValue()) {
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        }
        else {
            this.onChange(value);
        }
    }
    /**
     * Update datepicker value on input value change for split input date range selection, from date
     *
     * @param value
     */
    onInputChangeSplitRange(element) {
        const { value } = element;
        this.fromDate$.next(this.formatterHelper.parse(value && value.trim()));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
    }
    /**
     * Update datepicker value on input value change for split input date range selection, to date
     *
     * @param value
     */
    onInputChangeSplitRangeTo(element) {
        const { value } = element;
        this.toDate$.next(this.formatterHelper.parse(value && value.trim()));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
    }
    /**
     * Event handler for the native input
     */
    onInputFocus(open) {
        super.onFocus();
        if (open && this.datePicker) {
            this.bindDocumentEvents();
            this.datePicker.open();
            if (this.rangeSelection || this.rangeSelectionSplit) {
                this.datePicker.startDate = this.toDate$.getValue();
            }
        }
    }
    /**
     * Event handler for the native input
     */
    onInputFocusTo(open) {
        super.onFocus();
        if (open && this.datePickerTo) {
            this.datePickerTo.open();
        }
    }
    /**
     * Event handler for the picker toggle button to
     */
    onPickerTogglerClick(event) {
        if (!this.disabled && this.datePicker) {
            this.bindDocumentEvents();
            this.setStartDateOnPicker(this.datePicker);
            this.datePicker.toggle();
        }
    }
    /**
     * Event handler for the picker toggle button to (split range selection)
     */
    onPickerTogglerClickTo(event) {
        if (!this.disabled && this.datePickerTo) {
            this.bindDocumentEvents();
            this.setStartDateOnPicker(this.datePickerTo);
            this.datePickerTo.toggle();
        }
    }
    /**
     *
     * Set disable state for the host control
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.dateInput.disable();
        }
        else {
            this.dateInput.enable();
        }
        super.setDisabledState(isDisabled);
    }
    /**
     * Event handler blur on internal inputs and buttons
     *
     * @param $event
     */
    onControlBlur($event) {
        if (!$event.relatedTarget || !this.el.nativeElement.contains($event.relatedTarget)) {
            this.onBlur($event);
        }
        if (this.rangeSelection) {
            if (!this.toDate$.getValue() || !this.fromDate$.getValue()) {
                this.setDatesTheSame();
            }
            else {
                this.setRangeInput();
            }
        }
    }
    /**
     * Event handler for blur on the host control
     *
     * @param $event
     */
    onBlur($event) {
        this.blur.emit($event);
        this.onTouched();
    }
    /**
     * @description
     *
     * Event handler for closing `from` or single date picker
     *
     */
    onClosed() {
        const hoveredDateClosedValue = this.hoveredDate$.getValue();
        const hoveredDate = hoveredDateClosedValue === null || hoveredDateClosedValue === void 0 ? void 0 : hoveredDateClosedValue.date;
        if (hoveredDate) {
            this.setSelectedDate({ date: hoveredDate, isSelecting: false });
        }
        if (this.rangeSelection && this.datePickerButton) {
            this.datePickerButton.nativeElement.focus();
        }
        else if (this.rangeSelectionSplit && this.datePickerTo && this.datePickerInputTo) {
            this.datePickerInputTo.nativeElement.focus();
        }
    }
    /**
     * Event handler for closing picker for `to` date
     */
    onClosedTo() {
        if (this.datePickerButtonTo !== undefined && this.datePicker && !this.datePicker.isOpen()) {
            this.datePickerButtonTo.nativeElement.focus();
        }
    }
    /**
     * Event handler for date setting from picker for `to` date when split input range selection
     *
     * @param date
     */
    onRangeDateSelectSplitTo(date) {
        this.toDate$.next(this.copyDateElement(date));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        this.onTouched();
    }
    /**
     * Event handler for date setting from picker for `from` date when split input range selection
     *
     * @param date
     */
    onRangeDateSelectSplit(date) {
        this.fromDate$.next(this.copyDateElement(date));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        this.onTouched();
    }
    /**
     *  Event handler for date setting from picker when single input range selection
     *
     * @param date
     */
    onRangeDateSelect(date) {
        if (!this.fromDate$.getValue() && !this.toDate$.getValue()) {
            this.fromDate$.next(this.copyDateElement(date));
        }
        else if (this.fromDate$.getValue() &&
            !this.toDate$.getValue() &&
            date &&
            (date.after(this.fromDate$.getValue()) || date.equals(this.fromDate$.getValue()))) {
            this.toDate$.next(this.copyDateElement(date));
            setTimeout(() => this.closeDatePicker(), 0);
        }
        else {
            /* eslint-disable-next-line no-null/no-null */
            this.toDate$.next(null);
            this.fromDate$.next(this.copyDateElement(date));
        }
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        this.setRangeInput();
    }
    /**
     *
     * Handling day-hover from day-template on range selection.
     *
     * @param event
     */
    onDayHover(event) {
        if (event.isTo) {
            this.pickerHoveredDayDateTo = event.date;
        }
        else {
            this.setSelectedDate({ date: event.date, isSelecting: event.isSelecting });
        }
    }
    /**
     *
     * Implements the value update for the control
     *
     * @param model
     */
    /* eslint-disable-next-line complexity */
    writeValue(model) {
        if (!this.rangeSelection && !this.rangeSelectionSplit) {
            this.dateInput.setValue(typeof model === 'string' ? model : null);
        }
        else {
            if (isDateRangeModelType(model)) {
                if (model.from && this.validateSingleDate(model.from) === null) {
                    this.fromDate$.next(this.adapter.fromModel(model.from));
                }
                else {
                    this.fromDate$.next(model.from);
                }
                if (model.to && this.validateSingleDate(model.to) === null) {
                    this.toDate$.next(this.adapter.fromModel(model.to));
                }
                else {
                    this.toDate$.next(model.to);
                }
            }
            else {
                this.fromDate$.next(null);
                this.toDate$.next(null);
            }
            if (this.rangeSelection) {
                this.setRangeInput();
            }
            else if (this.rangeSelectionSplit) {
                this.dateInput.setValue(this.fromDate$.getValue() ? this.adapter.toModel(this.fromDate$.getValue()) : null);
                this.dateInputTo.setValue(this.toDate$.getValue() ? this.adapter.toModel(this.toDate$.getValue()) : null);
            }
        }
    }
    /*********************************
     *
     *        PRIVATE UTILS
     *
     **********************************/
    setSelectedDate(date) {
        this.hoveredDate$.next(date);
        this.focusedDate.emit(date);
    }
    setDatesTheSame() {
        const fromDate = this.fromDate$.getValue();
        if (fromDate) {
            this.toDate$.next(fromDate);
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
            this.setRangeInput();
        }
    }
    closeDatePicker() {
        var _a;
        if (this.datePicker) {
            this.datePicker.close();
            if (this.rangeSelection) {
                (_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.updateValueAndValidity();
            }
            this.onBlur();
        }
        if (this.datePickerTo) {
            this.datePickerTo.close();
            this.onBlur();
        }
        // Unbind the global document events once the date picker is closed
        if (this.unListenDocumentClick) {
            this.unListenDocumentClick();
        }
        if (this.unListenDocumentEsc) {
            this.unListenDocumentEsc();
        }
    }
    isValidRange(from, to) {
        if (new Date(from).getTime() > new Date(to).getTime()) {
            return { invalidDateFormat: true };
        }
        return null;
    }
    validateSingleDate(value) {
        const date = typeof value === 'string' ? value : value.toISOString();
        // check if value is in ISO format
        // this means that it has passed parsing and that it is in date format for current locale
        // This check is for IE11
        const ISODateRegExp = /^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)$/g;
        return ISODateRegExp.test(date) ? null : { invalidDateFormat: true };
    }
    /**
     * Document Event handler
     */
    handleDocumentEvent(event) {
        if (event.target && (!this.el.nativeElement.contains(event.target) || event.type === 'keyup')) {
            this.closeDatePicker();
        }
    }
    /**
     * Binds event on the global document when the datepicker is not opened
     */
    bindDocumentEvents() {
        if (this.datePicker && !this.datePicker.isOpen()) {
            this.unListenDocumentClick = this.renderer2.listen('document', 'click', this.handleDocumentEvent.bind(this));
            this.unListenDocumentEsc = this.renderer2.listen('document', 'keyup.escape', this.handleDocumentEvent.bind(this));
        }
    }
    /* eslint-disable-next-line complexity */
    validateDateRange(value) {
        let validateTo = null;
        let validateFrom = null;
        let validateRange = null;
        if (!isDateRangeModelType(value)) {
            return { invalidDateFormat: true };
        }
        if (!value.from && !value.to && !this.isRequired()) {
            return null;
        }
        if ((!value.to && value.from) || (value.to && !value.from) || (!value.from && !value.to && this.isRequired())) {
            return { required: true };
        }
        if (value.from) {
            validateFrom = this.validateSingleDate(value.from);
        }
        if (value.to) {
            validateTo = this.validateSingleDate(value.to);
        }
        if (!validateFrom && !validateTo && value.from && value.to) {
            validateRange = this.isValidRange(value.from, value.to);
        }
        return validateTo || validateFrom || validateRange;
    }
    setRangeInput() {
        var _a;
        if (this.fromDate$.getValue() || this.toDate$.getValue()) {
            const formattedFrom = this.formatterHelper.format(this.fromDate$.getValue());
            const formattedTo = this.formatterHelper.format(this.toDate$.getValue());
            this.dateInput.setValue(`${formattedFrom === null ? this.fromDate$.getValue() : formattedFrom} ${this.inputDateRangeSeparator} ${formattedTo === null ? this.toDate$.getValue() : formattedTo}`);
        }
        else {
            /* eslint-disable-next-line no-null/no-null */
            this.dateInput.setValue(null);
        }
        if ((_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.touched) {
            this.onTouched();
        }
    }
    copyDateElement(sourceDate) {
        return { year: sourceDate.year, month: sourceDate.month, day: sourceDate.day };
    }
    updateRangeModel(from, to) {
        this.onChange({
            from: from ? this.adapter.toModel(from) : null,
            to: to ? this.adapter.toModel(to) : null,
        });
    }
    isRequired() {
        var _a, _b;
        if ((_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.validator) {
            const validator = (_b = this.parentFormControl) === null || _b === void 0 ? void 0 : _b.validator({});
            if (validator && validator.required) {
                return true;
            }
        }
        return false;
    }
    setStartDateOnPicker(picker) {
        var _a, _b;
        let startDate = null;
        if (this.rangeSelection) {
            startDate = this.fromDate$.getValue();
        }
        else if (this.rangeSelectionSplit && ((_a = this.fromDate$.getValue()) === null || _a === void 0 ? void 0 : _a.year)) {
            startDate = this.fromDate$.getValue();
        }
        else if (this.rangeSelectionSplit && ((_b = this.toDate$.getValue()) === null || _b === void 0 ? void 0 : _b.year)) {
            startDate = this.toDate$.getValue();
        }
        if (!!startDate) {
            picker.startDate = startDate;
        }
    }
}
InputDatepickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerComponent, deps: [{ token: i1.NgbDateLocaleParserFormatter }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i2.DeprecationsService }, { token: i3.NgbDateAdapter }, { token: i0.Renderer2 }, { token: i4.DomAttributesService }], target: i0.ɵɵFactoryTarget.Component });
InputDatepickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerComponent, selector: "bb-input-datepicker-ui", inputs: { rangeSelection: "rangeSelection", rangeSelectionSplit: "rangeSelectionSplit", clickOpen: "clickOpen", focusOpen: "focusOpen", placement: "placement", datepickerDescribedby: "datepickerDescribedby", ariaLabelForButton: "ariaLabelForButton", minDate: "minDate", maxDate: "maxDate", markDisabled: "markDisabled", icon: "icon", iconSize: "iconSize", iconColor: "iconColor", btnColor: "btnColor", ariaLabel: "ariaLabel", navigation: "navigation", autocomplete: "autocomplete", firstDayOfWeek: "firstDayOfWeek", displayMonths: "displayMonths", placeholder: "placeholder", overrideDateFormat: "overrideDateFormat" }, outputs: { focusedDate: "focusedDate" }, host: { properties: { "attr.class": "this.cssClass" } }, providers: [
        DatePipe,
        NgbDateLocaleParserFormatter,
        {
            provide: NgbDateAdapter,
            useClass: NgbDateStringAdapter,
        },
        {
            provide: NgbDatepickerI18n,
            useClass: NgbDatepickerI18nDefault,
        },
        {
            provide: NgbDateParserFormatter,
            useExisting: NgbDateLocaleParserFormatter,
        },
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => InputDatepickerComponent),
            multi: true,
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => InputDatepickerComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "datePicker", first: true, predicate: ["datePicker"], descendants: true }, { propertyName: "datePickerTo", first: true, predicate: ["datePickerTo"], descendants: true }, { propertyName: "datePickerInput", first: true, predicate: ["datePickerInput"], descendants: true }, { propertyName: "datePickerRangeInput", first: true, predicate: ["datePickerRangeInput"], descendants: true }, { propertyName: "datePickerInputTo", first: true, predicate: ["datePickerInputTo"], descendants: true }, { propertyName: "datePickerButton", first: true, predicate: ["datePickerButton"], descendants: true }, { propertyName: "datePickerButtonTo", first: true, predicate: ["datePickerButtonTo"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"bb-input-datepicker__wrapper\"\n  [ngClass]=\"{\n    'ng-invalid': parentFormControl?.invalid,\n    'ng-touched': parentFormControl?.touched,\n    'bb-input-datepicker__range-split-wrapper': rangeSelectionSplit\n  }\"\n>\n  <label *ngIf=\"label\" class=\"bb-input-datepicker__label\" for=\"{{ id }}\">{{ label }}</label>\n  <div class=\"input-group bb-input-datepicker\" #positionTarget>\n    <ng-container *ngIf=\"!rangeSelection; else dateRangeInput\">\n      <input\n        type=\"text\"\n        id=\"{{ id }}\"\n        name=\"date\"\n        class=\"form-control bb-input-datepicker__input\"\n        [attr.placeholder]=\"placeholder\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"datepickerDescribedby\"\n        [attr.aria-expanded]=\"ariaExpanded\"\n        [attr.role]=\"role\"\n        [attr.aria-invalid]=\"ariaInvalid\"\n        [attr.aria-owns]=\"ariaOwns\"\n        [attr.aria-activedescendant]=\"ariaActivedescendant\"\n        [attr.aria-label]=\"(!label && ariaLabel) || null\"\n        ngbDatepicker\n        [minDate]=\"_minDate\"\n        [maxDate]=\"_maxDate\"\n        [markDisabled]=\"markDisabled\"\n        [readOnly]=\"readonly\"\n        [required]=\"required\"\n        [navigation]=\"navigation\"\n        [dayTemplate]=\"rangeSelectionSplit ? rangeDay : singleDay\"\n        [displayMonths]=\"displayMonths\"\n        [formControl]=\"dateInput\"\n        [placement]=\"placement\"\n        [positionTarget]=\"positionTarget\"\n        [restoreFocus]=\"!rangeSelectionSplit\"\n        (ngModelChange)=\"!rangeSelectionSplit ? onChange($event) : null\"\n        (click)=\"onInputFocus(clickOpen)\"\n        (focus)=\"onInputFocus(focusOpen)\"\n        (blur)=\"onControlBlur($event)\"\n        (input)=\"rangeSelectionSplit ? onInputChangeSplitRange(datePickerInput) : onInputChange(datePickerInput)\"\n        (closed)=\"onClosed()\"\n        #datePicker=\"ngbDatepicker\"\n        #datePickerInput\n        [attr.data-role]=\"'input-date-single'\"\n        [attr.autocomplete]=\"autocomplete\"\n        [firstDayOfWeek]=\"firstDayOfWeek\"\n        (dateSelect)=\"rangeSelectionSplit ? onRangeDateSelectSplit($event) : null\"\n        [autoClose]=\"!rangeSelectionSplit\"\n      />\n    </ng-container>\n\n    <div\n      *ngIf=\"datepickerDescribedby === 'defaultDatepickerDescribedbyLabel'\"\n      class=\"sr-only\"\n      aria-live=\"polite\"\n      id=\"defaultDatepickerDescribedbyLabel\"\n    >\n      <ng-container *ngIf=\"hoveredDate$ | async as hoveredDate\">\n        <span\n          *ngIf=\"hoveredDate.isSelecting; else selectedDate\"\n          i18n=\"Default selecting date state i18n message@@defaultSelectingState.with.i18n.support\"\n          >Selecting date:\n          {{\n            hoveredDate.date.year + '-' + hoveredDate.date.month + '-' + hoveredDate.date.day | date: 'longDate'\n          }}</span\n        >\n        <ng-template #selectedDate>\n          <ng-container\n            i18n=\"Default selected date state i18n message@@defaultSelectedState.with.i18n.support\"\n            *ngIf=\"hoveredDate.date\"\n            >Selected date is{{\n              hoveredDate.date.year + '-' + hoveredDate.date.month + '-' + hoveredDate.date.day | date: 'longDate'\n            }}.</ng-container\n          >\n        </ng-template>\n      </ng-container>\n    </div>\n\n    <div class=\"input-group-append\">\n      <button\n        #datePickerButton\n        bbButton\n        class=\"bb-input-datepicker__calendar-opener-button\"\n        [color]=\"btnColor\"\n        [disabled]=\"disabled || readonly\"\n        (blur)=\"onControlBlur($event)\"\n        [attr.aria-label]=\"ariaLabelForButton\"\n        (click)=\"onPickerTogglerClick($event)\"\n        [attr.data-role]=\"'toggle-calendar-button'\"\n      >\n        <bb-icon-ui [color]=\"iconColor\" [name]=\"icon\" [size]=\"iconSize\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n\n  <div class=\"input-group bb-input-datepicker\" *ngIf=\"rangeSelectionSplit\">\n    <input\n      type=\"text\"\n      id=\"to_{{ id }}\"\n      name=\"dateTo\"\n      class=\"form-control bb-input-datepicker__input\"\n      [attr.placeholder]=\"placeholder\"\n      [attr.aria-labelledby]=\"ariaLabelledby\"\n      [attr.aria-describedby]=\"datepickerDescribedby\"\n      [attr.aria-expanded]=\"ariaExpanded\"\n      [attr.role]=\"role\"\n      [attr.aria-invalid]=\"ariaInvalid\"\n      [attr.aria-owns]=\"ariaOwns\"\n      [attr.aria-activedescendant]=\"ariaActivedescendant\"\n      [attr.aria-label]=\"(!label && ariaLabel) || null\"\n      ngbDatepicker\n      [minDate]=\"_minDate\"\n      [maxDate]=\"_maxDate\"\n      [markDisabled]=\"markDisabled\"\n      [readOnly]=\"readonly\"\n      [required]=\"required\"\n      [displayMonths]=\"displayMonths\"\n      [navigation]=\"navigation\"\n      [restoreFocus]=\"false\"\n      [dayTemplate]=\"rangeDay\"\n      [dayTemplateData]=\"rangeTemplateData\"\n      [formControl]=\"dateInputTo\"\n      [placement]=\"placement\"\n      (click)=\"onInputFocusTo(clickOpen)\"\n      (focus)=\"onInputFocusTo(focusOpen)\"\n      (blur)=\"onControlBlur($event)\"\n      (input)=\"rangeSelectionSplit ? onInputChangeSplitRangeTo(datePickerInputTo) : onInputChange(datePickerInputTo)\"\n      (closed)=\"onClosedTo()\"\n      #datePickerTo=\"ngbDatepicker\"\n      #datePickerInputTo\n      [attr.data-role]=\"'input-date-single'\"\n      [attr.autocomplete]=\"autocomplete\"\n      [firstDayOfWeek]=\"firstDayOfWeek\"\n      (dateSelect)=\"rangeSelectionSplit ? onRangeDateSelectSplitTo($event) : null\"\n      [autoClose]=\"!rangeSelectionSplit\"\n    />\n    <div class=\"input-group-append\">\n      <button\n        #datePickerButtonTo\n        bbButton\n        class=\"bb-input-datepicker__calendar-opener-button\"\n        [color]=\"btnColor\"\n        [disabled]=\"disabled || readonly\"\n        [attr.aria-label]=\"ariaLabelForButton\"\n        (blur)=\"onControlBlur($event)\"\n        (click)=\"onPickerTogglerClickTo($event)\"\n        [attr.data-role]=\"'toggle-calendar-button'\"\n      >\n        <bb-icon-ui [color]=\"iconColor\" [name]=\"icon\" [size]=\"iconSize\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n</div>\n\n<!-- Single input date range template -->\n\n<ng-template #dateRangeInput>\n  <input\n    type=\"text\"\n    name=\"date\"\n    id=\"{{ id }}\"\n    class=\"form-control bb-input-datepicker__range\"\n    [formControl]=\"dateInput\"\n    [readOnly]=\"readonly\"\n    [required]=\"required\"\n    #datePickerRangeInput\n    [attr.placeholder]=\"placeholder\"\n    [attr.aria-label]=\"(!label && ariaLabel) || null\"\n    [attr.aria-describedby]=\"datepickerDescribedby\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-expanded]=\"ariaExpanded\"\n    [attr.role]=\"role\"\n    [attr.aria-invalid]=\"ariaInvalid\"\n    [attr.aria-owns]=\"ariaOwns\"\n    [attr.aria-activedescendant]=\"ariaActivedescendant\"\n    (click)=\"onInputFocus(clickOpen)\"\n    (focus)=\"onInputFocus(focusOpen)\"\n    (blur)=\"onControlBlur($event)\"\n    (input)=\"onInputChangeRange(datePickerRangeInput)\"\n    [attr.data-role]=\"'input-date-range'\"\n  />\n\n  <input\n    type=\"text\"\n    class=\"datepicker-input-hidden bb-input-datepicker__range-input-hidden\"\n    ngbDatepicker\n    (closed)=\"onClosed()\"\n    [minDate]=\"_minDate\"\n    [maxDate]=\"_maxDate\"\n    [markDisabled]=\"markDisabled\"\n    [autoClose]=\"false\"\n    [attr.aria-label]=\"label || ariaLabel || null\"\n    [attr.aria-describedby]=\"datepickerDescribedby\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-expanded]=\"ariaExpanded\"\n    [attr.role]=\"role\"\n    [attr.aria-invalid]=\"ariaInvalid\"\n    [attr.aria-owns]=\"ariaOwns\"\n    [attr.aria-activedescendant]=\"ariaActivedescendant\"\n    [readOnly]=\"readonly\"\n    [required]=\"required\"\n    [firstDayOfWeek]=\"firstDayOfWeek\"\n    [positionTarget]=\"positionTarget\"\n    [placement]=\"placement\"\n    #datePicker=\"ngbDatepicker\"\n    [dayTemplate]=\"rangeDay\"\n    navigation=\"arrows\"\n    [attr.data-role]=\"'input-datepicker'\"\n    (dateSelect)=\"onRangeDateSelect($event)\"\n  />\n</ng-template>\n\n<!-- template end -->\n\n<!-- Single Date day template -->\n<ng-template\n  #singleDay\n  let-date=\"date\"\n  let-disabled=\"disabled\"\n  let-selected=\"selected\"\n  let-currentMonth=\"currentMonth\"\n  let-data=\"data\"\n>\n  <bb-input-datepicker-single-day-template-ui\n    [disabled]=\"disabled\"\n    [selected]=\"selected\"\n    [currentMonth]=\"currentMonth\"\n    [date]=\"date\"\n    (hovered)=\"onDayHover($event)\"\n    [hoveredDate]=\"data?.isTo ? pickerHoveredDayDateTo : hoveredDate$.getValue().date\"\n  >\n  </bb-input-datepicker-single-day-template-ui>\n</ng-template>\n\n<!-- template end -->\n\n<!-- Date range day template -->\n<ng-template\n  #rangeDay\n  let-date=\"date\"\n  let-disabled=\"disabled\"\n  let-selected=\"selected\"\n  let-currentMonth=\"currentMonth\"\n  let-data=\"data\"\n>\n  <bb-input-datepicker-range-day-template-ui\n    [date]=\"date\"\n    [fromDate]=\"fromDate$.getValue()\"\n    [toDate]=\"toDate$.getValue()\"\n    [splitRange]=\"rangeSelectionSplit\"\n    [toDateDatepicker]=\"data?.isTo\"\n    [disabled]=\"disabled\"\n    [currentMonth]=\"currentMonth\"\n    (hovered)=\"onDayHover($event)\"\n    [hoveredDate]=\"data?.isTo ? pickerHoveredDayDateTo : hoveredDate$.getValue().date\"\n  >\n  </bb-input-datepicker-range-day-template-ui>\n</ng-template>\n", components: [{ type: i5.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i6.InputDatepickerDayTemplateSingleComponent, selector: "bb-input-datepicker-single-day-template-ui", inputs: ["date", "selected", "disabled", "currentMonth", "hoveredDate"], outputs: ["hovered"] }, { type: i7.InputDatepickerDayTemplateRangeComponent, selector: "bb-input-datepicker-range-day-template-ui", inputs: ["date", "disabled", "currentMonth", "fromDate", "toDate", "splitRange", "toDateDatepicker", "hoveredDate"], outputs: ["rangeSelect", "hovered"] }], directives: [{ type: i8.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i8.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgbInputDatepicker, selector: "input[ngbDatepicker]", inputs: ["disabled", "autoClose", "datepickerClass", "dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "placement", "restoreFocus", "showWeekNumbers", "startDate", "container", "positionTarget", "weekdays"], outputs: ["dateSelect", "navigate", "closed"], exportAs: ["ngbDatepicker"] }, { type: i9.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i9.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i9.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i9.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i10.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], pipes: { "async": i8.AsyncPipe, "date": i8.DatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-datepicker-ui',
                    templateUrl: './input-datepicker.component.html',
                    providers: [
                        DatePipe,
                        NgbDateLocaleParserFormatter,
                        {
                            provide: NgbDateAdapter,
                            useClass: NgbDateStringAdapter,
                        },
                        {
                            provide: NgbDatepickerI18n,
                            useClass: NgbDatepickerI18nDefault,
                        },
                        {
                            provide: NgbDateParserFormatter,
                            useExisting: NgbDateLocaleParserFormatter,
                        },
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => InputDatepickerComponent),
                            multi: true,
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => InputDatepickerComponent),
                            multi: true,
                        },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.NgbDateLocaleParserFormatter }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i2.DeprecationsService }, { type: i3.NgbDateAdapter }, { type: i0.Renderer2 }, { type: i4.DomAttributesService }]; }, propDecorators: { focusedDate: [{
                type: Output
            }], rangeSelection: [{
                type: Input
            }], rangeSelectionSplit: [{
                type: Input
            }], clickOpen: [{
                type: Input
            }], focusOpen: [{
                type: Input
            }], placement: [{
                type: Input
            }], datepickerDescribedby: [{
                type: Input
            }], ariaLabelForButton: [{
                type: Input
            }], minDate: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], markDisabled: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconSize: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], btnColor: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], navigation: [{
                type: Input
            }], autocomplete: [{
                type: Input
            }], firstDayOfWeek: [{
                type: Input
            }], displayMonths: [{
                type: Input
            }], placeholder: [{
                type: Input,
                args: ['placeholder']
            }], overrideDateFormat: [{
                type: Input,
                args: ['overrideDateFormat']
            }], datePicker: [{
                type: ViewChild,
                args: ['datePicker']
            }], datePickerTo: [{
                type: ViewChild,
                args: ['datePickerTo']
            }], datePickerInput: [{
                type: ViewChild,
                args: ['datePickerInput']
            }], datePickerRangeInput: [{
                type: ViewChild,
                args: ['datePickerRangeInput']
            }], datePickerInputTo: [{
                type: ViewChild,
                args: ['datePickerInputTo']
            }], datePickerButton: [{
                type: ViewChild,
                args: ['datePickerButton']
            }], datePickerButtonTo: [{
                type: ViewChild,
                args: ['datePickerButtonTo']
            }], cssClass: [{
                type: HostBinding,
                args: ['attr.class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZGF0ZXBpY2tlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9saWJzL3VpLWFuZy9pbnB1dC1kYXRlcGlja2VyL2lucHV0LWRhdGVwaWNrZXIuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvaW5wdXQtZGF0ZXBpY2tlci9pbnB1dC1kYXRlcGlja2VyLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUVULFlBQVksRUFDWixVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFFTCxNQUFNLEVBR04sU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBRUwsV0FBVyxFQUNYLGFBQWEsRUFDYixpQkFBaUIsR0FHbEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBRUwsY0FBYyxFQUNkLHNCQUFzQixFQUN0QixpQkFBaUIsR0FHbEIsTUFBTSw0QkFBNEIsQ0FBQztBQUVwQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUNsRSxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQztBQUM1RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7Ozs7Ozs7Ozs7QUFLdkMsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixNQUFNLENBQU4sSUFBWSxHQWFYO0FBYkQsV0FBWSxHQUFHO0lBQ2IsMkJBQU8sQ0FBQTtJQUNQLGdDQUFVLENBQUE7SUFDVixrQ0FBVyxDQUFBO0lBQ1gs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a0I7c0JBQTFCLEtBQUs7Z0JBT0YsT0FBTztzQkFEVixLQUFLO2dCQVlGLE9BQU87c0JBRFYsS0FBSztnQkFTRyxZQUFZO3NCQUFwQixLQUFLO2dCQU1HLElBQUk7c0JBQVosS0FBSztnQkFNRyxRQUFRO3NCQUFoQixLQUFLO2dCQUtHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBTUcsUUFBUTtzQkFBaEIsS0FBSztnQkFNTixTQUFTO3NCQURSLEtBQUs7Z0JBT0csVUFBVTtzQkFBbEIsS0FBSztnQkFLRyxZQUFZO3NCQUFwQixLQUFLO2dCQU9HLGNBQWM7c0JBQXRCLEtBQUs7Z0JBS0csYUFBYTtzQkFBckIsS0FBSztnQkFrQkYsV0FBVztzQkFEZCxLQUFLO3VCQUFDLGFBQWE7Z0JBVWhCLGtCQUFrQjtzQkFEckIsS0FBSzt1QkFBQyxvQkFBb0I7Z0JBbUJGLFVBQVU7c0JBQWxDLFNBQVM7dUJBQUMsWUFBWTtnQkFDSSxZQUFZO3NCQUF0QyxTQUFTO3VCQUFDLGNBQWM7Z0JBQ0ssZUFBZTtzQkFBNUMsU0FBUzt1QkFBQyxpQkFBaUI7Z0JBQ08sb0JBQW9CO3NCQUF0RCxTQUFTO3VCQUFDLHNCQUFzQjtnQkFDRCxpQkFBaUI7c0JBQWhELFNBQVM7dUJBQUMsbUJBQW1CO2dCQUNDLGdCQUFnQjtzQkFBOUMsU0FBUzt1QkFBQyxrQkFBa0I7Z0JBQ0ksa0JBQWtCO3NCQUFsRCxTQUFTO3VCQUFDLG9CQUFvQjtnQkFlSixRQUFRO3NCQUFsQyxXQUFXO3VCQUFDLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBIb3N0QmluZGluZyxcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxuICBSZW5kZXJlcjIsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBYnN0cmFjdENvbnRyb2wsXG4gIEZvcm1Db250cm9sLFxuICBOR19WQUxJREFUT1JTLFxuICBOR19WQUxVRV9BQ0NFU1NPUixcbiAgVmFsaWRhdGlvbkVycm9ycyxcbiAgVmFsaWRhdG9yLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICBOZ2JEYXRlLFxuICBOZ2JEYXRlQWRhcHRlcixcbiAgTmdiRGF0ZVBhcnNlckZvcm1hdHRlcixcbiAgTmdiRGF0ZXBpY2tlckkxOG4sXG4gIE5nYkRhdGVTdHJ1Y3QsXG4gIE5nYklucHV0RGF0ZXBpY2tlcixcbn0gZnJvbSAnQG5nLWJvb3RzdHJhcC9uZy1ib290c3RyYXAnO1xuXG5pbXBvcnQgeyBJbnB1dEJhc2VDb21wb25lbnQgfSBmcm9tICdAYmFja2Jhc2UvdWktYW5nL2Jhc2UtY2xhc3Nlcyc7XG5pbXBvcnQgeyBOZ2JEYXRlcGlja2VySTE4bkRlZmF1bHQgfSBmcm9tICcuL2lucHV0LWRhdGVwaWNrZXItaTE4bic7XG5pbXBvcnQgeyBOZ2JEYXRlU3RyaW5nQWRhcHRlciB9IGZyb20gJy4vaW5wdXQtZGF0ZXBpY2tlci1hZGFwdGVyJztcbmltcG9ydCB7IE5nYkRhdGVMb2NhbGVQYXJzZXJGb3JtYXR0ZXIgfSBmcm9tICcuL2lucHV0LWRhdGVwaWNrZXItZm9ybWF0dGVyJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRG9tQXR0cmlidXRlc1NlcnZpY2UgfSBmcm9tICdAYmFja2Jhc2UvdWktYW5nL3NlcnZpY2VzJztcbmltcG9ydCB7IERlcHJlY2F0aW9uc1NlcnZpY2UgfSBmcm9tICdAYmFja2Jhc2UvZm91bmRhdGlvbi1hbmcvZnV0dXJlJztcbmltcG9ydCB7IERhdGVSYW5nZU1vZGVsLCBEYXRlU2VsZWN0aW9uTW9kZWwsIE5nRGF0ZVN0cnVjdE51bGxhYmxlIH0gZnJvbSAnLi9pbnB1dC1kYXRlcGlja2VyLm1vZGVsJztcblxuLy8gT2xla3NpaSBkZXByaWNhdGVcbi8qIGVzbGludC1kaXNhYmxlICovXG5leHBvcnQgZW51bSBLZXkge1xuICBUYWIgPSA5LFxuICBFbnRlciA9IDEzLFxuICBFc2NhcGUgPSAyNyxcbiAgU3BhY2UgPSAzMixcbiAgUGFnZVVwID0gMzMsXG4gIFBhZ2VEb3duID0gMzQsXG4gIEVuZCA9IDM1LFxuICBIb21lID0gMzYsXG4gIEFycm93TGVmdCA9IDM3LFxuICBBcnJvd1VwID0gMzgsXG4gIEFycm93UmlnaHQgPSAzOSxcbiAgQXJyb3dEb3duID0gNDAsXG59XG5cbmV4cG9ydCBjb25zdCBpc0RhdGVSYW5nZU1vZGVsVHlwZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgRGF0ZVJhbmdlTW9kZWwgPT5cbiAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlIHx8IHt9LCAnZnJvbScpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSB8fCB7fSwgJ3RvJyk7XG5cbi8qKlxuICogQG5hbWUgSW5wdXREYXRlcGlja2VyQ29tcG9uZW50XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIGRhdGVwaWNrZXJcbiAqXG4gKiAjIyMgQ3VzdG9tIGludGVybmFsaXphdGlvblxuICogSXQgaXMgcG9zc2libGUgdG8gcHJvdmlkZSBhIGN1c3RvbSBpbnRlcm5hbGlzYXRpb24uIFRvIGRvIHRoaXMsIGEgYERBVEVQSUNLRVJfSTE4YCB0b2tlbiBmcm9tIGBAYmFja2Jhc2UvdWktYW5nL2lucHV0LWRhdGVwaWNrZXJgIHNob3VsZCBiZSBwcm92aWRlZCBvbiB0aGUgbW9kdWxlIGxldmVsLlxuICogVGhlIHRva2VuIHNob3VsZCBpbXBsZW1lbnQgdGhlIFtOZ2JEYXRlcGlja2VySTE4bl0oaHR0cHM6Ly9uZy1ib290c3RyYXAuZ2l0aHViLmlvLyMvY29tcG9uZW50cy9kYXRlcGlja2VyL2FwaSNOZ2JEYXRlcGlja2VySTE4bikgaW50ZXJmYWNlLiBcbiAqIFxuICogIyMjIFNldHRpbmcgYW5kIHJlYWRpbmcgdGhlICBkYXRlXG4gKiAqTm90ZSogRGF0ZXBpY2tlciB1c2VzIHRoZSBkYXRlICp3aXRoIHRoZSB0aW1lem9uZSogaW5zaWRlIGl0cyBtb2RlbC4gQW5kIGhlbmNlIHRvIG1ha2UgaXQgd29yayBwcm9wZXJseSBpbiBhbGwgY2FzZXMgdGhlcmUgYXJlIHNvbWUgcmVjb21tZW5kYXRpb25zIGZvciBzZXR0aW5nIGFuZCByZWFkaW5nIHRoZSBkYXRlIHRvIGFuZCBmcm9tIHRoZSBkYXRlcGlja2VyLlxuICogIyMjIyBTZXR0aW5nIHRoZSBkYXRlXG4gKiBXaGVuIHNldHRpbmcgdGhlIGRhdGUgdG8gdGhlIGRhdGVwaWNrZXIgdGhlIGRhdGUgbXVzdCBiZSBwcm92aWRlZCBpbiB0aGUgZm9ybWF0IHRoYXQgYXNzdW1lcyB6ZXJvIGhvdXJzIGFuZCB6ZXJvIG1pbnV0ZXMgaW4gdGhlIGxvY2FsIHRpbWV6b25lLiBIZXJlIGFyZSBzb21lIGV4YW1wbGVzIG9mIHdoYXQgdGhlIGRhdGUgc2V0dGluZyBzaG91bGQgbG9va3MgbGlrZTpcbiAqIGBgYFxuICAgdGhpcy5taW5EYXRlID0gbmV3IERhdGUoMjAyMSwxMSwxNSwgMCwgMCkudG9JU09TdHJpbmcoKTtcbiAgIGBgYFxuICpcbiAqIG9yXG4gKiBgYGBcbiAgIHRoaXMubWluRGF0ZSA9IG5ldyBEYXRlKCcyMDIxLTEyLTE1VDAwOjAwJykudG9JU09TdHJpbmcoKTtcbiAgIGBgYFxuICpcbiAqIE5vdGUgdGhhdFxuICogYGBgXG4gICBuZXcgRGF0ZSgnMjAyMS0xMi0xNScpLnRvSVNPU3RyaW5nKCk7XG4gICBgYGBcbiAqXG4gKiBnZW5lcmF0ZXMgYSBkYXRlIGluIEdNVDAgZm9ybWF0IGFuZCB0aGF0IGlzIG5vdCBjb3JyZWN0IGZvciB0aGUgZGF0ZXBpY2tlciBpbnB1dCBkYXRlLlxuICogIyMjIyBSZWFkaW5nIHRoZSBkYXRlXG4gKiBXaGVuIGEgZGF0ZSBpcyBzZWxlY3RlZCB2aWEgVUkgKHRoZSBkYXRlcGlja2VyJ3MgcG9wdXAgd2luZG93IG9yIGJyb3dzZXIncyBpbnB1dCBmaWVsZCkgaXRzIGRpc3BsYXkgZGF0ZSBpcyB0cmFuc2Zvcm1lZCB0byB0aGUgSVNPIHN0cmluZyBkYXRlIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCBpdOKAmXMgemVybyBob3VycyBhbmQgemVybyBtaW51dGVzIGluIHRoZSBjdXJyZW50IHRpbWUgem9uZS4gV2hpY2ggbGVhZHMgdG8gdGhlIGRpZmZlcmVudCBJU08gc3RyaW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHRpbWUgem9uZXMgZm9yIHRoZSBzYW1lIGRhdGUuIEYuZS4gXCJEZWMgMTUgMjAyMVwiIGlzIGdvaW5nIHRvIGJlIHRyYW5zZm9ybWVkIHRvIFwiMjAyMS0xMi0xNFQyMzowMDowMC4wMDBaXCIgZm9yIHRoZSBcIkdNVCswMTAwIChDZW50cmFsIEV1cm9wZWFuIFN0YW5kYXJkIFRpbWUpXCIgdGltZSB6b25lIGFuZCB0byBcIjIwMjEtMTItMTVUMDM6MDA6MDAuMDAwWlwiIGZvciBcIkdNVC0wMzAwIChXZXN0IEdyZWVubGFuZCBTdGFuZGFyZCBUaW1lKVwiIHRpbWUgem9uZS4gQXMgeW91IGNhbiBzZWUgdGhlIF9kYXlfIHZhbHVlIGlzIGRpZmZlcmVudCBpbiBJU08gc3RyaW5nIGJhc2VkIG9uIHRoZSB0aW1lem9uZS4gSXTigJlzIGdvaW5nIHRvIGJlIGVpdGhlciAxNCBvciAxNSBpbiB0aGUgZXhhbXBsZSBhYm92ZS5cbiAqIFxuICogVGhlIHJlY29tbWVuZGF0aW9uIGhlcmUgaXMgdG8gY29udmVydCB0aGUgSVNPIHN0cmluZywgdGhhdCB0aGUgZGF0ZXBpY2tlciByZXR1cm5zLCBpbnRvIHRoZSBEYXRlIG9iamVjdCBhbmQgcmVhZCBpdCdzIGRheSB2YWx1ZS4gSGVyZSBpcyBhbiBleGFtcGxlOlxuICogYGBgXG4gIHByaXZhdGUgZm9ybWF0RGF0ZShzdHJpbmdEYXRlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdHJpbmdEYXRlKTtcbiAgICBpZiAoc3RyaW5nRGF0ZSAmJiAhaXNOYU4oZGF0ZS52YWx1ZU9mKCkpKSB7XG4gICAgICByZXR1cm4gYCR7ZGF0ZS5nZXRGdWxsWWVhcigpfS0ke3RoaXMuYXBwZW5kTGVhZGluZ1plcm9lcyhkYXRlLmdldE1vbnRoKCkgKyAxKX0tJHt0aGlzLmFwcGVuZExlYWRpbmdaZXJvZXMoZGF0ZS5nZXREYXRlKCkpfWA7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kTGVhZGluZ1plcm9lcyh2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHZhbHVlID4gOSA/IHZhbHVlIDogYDAke3ZhbHVlfWA7XG4gIH1cbiAgIGBgYFxuICpcbiAqIEBhMTF5IEN1cnJlbnQgY29tcG9uZW50IHByb3ZpZGUgb3B0aW9uIHRvIHBhc3MgbmVlZGVkIGFjY2Vzc2liaWxpdHlcbiAqIGF0dHJpYnV0ZXMuIFlvdSBuZWVkIHRvIHRha2UgY2FyZSBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIHJlcXVpcmVkIGluIHlvdXIgY2FzZSA6XG4gKiAgLSByb2xlXG4gKiAgLSBhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcbiAqICAtIGFyaWEtZGVzY3JpYmVkYnlcbiAqICAtIGFyaWEtZXhwYW5kZWRcbiAqICAtIGFyaWEtaW52YWxpZFxuICogIC0gYXJpYS1sYWJlbFxuICogIC0gYXJpYS1sYWJlbGxlZGJ5XG4gKiAgLSBhcmlhLW93bnNcbiAqXG4gKiBgYXJpYUxhYmVsYCBpcyBkaXNjZXJuaWJsZSB0ZXh0IGZvciBkYXRlcGlja2VyXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWlucHV0LWRhdGVwaWNrZXItdWknLFxuICB0ZW1wbGF0ZVVybDogJy4vaW5wdXQtZGF0ZXBpY2tlci5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW1xuICAgIERhdGVQaXBlLFxuICAgIE5nYkRhdGVMb2NhbGVQYXJzZXJGb3JtYXR0ZXIsXG4gICAge1xuICAgICAgcHJvdmlkZTogTmdiRGF0ZUFkYXB0ZXIsXG4gICAgICB1c2VDbGFzczogTmdiRGF0ZVN0cmluZ0FkYXB0ZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBOZ2JEYXRlcGlja2VySTE4bixcbiAgICAgIHVzZUNsYXNzOiBOZ2JEYXRlcGlja2VySTE4bkRlZmF1bHQsXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBOZ2JEYXRlUGFyc2VyRm9ybWF0dGVyLFxuICAgICAgdXNlRXhpc3Rpbmc6IE5nYkRhdGVMb2NhbGVQYXJzZXJGb3JtYXR0ZXIsXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0RGF0ZXBpY2tlckNvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dERhdGVwaWNrZXJDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIElucHV0RGF0ZXBpY2tlckNvbXBvbmVudCBleHRlbmRzIElucHV0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgVmFsaWRhdG9yLCBBZnRlclZpZXdJbml0IHtcbiAgLyoqXG4gICAqIEV2ZW50IHRvIHRyaWdnZXIgb24gZGF0ZSBob3ZlclxuICAgKi9cbiAgQE91dHB1dCgpIGZvY3VzZWREYXRlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlU2VsZWN0aW9uTW9kZWw+KCk7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZGF0ZXBpY2tlciBzaG91bGQgc2VsZWN0IGEgZGF0ZSByYW5nZSB3aXRoIHNpbmdsZSBpbnB1dCAoZnJvbSAtIHRvKS5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIEBJbnB1dCgpIHJhbmdlU2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZGF0ZXBpY2tlciBzaG91bGQgYSBkYXRlIHJhbmdlIHdpdGggc3BsaXQgaW5wdXQuIE9uZSBmb3IgdGhlIGZyb20gZGF0ZSBhbmQgb25lIGZvciB0aGUgdG8gZGF0ZS5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIEBJbnB1dCgpIHJhbmdlU2VsZWN0aW9uU3BsaXQgPSBmYWxzZTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBkYXRlcGlja2VyIGlzIG9wZW5lZCB3aGVuIGNsaWNraW5nIGlucHV0LlxuICAgKiBEZWZhdWx0cyB0byBmYWxzZVxuICAgKi9cbiAgQElucHV0KCkgY2xpY2tPcGVuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZGF0ZXBpY2tlciBpcyBvcGVuZWQgd2hlbiBmb2N1c2luZyBpbnB1dC5cbiAgICogRGVmYXVsdHMgdG8gZmFsc2VcbiAgICovXG4gIEBJbnB1dCgpIGZvY3VzT3BlbiA9IGZhbHNlO1xuXG4gIF9wbGFjZW1lbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9ICdib3R0b20tbGVmdCc7XG5cbiAgZ2V0IHBsYWNlbWVudCgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoID4gMzIwID8gdGhpcy5fcGxhY2VtZW50IDogJ2JvdHRvbSc7XG4gIH1cblxuICAvKipcbiAgICogUGxhY2VtZW50IG9mIGEgcG9wdXAgd2luZG93XG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgcGxhY2VtZW50KHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3BsYWNlbWVudCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY2Nlc3NpYmxlIGRlc2NyaXB0aW9uIGZvciBkYXRlcGlja2VyIGRhdGUgc2VsZWN0aW9uIHBvcHVwLlxuICAgKi9cbiAgQElucHV0KCkgZGF0ZXBpY2tlckRlc2NyaWJlZGJ5ID0gJ2RlZmF1bHREYXRlcGlja2VyRGVzY3JpYmVkYnlMYWJlbCc7XG5cbiAgLyoqXG4gICAqIEFjY2Vzc2libGUgbGFiZWwgZm9yIERhdGVwaWNrZXIgYnV0dG9uLlxuICAgKi9cbiAgQElucHV0KCkgYXJpYUxhYmVsRm9yQnV0dG9uID0gJ1RvZ2dsZSBEYXRlIHBvcHVwJztcblxuICAvKipcbiAgICogTWluIGRhdGUgZm9yIHRoZSBuYXZpZ2F0aW9uLiBJZiBub3QgcHJvdmlkZWQsICd5ZWFyJyBzZWxlY3QgYm94IHdpbGwgZGlzcGxheSAxMCB5ZWFyc1xuICAgKiBiZWZvcmUgY3VycmVudCBtb250aFxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IG1pbkRhdGUoZGF0ZTogTmdiRGF0ZVN0cnVjdCB8IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX21pbkRhdGUgPSB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycgPyB0aGlzLmFkYXB0ZXIuZnJvbU1vZGVsKGRhdGUpIDogZGF0ZTtcbiAgfVxuXG4gIF9taW5EYXRlOiBOZ0RhdGVTdHJ1Y3ROdWxsYWJsZSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogTWF4IGRhdGUgZm9yIHRoZSBuYXZpZ2F0aW9uLiBJZiBub3QgcHJvdmlkZWQsICd5ZWFyJyBzZWxlY3QgYm94IHdpbGwgZGlzcGxheSAxMCB5ZWFyc1xuICAgKiBhZnRlciBjdXJyZW50IG1vbnRoXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgbWF4RGF0ZShkYXRlOiBOZ2JEYXRlU3RydWN0IHwgc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fbWF4RGF0ZSA9IHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyA/IHRoaXMuYWRhcHRlci5mcm9tTW9kZWwoZGF0ZSkgOiBkYXRlO1xuICB9XG5cbiAgX21heERhdGU6IE5nYkRhdGVTdHJ1Y3QgfCB1bmRlZmluZWQgfCBudWxsO1xuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gbWFyayBhIGdpdmVuIGRhdGUgYXMgZGlzYWJsZWRcbiAgICovXG4gIEBJbnB1dCgpIG1hcmtEaXNhYmxlZDogRnVuY3Rpb24gfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEljb24gdGhhdCBpcyBkaXNwYXllZCBpbiB0aGUgYnV0dG9uLlxuICAgKiBEZWZhdWx0cyB0byBjYWxlbmRhclxuICAgKi9cbiAgQElucHV0KCkgaWNvbiA9ICdjYWxlbmRhci10b2RheSc7XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBpY29uIHRvIGJlIGRpc3BsYXllZC5cbiAgICogRGVmYXVsdHMgdG8gbWRcbiAgICovXG4gIEBJbnB1dCgpIGljb25TaXplID0gJ21kJztcblxuICAvKipcbiAgICogVGhlIGNvbG9yIG9mIHRoZSBpY29uIHRvIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgQElucHV0KCkgaWNvbkNvbG9yOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIENvbG9yIG9mIHRoZSBidXR0b24uXG4gICAqIERlZmF1bHRzIHRvIGxpbmtcbiAgICovXG4gIEBJbnB1dCgpIGJ0bkNvbG9yID0gJ2xpbmsnO1xuXG4gIC8qKlxuICAgKiBBcmlhIGxhYmVsIGZvciB0aGUgZGF0ZXBpY2tlclxuICAgKi9cbiAgQElucHV0KClcbiAgYXJpYUxhYmVsID0gJ0RhdGVwaWNrZXInO1xuXG4gIC8qKlxuICAgKiBOYXZpZ2F0aW9uIHBhdHRlcm4gdGhyb3VnaCBkYXRlcy5cbiAgICogRGVmYXVsdCB0byBhcnJvd3NcbiAgICovXG4gIEBJbnB1dCgpIG5hdmlnYXRpb246ICdzZWxlY3QnIHwgJ2Fycm93cycgfCAnbm9uZScgPSAnYXJyb3dzJztcblxuICAvKipcbiAgICogVGhlIGF1dG9jb21wbGV0ZSB2YWx1ZSBvZiBlbmNsb3NlZCBpbnB1dCBjb250cm9sLlxuICAgKi9cbiAgQElucHV0KCkgYXV0b2NvbXBsZXRlOiAnc3RyaW5nJyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vla1xuICAgKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjYWxlbmRhciB1c2VzIElTTyA4NjAxIGFuZCB0aGUgd2Vla2RheXMgYXJlIGlzIDE9TW9uIC4uLiA3PVN1blxuICAgKi9cbiAgQElucHV0KCkgZmlyc3REYXlPZldlZWs6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGhvdyBtYW55IG1vbnRoIHdpbGwgYmUgc2hvd24gaW4gdGhlIHBpY2tlclxuICAgKi9cbiAgQElucHV0KCkgZGlzcGxheU1vbnRocyA9IDE7XG5cbiAgX3BsYWNlaG9sZGVyOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9wbGFjZWhvbGRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLmRhdGVGb3JtYXQudG9VcHBlckNhc2UoKTtcblxuICAgICAgcmV0dXJuIHRoaXMucmFuZ2VTZWxlY3Rpb24gPyBgJHtwYXR0ZXJufSAke3RoaXMuaW5wdXREYXRlUmFuZ2VTZXBhcmF0b3J9ICR7cGF0dGVybn1gIDogcGF0dGVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGxhY2Vob2xkZXI7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgZGF0ZXBpY2tlciBpbnB1dC4gRGVmYXVsdCBpcyBMb2NhbGUgRGF0ZSBGb3JtYXQ7XG4gICAqL1xuICBASW5wdXQoJ3BsYWNlaG9sZGVyJylcbiAgc2V0IHBsYWNlaG9sZGVyKHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyBTdHJpbmcodmFsdWUpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGRhdGUgZm9ybWF0IChvcHRpb25hbCkuIFN1cHBvcnRlZCBmb3JtYXRzIGFyZSBgeXl5eS9NTS9kZGAsIGBNTS9kZC95eXl5YCwgYE1NTU0gZGQsIHl5eXlgLlxuICAgKiBOb3RlLCBvdGhlciBmb3JtYXRzIG1pZ2h0IHdvcmsgaW5jb25zaXN0ZW50IGluIGRpZmZlcmVudCBicm93c2Vycy5cbiAgICovXG4gIEBJbnB1dCgnb3ZlcnJpZGVEYXRlRm9ybWF0JylcbiAgc2V0IG92ZXJyaWRlRGF0ZUZvcm1hdCh2YWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fb3ZlcnJpZGVEYXRlRm9ybWF0ID0gdmFsdWU7XG4gICAgdGhpcy5mb3JtYXR0ZXJIZWxwZXIuZGF0ZUZvcm1hdCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IG92ZXJyaWRlRGF0ZUZvcm1hdCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9vdmVycmlkZURhdGVGb3JtYXQ7XG4gIH1cblxuICBfb3ZlcnJpZGVEYXRlRm9ybWF0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXN0b20gb3IgbG9jYWxlIGRhdGUgZm9ybWF0IHRoYXQgaXMgdXNlZCB0byBkaXNwbGF5IGRhdGVzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICovXG4gIGdldCBkYXRlRm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVySGVscGVyLmxvY2FsZURhdGVGb3JtYXQ7XG4gIH1cblxuICBAVmlld0NoaWxkKCdkYXRlUGlja2VyJykgZGF0ZVBpY2tlcjogTmdiSW5wdXREYXRlcGlja2VyIHwgdW5kZWZpbmVkO1xuICBAVmlld0NoaWxkKCdkYXRlUGlja2VyVG8nKSBkYXRlUGlja2VyVG86IE5nYklucHV0RGF0ZXBpY2tlciB8IHVuZGVmaW5lZDtcbiAgQFZpZXdDaGlsZCgnZGF0ZVBpY2tlcklucHV0JykgZGF0ZVBpY2tlcklucHV0OiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuICBAVmlld0NoaWxkKCdkYXRlUGlja2VyUmFuZ2VJbnB1dCcpIGRhdGVQaWNrZXJSYW5nZUlucHV0OiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuICBAVmlld0NoaWxkKCdkYXRlUGlja2VySW5wdXRUbycpIGRhdGVQaWNrZXJJbnB1dFRvOiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuICBAVmlld0NoaWxkKCdkYXRlUGlja2VyQnV0dG9uJykgZGF0ZVBpY2tlckJ1dHRvbjogRWxlbWVudFJlZiB8IHVuZGVmaW5lZDtcbiAgQFZpZXdDaGlsZCgnZGF0ZVBpY2tlckJ1dHRvblRvJykgZGF0ZVBpY2tlckJ1dHRvblRvOiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuXG4gIGRhdGVJbnB1dDogRm9ybUNvbnRyb2w7XG4gIGRhdGVJbnB1dFRvOiBGb3JtQ29udHJvbDtcblxuICBwYXJlbnRGb3JtQ29udHJvbDogQWJzdHJhY3RDb250cm9sIHwgdW5kZWZpbmVkO1xuXG4gIGhvdmVyZWREYXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVNlbGVjdGlvbk1vZGVsPih7IGRhdGU6IG51bGwgfSk7XG4gIHBpY2tlckhvdmVyZWREYXlEYXRlVG86IE5nRGF0ZVN0cnVjdE51bGxhYmxlID0gbnVsbDtcblxuICBmcm9tRGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5nRGF0ZVN0cnVjdE51bGxhYmxlPihudWxsKTtcbiAgdG9EYXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8TmdEYXRlU3RydWN0TnVsbGFibGU+KG51bGwpO1xuXG4gIHJlYWRvbmx5IGlucHV0RGF0ZVJhbmdlU2VwYXJhdG9yID0gJy0nO1xuXG4gIEBIb3N0QmluZGluZygnYXR0ci5jbGFzcycpIGNzc0NsYXNzID0gJ2JiLWlucHV0LWRhdGVwaWNrZXItdWknO1xuXG4gIC8qKlxuICAgKiAgQW4gdW5saXN0ZW4gZnVuY3Rpb24gZm9yIGRpc3Bvc2luZyBkb2N1bWVudCBjbGljayBsaXN0ZW5lclxuICAgKi9cbiAgdW5MaXN0ZW5Eb2N1bWVudENsaWNrOiAoKCkgPT4gdm9pZCkgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBBbiB1bmxpc3RlbiBmdW5jdGlvbiBmb3IgZGlzcG9zaW5nIGVzY2FwZSBrZXkgbGlzdGVuZXJcbiAgICovXG4gIHVuTGlzdGVuRG9jdW1lbnRFc2M6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZvcm1hdHRlckhlbHBlcjogTmdiRGF0ZUxvY2FsZVBhcnNlckZvcm1hdHRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGVsOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCByZWFkb25seSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGRlcHJlY2F0aW9uc1NlcnZpY2U6IERlcHJlY2F0aW9uc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhZGFwdGVyOiBOZ2JEYXRlQWRhcHRlcjxzdHJpbmc+LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmVuZGVyZXIyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBkb21BdHRyU2VydmljZTogRG9tQXR0cmlidXRlc1NlcnZpY2UsXG4gICkge1xuICAgIHN1cGVyKGNkLCBkZXByZWNhdGlvbnNTZXJ2aWNlKTtcbiAgICB0aGlzLmRhdGVJbnB1dCA9IG5ldyBGb3JtQ29udHJvbChudWxsKTtcbiAgICB0aGlzLmRhdGVJbnB1dFRvID0gbmV3IEZvcm1Db250cm9sKG51bGwpO1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQgfSA9IGNoYW5nZXM7XG5cbiAgICBpZiAoZGlzYWJsZWQgJiYgZGlzYWJsZWQuY3VycmVudFZhbHVlICE9PSBkaXNhYmxlZC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRhdGVJbnB1dC5kaXNhYmxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGVJbnB1dC5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB0b2RvOiBkbyB3ZSBuZWVkIHRoaXM/XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICBjb25zdCBkYXRlcGlja2VySW5wdXQgPSB0aGlzLnJhbmdlU2VsZWN0aW9uID8gdGhpcy5kYXRlUGlja2VyUmFuZ2VJbnB1dCA6IHRoaXMuZGF0ZVBpY2tlcklucHV0O1xuICAgIHRoaXMuZG9tQXR0clNlcnZpY2UubW92ZUFyaWFBdHRyaWJ1dGVzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgZGF0ZXBpY2tlcklucHV0Py5uYXRpdmVFbGVtZW50LCB0aGlzLnJlbmRlcmVyMik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBpbnRlcm5hbCB2YWxpZGF0b3JzIGFyZSBub3QgdXNlZFxuICAgICAgdGhpcy5kYXRlSW5wdXQuc2V0VmFsaWRhdG9ycyhbXSk7XG4gICAgICB0aGlzLmRhdGVJbnB1dC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQYXNzaW5nIHRlbXBsYXRlIGRhdGUgdG8gdGhlIHJhbmdlIHRlbXBsYXRlIHRvIGlkZW50aWZ5IHdoZW4gaXQgaXMgdXNlZCBpbiB0aGUgXCJ0b1wiIGRhdGVcbiAgICogKHRoZSBzZWNvbmQgSFRNTCBkYXRlIGlucHV0IG9mIHRoZSBzcGxpdCBkYXRlcGlja2VyKS5cbiAgICogQ2hlY2sgaHR0cHM6Ly9uZy1ib290c3RyYXAuZ2l0aHViLmlvLyMvY29tcG9uZW50cy9kYXRlcGlja2VyL2FwaSBcImRheVRlbXBsYXRlRGF0YVwiIGZvciBkZXRhaWxzXG4gICAqL1xuICByYW5nZVRlbXBsYXRlRGF0YSA9ICgpID0+ICh7XG4gICAgaXNUbzogdHJ1ZSxcbiAgfSk7XG5cbiAgcHJpdmF0ZSBkYXRlRXF1YWwoeERhdGU6IE5nYkRhdGVTdHJ1Y3QsIHlEYXRlOiBOZ2JEYXRlU3RydWN0KSB7XG4gICAgY29uc3QgYSA9IG5ldyBEYXRlKHhEYXRlLnllYXIsIHhEYXRlLm1vbnRoIC0gMSwgeERhdGUuZGF5KS5nZXRUaW1lKCk7XG4gICAgY29uc3QgYiA9IG5ldyBEYXRlKHlEYXRlLnllYXIsIHlEYXRlLm1vbnRoIC0gMSwgeURhdGUuZGF5KS5nZXRUaW1lKCk7XG5cbiAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbiAgfVxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqXG4gICAqICAgICAgICBFVkVOVCBIQU5ETEVSU1xuICAgKlxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSW5wdXQgY2hhbmdlIGhhbmRsZXIgZm9yIHNpbmdsZSBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSBlbGVtZW50XG4gICAqL1xuICBvbklucHV0Q2hhbmdlKGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAvLyBDaGVja2luZyBmb3IgXCJicm93c2VyIGJ1Z1wiLCBmb3IgZXhhbXBsZSxcbiAgICAvLyBJbiBJRSBgbmV3IERhdGUoKWAgZm9yIHNob3J0IGRhdGUgZm9ybWF0IFlZIGdpdmVzIDE5WVksIGZvciBtb2Rlcm4gYnJvd3NlciBpbiBsb29rcyBsaWtlIDIwWVlcbiAgICAvLyBmb3IgdGhpcyByZWFzb24gd2UncmUgYWRkaW5nIDEwMCB5ZWFycyB0byBicm93c2VyIHVuZGVyc3RhbmQgdGhhdCBpdCBpcyAyMXN0IGNlbnR1cnlcbiAgICBjb25zdCBkYXRlSW5wdXRUb1VwZGF0ZSA9IGVsZW1lbnQubmFtZSA9PT0gJ2RhdGUnID8gdGhpcy5kYXRlSW5wdXQgOiB0aGlzLmRhdGVJbnB1dFRvO1xuXG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gZWxlbWVudDtcblxuICAgIGNvbnN0IGJyb3dzZXJEYXRlID0gbmV3IERhdGUodmFsdWUpO1xuXG4gICAgY29uc3QgcGFyc2VkRGF0ZSA9IHRoaXMuZm9ybWF0dGVySGVscGVyLmludGVycHJldERhdGUodmFsdWUpO1xuXG4gICAgaWYgKHBhcnNlZERhdGUgJiYgcGFyc2VkRGF0ZS5nZXRUaW1lKCkgIT09IGJyb3dzZXJEYXRlLmdldFRpbWUoKSkge1xuICAgICAgZGF0ZUlucHV0VG9VcGRhdGUuc2V0VmFsdWUocGFyc2VkRGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBkYXRlcGlja2VyIHZhbHVlIG9uIGlucHV0IHZhbHVlIGNoYW5nZSBmb3Igc2FtZSBpbnB1dCBkYXRlIHJhbmdlIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIG9uSW5wdXRDaGFuZ2VSYW5nZShlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gZWxlbWVudDtcblxuICAgIGNvbnN0IFtkYXRlRnJvbSwgZGF0ZVRvXSA9IHZhbHVlLnNwbGl0KHRoaXMuaW5wdXREYXRlUmFuZ2VTZXBhcmF0b3IpLnNsaWNlKDAsIDIpO1xuXG4gICAgdGhpcy5mcm9tRGF0ZSQubmV4dCh0aGlzLmZvcm1hdHRlckhlbHBlci5wYXJzZShkYXRlRnJvbT8udHJpbSgpKSk7XG4gICAgdGhpcy50b0RhdGUkLm5leHQodGhpcy5mb3JtYXR0ZXJIZWxwZXIucGFyc2UoZGF0ZVRvPy50cmltKCkpKTtcblxuICAgIGlmICh0aGlzLmZyb21EYXRlJC5nZXRWYWx1ZSgpIHx8IHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpKSB7XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlTW9kZWwodGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKSwgdGhpcy50b0RhdGUkLmdldFZhbHVlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGRhdGVwaWNrZXIgdmFsdWUgb24gaW5wdXQgdmFsdWUgY2hhbmdlIGZvciBzcGxpdCBpbnB1dCBkYXRlIHJhbmdlIHNlbGVjdGlvbiwgZnJvbSBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgb25JbnB1dENoYW5nZVNwbGl0UmFuZ2UoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGVsZW1lbnQ7XG5cbiAgICB0aGlzLmZyb21EYXRlJC5uZXh0KHRoaXMuZm9ybWF0dGVySGVscGVyLnBhcnNlKHZhbHVlICYmIHZhbHVlLnRyaW0oKSkpO1xuXG4gICAgdGhpcy51cGRhdGVSYW5nZU1vZGVsKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCksIHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGF0ZXBpY2tlciB2YWx1ZSBvbiBpbnB1dCB2YWx1ZSBjaGFuZ2UgZm9yIHNwbGl0IGlucHV0IGRhdGUgcmFuZ2Ugc2VsZWN0aW9uLCB0byBkYXRlXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgb25JbnB1dENoYW5nZVNwbGl0UmFuZ2VUbyhlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gZWxlbWVudDtcblxuICAgIHRoaXMudG9EYXRlJC5uZXh0KHRoaXMuZm9ybWF0dGVySGVscGVyLnBhcnNlKHZhbHVlICYmIHZhbHVlLnRyaW0oKSkpO1xuXG4gICAgdGhpcy51cGRhdGVSYW5nZU1vZGVsKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCksIHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB0aGUgbmF0aXZlIGlucHV0XG4gICAqL1xuICBvbklucHV0Rm9jdXMob3BlbjogYm9vbGVhbikge1xuICAgIHN1cGVyLm9uRm9jdXMoKTtcblxuICAgIGlmIChvcGVuICYmIHRoaXMuZGF0ZVBpY2tlcikge1xuICAgICAgdGhpcy5iaW5kRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZGF0ZVBpY2tlci5vcGVuKCk7XG5cbiAgICAgIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uIHx8IHRoaXMucmFuZ2VTZWxlY3Rpb25TcGxpdCkge1xuICAgICAgICB0aGlzLmRhdGVQaWNrZXIuc3RhcnREYXRlID0gdGhpcy50b0RhdGUkLmdldFZhbHVlKCkgYXMgTmdiRGF0ZVN0cnVjdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgdGhlIG5hdGl2ZSBpbnB1dFxuICAgKi9cbiAgb25JbnB1dEZvY3VzVG8ob3BlbjogYm9vbGVhbikge1xuICAgIHN1cGVyLm9uRm9jdXMoKTtcblxuICAgIGlmIChvcGVuICYmIHRoaXMuZGF0ZVBpY2tlclRvKSB7XG4gICAgICB0aGlzLmRhdGVQaWNrZXJUby5vcGVuKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSBwaWNrZXIgdG9nZ2xlIGJ1dHRvbiB0b1xuICAgKi9cbiAgb25QaWNrZXJUb2dnbGVyQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuZGF0ZVBpY2tlcikge1xuICAgICAgdGhpcy5iaW5kRG9jdW1lbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuc2V0U3RhcnREYXRlT25QaWNrZXIodGhpcy5kYXRlUGlja2VyKTtcblxuICAgICAgdGhpcy5kYXRlUGlja2VyLnRvZ2dsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciB0aGUgcGlja2VyIHRvZ2dsZSBidXR0b24gdG8gKHNwbGl0IHJhbmdlIHNlbGVjdGlvbilcbiAgICovXG4gIG9uUGlja2VyVG9nZ2xlckNsaWNrVG8oZXZlbnQ6IEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuZGF0ZVBpY2tlclRvKSB7XG4gICAgICB0aGlzLmJpbmREb2N1bWVudEV2ZW50cygpO1xuICAgICAgdGhpcy5zZXRTdGFydERhdGVPblBpY2tlcih0aGlzLmRhdGVQaWNrZXJUbyk7XG5cbiAgICAgIHRoaXMuZGF0ZVBpY2tlclRvLnRvZ2dsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBTZXQgZGlzYWJsZSBzdGF0ZSBmb3IgdGhlIGhvc3QgY29udHJvbFxuICAgKlxuICAgKiBAcGFyYW0gaXNEaXNhYmxlZFxuICAgKi9cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGF0ZUlucHV0LmRpc2FibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRlSW5wdXQuZW5hYmxlKCk7XG4gICAgfVxuICAgIHN1cGVyLnNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBibHVyIG9uIGludGVybmFsIGlucHV0cyBhbmQgYnV0dG9uc1xuICAgKlxuICAgKiBAcGFyYW0gJGV2ZW50XG4gICAqL1xuICBvbkNvbnRyb2xCbHVyKCRldmVudDogRm9jdXNFdmVudCkge1xuICAgIGlmICghJGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgIXRoaXMuZWwubmF0aXZlRWxlbWVudC5jb250YWlucygkZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHRoaXMub25CbHVyKCRldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmFuZ2VTZWxlY3Rpb24pIHtcbiAgICAgIGlmICghdGhpcy50b0RhdGUkLmdldFZhbHVlKCkgfHwgIXRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5zZXREYXRlc1RoZVNhbWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0UmFuZ2VJbnB1dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGZvciBibHVyIG9uIHRoZSBob3N0IGNvbnRyb2xcbiAgICpcbiAgICogQHBhcmFtICRldmVudFxuICAgKi9cbiAgb25CbHVyKCRldmVudD86IEZvY3VzRXZlbnQpIHtcbiAgICB0aGlzLmJsdXIuZW1pdCgkZXZlbnQpO1xuICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsb3NpbmcgYGZyb21gIG9yIHNpbmdsZSBkYXRlIHBpY2tlclxuICAgKlxuICAgKi9cbiAgb25DbG9zZWQoKSB7XG4gICAgY29uc3QgaG92ZXJlZERhdGVDbG9zZWRWYWx1ZSA9IHRoaXMuaG92ZXJlZERhdGUkLmdldFZhbHVlKCk7XG4gICAgY29uc3QgaG92ZXJlZERhdGUgPSBob3ZlcmVkRGF0ZUNsb3NlZFZhbHVlPy5kYXRlO1xuICAgIGlmIChob3ZlcmVkRGF0ZSkge1xuICAgICAgdGhpcy5zZXRTZWxlY3RlZERhdGUoeyBkYXRlOiBob3ZlcmVkRGF0ZSwgaXNTZWxlY3Rpbmc6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5yYW5nZVNlbGVjdGlvbiAmJiB0aGlzLmRhdGVQaWNrZXJCdXR0b24pIHtcbiAgICAgIHRoaXMuZGF0ZVBpY2tlckJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uU3BsaXQgJiYgdGhpcy5kYXRlUGlja2VyVG8gJiYgdGhpcy5kYXRlUGlja2VySW5wdXRUbykge1xuICAgICAgdGhpcy5kYXRlUGlja2VySW5wdXRUby5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV2ZW50IGhhbmRsZXIgZm9yIGNsb3NpbmcgcGlja2VyIGZvciBgdG9gIGRhdGVcbiAgICovXG4gIG9uQ2xvc2VkVG8oKSB7XG4gICAgaWYgKHRoaXMuZGF0ZVBpY2tlckJ1dHRvblRvICE9PSB1bmRlZmluZWQgJiYgdGhpcy5kYXRlUGlja2VyICYmICF0aGlzLmRhdGVQaWNrZXIuaXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuZGF0ZVBpY2tlckJ1dHRvblRvLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZGF0ZSBzZXR0aW5nIGZyb20gcGlja2VyIGZvciBgdG9gIGRhdGUgd2hlbiBzcGxpdCBpbnB1dCByYW5nZSBzZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIG9uUmFuZ2VEYXRlU2VsZWN0U3BsaXRUbyhkYXRlOiBOZ2JEYXRlKSB7XG4gICAgdGhpcy50b0RhdGUkLm5leHQodGhpcy5jb3B5RGF0ZUVsZW1lbnQoZGF0ZSkpO1xuXG4gICAgdGhpcy51cGRhdGVSYW5nZU1vZGVsKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCksIHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpKTtcblxuICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogRXZlbnQgaGFuZGxlciBmb3IgZGF0ZSBzZXR0aW5nIGZyb20gcGlja2VyIGZvciBgZnJvbWAgZGF0ZSB3aGVuIHNwbGl0IGlucHV0IHJhbmdlIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKi9cbiAgb25SYW5nZURhdGVTZWxlY3RTcGxpdChkYXRlOiBOZ2JEYXRlKSB7XG4gICAgdGhpcy5mcm9tRGF0ZSQubmV4dCh0aGlzLmNvcHlEYXRlRWxlbWVudChkYXRlKSk7XG5cbiAgICB0aGlzLnVwZGF0ZVJhbmdlTW9kZWwodGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKSwgdGhpcy50b0RhdGUkLmdldFZhbHVlKCkpO1xuXG4gICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgRXZlbnQgaGFuZGxlciBmb3IgZGF0ZSBzZXR0aW5nIGZyb20gcGlja2VyIHdoZW4gc2luZ2xlIGlucHV0IHJhbmdlIHNlbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKi9cbiAgb25SYW5nZURhdGVTZWxlY3QoZGF0ZTogTmdiRGF0ZSkge1xuICAgIGlmICghdGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKSAmJiAhdGhpcy50b0RhdGUkLmdldFZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZnJvbURhdGUkLm5leHQodGhpcy5jb3B5RGF0ZUVsZW1lbnQoZGF0ZSkpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLmZyb21EYXRlJC5nZXRWYWx1ZSgpICYmXG4gICAgICAhdGhpcy50b0RhdGUkLmdldFZhbHVlKCkgJiZcbiAgICAgIGRhdGUgJiZcbiAgICAgIChkYXRlLmFmdGVyKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCkpIHx8IGRhdGUuZXF1YWxzKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCkpKVxuICAgICkge1xuICAgICAgdGhpcy50b0RhdGUkLm5leHQodGhpcy5jb3B5RGF0ZUVsZW1lbnQoZGF0ZSkpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNsb3NlRGF0ZVBpY2tlcigpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW51bGwvbm8tbnVsbCAqL1xuICAgICAgdGhpcy50b0RhdGUkLm5leHQobnVsbCk7XG4gICAgICB0aGlzLmZyb21EYXRlJC5uZXh0KHRoaXMuY29weURhdGVFbGVtZW50KGRhdGUpKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVJhbmdlTW9kZWwodGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKSwgdGhpcy50b0RhdGUkLmdldFZhbHVlKCkpO1xuXG4gICAgdGhpcy5zZXRSYW5nZUlucHV0KCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogSGFuZGxpbmcgZGF5LWhvdmVyIGZyb20gZGF5LXRlbXBsYXRlIG9uIHJhbmdlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqL1xuICBvbkRheUhvdmVyKGV2ZW50OiB7IGRhdGU6IE5nRGF0ZVN0cnVjdE51bGxhYmxlOyBpc1RvOiBib29sZWFuOyBpc1NlbGVjdGluZzogYm9vbGVhbiB9KSB7XG4gICAgaWYgKGV2ZW50LmlzVG8pIHtcbiAgICAgIHRoaXMucGlja2VySG92ZXJlZERheURhdGVUbyA9IGV2ZW50LmRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWREYXRlKHsgZGF0ZTogZXZlbnQuZGF0ZSwgaXNTZWxlY3Rpbmc6IGV2ZW50LmlzU2VsZWN0aW5nIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKio4XG4gICAqXG4gICAqICBDT05UUk9MVkFMVUVBQ0NFU1NPUiBPVkVSUklERVNcbiAgICpcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGN1c3RvbSB2YWxpZGF0aW9uIGZvciB0aGUgY29udHJvbFxuICAgKlxuICAgKiBAcGFyYW0gY29udHJvbFxuICAgKi9cbiAgdmFsaWRhdGUgPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gY29udHJvbC52YWx1ZTtcblxuICAgIGlmICghdGhpcy5wYXJlbnRGb3JtQ29udHJvbCkge1xuICAgICAgdGhpcy5wYXJlbnRGb3JtQ29udHJvbCA9IGNvbnRyb2w7XG4gICAgfVxuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICBuby1udWxsL25vLW51bGwgKi9cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uIHx8IHRoaXMucmFuZ2VTZWxlY3Rpb25TcGxpdCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEYXRlUmFuZ2UodmFsdWUgYXMgRGF0ZVJhbmdlTW9kZWwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlU2luZ2xlRGF0ZSh2YWx1ZSBhcyBzdHJpbmcgfCBEYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogSW1wbGVtZW50cyB0aGUgdmFsdWUgdXBkYXRlIGZvciB0aGUgY29udHJvbFxuICAgKlxuICAgKiBAcGFyYW0gbW9kZWxcbiAgICovXG5cbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkgKi9cbiAgd3JpdGVWYWx1ZShtb2RlbDogRGF0ZVJhbmdlTW9kZWwgfCBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnJhbmdlU2VsZWN0aW9uICYmICF0aGlzLnJhbmdlU2VsZWN0aW9uU3BsaXQpIHtcbiAgICAgIHRoaXMuZGF0ZUlucHV0LnNldFZhbHVlKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycgPyBtb2RlbCA6IG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNEYXRlUmFuZ2VNb2RlbFR5cGUobW9kZWwpKSB7XG4gICAgICAgIGlmIChtb2RlbC5mcm9tICYmIHRoaXMudmFsaWRhdGVTaW5nbGVEYXRlKG1vZGVsLmZyb20pID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5mcm9tRGF0ZSQubmV4dCh0aGlzLmFkYXB0ZXIuZnJvbU1vZGVsKG1vZGVsLmZyb20pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmZyb21EYXRlJC5uZXh0KG1vZGVsLmZyb20gYXMgYW55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC50byAmJiB0aGlzLnZhbGlkYXRlU2luZ2xlRGF0ZShtb2RlbC50bykgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnRvRGF0ZSQubmV4dCh0aGlzLmFkYXB0ZXIuZnJvbU1vZGVsKG1vZGVsLnRvKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50b0RhdGUkLm5leHQobW9kZWwudG8gYXMgYW55KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcm9tRGF0ZSQubmV4dChudWxsKTtcbiAgICAgICAgdGhpcy50b0RhdGUkLm5leHQobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc2V0UmFuZ2VJbnB1dCgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uU3BsaXQpIHtcbiAgICAgICAgdGhpcy5kYXRlSW5wdXQuc2V0VmFsdWUodGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKSA/IHRoaXMuYWRhcHRlci50b01vZGVsKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCkpIDogbnVsbCk7XG4gICAgICAgIHRoaXMuZGF0ZUlucHV0VG8uc2V0VmFsdWUodGhpcy50b0RhdGUkLmdldFZhbHVlKCkgPyB0aGlzLmFkYXB0ZXIudG9Nb2RlbCh0aGlzLnRvRGF0ZSQuZ2V0VmFsdWUoKSkgOiBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqXG4gICAqICAgICAgICBQUklWQVRFIFVUSUxTXG4gICAqXG4gICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gIHByaXZhdGUgc2V0U2VsZWN0ZWREYXRlKGRhdGU6IERhdGVTZWxlY3Rpb25Nb2RlbCk6IHZvaWQge1xuICAgIHRoaXMuaG92ZXJlZERhdGUkLm5leHQoZGF0ZSk7XG4gICAgdGhpcy5mb2N1c2VkRGF0ZS5lbWl0KGRhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXREYXRlc1RoZVNhbWUoKSB7XG4gICAgY29uc3QgZnJvbURhdGUgPSB0aGlzLmZyb21EYXRlJC5nZXRWYWx1ZSgpO1xuICAgIGlmIChmcm9tRGF0ZSkge1xuICAgICAgdGhpcy50b0RhdGUkLm5leHQoZnJvbURhdGUpO1xuICAgICAgdGhpcy51cGRhdGVSYW5nZU1vZGVsKHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCksIHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpKTtcbiAgICAgIHRoaXMuc2V0UmFuZ2VJbnB1dCgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xvc2VEYXRlUGlja2VyKCkge1xuICAgIGlmICh0aGlzLmRhdGVQaWNrZXIpIHtcbiAgICAgIHRoaXMuZGF0ZVBpY2tlci5jbG9zZSgpO1xuICAgICAgaWYgKHRoaXMucmFuZ2VTZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5wYXJlbnRGb3JtQ29udHJvbD8udXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbkJsdXIoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRlUGlja2VyVG8pIHtcbiAgICAgIHRoaXMuZGF0ZVBpY2tlclRvLmNsb3NlKCk7XG4gICAgICB0aGlzLm9uQmx1cigpO1xuICAgIH1cblxuICAgIC8vIFVuYmluZCB0aGUgZ2xvYmFsIGRvY3VtZW50IGV2ZW50cyBvbmNlIHRoZSBkYXRlIHBpY2tlciBpcyBjbG9zZWRcbiAgICBpZiAodGhpcy51bkxpc3RlbkRvY3VtZW50Q2xpY2spIHtcbiAgICAgIHRoaXMudW5MaXN0ZW5Eb2N1bWVudENsaWNrKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVuTGlzdGVuRG9jdW1lbnRFc2MpIHtcbiAgICAgIHRoaXMudW5MaXN0ZW5Eb2N1bWVudEVzYygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNWYWxpZFJhbmdlKGZyb206IHN0cmluZywgdG86IHN0cmluZyk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICBpZiAobmV3IERhdGUoZnJvbSkuZ2V0VGltZSgpID4gbmV3IERhdGUodG8pLmdldFRpbWUoKSkge1xuICAgICAgcmV0dXJuIHsgaW52YWxpZERhdGVGb3JtYXQ6IHRydWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgdmFsaWRhdGVTaW5nbGVEYXRlKHZhbHVlOiBzdHJpbmcgfCBEYXRlKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIGNvbnN0IGRhdGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGluIElTTyBmb3JtYXRcbiAgICAvLyB0aGlzIG1lYW5zIHRoYXQgaXQgaGFzIHBhc3NlZCBwYXJzaW5nIGFuZCB0aGF0IGl0IGlzIGluIGRhdGUgZm9ybWF0IGZvciBjdXJyZW50IGxvY2FsZVxuICAgIC8vIFRoaXMgY2hlY2sgaXMgZm9yIElFMTFcbiAgICBjb25zdCBJU09EYXRlUmVnRXhwID0gL15cXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZFxcLlxcZCsoWystXVswLTJdXFxkOlswLTVdXFxkfFopJC9nO1xuXG4gICAgcmV0dXJuIElTT0RhdGVSZWdFeHAudGVzdChkYXRlKSA/IG51bGwgOiB7IGludmFsaWREYXRlRm9ybWF0OiB0cnVlIH07XG4gIH1cblxuICAvKipcbiAgICogRG9jdW1lbnQgRXZlbnQgaGFuZGxlclxuICAgKi9cbiAgaGFuZGxlRG9jdW1lbnRFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCB8IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmICghdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykpIHtcbiAgICAgIHRoaXMuY2xvc2VEYXRlUGlja2VyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IG9uIHRoZSBnbG9iYWwgZG9jdW1lbnQgd2hlbiB0aGUgZGF0ZXBpY2tlciBpcyBub3Qgb3BlbmVkXG4gICAqL1xuICBiaW5kRG9jdW1lbnRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuZGF0ZVBpY2tlciAmJiAhdGhpcy5kYXRlUGlja2VyLmlzT3BlbigpKSB7XG4gICAgICB0aGlzLnVuTGlzdGVuRG9jdW1lbnRDbGljayA9IHRoaXMucmVuZGVyZXIyLmxpc3RlbignZG9jdW1lbnQnLCAnY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50RXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnVuTGlzdGVuRG9jdW1lbnRFc2MgPSB0aGlzLnJlbmRlcmVyMi5saXN0ZW4oJ2RvY3VtZW50JywgJ2tleXVwLmVzY2FwZScsIHRoaXMuaGFuZGxlRG9jdW1lbnRFdmVudC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSAqL1xuICBwcml2YXRlIHZhbGlkYXRlRGF0ZVJhbmdlKHZhbHVlOiBEYXRlUmFuZ2VNb2RlbCkge1xuICAgIGxldCB2YWxpZGF0ZVRvID0gbnVsbDtcbiAgICBsZXQgdmFsaWRhdGVGcm9tID0gbnVsbDtcbiAgICBsZXQgdmFsaWRhdGVSYW5nZSA9IG51bGw7XG5cbiAgICBpZiAoIWlzRGF0ZVJhbmdlTW9kZWxUeXBlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgaW52YWxpZERhdGVGb3JtYXQ6IHRydWUgfTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZS5mcm9tICYmICF2YWx1ZS50byAmJiAhdGhpcy5pc1JlcXVpcmVkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKCF2YWx1ZS50byAmJiB2YWx1ZS5mcm9tKSB8fCAodmFsdWUudG8gJiYgIXZhbHVlLmZyb20pIHx8ICghdmFsdWUuZnJvbSAmJiAhdmFsdWUudG8gJiYgdGhpcy5pc1JlcXVpcmVkKCkpKSB7XG4gICAgICByZXR1cm4geyByZXF1aXJlZDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5mcm9tKSB7XG4gICAgICB2YWxpZGF0ZUZyb20gPSB0aGlzLnZhbGlkYXRlU2luZ2xlRGF0ZSh2YWx1ZS5mcm9tKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnRvKSB7XG4gICAgICB2YWxpZGF0ZVRvID0gdGhpcy52YWxpZGF0ZVNpbmdsZURhdGUodmFsdWUudG8pO1xuICAgIH1cbiAgICBpZiAoIXZhbGlkYXRlRnJvbSAmJiAhdmFsaWRhdGVUbyAmJiB2YWx1ZS5mcm9tICYmIHZhbHVlLnRvKSB7XG4gICAgICB2YWxpZGF0ZVJhbmdlID0gdGhpcy5pc1ZhbGlkUmFuZ2UodmFsdWUuZnJvbSwgdmFsdWUudG8pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZVRvIHx8IHZhbGlkYXRlRnJvbSB8fCB2YWxpZGF0ZVJhbmdlO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRSYW5nZUlucHV0KCkge1xuICAgIGlmICh0aGlzLmZyb21EYXRlJC5nZXRWYWx1ZSgpIHx8IHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpKSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRGcm9tID0gdGhpcy5mb3JtYXR0ZXJIZWxwZXIuZm9ybWF0KHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCkpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkVG8gPSB0aGlzLmZvcm1hdHRlckhlbHBlci5mb3JtYXQodGhpcy50b0RhdGUkLmdldFZhbHVlKCkpO1xuXG4gICAgICB0aGlzLmRhdGVJbnB1dC5zZXRWYWx1ZShcbiAgICAgICAgYCR7Zm9ybWF0dGVkRnJvbSA9PT0gbnVsbCA/IHRoaXMuZnJvbURhdGUkLmdldFZhbHVlKCkgOiBmb3JtYXR0ZWRGcm9tfSAke3RoaXMuaW5wdXREYXRlUmFuZ2VTZXBhcmF0b3J9ICR7XG4gICAgICAgICAgZm9ybWF0dGVkVG8gPT09IG51bGwgPyB0aGlzLnRvRGF0ZSQuZ2V0VmFsdWUoKSA6IGZvcm1hdHRlZFRvXG4gICAgICAgIH1gLFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW51bGwvbm8tbnVsbCAqL1xuICAgICAgdGhpcy5kYXRlSW5wdXQuc2V0VmFsdWUobnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50Rm9ybUNvbnRyb2w/LnRvdWNoZWQpIHtcbiAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb3B5RGF0ZUVsZW1lbnQoc291cmNlRGF0ZTogTmdiRGF0ZSB8IE5nYkRhdGVTdHJ1Y3QpOiBOZ2JEYXRlU3RydWN0IHtcbiAgICByZXR1cm4geyB5ZWFyOiBzb3VyY2VEYXRlLnllYXIsIG1vbnRoOiBzb3VyY2VEYXRlLm1vbnRoLCBkYXk6IHNvdXJjZURhdGUuZGF5IH0gYXMgTmdiRGF0ZVN0cnVjdDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlUmFuZ2VNb2RlbChmcm9tOiBOZ0RhdGVTdHJ1Y3ROdWxsYWJsZSwgdG86IE5nRGF0ZVN0cnVjdE51bGxhYmxlKSB7XG4gICAgdGhpcy5vbkNoYW5nZSh7XG4gICAgICBmcm9tOiBmcm9tID8gdGhpcy5hZGFwdGVyLnRvTW9kZWwoZnJvbSkgOiBudWxsLFxuICAgICAgdG86IHRvID8gdGhpcy5hZGFwdGVyLnRvTW9kZWwodG8pIDogbnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaXNSZXF1aXJlZCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRGb3JtQ29udHJvbD8udmFsaWRhdG9yKSB7XG4gICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLnBhcmVudEZvcm1Db250cm9sPy52YWxpZGF0b3Ioe30gYXMgQWJzdHJhY3RDb250cm9sKTtcblxuICAgICAgaWYgKHZhbGlkYXRvciAmJiB2YWxpZGF0b3IucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRTdGFydERhdGVPblBpY2tlcihwaWNrZXI6IE5nYklucHV0RGF0ZXBpY2tlcikge1xuICAgIGxldCBzdGFydERhdGU6IE5nRGF0ZVN0cnVjdE51bGxhYmxlID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uKSB7XG4gICAgICBzdGFydERhdGUgPSB0aGlzLmZyb21EYXRlJC5nZXRWYWx1ZSgpIGFzIE5nYkRhdGVTdHJ1Y3Q7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlU2VsZWN0aW9uU3BsaXQgJiYgdGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKT8ueWVhcikge1xuICAgICAgc3RhcnREYXRlID0gdGhpcy5mcm9tRGF0ZSQuZ2V0VmFsdWUoKSBhcyBOZ2JEYXRlU3RydWN0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5yYW5nZVNlbGVjdGlvblNwbGl0ICYmIHRoaXMudG9EYXRlJC5nZXRWYWx1ZSgpPy55ZWFyKSB7XG4gICAgICBzdGFydERhdGUgPSB0aGlzLnRvRGF0ZSQuZ2V0VmFsdWUoKSBhcyBOZ2JEYXRlU3RydWN0O1xuICAgIH1cblxuICAgIGlmICghIXN0YXJ0RGF0ZSkge1xuICAgICAgcGlja2VyLnN0YXJ0RGF0ZSA9IHN0YXJ0RGF0ZTtcbiAgICB9XG4gIH1cbn1cbiIsIjxkaXZcbiAgY2xhc3M9XCJiYi1pbnB1dC1kYXRlcGlja2VyX193cmFwcGVyXCJcbiAgW25nQ2xhc3NdPVwie1xuICAgICduZy1pbnZhbGlkJzogcGFyZW50Rm9ybUNvbnRyb2w/LmludmFsaWQsXG4gICAgJ25nLXRvdWNoZWQnOiBwYXJlbnRGb3JtQ29udHJvbD8udG91Y2hlZCxcbiAgICAnYmItaW5wdXQtZGF0ZXBpY2tlcl9fcmFuZ2Utc3BsaXQtd3JhcHBlcic6IHJhbmdlU2VsZWN0aW9uU3BsaXRcbiAgfVwiXG4+XG4gIDxsYWJlbCAqbmdJZj1cImxhYmVsXCIgY2xhc3M9XCJiYi1pbnB1dC1kYXRlcGlja2VyX19sYWJlbFwiIGZvcj1cInt7IGlkIH19XCI+e3sgbGFiZWwgfX08L2xhYmVsPlxuICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgYmItaW5wdXQtZGF0ZXBpY2tlclwiICNwb3NpdGlvblRhcmdldD5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXJhbmdlU2VsZWN0aW9uOyBlbHNlIGRhdGVSYW5nZUlucHV0XCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICBpZD1cInt7IGlkIH19XCJcbiAgICAgICAgbmFtZT1cImRhdGVcIlxuICAgICAgICBjbGFzcz1cImZvcm0tY29udHJvbCBiYi1pbnB1dC1kYXRlcGlja2VyX19pbnB1dFwiXG4gICAgICAgIFthdHRyLnBsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcbiAgICAgICAgW2F0dHIuYXJpYS1kZXNjcmliZWRieV09XCJkYXRlcGlja2VyRGVzY3JpYmVkYnlcIlxuICAgICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImFyaWFFeHBhbmRlZFwiXG4gICAgICAgIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gICAgICAgIFthdHRyLmFyaWEtaW52YWxpZF09XCJhcmlhSW52YWxpZFwiXG4gICAgICAgIFthdHRyLmFyaWEtb3duc109XCJhcmlhT3duc1wiXG4gICAgICAgIFthdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF09XCJhcmlhQWN0aXZlZGVzY2VuZGFudFwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiKCFsYWJlbCAmJiBhcmlhTGFiZWwpIHx8IG51bGxcIlxuICAgICAgICBuZ2JEYXRlcGlja2VyXG4gICAgICAgIFttaW5EYXRlXT1cIl9taW5EYXRlXCJcbiAgICAgICAgW21heERhdGVdPVwiX21heERhdGVcIlxuICAgICAgICBbbWFya0Rpc2FibGVkXT1cIm1hcmtEaXNhYmxlZFwiXG4gICAgICAgIFtyZWFkT25seV09XCJyZWFkb25seVwiXG4gICAgICAgIFtyZXF1aXJlZF09XCJyZXF1aXJlZFwiXG4gICAgICAgIFtuYXZpZ2F0aW9uXT1cIm5hdmlnYXRpb25cIlxuICAgICAgICBbZGF5VGVtcGxhdGVdPVwicmFuZ2VTZWxlY3Rpb25TcGxpdCA/IHJhbmdlRGF5IDogc2luZ2xlRGF5XCJcbiAgICAgICAgW2Rpc3BsYXlNb250aHNdPVwiZGlzcGxheU1vbnRoc1wiXG4gICAgICAgIFtmb3JtQ29udHJvbF09XCJkYXRlSW5wdXRcIlxuICAgICAgICBbcGxhY2VtZW50XT1cInBsYWNlbWVudFwiXG4gICAgICAgIFtwb3NpdGlvblRhcmdldF09XCJwb3NpdGlvblRhcmdldFwiXG4gICAgICAgIFtyZXN0b3JlRm9jdXNdPVwiIXJhbmdlU2VsZWN0aW9uU3BsaXRcIlxuICAgICAgICAobmdNb2RlbENoYW5nZSk9XCIhcmFuZ2VTZWxlY3Rpb25TcGxpdCA/IG9uQ2hhbmdlKCRldmVudCkgOiBudWxsXCJcbiAgICAgICAgKGNsaWNrKT1cIm9uSW5wdXRGb2N1cyhjbGlja09wZW4pXCJcbiAgICAgICAgKGZvY3VzKT1cIm9uSW5wdXRGb2N1cyhmb2N1c09wZW4pXCJcbiAgICAgICAgKGJsdXIpPVwib25Db250cm9sQmx1cigkZXZlbnQpXCJcbiAgICAgICAgKGlucHV0KT1cInJhbmdlU2VsZWN0aW9uU3BsaXQgPyBvbklucHV0Q2hhbmdlU3BsaXRSYW5nZShkYXRlUGlja2VySW5wdXQpIDogb25JbnB1dENoYW5nZShkYXRlUGlja2VySW5wdXQpXCJcbiAgICAgICAgKGNsb3NlZCk9XCJvbkNsb3NlZCgpXCJcbiAgICAgICAgI2RhdGVQaWNrZXI9XCJuZ2JEYXRlcGlja2VyXCJcbiAgICAgICAgI2RhdGVQaWNrZXJJbnB1dFxuICAgICAgICBbYXR0ci5kYXRhLXJvbGVdPVwiJ2lucHV0LWRhdGUtc2luZ2xlJ1wiXG4gICAgICAgIFthdHRyLmF1dG9jb21wbGV0ZV09XCJhdXRvY29tcGxldGVcIlxuICAgICAgICBbZmlyc3REYXlPZldlZWtdPVwiZmlyc3REYXlPZldlZWtcIlxuICAgICAgICAoZGF0ZVNlbGVjdCk9XCJyYW5nZVNlbGVjdGlvblNwbGl0ID8gb25SYW5nZURhdGVTZWxlY3RTcGxpdCgkZXZlbnQpIDogbnVsbFwiXG4gICAgICAgIFthdXRvQ2xvc2VdPVwiIXJhbmdlU2VsZWN0aW9uU3BsaXRcIlxuICAgICAgLz5cbiAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgIDxkaXZcbiAgICAgICpuZ0lmPVwiZGF0ZXBpY2tlckRlc2NyaWJlZGJ5ID09PSAnZGVmYXVsdERhdGVwaWNrZXJEZXNjcmliZWRieUxhYmVsJ1wiXG4gICAgICBjbGFzcz1cInNyLW9ubHlcIlxuICAgICAgYXJpYS1saXZlPVwicG9saXRlXCJcbiAgICAgIGlkPVwiZGVmYXVsdERhdGVwaWNrZXJEZXNjcmliZWRieUxhYmVsXCJcbiAgICA+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaG92ZXJlZERhdGUkIHwgYXN5bmMgYXMgaG92ZXJlZERhdGVcIj5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICAqbmdJZj1cImhvdmVyZWREYXRlLmlzU2VsZWN0aW5nOyBlbHNlIHNlbGVjdGVkRGF0ZVwiXG4gICAgICAgICAgaTE4bj1cIkRlZmF1bHQgc2VsZWN0aW5nIGRhdGUgc3RhdGUgaTE4biBtZXNzYWdlQEBkZWZhdWx0U2VsZWN0aW5nU3RhdGUud2l0aC5pMThuLnN1cHBvcnRcIlxuICAgICAgICAgID5TZWxlY3RpbmcgZGF0ZTpcbiAgICAgICAgICB7e1xuICAgICAgICAgICAgaG92ZXJlZERhdGUuZGF0ZS55ZWFyICsgJy0nICsgaG92ZXJlZERhdGUuZGF0ZS5tb250aCArICctJyArIGhvdmVyZWREYXRlLmRhdGUuZGF5IHwgZGF0ZTogJ2xvbmdEYXRlJ1xuICAgICAgICAgIH19PC9zcGFuXG4gICAgICAgID5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNzZWxlY3RlZERhdGU+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgaTE4bj1cIkRlZmF1bHQgc2VsZWN0ZWQgZGF0ZSBzdGF0ZSBpMThuIG1lc3NhZ2VAQGRlZmF1bHRTZWxlY3RlZFN0YXRlLndpdGguaTE4bi5zdXBwb3J0XCJcbiAgICAgICAgICAgICpuZ0lmPVwiaG92ZXJlZERhdGUuZGF0ZVwiXG4gICAgICAgICAgICA+U2VsZWN0ZWQgZGF0ZSBpc3t7XG4gICAgICAgICAgICAgIGhvdmVyZWREYXRlLmRhdGUueWVhciArICctJyArIGhvdmVyZWREYXRlLmRhdGUubW9udGggKyAnLScgKyBob3ZlcmVkRGF0ZS5kYXRlLmRheSB8IGRhdGU6ICdsb25nRGF0ZSdcbiAgICAgICAgICAgIH19LjwvbmctY29udGFpbmVyXG4gICAgICAgICAgPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XG4gICAgICA8YnV0dG9uXG4gICAgICAgICNkYXRlUGlja2VyQnV0dG9uXG4gICAgICAgIGJiQnV0dG9uXG4gICAgICAgIGNsYXNzPVwiYmItaW5wdXQtZGF0ZXBpY2tlcl9fY2FsZW5kYXItb3BlbmVyLWJ1dHRvblwiXG4gICAgICAgIFtjb2xvcl09XCJidG5Db2xvclwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZCB8fCByZWFkb25seVwiXG4gICAgICAgIChibHVyKT1cIm9uQ29udHJvbEJsdXIoJGV2ZW50KVwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsRm9yQnV0dG9uXCJcbiAgICAgICAgKGNsaWNrKT1cIm9uUGlja2VyVG9nZ2xlckNsaWNrKCRldmVudClcIlxuICAgICAgICBbYXR0ci5kYXRhLXJvbGVdPVwiJ3RvZ2dsZS1jYWxlbmRhci1idXR0b24nXCJcbiAgICAgID5cbiAgICAgICAgPGJiLWljb24tdWkgW2NvbG9yXT1cImljb25Db2xvclwiIFtuYW1lXT1cImljb25cIiBbc2l6ZV09XCJpY29uU2l6ZVwiPjwvYmItaWNvbi11aT5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cblxuICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAgYmItaW5wdXQtZGF0ZXBpY2tlclwiICpuZ0lmPVwicmFuZ2VTZWxlY3Rpb25TcGxpdFwiPlxuICAgIDxpbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgaWQ9XCJ0b197eyBpZCB9fVwiXG4gICAgICBuYW1lPVwiZGF0ZVRvXCJcbiAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIGJiLWlucHV0LWRhdGVwaWNrZXJfX2lucHV0XCJcbiAgICAgIFthdHRyLnBsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG4gICAgICBbYXR0ci5hcmlhLWRlc2NyaWJlZGJ5XT1cImRhdGVwaWNrZXJEZXNjcmliZWRieVwiXG4gICAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImFyaWFFeHBhbmRlZFwiXG4gICAgICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICAgICAgW2F0dHIuYXJpYS1pbnZhbGlkXT1cImFyaWFJbnZhbGlkXCJcbiAgICAgIFthdHRyLmFyaWEtb3duc109XCJhcmlhT3duc1wiXG4gICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYXJpYUFjdGl2ZWRlc2NlbmRhbnRcIlxuICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCIoIWxhYmVsICYmIGFyaWFMYWJlbCkgfHwgbnVsbFwiXG4gICAgICBuZ2JEYXRlcGlja2VyXG4gICAgICBbbWluRGF0ZV09XCJfbWluRGF0ZVwiXG4gICAgICBbbWF4RGF0ZV09XCJfbWF4RGF0ZVwiXG4gICAgICBbbWFya0Rpc2FibGVkXT1cIm1hcmtEaXNhYmxlZFwiXG4gICAgICBbcmVhZE9ubHldPVwicmVhZG9ubHlcIlxuICAgICAgW3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcbiAgICAgIFtkaXNwbGF5TW9udGhzXT1cImRpc3BsYXlNb250aHNcIlxuICAgICAgW25hdmlnYXRpb25dPVwibmF2aWdhdGlvblwiXG4gICAgICBbcmVzdG9yZUZvY3VzXT1cImZhbHNlXCJcbiAgICAgIFtkYXlUZW1wbGF0ZV09XCJyYW5nZURheVwiXG4gICAgICBbZGF5VGVtcGxhdGVEYXRhXT1cInJhbmdlVGVtcGxhdGVEYXRhXCJcbiAgICAgIFtmb3JtQ29udHJvbF09XCJkYXRlSW5wdXRUb1wiXG4gICAgICBbcGxhY2VtZW50XT1cInBsYWNlbWVudFwiXG4gICAgICAoY2xpY2spPVwib25JbnB1dEZvY3VzVG8oY2xpY2tPcGVuKVwiXG4gICAgICAoZm9jdXMpPVwib25JbnB1dEZvY3VzVG8oZm9jdXNPcGVuKVwiXG4gICAgICAoYmx1cik9XCJvbkNvbnRyb2xCbHVyKCRldmVudClcIlxuICAgICAgKGlucHV0KT1cInJhbmdlU2VsZWN0aW9uU3BsaXQgPyBvbklucHV0Q2hhbmdlU3BsaXRSYW5nZVRvKGRhdGVQaWNrZXJJbnB1dFRvKSA6IG9uSW5wdXRDaGFuZ2UoZGF0ZVBpY2tlcklucHV0VG8pXCJcbiAgICAgIChjbG9zZWQpPVwib25DbG9zZWRUbygpXCJcbiAgICAgICNkYXRlUGlja2VyVG89XCJuZ2JEYXRlcGlja2VyXCJcbiAgICAgICNkYXRlUGlja2VySW5wdXRUb1xuICAgICAgW2F0dHIuZGF0YS1yb2xlXT1cIidpbnB1dC1kYXRlLXNpbmdsZSdcIlxuICAgICAgW2F0dHIuYXV0b2NvbXBsZXRlXT1cImF1dG9jb21wbGV0ZVwiXG4gICAgICBbZmlyc3REYXlPZldlZWtdPVwiZmlyc3REYXlPZldlZWtcIlxuICAgICAgKGRhdGVTZWxlY3QpPVwicmFuZ2VTZWxlY3Rpb25TcGxpdCA/IG9uUmFuZ2VEYXRlU2VsZWN0U3BsaXRUbygkZXZlbnQpIDogbnVsbFwiXG4gICAgICBbYXV0b0Nsb3NlXT1cIiFyYW5nZVNlbGVjdGlvblNwbGl0XCJcbiAgICAvPlxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1hcHBlbmRcIj5cbiAgICAgIDxidXR0b25cbiAgICAgICAgI2RhdGVQaWNrZXJCdXR0b25Ub1xuICAgICAgICBiYkJ1dHRvblxuICAgICAgICBjbGFzcz1cImJiLWlucHV0LWRhdGVwaWNrZXJfX2NhbGVuZGFyLW9wZW5lci1idXR0b25cIlxuICAgICAgICBbY29sb3JdPVwiYnRuQ29sb3JcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbEZvckJ1dHRvblwiXG4gICAgICAgIChibHVyKT1cIm9uQ29udHJvbEJsdXIoJGV2ZW50KVwiXG4gICAgICAgIChjbGljayk9XCJvblBpY2tlclRvZ2dsZXJDbGlja1RvKCRldmVudClcIlxuICAgICAgICBbYXR0ci5kYXRhLXJvbGVdPVwiJ3RvZ2dsZS1jYWxlbmRhci1idXR0b24nXCJcbiAgICAgID5cbiAgICAgICAgPGJiLWljb24tdWkgW2NvbG9yXT1cImljb25Db2xvclwiIFtuYW1lXT1cImljb25cIiBbc2l6ZV09XCJpY29uU2l6ZVwiPjwvYmItaWNvbi11aT5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuXG48IS0tIFNpbmdsZSBpbnB1dCBkYXRlIHJhbmdlIHRlbXBsYXRlIC0tPlxuXG48bmctdGVtcGxhdGUgI2RhdGVSYW5nZUlucHV0PlxuICA8aW5wdXRcbiAgICB0eXBlPVwidGV4dFwiXG4gICAgbmFtZT1cImRhdGVcIlxuICAgIGlkPVwie3sgaWQgfX1cIlxuICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIGJiLWlucHV0LWRhdGVwaWNrZXJfX3JhbmdlXCJcbiAgICBbZm9ybUNvbnRyb2xdPVwiZGF0ZUlucHV0XCJcbiAgICBbcmVhZE9ubHldPVwicmVhZG9ubHlcIlxuICAgIFtyZXF1aXJlZF09XCJyZXF1aXJlZFwiXG4gICAgI2RhdGVQaWNrZXJSYW5nZUlucHV0XG4gICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiKCFsYWJlbCAmJiBhcmlhTGFiZWwpIHx8IG51bGxcIlxuICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiZGF0ZXBpY2tlckRlc2NyaWJlZGJ5XCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkYnlcIlxuICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiYXJpYUV4cGFuZGVkXCJcbiAgICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICAgIFthdHRyLmFyaWEtaW52YWxpZF09XCJhcmlhSW52YWxpZFwiXG4gICAgW2F0dHIuYXJpYS1vd25zXT1cImFyaWFPd25zXCJcbiAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYXJpYUFjdGl2ZWRlc2NlbmRhbnRcIlxuICAgIChjbGljayk9XCJvbklucHV0Rm9jdXMoY2xpY2tPcGVuKVwiXG4gICAgKGZvY3VzKT1cIm9uSW5wdXRGb2N1cyhmb2N1c09wZW4pXCJcbiAgICAoYmx1cik9XCJvbkNvbnRyb2xCbHVyKCRldmVudClcIlxuICAgIChpbnB1dCk9XCJvbklucHV0Q2hhbmdlUmFuZ2UoZGF0ZVBpY2tlclJhbmdlSW5wdXQpXCJcbiAgICBbYXR0ci5kYXRhLXJvbGVdPVwiJ2lucHV0LWRhdGUtcmFuZ2UnXCJcbiAgLz5cblxuICA8aW5wdXRcbiAgICB0eXBlPVwidGV4dFwiXG4gICAgY2xhc3M9XCJkYXRlcGlja2VyLWlucHV0LWhpZGRlbiBiYi1pbnB1dC1kYXRlcGlja2VyX19yYW5nZS1pbnB1dC1oaWRkZW5cIlxuICAgIG5nYkRhdGVwaWNrZXJcbiAgICAoY2xvc2VkKT1cIm9uQ2xvc2VkKClcIlxuICAgIFttaW5EYXRlXT1cIl9taW5EYXRlXCJcbiAgICBbbWF4RGF0ZV09XCJfbWF4RGF0ZVwiXG4gICAgW21hcmtEaXNhYmxlZF09XCJtYXJrRGlzYWJsZWRcIlxuICAgIFthdXRvQ2xvc2VdPVwiZmFsc2VcIlxuICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibGFiZWwgfHwgYXJpYUxhYmVsIHx8IG51bGxcIlxuICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiZGF0ZXBpY2tlckRlc2NyaWJlZGJ5XCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkYnlcIlxuICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiYXJpYUV4cGFuZGVkXCJcbiAgICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICAgIFthdHRyLmFyaWEtaW52YWxpZF09XCJhcmlhSW52YWxpZFwiXG4gICAgW2F0dHIuYXJpYS1vd25zXT1cImFyaWFPd25zXCJcbiAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiYXJpYUFjdGl2ZWRlc2NlbmRhbnRcIlxuICAgIFtyZWFkT25seV09XCJyZWFkb25seVwiXG4gICAgW3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcbiAgICBbZmlyc3REYXlPZldlZWtdPVwiZmlyc3REYXlPZldlZWtcIlxuICAgIFtwb3NpdGlvblRhcmdldF09XCJwb3NpdGlvblRhcmdldFwiXG4gICAgW3BsYWNlbWVudF09XCJwbGFjZW1lbnRcIlxuICAgICNkYXRlUGlja2VyPVwibmdiRGF0ZXBpY2tlclwiXG4gICAgW2RheVRlbXBsYXRlXT1cInJhbmdlRGF5XCJcbiAgICBuYXZpZ2F0aW9uPVwiYXJyb3dzXCJcbiAgICBbYXR0ci5kYXRhLXJvbGVdPVwiJ2lucHV0LWRhdGVwaWNrZXInXCJcbiAgICAoZGF0ZVNlbGVjdCk9XCJvblJhbmdlRGF0ZVNlbGVjdCgkZXZlbnQpXCJcbiAgLz5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gdGVtcGxhdGUgZW5kIC0tPlxuXG48IS0tIFNpbmdsZSBEYXRlIGRheSB0ZW1wbGF0ZSAtLT5cbjxuZy10ZW1wbGF0ZVxuICAjc2luZ2xlRGF5XG4gIGxldC1kYXRlPVwiZGF0ZVwiXG4gIGxldC1kaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgbGV0LXNlbGVjdGVkPVwic2VsZWN0ZWRcIlxuICBsZXQtY3VycmVudE1vbnRoPVwiY3VycmVudE1vbnRoXCJcbiAgbGV0LWRhdGE9XCJkYXRhXCJcbj5cbiAgPGJiLWlucHV0LWRhdGVwaWNrZXItc2luZ2xlLWRheS10ZW1wbGF0ZS11aVxuICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgW3NlbGVjdGVkXT1cInNlbGVjdGVkXCJcbiAgICBbY3VycmVudE1vbnRoXT1cImN1cnJlbnRNb250aFwiXG4gICAgW2RhdGVdPVwiZGF0ZVwiXG4gICAgKGhvdmVyZWQpPVwib25EYXlIb3ZlcigkZXZlbnQpXCJcbiAgICBbaG92ZXJlZERhdGVdPVwiZGF0YT8uaXNUbyA/IHBpY2tlckhvdmVyZWREYXlEYXRlVG8gOiBob3ZlcmVkRGF0ZSQuZ2V0VmFsdWUoKS5kYXRlXCJcbiAgPlxuICA8L2JiLWlucHV0LWRhdGVwaWNrZXItc2luZ2xlLWRheS10ZW1wbGF0ZS11aT5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gdGVtcGxhdGUgZW5kIC0tPlxuXG48IS0tIERhdGUgcmFuZ2UgZGF5IHRlbXBsYXRlIC0tPlxuPG5nLXRlbXBsYXRlXG4gICNyYW5nZURheVxuICBsZXQtZGF0ZT1cImRhdGVcIlxuICBsZXQtZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gIGxldC1zZWxlY3RlZD1cInNlbGVjdGVkXCJcbiAgbGV0LWN1cnJlbnRNb250aD1cImN1cnJlbnRNb250aFwiXG4gIGxldC1kYXRhPVwiZGF0YVwiXG4+XG4gIDxiYi1pbnB1dC1kYXRlcGlja2VyLXJhbmdlLWRheS10ZW1wbGF0ZS11aVxuICAgIFtkYXRlXT1cImRhdGVcIlxuICAgIFtmcm9tRGF0ZV09XCJmcm9tRGF0ZSQuZ2V0VmFsdWUoKVwiXG4gICAgW3RvRGF0ZV09XCJ0b0RhdGUkLmdldFZhbHVlKClcIlxuICAgIFtzcGxpdFJhbmdlXT1cInJhbmdlU2VsZWN0aW9uU3BsaXRcIlxuICAgIFt0b0RhdGVEYXRlcGlja2VyXT1cImRhdGE/LmlzVG9cIlxuICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgW2N1cnJlbnRNb250aF09XCJjdXJyZW50TW9udGhcIlxuICAgIChob3ZlcmVkKT1cIm9uRGF5SG92ZXIoJGV2ZW50KVwiXG4gICAgW2hvdmVyZWREYXRlXT1cImRhdGE/LmlzVG8gPyBwaWNrZXJIb3ZlcmVkRGF5RGF0ZVRvIDogaG92ZXJlZERhdGUkLmdldFZhbHVlKCkuZGF0ZVwiXG4gID5cbiAgPC9iYi1pbnB1dC1kYXRlcGlja2VyLXJhbmdlLWRheS10ZW1wbGF0ZS11aT5cbjwvbmctdGVtcGxhdGU+XG4iXX0=