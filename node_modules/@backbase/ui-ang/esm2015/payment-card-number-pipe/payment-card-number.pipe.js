import { Pipe } from '@angular/core';
import { SYNCHRONIZE_NUMBERS_MASKING } from './constants';
import { segment } from '@backbase/ui-ang/util';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/ui-ang/account-number-pipe";
import * as i2 from "@backbase/foundation-ang/future";
/**
 * @name pad
 * @inner
 * @param value - the string to pad
 * @param length - the length to pad the string to
 * @param ch - the character to pad the string width
 * @param leftPad - whether to pad left (true) or pad right (false)
 *
 * @description
 * Pad a string to specified length with specified character
 */
function pad(value, length, ch = '0', leftPad = true) {
    const paddingSize = Math.max(length - value.length, 0);
    const padding = ch.repeat(paddingSize);
    return leftPad ? padding + value : value + padding;
}
/**
 * @name mask
 * @inner
 * @param value - the string to mask
 * @param indexStart - the index to start masking from
 * @param indexEnd - the index to end masking
 * @param maskChar - the character to mask with
 *
 * @description
 * Mask part of a string with specified character
 */
function mask(value, [indexStart, indexEnd], maskChar = '*') {
    let maskedString = '';
    if (indexEnd < 0) {
        const charsToShow = value.slice(indexEnd);
        maskedString = maskChar.repeat(value.length - charsToShow.length) + charsToShow;
    }
    else {
        const maskStr = maskChar.repeat(indexEnd - indexStart);
        maskedString = value.substring(0, indexStart) + maskStr + value.substring(indexEnd);
    }
    return maskedString;
}
export class PaymentCardNumberPipe {
    /**
     * @name PaymentCardNumberPipe#constructor
     * @param accountsDisplayingFormatService - AccountsDisplayingFormatService
     * @param featuresService - FeaturesService
     *
     * @internal
     */
    constructor(accountsDisplayingFormatService, featuresService) {
        this.accountsDisplayingFormatService = accountsDisplayingFormatService;
        this.featuresService = featuresService;
        this.defaultFormat = this.accountsDisplayingFormatService.getDefaultFormat('cardNumber');
    }
    /**
     * @name PaymentCardNumberPipe#transform
     * @param value - the string to transform
     * @param config - the formatting configuration
     * @param maskChar - the character to mask with, deprecated from 6.0.0
     *
     * @description
     * Formats a card number, mask it and split it into segments
     * - do not set config parameter to use with a global accountsFormat configuration
     * - use config parameter to apply a custom accountsFormat configuration
     */
    transform(value, config, maskChar = '•') {
        const displayingFormat = config !== null && config !== void 0 ? config : this.defaultFormat;
        let formattedNumber = value.toString();
        if (config && !this.featuresService.isEnabled(SYNCHRONIZE_NUMBERS_MASKING)) {
            formattedNumber = pad(formattedNumber, config.length, maskChar);
            formattedNumber = mask(formattedNumber, config.maskRange, maskChar);
        }
        return segment(formattedNumber, displayingFormat.segments);
    }
}
PaymentCardNumberPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentCardNumberPipe, deps: [{ token: i1.AccountsDisplayingFormatService }, { token: i2.FeaturesService }], target: i0.ɵɵFactoryTarget.Pipe });
PaymentCardNumberPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentCardNumberPipe, name: "paymentCardNumber" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentCardNumberPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'paymentCardNumber',
                }]
        }], ctorParameters: function () { return [{ type: i1.AccountsDisplayingFormatService }, { type: i2.FeaturesService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF5bWVudC1jYXJkLW51bWJlci5waXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy91aS1hbmcvcGF5bWVudC1jYXJkLW51bWJlci1waXBlL3BheW1lbnQtY2FyZC1udW1iZXIucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsSUFBSSxFQUFpQixNQUFNLGVBQWUsQ0FBQztBQUVwRCxPQUFPLEVBQTJCLDJCQUEyQixFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ25GLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUdoRDs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBUyxHQUFHLENBQUMsS0FBYSxFQUFFLE1BQWMsRUFBRSxLQUFhLEdBQUcsRUFBRSxPQUFPLEdBQUcsSUFBSTtJQUMxRSxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7SUFFdkMsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUM7QUFDckQsQ0FBQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFTLElBQUksQ0FBQyxLQUFhLEVBQUUsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFtQixFQUFFLFdBQW1CLEdBQUc7SUFDM0YsSUFBSSxZQUFZLEdBQUcsRUFBRSxDQUFDO0lBRXRCLElBQUksUUFBUSxHQUFHLENBQUMsRUFBRTtRQUNoQixNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzFDLFlBQVksR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFdBQVcsQ0FBQztLQUNqRjtTQUFNO1FBQ0wsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUM7UUFDdkQsWUFBWSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxHQUFHLE9BQU8sR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3JGO0lBRUQsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQztBQUtELE1BQU0sT0FBTyxxQkFBcUI7SUFHaEM7Ozs7OztPQU1HO0lBQ0gsWUFDbUIsK0JBQWdFLEVBQ2hFLGVBQWdDO1FBRGhDLG9DQUErQixHQUEvQiwrQkFBK0IsQ0FBaUM7UUFDaEUsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBWGxDLGtCQUFhLEdBQUcsSUFBSSxDQUFDLCtCQUErQixDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO0lBWWxHLENBQUM7SUFFSjs7Ozs7Ozs7OztPQVVHO0lBQ0gsU0FBUyxDQUFDLEtBQXNCLEVBQUUsTUFBZ0MsRUFBRSxXQUFtQixHQUFHO1FBQ3hGLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUN0RCxJQUFJLGVBQWUsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFdkMsSUFBSSxNQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQywyQkFBMkIsQ0FBQyxFQUFFO1lBQzFFLGVBQWUsR0FBRyxHQUFHLENBQUMsZUFBZSxFQUFFLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDaEUsZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsTUFBTSxDQUFDLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUNyRTtRQUVELE9BQU8sT0FBTyxDQUFDLGVBQWUsRUFBRSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3RCxDQUFDOzttSEFwQ1UscUJBQXFCO2lIQUFyQixxQkFBcUI7NEZBQXJCLHFCQUFxQjtrQkFIakMsSUFBSTttQkFBQztvQkFDSixJQUFJLEVBQUUsbUJBQW1CO2lCQUMxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZlYXR1cmVzU2VydmljZSB9IGZyb20gJ0BiYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9mdXR1cmUnO1xuaW1wb3J0IHsgUGF5bWVudENhcmROdW1iZXJGb3JtYXQsIFNZTkNIUk9OSVpFX05VTUJFUlNfTUFTS0lORyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IHNlZ21lbnQgfSBmcm9tICdAYmFja2Jhc2UvdWktYW5nL3V0aWwnO1xuaW1wb3J0IHsgQWNjb3VudHNEaXNwbGF5aW5nRm9ybWF0U2VydmljZSB9IGZyb20gJ0BiYWNrYmFzZS91aS1hbmcvYWNjb3VudC1udW1iZXItcGlwZSc7XG5cbi8qKlxuICogQG5hbWUgcGFkXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gcGFkXG4gKiBAcGFyYW0gbGVuZ3RoIC0gdGhlIGxlbmd0aCB0byBwYWQgdGhlIHN0cmluZyB0b1xuICogQHBhcmFtIGNoIC0gdGhlIGNoYXJhY3RlciB0byBwYWQgdGhlIHN0cmluZyB3aWR0aFxuICogQHBhcmFtIGxlZnRQYWQgLSB3aGV0aGVyIHRvIHBhZCBsZWZ0ICh0cnVlKSBvciBwYWQgcmlnaHQgKGZhbHNlKVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUGFkIGEgc3RyaW5nIHRvIHNwZWNpZmllZCBsZW5ndGggd2l0aCBzcGVjaWZpZWQgY2hhcmFjdGVyXG4gKi9cbmZ1bmN0aW9uIHBhZCh2YWx1ZTogc3RyaW5nLCBsZW5ndGg6IG51bWJlciwgY2g6IHN0cmluZyA9ICcwJywgbGVmdFBhZCA9IHRydWUpIHtcbiAgY29uc3QgcGFkZGluZ1NpemUgPSBNYXRoLm1heChsZW5ndGggLSB2YWx1ZS5sZW5ndGgsIDApO1xuICBjb25zdCBwYWRkaW5nID0gY2gucmVwZWF0KHBhZGRpbmdTaXplKTtcblxuICByZXR1cm4gbGVmdFBhZCA/IHBhZGRpbmcgKyB2YWx1ZSA6IHZhbHVlICsgcGFkZGluZztcbn1cblxuLyoqXG4gKiBAbmFtZSBtYXNrXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB2YWx1ZSAtIHRoZSBzdHJpbmcgdG8gbWFza1xuICogQHBhcmFtIGluZGV4U3RhcnQgLSB0aGUgaW5kZXggdG8gc3RhcnQgbWFza2luZyBmcm9tXG4gKiBAcGFyYW0gaW5kZXhFbmQgLSB0aGUgaW5kZXggdG8gZW5kIG1hc2tpbmdcbiAqIEBwYXJhbSBtYXNrQ2hhciAtIHRoZSBjaGFyYWN0ZXIgdG8gbWFzayB3aXRoXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNYXNrIHBhcnQgb2YgYSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgY2hhcmFjdGVyXG4gKi9cbmZ1bmN0aW9uIG1hc2sodmFsdWU6IHN0cmluZywgW2luZGV4U3RhcnQsIGluZGV4RW5kXTogW251bWJlciwgbnVtYmVyXSwgbWFza0NoYXI6IHN0cmluZyA9ICcqJykge1xuICBsZXQgbWFza2VkU3RyaW5nID0gJyc7XG5cbiAgaWYgKGluZGV4RW5kIDwgMCkge1xuICAgIGNvbnN0IGNoYXJzVG9TaG93ID0gdmFsdWUuc2xpY2UoaW5kZXhFbmQpO1xuICAgIG1hc2tlZFN0cmluZyA9IG1hc2tDaGFyLnJlcGVhdCh2YWx1ZS5sZW5ndGggLSBjaGFyc1RvU2hvdy5sZW5ndGgpICsgY2hhcnNUb1Nob3c7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWFza1N0ciA9IG1hc2tDaGFyLnJlcGVhdChpbmRleEVuZCAtIGluZGV4U3RhcnQpO1xuICAgIG1hc2tlZFN0cmluZyA9IHZhbHVlLnN1YnN0cmluZygwLCBpbmRleFN0YXJ0KSArIG1hc2tTdHIgKyB2YWx1ZS5zdWJzdHJpbmcoaW5kZXhFbmQpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tlZFN0cmluZztcbn1cblxuQFBpcGUoe1xuICBuYW1lOiAncGF5bWVudENhcmROdW1iZXInLFxufSlcbmV4cG9ydCBjbGFzcyBQYXltZW50Q2FyZE51bWJlclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0Rm9ybWF0ID0gdGhpcy5hY2NvdW50c0Rpc3BsYXlpbmdGb3JtYXRTZXJ2aWNlLmdldERlZmF1bHRGb3JtYXQoJ2NhcmROdW1iZXInKTtcblxuICAvKipcbiAgICogQG5hbWUgUGF5bWVudENhcmROdW1iZXJQaXBlI2NvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBhY2NvdW50c0Rpc3BsYXlpbmdGb3JtYXRTZXJ2aWNlIC0gQWNjb3VudHNEaXNwbGF5aW5nRm9ybWF0U2VydmljZVxuICAgKiBAcGFyYW0gZmVhdHVyZXNTZXJ2aWNlIC0gRmVhdHVyZXNTZXJ2aWNlXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBhY2NvdW50c0Rpc3BsYXlpbmdGb3JtYXRTZXJ2aWNlOiBBY2NvdW50c0Rpc3BsYXlpbmdGb3JtYXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZmVhdHVyZXNTZXJ2aWNlOiBGZWF0dXJlc1NlcnZpY2UsXG4gICkge31cblxuICAvKipcbiAgICogQG5hbWUgUGF5bWVudENhcmROdW1iZXJQaXBlI3RyYW5zZm9ybVxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0gY29uZmlnIC0gdGhlIGZvcm1hdHRpbmcgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0gbWFza0NoYXIgLSB0aGUgY2hhcmFjdGVyIHRvIG1hc2sgd2l0aCwgZGVwcmVjYXRlZCBmcm9tIDYuMC4wXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGb3JtYXRzIGEgY2FyZCBudW1iZXIsIG1hc2sgaXQgYW5kIHNwbGl0IGl0IGludG8gc2VnbWVudHNcbiAgICogLSBkbyBub3Qgc2V0IGNvbmZpZyBwYXJhbWV0ZXIgdG8gdXNlIHdpdGggYSBnbG9iYWwgYWNjb3VudHNGb3JtYXQgY29uZmlndXJhdGlvblxuICAgKiAtIHVzZSBjb25maWcgcGFyYW1ldGVyIHRvIGFwcGx5IGEgY3VzdG9tIGFjY291bnRzRm9ybWF0IGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBjb25maWc/OiBQYXltZW50Q2FyZE51bWJlckZvcm1hdCwgbWFza0NoYXI6IHN0cmluZyA9ICfigKInKTogc3RyaW5nIHtcbiAgICBjb25zdCBkaXNwbGF5aW5nRm9ybWF0ID0gY29uZmlnID8/IHRoaXMuZGVmYXVsdEZvcm1hdDtcbiAgICBsZXQgZm9ybWF0dGVkTnVtYmVyID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgIGlmIChjb25maWcgJiYgIXRoaXMuZmVhdHVyZXNTZXJ2aWNlLmlzRW5hYmxlZChTWU5DSFJPTklaRV9OVU1CRVJTX01BU0tJTkcpKSB7XG4gICAgICBmb3JtYXR0ZWROdW1iZXIgPSBwYWQoZm9ybWF0dGVkTnVtYmVyLCBjb25maWcubGVuZ3RoLCBtYXNrQ2hhcik7XG4gICAgICBmb3JtYXR0ZWROdW1iZXIgPSBtYXNrKGZvcm1hdHRlZE51bWJlciwgY29uZmlnLm1hc2tSYW5nZSwgbWFza0NoYXIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWdtZW50KGZvcm1hdHRlZE51bWJlciwgZGlzcGxheWluZ0Zvcm1hdC5zZWdtZW50cyk7XG4gIH1cbn1cbiJdfQ==