import * as i0 from '@angular/core';
import { Directive, Input, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { startWith, filter, takeUntil } from 'rxjs/operators';
import '@angular/localize/init';

var ValueDiffPosition;
(function (ValueDiffPosition) {
    ValueDiffPosition["BEFORE"] = "before";
    ValueDiffPosition["AFTER"] = "after";
})(ValueDiffPosition || (ValueDiffPosition = {}));
const highlightValueClass = 'bb-value-diff--highlighted';
const crossOutValueClass = 'bb-value-diff--crossed';
const valueDiffArrowLeftClass = 'bb-value-diff--arrow-left';
const valueDiffArrowRightClass = 'bb-value-diff--arrow-right';
const srTextForNewVal = $localize `:@@value-diff-current-value-label:Current value:`;
const srTextForOldVal = $localize `:@@value-diff-previous-value-label:Previous value:`;

class ValueDiffDirective {
    constructor(elRef, renderer, cdRef) {
        this.elRef = elRef;
        this.renderer = renderer;
        this.cdRef = cdRef;
        this.destroyed$ = new Subject();
        this.valueChanged$ = new Subject();
        this.SROnlyOldEl = this.createA11ySpan(srTextForOldVal);
        this.SROnlyNewEl = this.createA11ySpan(srTextForNewVal);
        this._newValue = '';
        this._position = ValueDiffPosition.BEFORE;
        /**
         * Show arrow between old and new value
         * Default value: false
         */
        this.showArrow = false;
    }
    /**
     * New data with which we will compare content.
     */
    set newValue(value) {
        this._newValue = value;
        this.onValueChanged(value);
    }
    get newValue() {
        return this._newValue;
    }
    /**
     * A position where differences will be added.
     * Default value: 'before'
     */
    set position(val) {
        this._position = val;
        this.onValueChanged(this._newValue);
    }
    get position() {
        return this._position;
    }
    /**
     * Text for screen reader to describe old value
     * Default value: 'Previous value:'
     */
    set SROnlyOld(val) {
        this.renderer.setProperty(this.SROnlyOldEl, 'textContent', val);
    }
    /**
     * Text for screen reader to describe new value
     * Default value: 'Current value:'
     */
    set SROnlyNew(val) {
        this.renderer.setProperty(this.SROnlyNewEl, 'textContent', val);
    }
    static isEqual(newData, initialEl) {
        return initialEl.innerText.trim() === newData;
    }
    get isPositionBefore() {
        return this._position === ValueDiffPosition.BEFORE;
    }
    get parentEl() {
        return this.elRef.nativeElement.parentElement;
    }
    ngAfterContentInit() {
        const changedEl = this.elRef.nativeElement.cloneNode(true);
        this.valueChanged$
            .pipe(startWith({ newData: this._newValue, elRef: this.elRef }), filter(({ newData }) => !ValueDiffDirective.isEqual(newData, this.elRef.nativeElement)), takeUntil(this.destroyed$))
            .subscribe(({ newData }) => {
            this.cdRef.detectChanges();
            this.renderer.setProperty(changedEl, 'textContent', newData);
            this.setupContainer(changedEl);
        });
    }
    ngOnDestroy() {
        this.destroyed$.next();
    }
    setupContainer(changedEl) {
        const { nativeElement } = this.elRef;
        if (ValueDiffDirective.isEqual(changedEl.innerText, nativeElement)) {
            this.cleanUpContent(changedEl);
        }
        else {
            this.renderer.addClass(changedEl, highlightValueClass);
            this.renderer.addClass(nativeElement, crossOutValueClass);
            this.renderer.insertBefore(this.parentEl, changedEl, this.getSiblingEl());
            this.renderer.insertBefore(this.parentEl, this.SROnlyNewEl, changedEl);
            if (this.showArrow) {
                this.addElWithArrow();
            }
            this.renderer.insertBefore(this.parentEl, this.SROnlyOldEl, nativeElement);
        }
    }
    cleanUpContent(changedEl) {
        this.renderer.removeClass(changedEl, highlightValueClass);
        this.renderer.removeClass(this.elRef.nativeElement, crossOutValueClass);
        this.renderer.removeChild(this.parentEl, changedEl);
        this.renderer.removeChild(this.parentEl, this.SROnlyOldEl);
        this.renderer.removeChild(this.parentEl, this.SROnlyNewEl);
        if (this.arrow) {
            this.renderer.removeChild(this.parentEl, this.arrow);
        }
    }
    createA11ySpan(content) {
        const SROnlySpan = this.renderer.createElement('span');
        this.renderer.addClass(SROnlySpan, 'sr-only');
        this.renderer.setProperty(SROnlySpan, 'textContent', content);
        return SROnlySpan;
    }
    addElWithArrow() {
        if (!this.arrow) {
            const iconClass = this.isPositionBefore ? valueDiffArrowLeftClass : valueDiffArrowRightClass;
            this.arrow = this.renderer.createElement('i');
            this.renderer.addClass(this.arrow, iconClass);
        }
        this.renderer.insertBefore(this.parentEl, this.arrow, this.getSiblingEl());
    }
    getSiblingEl() {
        return this.isPositionBefore ? this.elRef.nativeElement : this.elRef.nativeElement.nextElementSibling;
    }
    onValueChanged(newData) {
        this.valueChanged$.next({ newData });
    }
}
ValueDiffDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValueDiffDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
ValueDiffDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: ValueDiffDirective, selector: "[bbValueDiff]", inputs: { newValue: ["bbValueDiff", "newValue"], position: "position", SROnlyOld: ["sr-only-old", "SROnlyOld"], SROnlyNew: ["sr-only-new", "SROnlyNew"], showArrow: "showArrow" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValueDiffDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbValueDiff]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { newValue: [{
                type: Input,
                args: ['bbValueDiff']
            }], position: [{
                type: Input
            }], SROnlyOld: [{
                type: Input,
                args: ['sr-only-old']
            }], SROnlyNew: [{
                type: Input,
                args: ['sr-only-new']
            }], showArrow: [{
                type: Input
            }] } });

class ValueDiffDirectiveModule {
}
ValueDiffDirectiveModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValueDiffDirectiveModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ValueDiffDirectiveModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValueDiffDirectiveModule, declarations: [ValueDiffDirective], imports: [CommonModule], exports: [ValueDiffDirective] });
ValueDiffDirectiveModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValueDiffDirectiveModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ValueDiffDirectiveModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [ValueDiffDirective],
                    exports: [ValueDiffDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ValueDiffDirective, ValueDiffDirectiveModule, ValueDiffPosition };
//# sourceMappingURL=backbase-ui-ang-value-diff.js.map
