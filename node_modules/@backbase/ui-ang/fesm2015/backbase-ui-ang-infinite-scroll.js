import * as i0 from '@angular/core';
import { EventEmitter, Component, Output, Input, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs';
import { debounceTime, map, filter, takeUntil } from 'rxjs/operators';

/**
 * @name InfiniteScrollComponent
 *
 * @description
 * Component that displays an infinite scroll.
 */
class InfiniteScrollComponent {
    constructor(elRef) {
        this.elRef = elRef;
        /**
         * Event that will be triggered when user has scrolled to
         * bottom of the element
         */
        this.scrollEnd = new EventEmitter();
        /**
         * An offset from the bottom of the element to trigger
         * `scrollEnd` event
         */
        this.offset = 0;
        /**
         * Specify debounce duration in ms
         */
        this.debounce = 100;
        /**
         * If true then `scrollEnd` event should NOT be emitted
         */
        this.disableScrollEnd = false;
        /**
         * Emits a new value on element scroll event
         */
        this.scroll$ = new Subject();
        /**
         * Completes on component destroy lifecycle event
         * used to unsubscribe from infinite observables
         */
        this.ngUnsubscribe$ = new Subject();
    }
    /**
     * Subscribe to `scroll$` observable and emit `scrollEnd` event
     * when element scroll position is at the end of the element
     */
    ngAfterViewInit() {
        this.scroll$
            .pipe(debounceTime(this.debounce), map((scroll) => {
            const y = scroll.y + this.offset;
            return { y, height: scroll.height };
        }), filter(() => !this.disableScrollEnd), filter((scroll) => scroll.y >= scroll.height), takeUntil(this.ngUnsubscribe$))
            .subscribe(() => this.scrollEnd.emit());
    }
    onScroll(scrollTop, scrollheight, offsetHeight) {
        const height = scrollheight;
        const y = scrollTop + offsetHeight;
        this.scroll$.next({ y, height });
    }
    onMouseOver(evTarget) {
        const hasScroll = this.elRef.nativeElement.scrollHeight > this.elRef.nativeElement.clientHeight;
        const firstElementChild = this.elRef.nativeElement.firstElementChild;
        const lastElementChild = firstElementChild && firstElementChild.lastElementChild;
        const isLastElement = evTarget && (lastElementChild === evTarget.parentElement || lastElementChild === evTarget);
        if (!this.disableScrollEnd && !hasScroll && isLastElement) {
            this.scroll$.next({ height: 0, y: 0 });
        }
    }
    /**
     * trigger `ngUnsubscribe` complete on
     * component destroy lifecycle hook
     */
    ngOnDestroy() {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
}
InfiniteScrollComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InfiniteScrollComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
InfiniteScrollComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InfiniteScrollComponent, selector: "bb-infinite-scroll-ui", inputs: { offset: "offset", debounce: "debounce", disableScrollEnd: "disableScrollEnd" }, outputs: { scrollEnd: "scrollEnd" }, host: { listeners: { "scroll": "onScroll($event.target.scrollTop,$event.target.scrollHeight,$event.target.offsetHeight)", "mouseover": "onMouseOver($event.target)", "touchmove": "onMouseOver()" } }, ngImport: i0, template: "<ng-content></ng-content>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InfiniteScrollComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-infinite-scroll-ui',
                    templateUrl: './infinite-scroll.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { scrollEnd: [{
                type: Output
            }], offset: [{
                type: Input
            }], debounce: [{
                type: Input
            }], disableScrollEnd: [{
                type: Input
            }], onScroll: [{
                type: HostListener,
                args: ['scroll', ['$event.target.scrollTop', '$event.target.scrollHeight', '$event.target.offsetHeight']]
            }], onMouseOver: [{
                type: HostListener,
                args: ['mouseover', ['$event.target']]
            }, {
                type: HostListener,
                args: ['touchmove']
            }] } });

class InfiniteScrollModule {
}
InfiniteScrollModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InfiniteScrollModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
InfiniteScrollModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InfiniteScrollModule, declarations: [InfiniteScrollComponent], imports: [CommonModule], exports: [InfiniteScrollComponent] });
InfiniteScrollModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InfiniteScrollModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InfiniteScrollModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [InfiniteScrollComponent],
                    exports: [InfiniteScrollComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { InfiniteScrollComponent, InfiniteScrollModule };
//# sourceMappingURL=backbase-ui-ang-infinite-scroll.js.map
