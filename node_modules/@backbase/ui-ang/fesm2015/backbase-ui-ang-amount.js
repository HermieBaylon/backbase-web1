import * as i1 from '@angular/common';
import { getNumberOfCurrencyDigits, getLocaleNumberFormat, NumberFormatStyle, getLocaleNumberSymbol, NumberSymbol, getCurrencySymbol, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { LOCALE_ID, Component, ChangeDetectionStrategy, Inject, Input, NgModule } from '@angular/core';
import BigNumber from 'bignumber.js';

/**
 * @name AmountComponent
 *
 * @description
 * Component for representing amount in currency format .
 *
 * @dynamic (to suppress error with resolving statics declarations during compilation)
 *
 * @a11y
 * The amount component doesn't provide any specific properties for accessibility. But handles accessibility internally.
 *
 */
class AmountComponent {
    constructor(locale) {
        this.locale = locale;
        /**
         * Determines currency type.
         * If nothing provided, wouldn't be displayed.
         */
        this.currency = '';
        /**
         * If "true" and amount is positive adds plus sign at the beginning.
         * Default value false.
         */
        this.showPlusSign = false;
        /**
         * Whether currency local should be transformed to symbol.
         * Default value true.
         */
        this.mapCurrency = true;
        /**
         * Whether percent symbol should be shown.
         * Default value false.
         */
        this.showPercent = false;
        /**
         * Whether abbreviation should be applied.
         * Default value false.
         */
        this.abbreviate = false;
        /**
         * Whether to display trailing zeroes.
         * Default value true
         */
        this.trailingZeroes = true;
        this._amountValue = new BigNumber(NaN);
        this.setupConfiguration();
    }
    ngOnChanges() {
        if (this.isUnsafeAmount) {
            console.warn('[bb-amount]: the amount was passed as a non safe number, the display can be wrong');
        }
        this.updateNumberFormat();
        this._amountValue = new BigNumber(this.amount);
        this.amountTemplate = this.getAmountTemplate(this.transformedAmount);
    }
    get isNumeric() {
        return !this._amountValue.isNaN();
    }
    get isPositive() {
        return this._amountValue.isPositive();
    }
    get isZero() {
        return this._amountValue.isZero();
    }
    get isUnsafeAmount() {
        return (typeof this.amount === 'number' &&
            (this.amount > Number.MAX_SAFE_INTEGER ||
                this.amount.toString().replace(/\D/, '').length > AmountComponent.maxSafeIntegerLength));
    }
    get configDecimalPlaces() {
        return this.decimalPlaces === undefined ? getNumberOfCurrencyDigits(this.currency) : this.decimalPlaces;
    }
    /**
     * Currency format depends on locale and could be represented for negative and
     * positive values differently (separated by `;` symbol).
     * See more http://cldr.unicode.org/translation/numbers-currency/number-patterns
     *
     * Example:
     * en-NL locale: '¤ #,##0.00;¤ -#,##0.00'
     */
    get amountFormat() {
        const { currencyFormat, decimalFormat, percentFormat, minusSymbol, plusSymbol } = AmountComponent.localeConfig;
        let formatPattern = decimalFormat;
        if (this.showPercent) {
            formatPattern = percentFormat;
        }
        if (this.currency) {
            if (this.showPercent) {
                console.warn('[bb-amount]: wrong configuration, `currency` and `showPercent` were set at the same time, therefore showPercent format will be ignored');
            }
            formatPattern = currencyFormat;
        }
        const [generalPattern, negativePattern] = formatPattern.split(';');
        if (this.isZero) {
            return generalPattern;
        }
        else if (this.isPositive) {
            return this.showPlusSign ? plusSymbol + generalPattern : generalPattern;
        }
        else {
            return negativePattern || minusSymbol + generalPattern;
        }
    }
    get transformedAmount() {
        const positiveAmount = this._amountValue.abs();
        const configDecimalPlaces = this.configDecimalPlaces;
        const shouldAbbreviate = this.abbreviate && positiveAmount.isGreaterThanOrEqualTo(AmountComponent.abbreviationConfig.minAmount);
        /**
         * Example:
         *
         * {@link groupSymbol} = ','
         * {@link decimalSymbol} = '.'
         * {@link configDecimalPlaces} = '2'
         *
         * Here how regexp source looks line with config above: ([\d,]+[.]\d{2}).*
         * This regexp has two selections:
         * - selection for the group `([\d,]+[.]\d{2})` to match the decimal precision (no rounding)
         * - and full string selection `.*` (used to replace full string with the group)
         *
         * REGEXP GROUP MATCHES ONLY THE AMOUNTS THAT HAVE TO BE UPDATED (TRIMMED)
         *
         * There are the cases when it does not have an effect, and it means that amount is already in appropriate format
         */
        const regexp = new RegExp(`([\\d${this.groupSymbol}]+[${this.decimalSymbol}]\\d{${configDecimalPlaces}}).*`, 'g');
        const amount = shouldAbbreviate ? this.getAbbreviatedAmount(positiveAmount) : positiveAmount;
        const amountDecimalPlaces = amount.decimalPlaces();
        // In order to keep the precision keeping the original decimal places and replace with regexp
        const formattedAmount = amount
            .toFormat(amountDecimalPlaces, BigNumber.ROUND_CEIL, this.numberFormat)
            .replace(regexp, '$1');
        return this.getAmountWithZeroPaddings(formattedAmount, configDecimalPlaces, amountDecimalPlaces);
    }
    getAmountWithZeroPaddings(formattedAmount, configDecimalPlaces, amountDecimalPlaces) {
        if (!this.trailingZeroes || amountDecimalPlaces >= configDecimalPlaces) {
            return formattedAmount;
        }
        const amountOfZeros = configDecimalPlaces - amountDecimalPlaces;
        let stringToAppend = '0'.repeat(amountOfZeros);
        if (!formattedAmount.includes(this.decimalSymbol)) {
            stringToAppend = this.decimalSymbol + stringToAppend;
        }
        return formattedAmount + stringToAppend;
    }
    setupConfiguration() {
        if (!AmountComponent.localeConfig) {
            AmountComponent.localeConfig = {
                currencyFormat: getLocaleNumberFormat(this.locale, NumberFormatStyle.Currency),
                decimalFormat: getLocaleNumberFormat(this.locale, NumberFormatStyle.Decimal),
                percentFormat: getLocaleNumberFormat(this.locale, NumberFormatStyle.Percent),
                decimalSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.Decimal),
                groupSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.Group),
                currencyGroupSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.CurrencyGroup),
                currencyDecimalSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.CurrencyDecimal),
                minusSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.MinusSign),
                plusSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.PlusSign),
                percentSymbol: getLocaleNumberSymbol(this.locale, NumberSymbol.PercentSign),
            };
        }
    }
    updateNumberFormat() {
        const { decimalSymbol, currencyDecimalSymbol, groupSymbol, currencyGroupSymbol } = AmountComponent.localeConfig;
        this.groupSymbol = this.currency ? currencyGroupSymbol : groupSymbol;
        this.decimalSymbol = this.currency ? currencyDecimalSymbol : decimalSymbol;
        this.numberFormat = {
            groupSeparator: this.groupSymbol,
            decimalSeparator: this.decimalSymbol,
            groupSize: 3,
        };
    }
    /**
     * Converts original amount to abbreviated
     * Max abbreviated suffix value is 'T' (trillion) see {@link AmountComponent.abbreviationConfig}
     */
    getAbbreviatedAmount(positiveAmount) {
        const suffixes = AmountComponent.abbreviationConfig.suffixes;
        const config = { suffix: suffixes[0], amount: positiveAmount.shiftedBy(-3) };
        for (let i = 1; i < suffixes.length; i++) {
            if (!config.amount.isGreaterThanOrEqualTo(1000)) {
                break;
            }
            config.suffix = suffixes[i];
            config.amount = config.amount.shiftedBy(-3);
        }
        this.abbreviationSuffix = config.suffix;
        return config.amount;
    }
    getAmountTemplate(amount) {
        const { percentSymbol, minusSymbol, plusSymbol } = AmountComponent.localeConfig;
        const signSymbol = this.isPositive ? plusSymbol : minusSymbol;
        const currencySymbol = this.mapCurrency ? getCurrencySymbol(this.currency, 'wide', this.locale) : this.currency;
        return this.amountFormat
            .replace(signSymbol, this.fillTemplate('sign', signSymbol))
            .replace('¤', this.fillTemplate('currency', currencySymbol))
            .replace('%', this.fillTemplate('percent', percentSymbol))
            .replace(/[#0,.]+/g, this.wrapAmount(amount));
    }
    wrapAmount(amount) {
        const [integer, decimals] = amount.split(this.decimalSymbol);
        return (this.fillTemplate('integer', integer) +
            (decimals ? this.fillTemplate('separator', this.decimalSymbol) + this.fillTemplate('decimals', decimals) : ''));
    }
    fillTemplate(templateKey, value) {
        return AmountComponent.templates[templateKey].replace(AmountComponent.placeholder, value);
    }
}
AmountComponent.placeholder = '{{}}';
AmountComponent.templates = {
    sign: `<span class="sign">${AmountComponent.placeholder}</span>`,
    currency: `<span class="symbol">${AmountComponent.placeholder}</span>`,
    integer: `<span class="integer">${AmountComponent.placeholder}</span>`,
    separator: `<span class="decimal-separator">${AmountComponent.placeholder}</span>`,
    decimals: `<span class="decimals">${AmountComponent.placeholder}</span>`,
    percent: `<span class="percent">${AmountComponent.placeholder}</span>`,
};
AmountComponent.abbreviationConfig = {
    minAmount: 100000,
    suffixes: ['K', 'M', 'B', 'T'],
};
AmountComponent.maxSafeIntegerLength = Number.MAX_SAFE_INTEGER.toString().length;
AmountComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountComponent, deps: [{ token: LOCALE_ID }], target: i0.ɵɵFactoryTarget.Component });
AmountComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: AmountComponent, selector: "bb-amount-ui", inputs: { currency: "currency", showPlusSign: "showPlusSign", mapCurrency: "mapCurrency", showPercent: "showPercent", abbreviate: "abbreviate", decimalPlaces: "decimalPlaces", trailingZeroes: "trailingZeroes", amount: "amount" }, usesOnChanges: true, ngImport: i0, template: "<span *ngIf=\"isNumeric\" data-role=\"bb-amount-value\" class=\"bb-amount\">\n  <span [innerHtml]=\"amountTemplate\" class=\"amount bb-amount__value\" data-role=\"bb-amount-value__amount\"></span>\n  <ng-container *ngIf=\"abbreviationSuffix\"\n    >&nbsp;<span class=\"sr-only\" i18n=\"Amount abbreviation long suffix@@bb-amount-ui.abbr.long\" #abbrTitle\n      >{ abbreviationSuffix, select, K {Thousand} M {Million} B {Billion} T {Trillion} }</span\n    ><abbr\n      [title]=\"abbrTitle.textContent\"\n      aria-hidden=\"true\"\n      data-role=\"bb-amount-value__abbreviation\"\n      i18n=\"Amount abbreviation short suffix@@bb-amount-ui.abbr.short\"\n      class=\"abbreviation bb-amount__abbreviation\"\n      >{ abbreviationSuffix, select, K {K} M {M} B {B} T {T} }</abbr\n    >\n  </ng-container>\n</span>\n", directives: [{ type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-amount-ui',
                    templateUrl: './amount.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }]; }, propDecorators: { currency: [{
                type: Input
            }], showPlusSign: [{
                type: Input
            }], mapCurrency: [{
                type: Input
            }], showPercent: [{
                type: Input
            }], abbreviate: [{
                type: Input
            }], decimalPlaces: [{
                type: Input
            }], trailingZeroes: [{
                type: Input
            }], amount: [{
                type: Input
            }] } });

class AmountModule {
}
AmountModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
AmountModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountModule, declarations: [AmountComponent], imports: [CommonModule], exports: [AmountComponent] });
AmountModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AmountModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [AmountComponent],
                    exports: [AmountComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AmountComponent, AmountModule, AmountComponent as FormatAmountComponent, AmountModule as FormatAmountModule };
//# sourceMappingURL=backbase-ui-ang-amount.js.map
