import * as i0 from '@angular/core';
import { Injectable, EventEmitter, TemplateRef, Component, Inject, Input, Output, ViewChild, HostBinding, HostListener, NgModule } from '@angular/core';
import * as i3 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { getBemModifiers, fadeSlideAnimation } from '@backbase/ui-ang/util';
import * as i2 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import * as i4 from '@backbase/ui-ang/focus';
import { FocusModule } from '@backbase/ui-ang/focus';
import * as i5 from '@backbase/ui-ang/keyboard-click-directive';
import { KeyboardClickModule } from '@backbase/ui-ang/keyboard-click-directive';
import * as i6 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import { Subject } from 'rxjs';
import { first } from 'rxjs/operators';
import { NgbAlertModule } from '@ng-bootstrap/ng-bootstrap';

class AppendToDomService {
    constructor(componentFactoryResolver, appRef, injector) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.injector = injector;
    }
    appendComponentToRoot(component, autofocus = true, projectables = [], root = document.body) {
        var _a, _b;
        // 1. Create a component reference from the component
        const componentRef = this.componentFactoryResolver
            .resolveComponentFactory(component)
            .create(this.injector, [projectables]);
        // 2. Attach component to the appRef so that it's inside the ng component tree
        this.appRef.attachView(componentRef.hostView);
        // 3. Get DOM element from component
        const domElem = componentRef.hostView.rootNodes[0];
        // 4. Append notification list if missing
        const listElement = this.generateListElement(root);
        // 5. Add item class
        domElem.setAttribute('class', 'bb-notification-list__item');
        // 6. Set role='status' if autofocus is set to true and role='alert' if autofocus is set to false
        if (autofocus) {
            (_a = domElem === null || domElem === void 0 ? void 0 : domElem.firstElementChild) === null || _a === void 0 ? void 0 : _a.setAttribute('role', 'status');
        }
        else {
            componentRef.instance.autofocus = false;
            // For Firefox and NVDA role should be set to list element
            if (navigator.userAgent.indexOf('Firefox') > -1) {
                listElement.setAttribute('role', 'alert');
            }
            else {
                (_b = domElem === null || domElem === void 0 ? void 0 : domElem.firstElementChild) === null || _b === void 0 ? void 0 : _b.setAttribute('role', 'alert');
            }
        }
        // 7. Append new element to list of elements and push old ones down.
        if (listElement) {
            listElement.insertBefore(domElem, listElement.firstChild);
        }
        return {
            componentInstance: componentRef.instance,
            unmountComponent: () => {
                this.destroyElement(componentRef);
            },
        };
    }
    generateListElement(root) {
        let listElement = document.getElementsByClassName('bb-notification-list')[0];
        if (!listElement) {
            listElement = document.createElement('div');
            listElement.setAttribute('class', 'bb-notification-list');
            root.appendChild(listElement);
        }
        return listElement;
    }
    /*
      This method is a hack to make notifications visible to screen readers
      (NVDA and VoiceOver) when a modal window (role="dialog") is opened.
      aria-label="polite" on the list element and role="status" with
      aria-atomic="true" on notification element don't resolve the issue.
      Any better ideas are welcome.
     */
    checkAndDestroyListElement() {
        const listElement = document.getElementsByClassName('bb-notification-list')[0];
        // don't remove list element if there are any remaining notifications
        if (!listElement || listElement.childElementCount > 0) {
            return;
        }
        listElement.remove();
    }
    destroyElement(componentRef) {
        componentRef.instance.beforeDestroy();
        this.appRef.detachView(componentRef.hostView);
        componentRef.destroy();
        // is required to make notifications visible to screen readers when any modal window is opened
        this.checkAndDestroyListElement();
    }
}
AppendToDomService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AppendToDomService, deps: [{ token: i0.ComponentFactoryResolver }, { token: i0.ApplicationRef }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
AppendToDomService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AppendToDomService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AppendToDomService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.Injector }]; } });

/**
 * A configuration service for the [NotificationComponent] component.
 *
 * You can inject this service, typically in your root component, and customize its properties
 * to provide default values for all alerts used in the application.
 */
class BBNotificationConfig {
    constructor() {
        this.animation = true;
    }
}
BBNotificationConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BBNotificationConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
BBNotificationConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BBNotificationConfig, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BBNotificationConfig, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * @name NotificationComponent
 *
 * @description
 * Component that displays a notification.
 */
// @dynamic to suppress error with resolving Document type during compilation
class NotificationComponent {
    constructor(document, elem, config) {
        this.document = document;
        this.elem = elem;
        /**
         * The message template for the notification. Defaults to an empty string
         */
        this.message = '';
        /**
         * The type modifier for the notification. Defaults to 'info'
         *
         * This property will be used to add additional class names to the wrapper div of the notification
         * in the following format: `bb-notification--<<modifier>>`
         *
         */
        this.modifier = 'info';
        /**
         * Whether the notification is dismissible. Defaults to `true`.
         *
         *
         * If `true` then an additional class name is added to the wrapper div of the notification in the following format
         * `bb-notification--dismissible`
         */
        this.dismissible = true;
        /**
         * The callback function for the manually close event.
         */
        this.closeAction = undefined;
        /**
         * The callback function for the host click event.
         */
        this.hostAction = undefined;
        /**
         * Notification manually close event stream.
         */
        this.close = new EventEmitter();
        /**
         * Autofocus will cause the component to be focused on the first rendering.
         */
        this.autofocus = true;
        this.bemBlock = 'bb-notification';
        this.bemModifiers = [() => (this.dismissible ? 'dismissible' : ''), () => this.modifier];
        this.animation = config.animation;
    }
    get dynamicClassNames() {
        return getBemModifiers(this.bemBlock, this.bemModifiers);
    }
    get noAnimation() {
        return !this.animation;
    }
    get animated() {
        return this.animation;
    }
    onKeyEvent(event) {
        switch (event.key) {
            case 'Escape':
                this.onNotificationClose();
                break;
            default:
                return;
        }
        event.preventDefault();
    }
    ngOnInit() {
        if (this.hasPrimaryAction() && typeof this.primaryActionText === 'undefined') {
            throw new Error(`"primaryActionText" input is required when a primaryAction is set in "${this.constructor.name}"`);
        }
        if (this.hasSecondaryAction() && typeof this.secondaryActionText === 'undefined') {
            throw new Error(`"secondaryActionText" input is required when a secondaryAction is set in "${this.constructor.name}"`);
        }
        this.iconColor = this.modifier === 'error' ? 'danger' : this.modifier;
    }
    ngAfterViewInit() {
        if (document.activeElement instanceof HTMLElement) {
            this.previousFocusedElement = document.activeElement;
        }
    }
    get hostTabIndex() {
        return this.hostAction ? 0 : -1;
    }
    onNotificationClick() {
        if (this.hostAction) {
            this.hostAction();
            this.close.emit();
        }
    }
    onNotificationClose() {
        if (this.closeAction) {
            this.closeAction();
        }
        this.close.emit();
    }
    beforeDestroy() {
        const notificationList = this.document.querySelector('.bb-notification-list');
        const isNotificationListFocused = notificationList && notificationList.contains(this.document.activeElement);
        if (notificationList && isNotificationListFocused) {
            const notificationBtns = notificationList.querySelectorAll('.bb-notification__close');
            const currentIndex = Array.from(notificationList.children).findIndex((listElement) => listElement === this.elem.nativeElement);
            const nextElementToFocus = notificationBtns[currentIndex + 1] || notificationBtns[currentIndex - 1] || this.previousFocusedElement;
            if (nextElementToFocus) {
                nextElementToFocus.focus();
            }
        }
    }
    onPrimaryPress() {
        if (this.primaryAction) {
            this.primaryAction();
            this.onNotificationClose();
        }
    }
    onSecondaryPress() {
        if (this.secondaryAction) {
            this.secondaryAction();
            this.onNotificationClose();
        }
    }
    getHeaderTemplate() {
        if (this.header instanceof TemplateRef) {
            return this.header;
        }
        return this.defaultHeaderTemplate;
    }
    getMessageTemplate() {
        if (this.message instanceof TemplateRef) {
            return this.message;
        }
        return this.defaultMessageTemplate;
    }
    hasButtonRow() {
        return this.hasPrimaryAction() || this.hasSecondaryAction();
    }
    hasPrimaryAction() {
        return this.primaryAction !== undefined;
    }
    hasSecondaryAction() {
        return this.secondaryAction !== undefined;
    }
}
NotificationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationComponent, deps: [{ token: DOCUMENT }, { token: i0.ElementRef }, { token: BBNotificationConfig }], target: i0.ɵɵFactoryTarget.Component });
NotificationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationComponent, selector: "bb-notification-ui", inputs: { header: "header", message: "message", primaryActionTemplate: "primaryActionTemplate", secondaryActionTemplate: "secondaryActionTemplate", modifier: "modifier", dismissible: "dismissible", primaryActionText: "primaryActionText", primaryAction: "primaryAction", secondaryActionText: "secondaryActionText", secondaryAction: "secondaryAction", closeAction: "closeAction", hostAction: "hostAction", headerContext: "headerContext", messageContext: "messageContext", animation: "animation" }, outputs: { close: "close" }, host: { listeners: { "window:keydown": "onKeyEvent($event)" }, properties: { "@.disabled": "this.noAnimation", "@fadeSlideInOut": "this.animated" } }, viewQueries: [{ propertyName: "notificationContent", first: true, predicate: ["notificationContent"], descendants: true }, { propertyName: "defaultHeaderTemplate", first: true, predicate: ["defaultNotificationHeaderTemplate"], descendants: true, static: true }, { propertyName: "defaultMessageTemplate", first: true, predicate: ["defaultNotificationMessageTemplate"], descendants: true, static: true }, { propertyName: "defaultPrimaryActionsTemplate", first: true, predicate: ["defaultPrimaryActionsTemplate"], descendants: true, static: true }, { propertyName: "defaultSecondaryActionsTemplate", first: true, predicate: ["defaultSecondaryActionsTemplate"], descendants: true, static: true }], ngImport: i0, template: "<div\n  class=\"bb-notification\"\n  [ngClass]=\"dynamicClassNames\"\n  data-role=\"notification-alert\"\n  #notificationContent\n  [bbFocus]=\"autofocus\"\n  [attr.tabindex]=\"hostTabIndex\"\n  (bbKeyboardClick)=\"onNotificationClick()\"\n>\n  <bb-icon-ui\n    [name]=\"modifier\"\n    [color]=\"iconColor\"\n    class=\"bb-notification__icon\"\n    [attr.data-role]=\"'notification-icon'\"\n  ></bb-icon-ui>\n  <div class=\"bb-notification__body\">\n    <div class=\"bb-notification__title\" data-role=\"notification-heading\">\n      <ng-container *ngTemplateOutlet=\"getHeaderTemplate(); context: headerContext\"></ng-container>\n    </div>\n    <div data-role=\"notification-message\" class=\"bb-text-support\">\n      <ng-container *ngTemplateOutlet=\"getMessageTemplate(); context: messageContext\"></ng-container>\n    </div>\n    <div\n      data-role=\"notification-actions\"\n      *ngIf=\"primaryActionTemplate || primaryActionText || secondaryActionTemplate || secondaryActionText\"\n    >\n      <div class=\"bb-button-bar\">\n        <button\n          *ngIf=\"hasPrimaryAction()\"\n          bbButton\n          type=\"button\"\n          data-role=\"notification-primary-button\"\n          class=\"bb-button-bar__button\"\n          (click)=\"onPrimaryPress()\"\n        >\n          <ng-container *ngIf=\"primaryActionTemplate; else defaultPrimaryActionsTemplate\">\n            <ng-container *ngTemplateOutlet=\"primaryActionTemplate; context: this\"></ng-container>\n          </ng-container>\n        </button>\n        <button\n          bbButton\n          color=\"secondary\"\n          *ngIf=\"hasSecondaryAction()\"\n          data-role=\"notification-secondary-button\"\n          class=\"bb-button-bar__button\"\n          (click)=\"onSecondaryPress()\"\n        >\n          <ng-container *ngIf=\"secondaryActionTemplate; else defaultSecondaryActionsTemplate\">\n            <ng-container *ngTemplateOutlet=\"secondaryActionTemplate; context: this\"></ng-container>\n          </ng-container>\n        </button>\n      </div>\n    </div>\n  </div>\n  <button\n    *ngIf=\"dismissible\"\n    (click)=\"onNotificationClose()\"\n    type=\"button\"\n    data-role=\"notification-close-button\"\n    class=\"bb-notification__close close\"\n    aria-label=\"Close\"\n    i18n-aria-label=\"Close notification button| Text for the close notification button @@bb-notification-ui.close\"\n  >\n    <bb-icon-ui name=\"times\"></bb-icon-ui>\n  </button>\n</div>\n\n<ng-template #defaultNotificationHeaderTemplate>\n  <div [ngClass]=\"{ 'bb-block bb-block--sm': !!header }\">\n    {{ header }}\n  </div>\n</ng-template>\n\n<ng-template #defaultNotificationMessageTemplate>\n  {{ message }}\n</ng-template>\n\n<ng-template #defaultPrimaryActionsTemplate>\n  {{ primaryActionText }}\n</ng-template>\n\n<ng-template #defaultSecondaryActionsTemplate>\n  {{ secondaryActionText }}\n</ng-template>\n", components: [{ type: i2.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i4.FocusDirective, selector: "[bbFocus]", inputs: ["bbFocus"], exportAs: ["bbFocus"] }, { type: i5.KeyboardClickDirective, selector: "[bbKeyboardClick]", outputs: ["bbKeyboardClick"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], animations: [fadeSlideAnimation] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notification-ui',
                    templateUrl: './notification.component.html',
                    animations: [fadeSlideAnimation],
                }]
        }], ctorParameters: function () { return [{ type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef }, { type: BBNotificationConfig }]; }, propDecorators: { header: [{
                type: Input
            }], message: [{
                type: Input
            }], primaryActionTemplate: [{
                type: Input
            }], secondaryActionTemplate: [{
                type: Input
            }], modifier: [{
                type: Input
            }], dismissible: [{
                type: Input
            }], primaryActionText: [{
                type: Input
            }], primaryAction: [{
                type: Input
            }], secondaryActionText: [{
                type: Input
            }], secondaryAction: [{
                type: Input
            }], closeAction: [{
                type: Input
            }], hostAction: [{
                type: Input
            }], headerContext: [{
                type: Input
            }], messageContext: [{
                type: Input
            }], animation: [{
                type: Input
            }], close: [{
                type: Output
            }], notificationContent: [{
                type: ViewChild,
                args: ['notificationContent']
            }], defaultHeaderTemplate: [{
                type: ViewChild,
                args: ['defaultNotificationHeaderTemplate', { static: true }]
            }], defaultMessageTemplate: [{
                type: ViewChild,
                args: ['defaultNotificationMessageTemplate', { static: true }]
            }], defaultPrimaryActionsTemplate: [{
                type: ViewChild,
                args: ['defaultPrimaryActionsTemplate', { static: true }]
            }], defaultSecondaryActionsTemplate: [{
                type: ViewChild,
                args: ['defaultSecondaryActionsTemplate', { static: true }]
            }], noAnimation: [{
                type: HostBinding,
                args: ['@.disabled']
            }], animated: [{
                type: HostBinding,
                args: ['@fadeSlideInOut']
            }], onKeyEvent: [{
                type: HostListener,
                args: ['window:keydown', ['$event']]
            }] } });

class NotificationService {
    constructor(appendtoDomService) {
        this.appendtoDomService = appendtoDomService;
    }
    showNotification({ header, message, dismissible = true, ttl = 3000, modifier = 'info', headerContext = {}, messageContext = {}, primaryActionText, primaryAction, secondaryActionText, secondaryAction, closeAction, hostAction, primaryActionTemplate, secondaryActionTemplate, autofocus = true, }) {
        const res = this.appendtoDomService.appendComponentToRoot(NotificationComponent, autofocus);
        const componentInstance = res.componentInstance;
        componentInstance.message = message;
        componentInstance.modifier = modifier;
        componentInstance.dismissible = dismissible;
        componentInstance.header = header;
        componentInstance.primaryActionText = primaryActionText;
        componentInstance.primaryAction = primaryAction;
        componentInstance.secondaryActionText = secondaryActionText;
        componentInstance.secondaryAction = secondaryAction;
        componentInstance.closeAction = closeAction;
        componentInstance.hostAction = hostAction;
        componentInstance.headerContext = headerContext;
        componentInstance.messageContext = messageContext;
        componentInstance.primaryActionTemplate = primaryActionTemplate;
        componentInstance.secondaryActionTemplate = secondaryActionTemplate;
        return this.createHideNotificationFunction(res.unmountComponent, ttl, componentInstance.close);
    }
    createHideNotificationFunction(hideFn, ttl = 0, closeStream) {
        const hideSubject = new Subject();
        const hideNotification = () => {
            hideSubject.next();
        };
        const closeSubscription = closeStream.subscribe(hideNotification);
        const hideSubscription = hideSubject.pipe(first()).subscribe(() => {
            hideFn();
            hideSubscription.unsubscribe();
            closeSubscription.unsubscribe();
        });
        if (ttl > 0) {
            setTimeout(hideNotification, ttl);
        }
        return hideNotification;
    }
}
NotificationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationService, deps: [{ token: AppendToDomService }], target: i0.ɵɵFactoryTarget.Injectable });
NotificationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: AppendToDomService }]; } });

class NotificationModule {
}
NotificationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NotificationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationModule, declarations: [NotificationComponent], imports: [CommonModule, NgbAlertModule, IconModule, ButtonModule, KeyboardClickModule, FocusModule], exports: [NotificationComponent] });
NotificationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationModule, imports: [[CommonModule, NgbAlertModule, IconModule, ButtonModule, KeyboardClickModule, FocusModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NgbAlertModule, IconModule, ButtonModule, KeyboardClickModule, FocusModule],
                    declarations: [NotificationComponent],
                    exports: [NotificationComponent],
                    entryComponents: [NotificationComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { AppendToDomService, BBNotificationConfig, NotificationComponent, NotificationModule, NotificationService };
//# sourceMappingURL=backbase-ui-ang-notification.js.map
