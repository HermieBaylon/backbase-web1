import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { EventEmitter, Directive, Input, Output, HostBinding, HostListener, ContentChild, ContentChildren, ElementRef, NgModule } from '@angular/core';
import { switchMap, takeUntil } from 'rxjs/operators';
import { merge, Subject } from 'rxjs';
import { DropdownMenuToken, DropdownMenuOptionToken } from '@backbase/ui-ang/dropdown-menu';
import { getKeyCode, KEY_CODES } from '@backbase/ui-ang/util';

/**
 * @name TableDirective
 *
 * @description
 * Directive that displays a table.
 *
 * @a11y
 * The table directive doesn't provide any specific properties for accessibility.
 * But aria-sort tag can be set on the sortable header cells with ascending and descending values.
 *
 */
class TableDirective {
    constructor() {
        /**
         * An event emitter for on select row action.
         */
        this.selectRow = new EventEmitter();
        /**
         * An event emitter for on row click action.
         */
        this.rowClick = new EventEmitter();
        /**
         * An event emitter for on column sort action.
         */
        this.sort = new EventEmitter();
        this.selectedRows = new Set();
        this.headers = new Set();
    }
    registerHeader(header) {
        this.headers.add(header);
    }
    unRegisterHeader(header) {
        this.headers.delete(header);
    }
    onRowClick(rowItem) {
        this.rowClick.emit(rowItem);
    }
    isSelected(row) {
        return this.selectedRows.has(row);
    }
    toggleItem(row, isChecked) {
        if (isChecked) {
            this.selectedRows.add(row);
        }
        else {
            this.selectedRows.delete(row);
        }
        this.selectRow.emit(this.selectedRows);
    }
    toggleAllItems() {
        if (this.isSelectedAll()) {
            this.selectedRows = new Set();
        }
        else {
            this.selectedRows = new Set(this.dataSource);
        }
        this.selectRow.emit(this.selectedRows);
    }
    isSelectedAll() {
        if (this.dataSource) {
            const matches = this.dataSource.filter((item) => this.selectedRows.has(item));
            return matches.length === this.dataSource.length;
        }
        return false;
    }
    isSelectedPart() {
        if (this.dataSource) {
            return this.selectedRows.size > 0 && this.selectedRows.size < this.dataSource.length;
        }
        return false;
    }
    onSort(sortEvent) {
        this.headers.forEach((header) => {
            if (header.bbSortable !== sortEvent.column) {
                header.direction = '';
                header.markAllMenuOptionAsInactive();
            }
        });
        this.sort.emit(sortEvent);
    }
}
TableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
TableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TableDirective, selector: "table[bbTable]", inputs: { dataSource: ["bbTable", "dataSource"] }, outputs: { selectRow: "selectRow", rowClick: "rowClick", sort: "sort" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'table[bbTable]',
                }]
        }], propDecorators: { dataSource: [{
                type: Input,
                args: ['bbTable']
            }], selectRow: [{
                type: Output
            }], rowClick: [{
                type: Output
            }], sort: [{
                type: Output
            }] } });

class TableRowDirective {
    constructor(parentTable) {
        this.parentTable = parentTable;
    }
    get selected() {
        return this.parentTable.isSelected(this.bbRow);
    }
    onRowClick() {
        this.parentTable.onRowClick(this.bbRow);
    }
}
TableRowDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableRowDirective, deps: [{ token: TableDirective }], target: i0.ɵɵFactoryTarget.Directive });
TableRowDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TableRowDirective, selector: "tr[bbRow]", inputs: { bbRow: "bbRow" }, host: { listeners: { "click": "onRowClick()" }, properties: { "class.selected": "this.selected" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableRowDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'tr[bbRow]',
                }]
        }], ctorParameters: function () { return [{ type: TableDirective }]; }, propDecorators: { bbRow: [{
                type: Input
            }], selected: [{
                type: HostBinding,
                args: ['class.selected']
            }], onRowClick: [{
                type: HostListener,
                args: ['click']
            }] } });

const rotate = { asc: 'desc', desc: '', '': 'asc' };
class TableSortableDirective {
    constructor(parentTable, renderer) {
        this.parentTable = parentTable;
        this.renderer = renderer;
        /**
         * The current sort direction. Accepts one of the values of 'asc', 'desc' or ''
         */
        this.direction = '';
        /**
         * An event emitter for on sort actions.
         */
        this.sort = new EventEmitter();
        this.sortable = true;
        this.parentTable.registerHeader(this);
    }
    get asc() {
        return this.direction === 'asc';
    }
    get desc() {
        return this.direction === 'desc';
    }
    rotate() {
        if (this.dropdown) {
            return;
        }
        this.emitSortEvent();
    }
    ngAfterViewInit() {
        if (this.dropdown) {
            this.presetDropdown(this.dropdown);
        }
        this.getMenuOptionSelectionChanges(this.bbMenuOptions).subscribe((menuOption) => this.onMenuOptionSelect(menuOption));
    }
    onMenuOptionSelect(menuOption) {
        var _a;
        const columnValue = menuOption.bbDropdownMenuOption;
        const activeMenuOption = (_a = this.bbMenuOptions) === null || _a === void 0 ? void 0 : _a.find((option) => option.active);
        // Reset currently active item
        if (activeMenuOption) {
            activeMenuOption.active = false;
        }
        // If same menu item is not clicked, then reset the direction for new menuitem
        if (activeMenuOption && columnValue !== activeMenuOption.bbDropdownMenuOption) {
            this.direction = '';
        }
        this.bbSortable = menuOption.bbDropdownMenuOption;
        this.emitSortEvent();
        this.markMenuOptionAsActive(menuOption);
        this.updateAriaSortAttribute();
    }
    /** Notify table with new sorting params */
    emitSortEvent() {
        if (this.bbSortable) {
            this.direction = rotate[this.direction];
            this.parentTable.onSort({ column: this.bbSortable, direction: this.direction });
        }
    }
    /** Combined stream of all of the bbTableMenuitem selectionChange events. */
    getMenuOptionSelectionChanges(menuOptions) {
        return menuOptions.changes.pipe(switchMap((_) => merge(...menuOptions.map((menuOption) => menuOption.selectionChange))));
    }
    /** mark the new menuitem as active only if sorting order is asc/desc */
    markMenuOptionAsActive(menuOption) {
        if (this.direction !== '') {
            menuOption.active = true;
        }
    }
    markAllMenuOptionAsInactive() {
        if (this.bbMenuOptions.length) {
            this.bbMenuOptions.forEach((menuOption) => (menuOption.active = false));
        }
    }
    updateAriaSortAttribute() {
        var _a;
        if (this.dropdown) {
            const buttonEl = (_a = this.dropdown.buttonEl) === null || _a === void 0 ? void 0 : _a.nativeElement;
            if (!this.direction) {
                this.renderer.removeAttribute(buttonEl, 'aria-sort');
            }
            else {
                this.renderer.setAttribute(buttonEl, 'aria-sort', this.getAriaSortAttribute(this.direction));
            }
        }
    }
    getAriaSortAttribute(direction) {
        return direction === 'asc' ? 'ascending' : 'descending';
    }
    /** Preset bb-dropdown button to add role for a11y and set full height and width of table column */
    presetDropdown(dropdown) {
        var _a;
        const buttonEl = (_a = dropdown.buttonEl) === null || _a === void 0 ? void 0 : _a.nativeElement;
        this.renderer.setAttribute(buttonEl, 'role', 'columnheader');
        this.renderer.setStyle(buttonEl, 'height', '100%');
        this.renderer.setStyle(buttonEl, 'width', '100%');
    }
    ngOnDestroy() {
        this.parentTable.unRegisterHeader(this);
    }
}
TableSortableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableSortableDirective, deps: [{ token: TableDirective }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
TableSortableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TableSortableDirective, selector: "th[bbSortable]", inputs: { bbSortable: "bbSortable", direction: "direction" }, outputs: { sort: "sort" }, host: { listeners: { "click": "rotate()", "keyup.enter": "rotate()", "keyup.space": "rotate()" }, properties: { "class.sortable": "this.sortable", "class.asc": "this.asc", "class.desc": "this.desc" } }, queries: [{ propertyName: "dropdown", first: true, predicate: DropdownMenuToken, descendants: true }, { propertyName: "bbMenuOptions", predicate: DropdownMenuOptionToken, descendants: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableSortableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'th[bbSortable]',
                }]
        }], ctorParameters: function () { return [{ type: TableDirective }, { type: i0.Renderer2 }]; }, propDecorators: { bbSortable: [{
                type: Input
            }], direction: [{
                type: Input
            }], sort: [{
                type: Output
            }], dropdown: [{
                type: ContentChild,
                args: [DropdownMenuToken]
            }], bbMenuOptions: [{
                type: ContentChildren,
                args: [DropdownMenuOptionToken, { descendants: true }]
            }], sortable: [{
                type: HostBinding,
                args: ['class.sortable']
            }], asc: [{
                type: HostBinding,
                args: ['class.asc']
            }], desc: [{
                type: HostBinding,
                args: ['class.desc']
            }], rotate: [{
                type: HostListener,
                args: ['click']
            }, {
                type: HostListener,
                args: ['keyup.enter']
            }, {
                type: HostListener,
                args: ['keyup.space']
            }] } });

class TableFocusDirective {
    constructor(renderer) {
        this.renderer = renderer;
        this.focusedItemIndex = -1;
        this.focusFirstRowOnChanges = false;
        this.destroy$ = new Subject();
    }
    onKeyEvent(event) {
        switch (getKeyCode(event)) {
            case KEY_CODES.DOWN:
                this.focusedItemIndex = Math.min(this.focusedItemIndex + 1, this.listItems.length - 1);
                this.focusItem();
                event.preventDefault();
                break;
            case KEY_CODES.UP:
                this.focusedItemIndex = Math.max(this.focusedItemIndex - 1, 0);
                this.focusItem();
                event.preventDefault();
                break;
            case KEY_CODES.ENTER:
                const currentActiveItem = this.listItems.find((item, index) => index === this.focusedItemIndex);
                if (currentActiveItem) {
                    currentActiveItem.nativeElement.click();
                    event.preventDefault();
                }
                break;
        }
    }
    focusItem(focusNativeElement = true) {
        this.listItems.forEach((el, index) => {
            if (index === this.focusedItemIndex) {
                this.renderer.addClass(el.nativeElement, 'active');
                this.renderer.setAttribute(el.nativeElement, 'tabIndex', '0');
                if (focusNativeElement) {
                    el.nativeElement.focus();
                }
            }
            else {
                this.renderer.removeClass(el.nativeElement, 'active');
                this.renderer.setAttribute(el.nativeElement, 'tabIndex', '-1');
            }
        });
    }
    /**
     * @internal
     */
    ngAfterViewInit() {
        // make first row in a table focusable
        this.listItems.changes.pipe(takeUntil(this.destroy$)).subscribe((items) => {
            var _a;
            if ((_a = items.first) === null || _a === void 0 ? void 0 : _a.nativeElement) {
                this.focusedItemIndex = 0;
                this.focusItem(this.focusFirstRowOnChanges);
            }
        });
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
TableFocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableFocusDirective, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
TableFocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TableFocusDirective, selector: "[bbTableFocus]", inputs: { focusFirstRowOnChanges: "focusFirstRowOnChanges" }, host: { listeners: { "keydown": "onKeyEvent($event)" } }, queries: [{ propertyName: "listItems", predicate: TableRowDirective, emitDistinctChangesOnly: false, descendants: true, read: ElementRef }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableFocusDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTableFocus]',
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }]; }, propDecorators: { listItems: [{
                type: ContentChildren,
                args: [TableRowDirective, { read: ElementRef, descendants: true, emitDistinctChangesOnly: false }]
            }], focusFirstRowOnChanges: [{
                type: Input
            }], onKeyEvent: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

const directives = [TableRowDirective, TableDirective, TableSortableDirective, TableFocusDirective];
class TableModule {
}
TableModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TableModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableModule, declarations: [TableRowDirective, TableDirective, TableSortableDirective, TableFocusDirective], imports: [CommonModule], exports: [TableRowDirective, TableDirective, TableSortableDirective, TableFocusDirective] });
TableModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TableModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [...directives],
                    exports: [...directives],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { TableDirective, TableFocusDirective, TableModule, TableRowDirective, TableSortableDirective };
//# sourceMappingURL=backbase-ui-ang-table.js.map
