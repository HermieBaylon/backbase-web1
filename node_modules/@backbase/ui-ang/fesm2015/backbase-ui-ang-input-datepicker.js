import * as i8 from '@angular/common';
import { getLocaleDayNames, FormStyle, TranslationWidth, getLocaleMonthNames, getLocaleDateFormat, FormatWidth, DatePipe, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, LOCALE_ID, Injectable, Inject, Optional, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, HostListener, forwardRef, ViewChild, HostBinding, Directive, NgModule } from '@angular/core';
import * as i9 from '@angular/forms';
import { FormControl, NG_VALUE_ACCESSOR, NG_VALIDATORS, ReactiveFormsModule, FormsModule } from '@angular/forms';
import * as i3 from '@ng-bootstrap/ng-bootstrap';
import { NgbDatepickerI18n, NgbDateAdapter, NgbDateParserFormatter, NgbDate, NgbDatepickerModule } from '@ng-bootstrap/ng-bootstrap';
import { InputBaseComponent, BaseClassesModule } from '@backbase/ui-ang/base-classes';
import * as i10 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import * as i5 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import { BehaviorSubject } from 'rxjs';
import * as i2$1 from '@backbase/foundation-ang/future';
import * as i2 from '@backbase/ui-ang/services';
import { BrowserService, NAVIGATOR_TOKEN, navigatorFactory } from '@backbase/ui-ang/services';
import { KEY_CODES } from '@backbase/ui-ang/util';

const DATEPICKER_I18 = new InjectionToken('datepickerI18');
class NgbDatepickerI18nDefault extends NgbDatepickerI18n {
    constructor(locale, datepickerI18) {
        super();
        this.datepickerI18 = datepickerI18;
        const weekdaysStartingOnSunday = getLocaleDayNames(locale, FormStyle.Standalone, TranslationWidth.Short);
        this.weekdaysShort = weekdaysStartingOnSunday.map((day, index) => weekdaysStartingOnSunday[(index + 1) % 7]);
        this.monthsShort = getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Abbreviated);
        this.monthsFull = getLocaleMonthNames(locale, FormStyle.Standalone, TranslationWidth.Wide);
    }
    getWeekdayLabel(weekday) {
        return this.datepickerI18 ? this.datepickerI18.getWeekdayLabel(weekday) : this.weekdaysShort[weekday - 1];
    }
    getMonthShortName(month) {
        return this.datepickerI18 ? this.datepickerI18.getMonthShortName(month) : this.monthsShort[month - 1];
    }
    getMonthFullName(month) {
        return this.datepickerI18 ? this.datepickerI18.getMonthFullName(month) : this.monthsFull[month - 1];
    }
    getDayAriaLabel(date) {
        // @todo: use i18n date pipes?
        return this.datepickerI18 ? this.datepickerI18.getDayAriaLabel(date) : `${date.day}-${date.month}-${date.year}`;
    }
}
NgbDatepickerI18nDefault.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDatepickerI18nDefault, deps: [{ token: LOCALE_ID }, { token: DATEPICKER_I18, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NgbDatepickerI18nDefault.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDatepickerI18nDefault });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDatepickerI18nDefault, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i3.NgbDatepickerI18n, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DATEPICKER_I18]
                }] }]; } });

const isValidNgbDateStructProp = (struct, propName) => struct ? Object.prototype.hasOwnProperty.call(struct, propName) && typeof struct[propName] === 'number' : false;
const isNgbDateStruct = (value) => isValidNgbDateStructProp(value, 'day') &&
    isValidNgbDateStructProp(value, 'month') &&
    isValidNgbDateStructProp(value, 'year');
class NgbDateStringAdapter extends NgbDateAdapter {
    fromModel(dateString) {
        if (dateString) {
            const d = new Date(dateString);
            const year = d.getFullYear();
            if (year) {
                return {
                    year: year,
                    month: d.getMonth() + 1,
                    day: d.getDate(),
                };
            }
        }
        return null;
    }
    toModel(date) {
        if (!date) {
            return '';
        }
        else if (typeof date === 'string') {
            return date;
        }
        else if (isNgbDateStruct(date)) {
            return new Date(date.year, date.month - 1, date.day).toISOString();
        }
        return Object.prototype.toString.call(date);
    }
}
NgbDateStringAdapter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateStringAdapter, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
NgbDateStringAdapter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateStringAdapter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateStringAdapter, decorators: [{
            type: Injectable
        }] });

// TODO: get rid of non null assertions. They are added due to problem with NgbDateParserFormatter.
// It specifies result of parse function as NgbDateStruct, but allows to return null if value can not be parsed.
// They should have defined parse method with NgbDateStruct | null return, since now compilation
// fails due to strict null checks.
class NgbDateLocaleParserFormatter extends NgbDateParserFormatter {
    constructor(locale, datePipe) {
        super();
        this.locale = locale;
        this.datePipe = datePipe;
    }
    get localeDateFormat() {
        return this._dateFormat || getLocaleDateFormat(this.locale, FormatWidth.Short);
    }
    set dateFormat(format) {
        this._dateFormat = format;
    }
    static getAdaptedYear(year, month, day, yearValue) {
        const date = new Date(year, month - 1, day);
        year = date.getFullYear();
        if (yearValue && yearValue.length < 3 && year < 1950) {
            year += 100;
        }
        return year;
    }
    static getIndexFromFormat(regex, formatArray) {
        const index = formatArray.findIndex((item) => !Boolean(item.replace(regex, '')));
        return index;
    }
    interpretDate(value) {
        const date = new Date(value);
        if (isNaN(date.getTime()))
            return;
        const year = date.getFullYear();
        const yearLength = this.getYearLength(value);
        if (yearLength < 3 && // prevent transformation of 1902 to 2002
            year < 1950 &&
            !value.includes(String(year)) &&
            new Date('01/01/00').getFullYear() === 1900) {
            date.setFullYear(year + 100);
        }
        return date;
    }
    parse(value) {
        if (!value) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return null;
        }
        const dateElementsRegex = /[^GyMLwWdE]/;
        const dateFormatDelimiterMatches = this.localeDateFormat.match(dateElementsRegex);
        const dateFormatDelimiter = dateFormatDelimiterMatches && dateFormatDelimiterMatches[0];
        const dateValueRegex = new RegExp('[\\d' + dateFormatDelimiter + ']+');
        // Try to parse manually the value in case if contains only numbers and the delimiter.
        // If no delimiter found or the value has other than number characters,
        // the the parsing will fallback to the angular date pipe
        if (dateFormatDelimiter && !Boolean(value.replace(dateValueRegex, ''))) {
            const formatParsedDate = this.getFormatParsedDate(value, this.localeDateFormat, dateFormatDelimiter);
            if (formatParsedDate) {
                // the formatter has all three date elements
                return formatParsedDate;
            }
        }
        return this.getAngularPipeFormatParseDate(value);
    }
    /**
     *
     * Parse date value with angular date pipe
     *
     * @param value The string date value
     *
     */
    getAngularPipeFormatParseDate(value) {
        let parsedValue = '';
        try {
            parsedValue = this.datePipe.transform(value, this.localeDateFormat, undefined, this.locale) || '';
        }
        catch (e) {
            // there is no error handling, because transform fails only with temporary and invalid values like '22/'
            //  during manual input to datepicker
        }
        const parsedDate = this.interpretDate(value);
        if (!parsedValue || !parsedDate) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return null;
        }
        return {
            year: parsedDate.getFullYear(),
            month: parsedDate.getMonth() + 1,
            day: parsedDate.getDate(),
        };
    }
    /**
     *
     * @description
     * Proprietary parse to be able to use date override in the input field.
     *
     * Parse the string date value if the date format only contains y, M, d with one single format delimiter.
     *
     * @param value The string date value
     * @param format The date format
     * @param delimiter The delimiter character between date elements (e.g. - or /)
     *
     */
    getFormatParsedDate(value, format, delimiter) {
        const dateValueArr = value.split(delimiter); // split date string value by the delimiter
        const dateFormatArr = format.split(delimiter);
        if (dateFormatArr.length === 3) {
            const dayFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/d{1,2}/, dateFormatArr);
            const monthFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/M{1,5}/, dateFormatArr);
            const yearFormatIndex = NgbDateLocaleParserFormatter.getIndexFromFormat(/y{1,4}/, dateFormatArr);
            if (dayFormatIndex > -1 && monthFormatIndex > -1 && yearFormatIndex > -1) {
                const today = new Date();
                const year = dateValueArr[yearFormatIndex] ? Number(dateValueArr[yearFormatIndex]) : today.getFullYear();
                const month = dateValueArr[monthFormatIndex] ? Number(dateValueArr[monthFormatIndex]) : today.getMonth() + 1;
                const day = dateValueArr[dayFormatIndex] ? Number(dateValueArr[dayFormatIndex]) : today.getDate();
                return {
                    day,
                    month,
                    year: NgbDateLocaleParserFormatter.getAdaptedYear(year, month, day, dateValueArr[yearFormatIndex]),
                };
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return null;
    }
    getYearLength(value) {
        const separator = String(this.localeDateFormat.match(/[^\w\*]/));
        const dateArray = value.split(separator);
        const yearPosition = this.localeDateFormat.toLocaleLowerCase().split(separator);
        const yearIndex = yearPosition.findIndex((val) => val.includes('y'));
        return yearIndex >= 0 && yearIndex < dateArray.length ? dateArray[yearIndex].length : 0;
    }
    format(date, format = this.localeDateFormat) {
        let formattedDate = '';
        if (date && isNgbDateStruct(date)) {
            formattedDate =
                this.datePipe.transform(new Date(date.year, date.month - 1, date.day), format, undefined, this.locale) || '';
        }
        return formattedDate;
    }
}
NgbDateLocaleParserFormatter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateLocaleParserFormatter, deps: [{ token: LOCALE_ID }, { token: i8.DatePipe }], target: i0.ɵɵFactoryTarget.Injectable });
NgbDateLocaleParserFormatter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateLocaleParserFormatter });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgbDateLocaleParserFormatter, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i8.DatePipe }]; } });

/* eslint-disable */
var Key$2;
(function (Key) {
    Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowRight"] = 39] = "ArrowRight";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key$2 || (Key$2 = {}));
class InputDatepickerDayTemplateSingleComponent {
    constructor(formatterHelper, browserService) {
        this.formatterHelper = formatterHelper;
        this.browserService = browserService;
        /**
         * Indicates whether the date is selected
         */
        this.selected = false;
        /**
         * When true the date is rendered as disabled
         */
        this.disabled = false;
        /**
         * Hovered date by a user
         */
        this.hoveredDate = null;
        /**
         * Event to trigger on date hover
         */
        this.hovered = new EventEmitter();
        /**
         * Indicates if the date displayed as greyed out
         */
        this.isTextMuted = false;
        /**
         * Indicates if the date is hovered the range
         */
        this.isHovered = false;
        this.format = (date) => this.formatterHelper.format(date);
        this.isIE = this.browserService.browserIsMSIE();
    }
    ngOnChanges(changes) {
        var _a, _b;
        if ((changes === null || changes === void 0 ? void 0 : changes.selected) || (changes === null || changes === void 0 ? void 0 : changes.disabled) || (changes === null || changes === void 0 ? void 0 : changes.date) || (changes === null || changes === void 0 ? void 0 : changes.currentMonth)) {
            this.isTextMuted = !this.selected && (this.disabled || ((_a = this.date) === null || _a === void 0 ? void 0 : _a.month) !== +this.currentMonth);
        }
        this.isHovered = (_b = this.date) === null || _b === void 0 ? void 0 : _b.equals(this.hoveredDate);
    }
    /**
     *
     * @description
     * Handle mouseover. Emit the hovered date with null.
     *
     */
    onMouseOut() {
        this.hovered.emit({ date: null, isSelecting: false });
    }
    /**
     *
     * @description
     * Handle mouseover. Emit the hovered date with date.
     *
     */
    onMouseOver() {
        this.hovered.emit({ date: this.date, isSelecting: true });
    }
    /**
     * @description
     * Keypress handler
     *
     * @param evt
     * @param curMonth
     * @param curDay
     * @param date
     */
    onKeyUp(event) {
        const day = event.target.textContent;
        const matchKey = this.isIE
            ? Object.values(Key$2).includes(event === null || event === void 0 ? void 0 : event.keyCode)
            : InputDatepickerDayTemplateSingleComponent.hangledKeyCodes.includes(event === null || event === void 0 ? void 0 : event.key);
        if (Number(day) === this.date.day && Number(this.currentMonth) === this.date.month && matchKey) {
            this.hovered.emit({ date: this.date, isSelecting: true });
        }
    }
}
InputDatepickerDayTemplateSingleComponent.hangledKeyCodes = [KEY_CODES.LEFT, KEY_CODES.UP, KEY_CODES.RIGHT, KEY_CODES.DOWN];
InputDatepickerDayTemplateSingleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerDayTemplateSingleComponent, deps: [{ token: NgbDateLocaleParserFormatter }, { token: i2.BrowserService }], target: i0.ɵɵFactoryTarget.Component });
InputDatepickerDayTemplateSingleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerDayTemplateSingleComponent, selector: "bb-input-datepicker-single-day-template-ui", inputs: { date: "date", selected: "selected", disabled: "disabled", currentMonth: "currentMonth", hoveredDate: "hoveredDate" }, outputs: { hovered: "hovered" }, host: { listeners: { "mouseout": "onMouseOut()", "mouseover": "onMouseOver()", "document:keyup": "onKeyUp($event)" } }, providers: [
        DatePipe,
        NgbDateLocaleParserFormatter,
        {
            provide: NgbDateParserFormatter,
            useExisting: NgbDateLocaleParserFormatter,
        },
        BrowserService,
        { provide: NAVIGATOR_TOKEN, useFactory: navigatorFactory },
    ], usesOnChanges: true, ngImport: i0, template: "<time\n  class=\"custom-day text-center bb-input-datepicker__single-day\"\n  [ngClass]=\"{\n    'is-selected': selected,\n    'text-muted': isTextMuted\n  }\"\n  [attr.data-role]=\"'calendar-date-item'\"\n  [dateTime]=\"format(date)\"\n>\n  {{ date?.day }}\n</time>\n", directives: [{ type: i8.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerDayTemplateSingleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-datepicker-single-day-template-ui',
                    templateUrl: './input-datepicker-day-template-single.component.html',
                    providers: [
                        DatePipe,
                        NgbDateLocaleParserFormatter,
                        {
                            provide: NgbDateParserFormatter,
                            useExisting: NgbDateLocaleParserFormatter,
                        },
                        BrowserService,
                        { provide: NAVIGATOR_TOKEN, useFactory: navigatorFactory },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: NgbDateLocaleParserFormatter }, { type: i2.BrowserService }]; }, propDecorators: { date: [{
                type: Input
            }], selected: [{
                type: Input
            }], disabled: [{
                type: Input
            }], currentMonth: [{
                type: Input
            }], hoveredDate: [{
                type: Input
            }], hovered: [{
                type: Output
            }], onMouseOut: [{
                type: HostListener,
                args: ['mouseout']
            }], onMouseOver: [{
                type: HostListener,
                args: ['mouseover']
            }], onKeyUp: [{
                type: HostListener,
                args: ['document:keyup', ['$event']]
            }] } });

/* eslint-disable */
var Key$1;
(function (Key) {
    Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowRight"] = 39] = "ArrowRight";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key$1 || (Key$1 = {}));
class InputDatepickerDayTemplateRangeComponent {
    constructor(formatterHelper, browserService) {
        this.formatterHelper = formatterHelper;
        this.browserService = browserService;
        /**
         * When true the date is rendered as disabled
         */
        this.disabled = false;
        /**
         * Selected "from" date
         */
        this.fromDate = null;
        /**
         * Selected "to" date
         */
        this.toDate = null;
        /**
         * If "true" the datepicker is displayed with two input fields for "from" and "to" dates
         */
        this.splitRange = false;
        /**
         * "true" when "splitRange" is "true" and the parent datepicker belongs to
         * second datepicker input (the one for "to" date)
         */
        this.toDateDatepicker = false;
        /**
         * Hovered date by a user
         */
        this.hoveredDate = null;
        /**
         * Date range
         */
        this.rangeSelect = new EventEmitter();
        /**
         * Event to trigger on date hover
         */
        this.hovered = new EventEmitter();
        /**
         * Prevent keypress to be called on toggle button enter
         */
        this.firstKey = true;
        /**
         * Indicates if the date is between the from-date and the hovered date
         */
        this.isWithinRangeHover = false;
        /**
         * Indicates if the date is between the from-date and the to-date date
         */
        this.isWithinSelectedRange = false;
        /**
         * Indicates if the date displayed as greyed out
         */
        this.isTextMuted = false;
        /**
         * Indicates if the date is hovered the range
         */
        this.isHovered = false;
        /**
         * Indicates if the date is the from-date of the range
         */
        this.isFrom = false;
        /**
         * Indicates if the the date is the to-date of the range
         */
        this.isTo = false;
        /**
         * Formatted date
         */
        this.formattedDate = '';
        this.isIE = this.browserService.browserIsMSIE();
    }
    get withinHoverRangeSingle() {
        return (!this.toDate &&
            (this.date.after(this.fromDate) || this.date.equals(this.fromDate)) &&
            (this.date.before(this.hoveredDate) || this.date.equals(this.hoveredDate)));
    }
    get withinHoverRangeSplitTo() {
        return ((this.date.before(this.hoveredDate) || this.date.equals(this.hoveredDate)) &&
            (this.date.after(this.toDate) ||
                this.date.equals(this.toDate) ||
                (this.date.before(this.toDate) && this.date.after(this.fromDate))) &&
            this.toDateDatepicker);
    }
    get withinHoverRangeSplitFrom() {
        return ((this.date.after(this.hoveredDate) || this.date.equals(this.hoveredDate)) &&
            this.date.before(this.toDate) &&
            !this.toDateDatepicker &&
            this.toDate);
    }
    /* eslint-disable complexity */
    ngOnChanges(changes) {
        var _a, _b, _c, _d;
        if (changes === null || changes === void 0 ? void 0 : changes.hoveredDate) {
            this.isWithinRangeHover = !!(this.isValidRange() &&
                this.date &&
                this.hoveredDate &&
                (((this.withinHoverRangeSplitTo || this.withinHoverRangeSplitFrom) && this.splitRange) ||
                    (this.withinHoverRangeSingle && this.toDateDatepicker && this.splitRange) ||
                    (this.withinHoverRangeSingle && !this.splitRange)));
            this.isHovered = (_a = this.date) === null || _a === void 0 ? void 0 : _a.equals(this.hoveredDate);
        }
        if ((changes === null || changes === void 0 ? void 0 : changes.fromDate) || (changes === null || changes === void 0 ? void 0 : changes.toDate) || (changes === null || changes === void 0 ? void 0 : changes.date)) {
            this.isWithinSelectedRange = this.date && this.date.before(this.toDate) && this.date.after(this.fromDate);
            this.isTo = (_b = this.date) === null || _b === void 0 ? void 0 : _b.equals(this.toDate);
            this.formattedDate = this.formatterHelper.format(this.date);
            this.isFrom = (_c = this.date) === null || _c === void 0 ? void 0 : _c.equals(this.fromDate);
        }
        this.isTextMuted =
            !this.isWithinRangeHover &&
                !this.isWithinSelectedRange &&
                !this.isFrom &&
                !this.isTo &&
                (this.disabled || ((_d = this.date) === null || _d === void 0 ? void 0 : _d.month) !== +this.currentMonth);
    }
    /**
     *
     * @description
     * Handle mouseover. Emit the hovered date with null.
     *
     */
    onMouseOut() {
        this.hovered.emit({ date: null, isTo: this.toDateDatepicker, isSelecting: false });
    }
    /**
     *
     * @description
     * Handle mouseover. Emit the hovered date with date.
     *
     */
    onMouseOver() {
        this.hovered.emit({ date: this.date, isTo: this.toDateDatepicker, isSelecting: true });
    }
    /**
     * @description
     * Keypress handler
     *
     * @param evt
     * @param curMonth
     * @param curDay
     * @param date
     */
    onKeyUp(event) {
        const day = event.target.textContent;
        const matchKey = this.isIE
            ? Object.values(Key$1).includes(event === null || event === void 0 ? void 0 : event.keyCode)
            : InputDatepickerDayTemplateRangeComponent.hangledKeyCodes.includes(event === null || event === void 0 ? void 0 : event.key);
        if (Number(day) === this.date.day && Number(this.currentMonth) === this.date.month && matchKey) {
            this.hovered.emit({ date: this.date, isTo: this.toDateDatepicker, isSelecting: true });
        }
    }
    isValidRange() {
        return (!this.fromDate ||
            !this.toDate ||
            new NgbDate(this.fromDate.year, this.fromDate.month, this.fromDate.day).before(this.toDate));
    }
}
InputDatepickerDayTemplateRangeComponent.hangledKeyCodes = [KEY_CODES.LEFT, KEY_CODES.UP, KEY_CODES.RIGHT, KEY_CODES.DOWN];
InputDatepickerDayTemplateRangeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerDayTemplateRangeComponent, deps: [{ token: NgbDateLocaleParserFormatter }, { token: i2.BrowserService }], target: i0.ɵɵFactoryTarget.Component });
InputDatepickerDayTemplateRangeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerDayTemplateRangeComponent, selector: "bb-input-datepicker-range-day-template-ui", inputs: { date: "date", disabled: "disabled", currentMonth: "currentMonth", fromDate: "fromDate", toDate: "toDate", splitRange: "splitRange", toDateDatepicker: "toDateDatepicker", hoveredDate: "hoveredDate" }, outputs: { rangeSelect: "rangeSelect", hovered: "hovered" }, host: { listeners: { "mouseout": "onMouseOut()", "mouseover": "onMouseOver()", "document:keyup": "onKeyUp($event)" } }, providers: [
        DatePipe,
        NgbDateLocaleParserFormatter,
        {
            provide: NgbDateParserFormatter,
            useExisting: NgbDateLocaleParserFormatter,
        },
        BrowserService,
        { provide: NAVIGATOR_TOKEN, useFactory: navigatorFactory },
    ], usesOnChanges: true, ngImport: i0, template: "<time\n  class=\"custom-day text-center bb-input-datepicker__custom-day\"\n  [ngClass]=\"{\n    'is-range-selected': isWithinSelectedRange,\n    'is-faded': isWithinRangeHover,\n    'is-faded-from-date': isWithinRangeHover && !toDateDatepicker && splitRange,\n    'is-hovered': isHovered,\n    'text-muted': isTextMuted,\n    'from-date': isFrom,\n    'to-date': isTo\n  }\"\n  [attr.data-role]=\"'calendar-date-item'\"\n  [dateTime]=\"formattedDate\"\n>\n  {{ date?.day }}\n</time>\n", directives: [{ type: i8.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerDayTemplateRangeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-datepicker-range-day-template-ui',
                    templateUrl: './input-datepicker-day-template-range.component.html',
                    providers: [
                        DatePipe,
                        NgbDateLocaleParserFormatter,
                        {
                            provide: NgbDateParserFormatter,
                            useExisting: NgbDateLocaleParserFormatter,
                        },
                        BrowserService,
                        { provide: NAVIGATOR_TOKEN, useFactory: navigatorFactory },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: NgbDateLocaleParserFormatter }, { type: i2.BrowserService }]; }, propDecorators: { date: [{
                type: Input
            }], disabled: [{
                type: Input
            }], currentMonth: [{
                type: Input
            }], fromDate: [{
                type: Input
            }], toDate: [{
                type: Input
            }], splitRange: [{
                type: Input
            }], toDateDatepicker: [{
                type: Input
            }], hoveredDate: [{
                type: Input
            }], rangeSelect: [{
                type: Output
            }], hovered: [{
                type: Output
            }], onMouseOut: [{
                type: HostListener,
                args: ['mouseout']
            }], onMouseOver: [{
                type: HostListener,
                args: ['mouseover']
            }], onKeyUp: [{
                type: HostListener,
                args: ['document:keyup', ['$event']]
            }] } });

// Oleksii depricate
/* eslint-disable */
var Key;
(function (Key) {
    Key[Key["Tab"] = 9] = "Tab";
    Key[Key["Enter"] = 13] = "Enter";
    Key[Key["Escape"] = 27] = "Escape";
    Key[Key["Space"] = 32] = "Space";
    Key[Key["PageUp"] = 33] = "PageUp";
    Key[Key["PageDown"] = 34] = "PageDown";
    Key[Key["End"] = 35] = "End";
    Key[Key["Home"] = 36] = "Home";
    Key[Key["ArrowLeft"] = 37] = "ArrowLeft";
    Key[Key["ArrowUp"] = 38] = "ArrowUp";
    Key[Key["ArrowRight"] = 39] = "ArrowRight";
    Key[Key["ArrowDown"] = 40] = "ArrowDown";
})(Key || (Key = {}));
const isDateRangeModelType = (value) => Object.prototype.hasOwnProperty.call(value || {}, 'from') && Object.prototype.hasOwnProperty.call(value || {}, 'to');
/**
 * @name InputDatepickerComponent
 *
 * @description
 * Component that displays a datepicker
 *
 * ### Custom internalization
 * It is possible to provide a custom internalisation. To do this, a `DATEPICKER_I18` token from `@backbase/ui-ang/input-datepicker` should be provided on the module level.
 * The token should implement the [NgbDatepickerI18n](https://ng-bootstrap.github.io/#/components/datepicker/api#NgbDatepickerI18n) interface.
 *
 * ### Setting and reading the  date
 * *Note* Datepicker uses the date *with the timezone* inside its model. And hence to make it work properly in all cases there are some recommendations for setting and reading the date to and from the datepicker.
 * #### Setting the date
 * When setting the date to the datepicker the date must be provided in the format that assumes zero hours and zero minutes in the local timezone. Here are some examples of what the date setting should looks like:
 * ```
   this.minDate = new Date(2021,11,15, 0, 0).toISOString();
   ```
 *
 * or
 * ```
   this.minDate = new Date('2021-12-15T00:00').toISOString();
   ```
 *
 * Note that
 * ```
   new Date('2021-12-15').toISOString();
   ```
 *
 * generates a date in GMT0 format and that is not correct for the datepicker input date.
 * #### Reading the date
 * When a date is selected via UI (the datepicker's popup window or browser's input field) its display date is transformed to the ISO string date with the assumption that it’s zero hours and zero minutes in the current time zone. Which leads to the different ISO string values for different time zones for the same date. F.e. "Dec 15 2021" is going to be transformed to "2021-12-14T23:00:00.000Z" for the "GMT+0100 (Central European Standard Time)" time zone and to "2021-12-15T03:00:00.000Z" for "GMT-0300 (West Greenland Standard Time)" time zone. As you can see the _day_ value is different in ISO string based on the timezone. It’s going to be either 14 or 15 in the example above.
 *
 * The recommendation here is to convert the ISO string, that the datepicker returns, into the Date object and read it's day value. Here is an example:
 * ```
  private formatDate(stringDate: string): string {
    const date = new Date(stringDate);
    if (stringDate && !isNaN(date.valueOf())) {
      return `${date.getFullYear()}-${this.appendLeadingZeroes(date.getMonth() + 1)}-${this.appendLeadingZeroes(date.getDate())}`;
    }
    return '';
  }

  private appendLeadingZeroes(value: number) {
    return value > 9 ? value : `0${value}`;
  }
   ```
 *
 * @a11y Current component provide option to pass needed accessibility
 * attributes. You need to take care of properties that are required in your case :
 *  - role
 *  - aria-activedescendant
 *  - aria-describedby
 *  - aria-expanded
 *  - aria-invalid
 *  - aria-label
 *  - aria-labelledby
 *  - aria-owns
 *
 * `ariaLabel` is discernible text for datepicker
 */
class InputDatepickerComponent extends InputBaseComponent {
    constructor(formatterHelper, el, cd, deprecationsService, adapter, renderer2, domAttrService) {
        super(cd, deprecationsService);
        this.formatterHelper = formatterHelper;
        this.el = el;
        this.cd = cd;
        this.deprecationsService = deprecationsService;
        this.adapter = adapter;
        this.renderer2 = renderer2;
        this.domAttrService = domAttrService;
        /**
         * Event to trigger on date hover
         */
        this.focusedDate = new EventEmitter();
        /**
         * Indicates if the datepicker should select a date range with single input (from - to).
         * Defaults to false
         */
        this.rangeSelection = false;
        /**
         * Indicates if the datepicker should a date range with split input. One for the from date and one for the to date.
         * Defaults to false
         */
        this.rangeSelectionSplit = false;
        /**
         * Indicates if the datepicker is opened when clicking input.
         * Defaults to false
         */
        this.clickOpen = false;
        /**
         * Indicates if the datepicker is opened when focusing input.
         * Defaults to false
         */
        this.focusOpen = false;
        this._placement = 'bottom-left';
        /**
         * Accessible description for datepicker date selection popup.
         */
        this.datepickerDescribedby = 'defaultDatepickerDescribedbyLabel';
        /**
         * Accessible label for Datepicker button.
         */
        this.ariaLabelForButton = 'Toggle Date popup';
        /**
         * Icon that is dispayed in the button.
         * Defaults to calendar
         */
        this.icon = 'calendar-today';
        /**
         * The size of the icon to be displayed.
         * Defaults to md
         */
        this.iconSize = 'md';
        /**
         * Color of the button.
         * Defaults to link
         */
        this.btnColor = 'link';
        /**
         * Aria label for the datepicker
         */
        this.ariaLabel = 'Datepicker';
        /**
         * Navigation pattern through dates.
         * Default to arrows
         */
        this.navigation = 'arrows';
        /**
         * Indicates how many month will be shown in the picker
         */
        this.displayMonths = 1;
        this.hoveredDate$ = new BehaviorSubject({ date: null });
        this.pickerHoveredDayDateTo = null;
        this.fromDate$ = new BehaviorSubject(null);
        this.toDate$ = new BehaviorSubject(null);
        this.inputDateRangeSeparator = '-';
        this.cssClass = 'bb-input-datepicker-ui';
        /**
         * @description
         * Passing template date to the range template to identify when it is used in the "to" date
         * (the second HTML date input of the split datepicker).
         * Check https://ng-bootstrap.github.io/#/components/datepicker/api "dayTemplateData" for details
         */
        this.rangeTemplateData = () => ({
            isTo: true,
        });
        /***************************************8
         *
         *  CONTROLVALUEACCESSOR OVERRIDES
         *
         **************************************/
        /**
         * Implements custom validation for the control
         *
         * @param control
         */
        this.validate = (control) => {
            const value = control.value;
            if (!this.parentFormControl) {
                this.parentFormControl = control;
            }
            if (!value) {
                /* eslint-disable-next-line  no-null/no-null */
                return null;
            }
            if (this.rangeSelection || this.rangeSelectionSplit) {
                return this.validateDateRange(value);
            }
            return this.validateSingleDate(value);
        };
        this.dateInput = new FormControl(null);
        this.dateInputTo = new FormControl(null);
    }
    get placement() {
        return document.documentElement.clientWidth > 320 ? this._placement : 'bottom';
    }
    /**
     * Placement of a popup window
     */
    set placement(value) {
        if (value) {
            this._placement = value;
        }
    }
    /**
     * Min date for the navigation. If not provided, 'year' select box will display 10 years
     * before current month
     */
    set minDate(date) {
        this._minDate = typeof date === 'string' ? this.adapter.fromModel(date) : date;
    }
    /**
     * Max date for the navigation. If not provided, 'year' select box will display 10 years
     * after current month
     */
    set maxDate(date) {
        this._maxDate = typeof date === 'string' ? this.adapter.fromModel(date) : date;
    }
    get placeholder() {
        if (typeof this._placeholder === 'undefined') {
            const pattern = this.dateFormat.toUpperCase();
            return this.rangeSelection ? `${pattern} ${this.inputDateRangeSeparator} ${pattern}` : pattern;
        }
        return this._placeholder;
    }
    /**
     * The placeholder for the datepicker input. Default is Locale Date Format;
     */
    set placeholder(value) {
        this._placeholder = typeof value !== 'undefined' ? String(value) : undefined;
    }
    /**
     * Override date format (optional). Supported formats are `yyyy/MM/dd`, `MM/dd/yyyy`, `MMMM dd, yyyy`.
     * Note, other formats might work inconsistent in different browsers.
     */
    set overrideDateFormat(value) {
        this._overrideDateFormat = value;
        this.formatterHelper.dateFormat = value;
    }
    get overrideDateFormat() {
        return this._overrideDateFormat;
    }
    /**
     * The custom or locale date format that is used to display dates and placeholders
     */
    get dateFormat() {
        return this.formatterHelper.localeDateFormat;
    }
    ngOnChanges(changes) {
        const { disabled } = changes;
        if (disabled && disabled.currentValue !== disabled.previousValue) {
            if (this.disabled) {
                this.dateInput.disable();
            }
            else {
                this.dateInput.enable();
            }
        }
    }
    // todo: do we need this?
    ngAfterViewInit() {
        const datepickerInput = this.rangeSelection ? this.datePickerRangeInput : this.datePickerInput;
        this.domAttrService.moveAriaAttributes(this.el.nativeElement, datepickerInput === null || datepickerInput === void 0 ? void 0 : datepickerInput.nativeElement, this.renderer2);
        setTimeout(() => {
            // internal validators are not used
            this.dateInput.setValidators([]);
            this.dateInput.updateValueAndValidity();
            this.cd.markForCheck();
        });
    }
    dateEqual(xDate, yDate) {
        const a = new Date(xDate.year, xDate.month - 1, xDate.day).getTime();
        const b = new Date(yDate.year, yDate.month - 1, yDate.day).getTime();
        return a === b ? 0 : a > b ? 1 : -1;
    }
    /****************************************
     *
     *        EVENT HANDLERS
     *
     ***************************************/
    /**
     * @description
     * Input change handler for single date
     *
     * @param element
     */
    onInputChange(element) {
        // Checking for "browser bug", for example,
        // In IE `new Date()` for short date format YY gives 19YY, for modern browser in looks like 20YY
        // for this reason we're adding 100 years to browser understand that it is 21st century
        const dateInputToUpdate = element.name === 'date' ? this.dateInput : this.dateInputTo;
        const { value } = element;
        const browserDate = new Date(value);
        const parsedDate = this.formatterHelper.interpretDate(value);
        if (parsedDate && parsedDate.getTime() !== browserDate.getTime()) {
            dateInputToUpdate.setValue(parsedDate);
        }
    }
    /**
     * Update datepicker value on input value change for same input date range selection
     *
     * @param value
     */
    onInputChangeRange(element) {
        const { value } = element;
        const [dateFrom, dateTo] = value.split(this.inputDateRangeSeparator).slice(0, 2);
        this.fromDate$.next(this.formatterHelper.parse(dateFrom === null || dateFrom === void 0 ? void 0 : dateFrom.trim()));
        this.toDate$.next(this.formatterHelper.parse(dateTo === null || dateTo === void 0 ? void 0 : dateTo.trim()));
        if (this.fromDate$.getValue() || this.toDate$.getValue()) {
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        }
        else {
            this.onChange(value);
        }
    }
    /**
     * Update datepicker value on input value change for split input date range selection, from date
     *
     * @param value
     */
    onInputChangeSplitRange(element) {
        const { value } = element;
        this.fromDate$.next(this.formatterHelper.parse(value && value.trim()));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
    }
    /**
     * Update datepicker value on input value change for split input date range selection, to date
     *
     * @param value
     */
    onInputChangeSplitRangeTo(element) {
        const { value } = element;
        this.toDate$.next(this.formatterHelper.parse(value && value.trim()));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
    }
    /**
     * Event handler for the native input
     */
    onInputFocus(open) {
        super.onFocus();
        if (open && this.datePicker) {
            this.bindDocumentEvents();
            this.datePicker.open();
            if (this.rangeSelection || this.rangeSelectionSplit) {
                this.datePicker.startDate = this.toDate$.getValue();
            }
        }
    }
    /**
     * Event handler for the native input
     */
    onInputFocusTo(open) {
        super.onFocus();
        if (open && this.datePickerTo) {
            this.datePickerTo.open();
        }
    }
    /**
     * Event handler for the picker toggle button to
     */
    onPickerTogglerClick(event) {
        if (!this.disabled && this.datePicker) {
            this.bindDocumentEvents();
            this.setStartDateOnPicker(this.datePicker);
            this.datePicker.toggle();
        }
    }
    /**
     * Event handler for the picker toggle button to (split range selection)
     */
    onPickerTogglerClickTo(event) {
        if (!this.disabled && this.datePickerTo) {
            this.bindDocumentEvents();
            this.setStartDateOnPicker(this.datePickerTo);
            this.datePickerTo.toggle();
        }
    }
    /**
     *
     * Set disable state for the host control
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled) {
        if (isDisabled) {
            this.dateInput.disable();
        }
        else {
            this.dateInput.enable();
        }
        super.setDisabledState(isDisabled);
    }
    /**
     * Event handler blur on internal inputs and buttons
     *
     * @param $event
     */
    onControlBlur($event) {
        if (!$event.relatedTarget || !this.el.nativeElement.contains($event.relatedTarget)) {
            this.onBlur($event);
        }
        if (this.rangeSelection) {
            if (!this.toDate$.getValue() || !this.fromDate$.getValue()) {
                this.setDatesTheSame();
            }
            else {
                this.setRangeInput();
            }
        }
    }
    /**
     * Event handler for blur on the host control
     *
     * @param $event
     */
    onBlur($event) {
        this.blur.emit($event);
        this.onTouched();
    }
    /**
     * @description
     *
     * Event handler for closing `from` or single date picker
     *
     */
    onClosed() {
        const hoveredDateClosedValue = this.hoveredDate$.getValue();
        const hoveredDate = hoveredDateClosedValue === null || hoveredDateClosedValue === void 0 ? void 0 : hoveredDateClosedValue.date;
        if (hoveredDate) {
            this.setSelectedDate({ date: hoveredDate, isSelecting: false });
        }
        if (this.rangeSelection && this.datePickerButton) {
            this.datePickerButton.nativeElement.focus();
        }
        else if (this.rangeSelectionSplit && this.datePickerTo && this.datePickerInputTo) {
            this.datePickerInputTo.nativeElement.focus();
        }
    }
    /**
     * Event handler for closing picker for `to` date
     */
    onClosedTo() {
        if (this.datePickerButtonTo !== undefined && this.datePicker && !this.datePicker.isOpen()) {
            this.datePickerButtonTo.nativeElement.focus();
        }
    }
    /**
     * Event handler for date setting from picker for `to` date when split input range selection
     *
     * @param date
     */
    onRangeDateSelectSplitTo(date) {
        this.toDate$.next(this.copyDateElement(date));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        this.onTouched();
    }
    /**
     * Event handler for date setting from picker for `from` date when split input range selection
     *
     * @param date
     */
    onRangeDateSelectSplit(date) {
        this.fromDate$.next(this.copyDateElement(date));
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        this.onTouched();
    }
    /**
     *  Event handler for date setting from picker when single input range selection
     *
     * @param date
     */
    onRangeDateSelect(date) {
        if (!this.fromDate$.getValue() && !this.toDate$.getValue()) {
            this.fromDate$.next(this.copyDateElement(date));
        }
        else if (this.fromDate$.getValue() &&
            !this.toDate$.getValue() &&
            date &&
            (date.after(this.fromDate$.getValue()) || date.equals(this.fromDate$.getValue()))) {
            this.toDate$.next(this.copyDateElement(date));
            setTimeout(() => this.closeDatePicker(), 0);
        }
        else {
            /* eslint-disable-next-line no-null/no-null */
            this.toDate$.next(null);
            this.fromDate$.next(this.copyDateElement(date));
        }
        this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
        this.setRangeInput();
    }
    /**
     *
     * Handling day-hover from day-template on range selection.
     *
     * @param event
     */
    onDayHover(event) {
        if (event.isTo) {
            this.pickerHoveredDayDateTo = event.date;
        }
        else {
            this.setSelectedDate({ date: event.date, isSelecting: event.isSelecting });
        }
    }
    /**
     *
     * Implements the value update for the control
     *
     * @param model
     */
    /* eslint-disable-next-line complexity */
    writeValue(model) {
        if (!this.rangeSelection && !this.rangeSelectionSplit) {
            this.dateInput.setValue(typeof model === 'string' ? model : null);
        }
        else {
            if (isDateRangeModelType(model)) {
                if (model.from && this.validateSingleDate(model.from) === null) {
                    this.fromDate$.next(this.adapter.fromModel(model.from));
                }
                else {
                    this.fromDate$.next(model.from);
                }
                if (model.to && this.validateSingleDate(model.to) === null) {
                    this.toDate$.next(this.adapter.fromModel(model.to));
                }
                else {
                    this.toDate$.next(model.to);
                }
            }
            else {
                this.fromDate$.next(null);
                this.toDate$.next(null);
            }
            if (this.rangeSelection) {
                this.setRangeInput();
            }
            else if (this.rangeSelectionSplit) {
                this.dateInput.setValue(this.fromDate$.getValue() ? this.adapter.toModel(this.fromDate$.getValue()) : null);
                this.dateInputTo.setValue(this.toDate$.getValue() ? this.adapter.toModel(this.toDate$.getValue()) : null);
            }
        }
    }
    /*********************************
     *
     *        PRIVATE UTILS
     *
     **********************************/
    setSelectedDate(date) {
        this.hoveredDate$.next(date);
        this.focusedDate.emit(date);
    }
    setDatesTheSame() {
        const fromDate = this.fromDate$.getValue();
        if (fromDate) {
            this.toDate$.next(fromDate);
            this.updateRangeModel(this.fromDate$.getValue(), this.toDate$.getValue());
            this.setRangeInput();
        }
    }
    closeDatePicker() {
        var _a;
        if (this.datePicker) {
            this.datePicker.close();
            if (this.rangeSelection) {
                (_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.updateValueAndValidity();
            }
            this.onBlur();
        }
        if (this.datePickerTo) {
            this.datePickerTo.close();
            this.onBlur();
        }
        // Unbind the global document events once the date picker is closed
        if (this.unListenDocumentClick) {
            this.unListenDocumentClick();
        }
        if (this.unListenDocumentEsc) {
            this.unListenDocumentEsc();
        }
    }
    isValidRange(from, to) {
        if (new Date(from).getTime() > new Date(to).getTime()) {
            return { invalidDateFormat: true };
        }
        return null;
    }
    validateSingleDate(value) {
        const date = typeof value === 'string' ? value : value.toISOString();
        // check if value is in ISO format
        // this means that it has passed parsing and that it is in date format for current locale
        // This check is for IE11
        const ISODateRegExp = /^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)$/g;
        return ISODateRegExp.test(date) ? null : { invalidDateFormat: true };
    }
    /**
     * Document Event handler
     */
    handleDocumentEvent(event) {
        if (event.target && (!this.el.nativeElement.contains(event.target) || event.type === 'keyup')) {
            this.closeDatePicker();
        }
    }
    /**
     * Binds event on the global document when the datepicker is not opened
     */
    bindDocumentEvents() {
        if (this.datePicker && !this.datePicker.isOpen()) {
            this.unListenDocumentClick = this.renderer2.listen('document', 'click', this.handleDocumentEvent.bind(this));
            this.unListenDocumentEsc = this.renderer2.listen('document', 'keyup.escape', this.handleDocumentEvent.bind(this));
        }
    }
    /* eslint-disable-next-line complexity */
    validateDateRange(value) {
        let validateTo = null;
        let validateFrom = null;
        let validateRange = null;
        if (!isDateRangeModelType(value)) {
            return { invalidDateFormat: true };
        }
        if (!value.from && !value.to && !this.isRequired()) {
            return null;
        }
        if ((!value.to && value.from) || (value.to && !value.from) || (!value.from && !value.to && this.isRequired())) {
            return { required: true };
        }
        if (value.from) {
            validateFrom = this.validateSingleDate(value.from);
        }
        if (value.to) {
            validateTo = this.validateSingleDate(value.to);
        }
        if (!validateFrom && !validateTo && value.from && value.to) {
            validateRange = this.isValidRange(value.from, value.to);
        }
        return validateTo || validateFrom || validateRange;
    }
    setRangeInput() {
        var _a;
        if (this.fromDate$.getValue() || this.toDate$.getValue()) {
            const formattedFrom = this.formatterHelper.format(this.fromDate$.getValue());
            const formattedTo = this.formatterHelper.format(this.toDate$.getValue());
            this.dateInput.setValue(`${formattedFrom === null ? this.fromDate$.getValue() : formattedFrom} ${this.inputDateRangeSeparator} ${formattedTo === null ? this.toDate$.getValue() : formattedTo}`);
        }
        else {
            /* eslint-disable-next-line no-null/no-null */
            this.dateInput.setValue(null);
        }
        if ((_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.touched) {
            this.onTouched();
        }
    }
    copyDateElement(sourceDate) {
        return { year: sourceDate.year, month: sourceDate.month, day: sourceDate.day };
    }
    updateRangeModel(from, to) {
        this.onChange({
            from: from ? this.adapter.toModel(from) : null,
            to: to ? this.adapter.toModel(to) : null,
        });
    }
    isRequired() {
        var _a, _b;
        if ((_a = this.parentFormControl) === null || _a === void 0 ? void 0 : _a.validator) {
            const validator = (_b = this.parentFormControl) === null || _b === void 0 ? void 0 : _b.validator({});
            if (validator && validator.required) {
                return true;
            }
        }
        return false;
    }
    setStartDateOnPicker(picker) {
        var _a, _b;
        let startDate = null;
        if (this.rangeSelection) {
            startDate = this.fromDate$.getValue();
        }
        else if (this.rangeSelectionSplit && ((_a = this.fromDate$.getValue()) === null || _a === void 0 ? void 0 : _a.year)) {
            startDate = this.fromDate$.getValue();
        }
        else if (this.rangeSelectionSplit && ((_b = this.toDate$.getValue()) === null || _b === void 0 ? void 0 : _b.year)) {
            startDate = this.toDate$.getValue();
        }
        if (!!startDate) {
            picker.startDate = startDate;
        }
    }
}
InputDatepickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerComponent, deps: [{ token: NgbDateLocaleParserFormatter }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i2$1.DeprecationsService }, { token: i3.NgbDateAdapter }, { token: i0.Renderer2 }, { token: i2.DomAttributesService }], target: i0.ɵɵFactoryTarget.Component });
InputDatepickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: InputDatepickerComponent, selector: "bb-input-datepicker-ui", inputs: { rangeSelection: "rangeSelection", rangeSelectionSplit: "rangeSelectionSplit", clickOpen: "clickOpen", focusOpen: "focusOpen", placement: "placement", datepickerDescribedby: "datepickerDescribedby", ariaLabelForButton: "ariaLabelForButton", minDate: "minDate", maxDate: "maxDate", markDisabled: "markDisabled", icon: "icon", iconSize: "iconSize", iconColor: "iconColor", btnColor: "btnColor", ariaLabel: "ariaLabel", navigation: "navigation", autocomplete: "autocomplete", firstDayOfWeek: "firstDayOfWeek", displayMonths: "displayMonths", placeholder: "placeholder", overrideDateFormat: "overrideDateFormat" }, outputs: { focusedDate: "focusedDate" }, host: { properties: { "attr.class": "this.cssClass" } }, providers: [
        DatePipe,
        NgbDateLocaleParserFormatter,
        {
            provide: NgbDateAdapter,
            useClass: NgbDateStringAdapter,
        },
        {
            provide: NgbDatepickerI18n,
            useClass: NgbDatepickerI18nDefault,
        },
        {
            provide: NgbDateParserFormatter,
            useExisting: NgbDateLocaleParserFormatter,
        },
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => InputDatepickerComponent),
            multi: true,
        },
        {
            provide: NG_VALIDATORS,
            useExisting: forwardRef(() => InputDatepickerComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "datePicker", first: true, predicate: ["datePicker"], descendants: true }, { propertyName: "datePickerTo", first: true, predicate: ["datePickerTo"], descendants: true }, { propertyName: "datePickerInput", first: true, predicate: ["datePickerInput"], descendants: true }, { propertyName: "datePickerRangeInput", first: true, predicate: ["datePickerRangeInput"], descendants: true }, { propertyName: "datePickerInputTo", first: true, predicate: ["datePickerInputTo"], descendants: true }, { propertyName: "datePickerButton", first: true, predicate: ["datePickerButton"], descendants: true }, { propertyName: "datePickerButtonTo", first: true, predicate: ["datePickerButtonTo"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div\n  class=\"bb-input-datepicker__wrapper\"\n  [ngClass]=\"{\n    'ng-invalid': parentFormControl?.invalid,\n    'ng-touched': parentFormControl?.touched,\n    'bb-input-datepicker__range-split-wrapper': rangeSelectionSplit\n  }\"\n>\n  <label *ngIf=\"label\" class=\"bb-input-datepicker__label\" for=\"{{ id }}\">{{ label }}</label>\n  <div class=\"input-group bb-input-datepicker\" #positionTarget>\n    <ng-container *ngIf=\"!rangeSelection; else dateRangeInput\">\n      <input\n        type=\"text\"\n        id=\"{{ id }}\"\n        name=\"date\"\n        class=\"form-control bb-input-datepicker__input\"\n        [attr.placeholder]=\"placeholder\"\n        [attr.aria-labelledby]=\"ariaLabelledby\"\n        [attr.aria-describedby]=\"datepickerDescribedby\"\n        [attr.aria-expanded]=\"ariaExpanded\"\n        [attr.role]=\"role\"\n        [attr.aria-invalid]=\"ariaInvalid\"\n        [attr.aria-owns]=\"ariaOwns\"\n        [attr.aria-activedescendant]=\"ariaActivedescendant\"\n        [attr.aria-label]=\"(!label && ariaLabel) || null\"\n        ngbDatepicker\n        [minDate]=\"_minDate\"\n        [maxDate]=\"_maxDate\"\n        [markDisabled]=\"markDisabled\"\n        [readOnly]=\"readonly\"\n        [required]=\"required\"\n        [navigation]=\"navigation\"\n        [dayTemplate]=\"rangeSelectionSplit ? rangeDay : singleDay\"\n        [displayMonths]=\"displayMonths\"\n        [formControl]=\"dateInput\"\n        [placement]=\"placement\"\n        [positionTarget]=\"positionTarget\"\n        [restoreFocus]=\"!rangeSelectionSplit\"\n        (ngModelChange)=\"!rangeSelectionSplit ? onChange($event) : null\"\n        (click)=\"onInputFocus(clickOpen)\"\n        (focus)=\"onInputFocus(focusOpen)\"\n        (blur)=\"onControlBlur($event)\"\n        (input)=\"rangeSelectionSplit ? onInputChangeSplitRange(datePickerInput) : onInputChange(datePickerInput)\"\n        (closed)=\"onClosed()\"\n        #datePicker=\"ngbDatepicker\"\n        #datePickerInput\n        [attr.data-role]=\"'input-date-single'\"\n        [attr.autocomplete]=\"autocomplete\"\n        [firstDayOfWeek]=\"firstDayOfWeek\"\n        (dateSelect)=\"rangeSelectionSplit ? onRangeDateSelectSplit($event) : null\"\n        [autoClose]=\"!rangeSelectionSplit\"\n      />\n    </ng-container>\n\n    <div\n      *ngIf=\"datepickerDescribedby === 'defaultDatepickerDescribedbyLabel'\"\n      class=\"sr-only\"\n      aria-live=\"polite\"\n      id=\"defaultDatepickerDescribedbyLabel\"\n    >\n      <ng-container *ngIf=\"hoveredDate$ | async as hoveredDate\">\n        <span\n          *ngIf=\"hoveredDate.isSelecting; else selectedDate\"\n          i18n=\"Default selecting date state i18n message@@defaultSelectingState.with.i18n.support\"\n          >Selecting date:\n          {{\n            hoveredDate.date.year + '-' + hoveredDate.date.month + '-' + hoveredDate.date.day | date: 'longDate'\n          }}</span\n        >\n        <ng-template #selectedDate>\n          <ng-container\n            i18n=\"Default selected date state i18n message@@defaultSelectedState.with.i18n.support\"\n            *ngIf=\"hoveredDate.date\"\n            >Selected date is{{\n              hoveredDate.date.year + '-' + hoveredDate.date.month + '-' + hoveredDate.date.day | date: 'longDate'\n            }}.</ng-container\n          >\n        </ng-template>\n      </ng-container>\n    </div>\n\n    <div class=\"input-group-append\">\n      <button\n        #datePickerButton\n        bbButton\n        class=\"bb-input-datepicker__calendar-opener-button\"\n        [color]=\"btnColor\"\n        [disabled]=\"disabled || readonly\"\n        (blur)=\"onControlBlur($event)\"\n        [attr.aria-label]=\"ariaLabelForButton\"\n        (click)=\"onPickerTogglerClick($event)\"\n        [attr.data-role]=\"'toggle-calendar-button'\"\n      >\n        <bb-icon-ui [color]=\"iconColor\" [name]=\"icon\" [size]=\"iconSize\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n\n  <div class=\"input-group bb-input-datepicker\" *ngIf=\"rangeSelectionSplit\">\n    <input\n      type=\"text\"\n      id=\"to_{{ id }}\"\n      name=\"dateTo\"\n      class=\"form-control bb-input-datepicker__input\"\n      [attr.placeholder]=\"placeholder\"\n      [attr.aria-labelledby]=\"ariaLabelledby\"\n      [attr.aria-describedby]=\"datepickerDescribedby\"\n      [attr.aria-expanded]=\"ariaExpanded\"\n      [attr.role]=\"role\"\n      [attr.aria-invalid]=\"ariaInvalid\"\n      [attr.aria-owns]=\"ariaOwns\"\n      [attr.aria-activedescendant]=\"ariaActivedescendant\"\n      [attr.aria-label]=\"(!label && ariaLabel) || null\"\n      ngbDatepicker\n      [minDate]=\"_minDate\"\n      [maxDate]=\"_maxDate\"\n      [markDisabled]=\"markDisabled\"\n      [readOnly]=\"readonly\"\n      [required]=\"required\"\n      [displayMonths]=\"displayMonths\"\n      [navigation]=\"navigation\"\n      [restoreFocus]=\"false\"\n      [dayTemplate]=\"rangeDay\"\n      [dayTemplateData]=\"rangeTemplateData\"\n      [formControl]=\"dateInputTo\"\n      [placement]=\"placement\"\n      (click)=\"onInputFocusTo(clickOpen)\"\n      (focus)=\"onInputFocusTo(focusOpen)\"\n      (blur)=\"onControlBlur($event)\"\n      (input)=\"rangeSelectionSplit ? onInputChangeSplitRangeTo(datePickerInputTo) : onInputChange(datePickerInputTo)\"\n      (closed)=\"onClosedTo()\"\n      #datePickerTo=\"ngbDatepicker\"\n      #datePickerInputTo\n      [attr.data-role]=\"'input-date-single'\"\n      [attr.autocomplete]=\"autocomplete\"\n      [firstDayOfWeek]=\"firstDayOfWeek\"\n      (dateSelect)=\"rangeSelectionSplit ? onRangeDateSelectSplitTo($event) : null\"\n      [autoClose]=\"!rangeSelectionSplit\"\n    />\n    <div class=\"input-group-append\">\n      <button\n        #datePickerButtonTo\n        bbButton\n        class=\"bb-input-datepicker__calendar-opener-button\"\n        [color]=\"btnColor\"\n        [disabled]=\"disabled || readonly\"\n        [attr.aria-label]=\"ariaLabelForButton\"\n        (blur)=\"onControlBlur($event)\"\n        (click)=\"onPickerTogglerClickTo($event)\"\n        [attr.data-role]=\"'toggle-calendar-button'\"\n      >\n        <bb-icon-ui [color]=\"iconColor\" [name]=\"icon\" [size]=\"iconSize\"></bb-icon-ui>\n      </button>\n    </div>\n  </div>\n</div>\n\n<!-- Single input date range template -->\n\n<ng-template #dateRangeInput>\n  <input\n    type=\"text\"\n    name=\"date\"\n    id=\"{{ id }}\"\n    class=\"form-control bb-input-datepicker__range\"\n    [formControl]=\"dateInput\"\n    [readOnly]=\"readonly\"\n    [required]=\"required\"\n    #datePickerRangeInput\n    [attr.placeholder]=\"placeholder\"\n    [attr.aria-label]=\"(!label && ariaLabel) || null\"\n    [attr.aria-describedby]=\"datepickerDescribedby\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-expanded]=\"ariaExpanded\"\n    [attr.role]=\"role\"\n    [attr.aria-invalid]=\"ariaInvalid\"\n    [attr.aria-owns]=\"ariaOwns\"\n    [attr.aria-activedescendant]=\"ariaActivedescendant\"\n    (click)=\"onInputFocus(clickOpen)\"\n    (focus)=\"onInputFocus(focusOpen)\"\n    (blur)=\"onControlBlur($event)\"\n    (input)=\"onInputChangeRange(datePickerRangeInput)\"\n    [attr.data-role]=\"'input-date-range'\"\n  />\n\n  <input\n    type=\"text\"\n    class=\"datepicker-input-hidden bb-input-datepicker__range-input-hidden\"\n    ngbDatepicker\n    (closed)=\"onClosed()\"\n    [minDate]=\"_minDate\"\n    [maxDate]=\"_maxDate\"\n    [markDisabled]=\"markDisabled\"\n    [autoClose]=\"false\"\n    [attr.aria-label]=\"label || ariaLabel || null\"\n    [attr.aria-describedby]=\"datepickerDescribedby\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [attr.aria-expanded]=\"ariaExpanded\"\n    [attr.role]=\"role\"\n    [attr.aria-invalid]=\"ariaInvalid\"\n    [attr.aria-owns]=\"ariaOwns\"\n    [attr.aria-activedescendant]=\"ariaActivedescendant\"\n    [readOnly]=\"readonly\"\n    [required]=\"required\"\n    [firstDayOfWeek]=\"firstDayOfWeek\"\n    [positionTarget]=\"positionTarget\"\n    [placement]=\"placement\"\n    #datePicker=\"ngbDatepicker\"\n    [dayTemplate]=\"rangeDay\"\n    navigation=\"arrows\"\n    [attr.data-role]=\"'input-datepicker'\"\n    (dateSelect)=\"onRangeDateSelect($event)\"\n  />\n</ng-template>\n\n<!-- template end -->\n\n<!-- Single Date day template -->\n<ng-template\n  #singleDay\n  let-date=\"date\"\n  let-disabled=\"disabled\"\n  let-selected=\"selected\"\n  let-currentMonth=\"currentMonth\"\n  let-data=\"data\"\n>\n  <bb-input-datepicker-single-day-template-ui\n    [disabled]=\"disabled\"\n    [selected]=\"selected\"\n    [currentMonth]=\"currentMonth\"\n    [date]=\"date\"\n    (hovered)=\"onDayHover($event)\"\n    [hoveredDate]=\"data?.isTo ? pickerHoveredDayDateTo : hoveredDate$.getValue().date\"\n  >\n  </bb-input-datepicker-single-day-template-ui>\n</ng-template>\n\n<!-- template end -->\n\n<!-- Date range day template -->\n<ng-template\n  #rangeDay\n  let-date=\"date\"\n  let-disabled=\"disabled\"\n  let-selected=\"selected\"\n  let-currentMonth=\"currentMonth\"\n  let-data=\"data\"\n>\n  <bb-input-datepicker-range-day-template-ui\n    [date]=\"date\"\n    [fromDate]=\"fromDate$.getValue()\"\n    [toDate]=\"toDate$.getValue()\"\n    [splitRange]=\"rangeSelectionSplit\"\n    [toDateDatepicker]=\"data?.isTo\"\n    [disabled]=\"disabled\"\n    [currentMonth]=\"currentMonth\"\n    (hovered)=\"onDayHover($event)\"\n    [hoveredDate]=\"data?.isTo ? pickerHoveredDayDateTo : hoveredDate$.getValue().date\"\n  >\n  </bb-input-datepicker-range-day-template-ui>\n</ng-template>\n", components: [{ type: i5.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: InputDatepickerDayTemplateSingleComponent, selector: "bb-input-datepicker-single-day-template-ui", inputs: ["date", "selected", "disabled", "currentMonth", "hoveredDate"], outputs: ["hovered"] }, { type: InputDatepickerDayTemplateRangeComponent, selector: "bb-input-datepicker-range-day-template-ui", inputs: ["date", "disabled", "currentMonth", "fromDate", "toDate", "splitRange", "toDateDatepicker", "hoveredDate"], outputs: ["rangeSelect", "hovered"] }], directives: [{ type: i8.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i8.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgbInputDatepicker, selector: "input[ngbDatepicker]", inputs: ["disabled", "autoClose", "datepickerClass", "dayTemplate", "dayTemplateData", "displayMonths", "firstDayOfWeek", "footerTemplate", "markDisabled", "minDate", "maxDate", "navigation", "outsideDays", "placement", "restoreFocus", "showWeekNumbers", "startDate", "container", "positionTarget", "weekdays"], outputs: ["dateSelect", "navigate", "closed"], exportAs: ["ngbDatepicker"] }, { type: i9.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i9.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }, { type: i9.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i9.FormControlDirective, selector: "[formControl]", inputs: ["disabled", "formControl", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i10.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], pipes: { "async": i8.AsyncPipe, "date": i8.DatePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-input-datepicker-ui',
                    templateUrl: './input-datepicker.component.html',
                    providers: [
                        DatePipe,
                        NgbDateLocaleParserFormatter,
                        {
                            provide: NgbDateAdapter,
                            useClass: NgbDateStringAdapter,
                        },
                        {
                            provide: NgbDatepickerI18n,
                            useClass: NgbDatepickerI18nDefault,
                        },
                        {
                            provide: NgbDateParserFormatter,
                            useExisting: NgbDateLocaleParserFormatter,
                        },
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => InputDatepickerComponent),
                            multi: true,
                        },
                        {
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => InputDatepickerComponent),
                            multi: true,
                        },
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: NgbDateLocaleParserFormatter }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i2$1.DeprecationsService }, { type: i3.NgbDateAdapter }, { type: i0.Renderer2 }, { type: i2.DomAttributesService }]; }, propDecorators: { focusedDate: [{
                type: Output
            }], rangeSelection: [{
                type: Input
            }], rangeSelectionSplit: [{
                type: Input
            }], clickOpen: [{
                type: Input
            }], focusOpen: [{
                type: Input
            }], placement: [{
                type: Input
            }], datepickerDescribedby: [{
                type: Input
            }], ariaLabelForButton: [{
                type: Input
            }], minDate: [{
                type: Input
            }], maxDate: [{
                type: Input
            }], markDisabled: [{
                type: Input
            }], icon: [{
                type: Input
            }], iconSize: [{
                type: Input
            }], iconColor: [{
                type: Input
            }], btnColor: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }], navigation: [{
                type: Input
            }], autocomplete: [{
                type: Input
            }], firstDayOfWeek: [{
                type: Input
            }], displayMonths: [{
                type: Input
            }], placeholder: [{
                type: Input,
                args: ['placeholder']
            }], overrideDateFormat: [{
                type: Input,
                args: ['overrideDateFormat']
            }], datePicker: [{
                type: ViewChild,
                args: ['datePicker']
            }], datePickerTo: [{
                type: ViewChild,
                args: ['datePickerTo']
            }], datePickerInput: [{
                type: ViewChild,
                args: ['datePickerInput']
            }], datePickerRangeInput: [{
                type: ViewChild,
                args: ['datePickerRangeInput']
            }], datePickerInputTo: [{
                type: ViewChild,
                args: ['datePickerInputTo']
            }], datePickerButton: [{
                type: ViewChild,
                args: ['datePickerButton']
            }], datePickerButtonTo: [{
                type: ViewChild,
                args: ['datePickerButtonTo']
            }], cssClass: [{
                type: HostBinding,
                args: ['attr.class']
            }] } });

class MinDateValidatorDirective {
    constructor() {
        this._minDate = -Number.MAX_VALUE;
        this.onValidatorChange = () => { };
    }
    set minDate(date) {
        if (!date) {
            this._minDate = -Number.MAX_VALUE;
        }
        else {
            const minDate = typeof date === 'string' ? new Date(date) : new Date(date.year, date.month - 1, date.day);
            this._minDate = minDate.getTime();
        }
        this.onValidatorChange();
    }
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    validate(control) {
        const value = control.value && control.value.from ? control.value.from : control.value;
        if (!value) {
            return null;
        }
        return new Date(value).getTime() >= this._minDate
            ? // eslint-disable-next-line no-null/no-null
                null
            : { dateLessThanMinDate: true };
    }
    ngOnDestroy() {
        this.minDate = undefined;
    }
}
MinDateValidatorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MinDateValidatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
MinDateValidatorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: MinDateValidatorDirective, selector: "bb-input-datepicker-ui[minDate]", inputs: { minDate: "minDate" }, providers: [
        {
            provide: NG_VALIDATORS,
            multi: true,
            useExisting: forwardRef(() => MinDateValidatorDirective),
        },
    ], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MinDateValidatorDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'bb-input-datepicker-ui[minDate]',
                    providers: [
                        {
                            provide: NG_VALIDATORS,
                            multi: true,
                            useExisting: forwardRef(() => MinDateValidatorDirective),
                        },
                    ],
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { minDate: [{
                type: Input
            }] } });

class MaxDateValidatorDirective {
    constructor() {
        this._maxDate = Number.MAX_VALUE;
        this.onValidatorChange = () => { };
    }
    set maxDate(date) {
        if (!date) {
            this._maxDate = Number.MAX_VALUE;
        }
        else {
            const maxDate = typeof date === 'string' ? new Date(date) : new Date(date.year, date.month - 1, date.day);
            this._maxDate = maxDate.getTime();
        }
        this.onValidatorChange();
    }
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    validate(control) {
        const value = control.value && control.value.to ? control.value.to : control.value;
        if (!value) {
            return null;
        }
        return new Date(value).getTime() <= this._maxDate
            ? // eslint-disable-next-line no-null/no-null
                null
            : { dateGreaterThanMaxDate: true };
    }
    ngOnDestroy() {
        this.maxDate = undefined;
    }
}
MaxDateValidatorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MaxDateValidatorDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
MaxDateValidatorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: MaxDateValidatorDirective, selector: "bb-input-datepicker-ui[maxDate]", inputs: { maxDate: "maxDate" }, providers: [
        {
            provide: NG_VALIDATORS,
            multi: true,
            useExisting: forwardRef(() => MaxDateValidatorDirective),
        },
    ], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MaxDateValidatorDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'bb-input-datepicker-ui[maxDate]',
                    providers: [
                        {
                            provide: NG_VALIDATORS,
                            multi: true,
                            useExisting: forwardRef(() => MaxDateValidatorDirective),
                        },
                    ],
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { maxDate: [{
                type: Input
            }] } });

class InputDatepickerModule {
}
InputDatepickerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
InputDatepickerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerModule, declarations: [InputDatepickerComponent,
        MinDateValidatorDirective,
        MaxDateValidatorDirective,
        InputDatepickerDayTemplateSingleComponent,
        InputDatepickerDayTemplateRangeComponent], imports: [CommonModule,
        ReactiveFormsModule,
        FormsModule,
        NgbDatepickerModule,
        ButtonModule,
        IconModule,
        BaseClassesModule], exports: [InputDatepickerComponent,
        MinDateValidatorDirective,
        MaxDateValidatorDirective,
        /**
         * @deprecated
         * Exporting `FormsModule` is deprecated
         **/
        FormsModule] });
InputDatepickerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerModule, imports: [[
            CommonModule,
            ReactiveFormsModule,
            FormsModule,
            NgbDatepickerModule,
            ButtonModule,
            IconModule,
            BaseClassesModule,
        ], 
        /**
         * @deprecated
         * Exporting `FormsModule` is deprecated
         **/
        FormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: InputDatepickerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        FormsModule,
                        NgbDatepickerModule,
                        ButtonModule,
                        IconModule,
                        BaseClassesModule,
                    ],
                    declarations: [
                        InputDatepickerComponent,
                        MinDateValidatorDirective,
                        MaxDateValidatorDirective,
                        InputDatepickerDayTemplateSingleComponent,
                        InputDatepickerDayTemplateRangeComponent,
                    ],
                    exports: [
                        InputDatepickerComponent,
                        MinDateValidatorDirective,
                        MaxDateValidatorDirective,
                        /**
                         * @deprecated
                         * Exporting `FormsModule` is deprecated
                         **/
                        FormsModule,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { InputDatepickerComponent as CalendarPopupComponent, InputDatepickerModule as CalendarPopupModule, DATEPICKER_I18, InputDatepickerComponent, InputDatepickerModule, MaxDateValidatorDirective, MinDateValidatorDirective };
//# sourceMappingURL=backbase-ui-ang-input-datepicker.js.map
