import { Component, Inject, Optional } from '@angular/core';
import { BehaviorSubject, of, throwError, timer } from 'rxjs';
import { retryWhen, switchMap } from 'rxjs/operators';
import { TransactionSigningService } from '../service/transaction-signing.service';
import { TRANSACTION_SIGNING_CONFIG, } from '../util';
import * as i0 from "@angular/core";
import * as i1 from "../service/transaction-signing.service";
import * as i2 from "../ui/interface/interface.component";
import * as i3 from "@angular/common";
export class TransactionSigningComponent {
    constructor(transactionSigningService, config) {
        this.transactionSigningService = transactionSigningService;
        this.config = config;
        this.errorSubject = new BehaviorSubject(undefined);
        this.pendingSubject = new BehaviorSubject(false);
        this.challengeSubject = new BehaviorSubject(undefined);
        this.requestSubscription = this.setupRequestSubscription();
        this.challenge = this.challengeSubject.asObservable();
        this.error = this.errorSubject.asObservable();
        this.pending = this.pendingSubject.asObservable();
        this.enableResendPushNotification = this.config.enableResendPushNotification;
    }
    ngOnDestroy() {
        this.requestSubscription.unsubscribe();
        if (this.pollingSubscription) {
            this.pollingSubscription.unsubscribe();
        }
    }
    onFailure(error) {
        this.transactionSigningService.completeWithFailure(error);
        this.clearChallenge();
    }
    onSuccess() {
        this.transactionSigningService.completeWithSuccess();
        this.clearChallenge();
    }
    onPoll(data) {
        this.pollingSubscription = of(data)
            .pipe(switchMap((d) => this.transactionSigningService.respondToChallenge(d)), retryWhen((errors) => {
            return errors.pipe(switchMap((response) => {
                if (response.error) {
                    return throwError(response);
                }
                return timer(this.config.pollingCycleTime);
            }));
        }))
            .subscribe({
            next: () => this.onSuccess(),
            error: (response) => {
                this.errorSubject.next(response.error);
            },
        });
    }
    onPost(data) {
        if (this.pollingSubscription) {
            this.pollingSubscription.unsubscribe();
        }
        this.pendingSubject.next(true);
        this.transactionSigningService.respondToChallenge(data).subscribe({
            next: () => this.onSuccess(),
            error: (response) => {
                if (response.error) {
                    if (response.error.errorDescription === 'rejected_by_user') {
                        this.onFailure(new Error(response.error.errorDescription));
                    }
                    else {
                        this.errorSubject.next(response.error);
                    }
                }
                else {
                    this.challengeSubject.next(response);
                }
                this.pendingSubject.next(false);
            },
        });
    }
    setupRequestSubscription() {
        return this.transactionSigningService.requestSubject.subscribe((value) => this.updateChallenge(value));
    }
    updateChallenge(handler) {
        this.txnData = handler.transactionData;
        this.pendingSubject.next(false);
        if (handler.challenge) {
            this.challengeSubject.next(handler.challenge);
        }
    }
    clearChallenge() {
        this.challengeSubject.next(undefined);
        this.errorSubject.next(undefined);
        this.txnData = undefined;
        this.pendingSubject.next(false);
    }
}
/** @nocollapse */ TransactionSigningComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningComponent, deps: [{ token: i1.TransactionSigningService }, { token: TRANSACTION_SIGNING_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ TransactionSigningComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.15", type: TransactionSigningComponent, selector: "bb-transaction-signing", ngImport: i0, template: "<bb-transaction-signing-interface\n  *ngIf=\"challenge | async as challengeData\"\n  [isPending]=\"(pending | async) || false\"\n  [error]=\"(error | async) || undefined\"\n  [transactionData]=\"txnData\"\n  [challengeType]=\"challengeData.challengeType\"\n  [challengeData]=\"challengeData.challengeData\"\n  [challengeError]=\"challengeData.error\"\n  [enableResendPushNotification]=\"enableResendPushNotification\"\n  (failure)=\"onFailure($event)\"\n  (postSuccess)=\"onSuccess()\"\n  (poll)=\"onPoll($event)\"\n  (post)=\"onPost($event)\"\n>\n</bb-transaction-signing-interface>\n", components: [{ type: i2.TransactionSigningInterfaceComponent, selector: "bb-transaction-signing-interface", inputs: ["isPending", "error", "transactionData", "challengeType", "enableResendPushNotification", "challengeError", "challengeData"], outputs: ["failure", "postSuccess", "poll", "post"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i3.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-transaction-signing',
                    templateUrl: 'transaction-signing.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.TransactionSigningService }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSACTION_SIGNING_CONFIG]
                }] }]; } });
//# sourceMappingURL=transaction-signing.component.js.map