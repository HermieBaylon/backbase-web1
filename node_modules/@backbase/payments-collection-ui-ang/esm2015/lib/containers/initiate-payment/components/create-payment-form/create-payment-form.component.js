import { ChangeDetectorRef, Component, ElementRef, Inject, Optional, TemplateRef, ViewChild, ViewContainerRef, } from '@angular/core';
import { BB_PAYORD_PAYMENT_ERROR_MESSAGES_TOKEN, CounterPartyFields, defaultPaymentSuccessEventName, HiddenFields, InitiatePaymentHeaderStates, NavigationService, PaymentBaseFields, PaymentHooks, PaymentMode, PaymentOptionsService, PaymentOrderHttpService, PaymentState, PaymentTemplateFields, removeScheduleFromConfig, RoutableModalService, P2PLimitErrorKeys, setFormDetailsFromResponse, setFormDetailsFromService, setFrequencyOptionsPerConfig, StateService, toPostPaymentTemplate, toPostRequest, triggerPaymentHook, focusErrorElement, RemittanceInfoFields, getConfig, } from '@backbase/payment-orders-ang';
import { BehaviorSubject, combineLatest, of, Subject } from 'rxjs';
import { FormControl, FormGroup } from '@angular/forms';
import { catchError, distinctUntilChanged, filter, map, switchMap, take, takeUntil, tap, } from 'rxjs/operators';
import { PUBSUB } from '@backbase/foundation-ang/web-sdk';
import { isEditFormDirty, registerFormControl, } from '@backbase/payord-form-builder-ang';
import { mapPaymentOptionRequest, normalisePaymentTemplate, normalizePaymentType, } from '../../helpers/payment-options-mappers';
import { CreatePaymentConfigSetupService } from '../../services/create-payment-config-setup.service';
import { CreatePaymentFieldsSetupService } from '../../services/create-payment-fields-setup.service';
import { commonI18n, formI18n } from '../../constants/initiate-payment.i18n';
import { CreatePaymentService } from '../../services/create-payment.service';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/payment-orders-ang";
import * as i2 from "../../services/create-payment.service";
import * as i3 from "../../services/create-payment-config-setup.service";
import * as i4 from "../../services/create-payment-fields-setup.service";
import * as i5 from "@backbase/ui-ang/header";
import * as i6 from "@backbase/ui-ang/alert";
import * as i7 from "@backbase/payord-form-builder-ang";
import * as i8 from "@angular/common";
export class CreatePaymentFormComponent {
    constructor(paymentOrderHttpService, paymentOptionsService, createPaymentService, navigationService, stateService, cdRef, createPaymentSetup, fieldSetupService, formEl, modalService, eventBus, paymentErrors) {
        var _a, _b;
        this.paymentOrderHttpService = paymentOrderHttpService;
        this.paymentOptionsService = paymentOptionsService;
        this.createPaymentService = createPaymentService;
        this.navigationService = navigationService;
        this.stateService = stateService;
        this.cdRef = cdRef;
        this.createPaymentSetup = createPaymentSetup;
        this.fieldSetupService = fieldSetupService;
        this.formEl = formEl;
        this.modalService = modalService;
        this.eventBus = eventBus;
        this.paymentErrors = paymentErrors;
        this.destroyed$ = new Subject();
        this.paymentTemplate = null;
        this.shouldResetPaymentOptions = false;
        this.formValue = (_a = this.stateService.formInstance) === null || _a === void 0 ? void 0 : _a.value;
        this.paymentTemplateSearch = new FormControl();
        this.fetchOptions$ = new Subject();
        this.submitting$ = new BehaviorSubject(false);
        this.paymentState$ = this.stateService.paymentState$;
        this.paymentTemplates$ = this.paymentOrderHttpService.paymentTemplates$;
        this.loadingTemplates$ = this.paymentOrderHttpService.loading$;
        this.fetchingPaymentOptions$ = new BehaviorSubject(false);
        this.paymentOptions$ = this.fieldSetupService.paymentOptions$;
        this.paymentOptionsError$ = this.fieldSetupService.paymentOptionsError$;
        this.selectedPaymentConfig$ = this.createPaymentService.selectedPaymentConfig$;
        this.selectedPaymentOption$ = this.createPaymentService.selectedPaymentOption$;
        this.fetchPaymentOptionsListener$ = this.createPaymentSetup.fetchPaymentOptionsListener$;
        this.baseFields$ = this.createPaymentSetup.baseFields$.pipe(map((baseFields) => {
            this.fieldSetupService.injectData(baseFields);
            return baseFields;
        }));
        this.options = {};
        this.configs = [];
        this.templateNameControl = (_b = this.stateService.formInstance) === null || _b === void 0 ? void 0 : _b.get('templateName');
        this.errors = [];
        this.isEditPaymentConfirmationDialogOpen = false;
        this.enablePaymentTemplateSelector = true;
        this.editPaymentHasNoChanges = false;
        this.isErrorTitleDisplayed = true;
        this.shouldApplyTemplate = false;
        this.showApiError = false;
        this.paymentMode = PaymentMode;
    }
    ngOnInit() {
        combineLatest([
            this.createPaymentSetup.configs$,
            this.createPaymentSetup.options$,
            this.stateService.paymentEditState$,
        ])
            .pipe(distinctUntilChanged(), takeUntil(this.destroyed$))
            .subscribe(([configs, options, editedPaymentDetails]) => {
            var _a, _b, _c;
            this.options = options;
            this.editedPaymentDetails = editedPaymentDetails;
            this.isErrorTitleDisplayed =
                (_a = options.isErrorTitleDisplayed) !== null && _a !== void 0 ? _a : this.isErrorTitleDisplayed;
            this.enablePaymentTemplateSelector =
                (_b = options.enablePaymentTemplateSelector) !== null && _b !== void 0 ? _b : this.enablePaymentTemplateSelector;
            if (configs.length === 1) {
                // TODO: find a better solution for this
                this.setArrangementBusFunctions((_c = configs[0].options) === null || _c === void 0 ? void 0 : _c.closedPaymentBusFns, configs[0].businessFunction);
                this.onSelectConfig(configs[0]);
            }
            const { isOneOffToRecurrentAllowed, isRecurrentToOneOffAllowed } = options;
            this.configs = configs.map((config) => {
                let _config = options.isTemplateMode
                    ? removeScheduleFromConfig(config)
                    : config;
                if (editedPaymentDetails) {
                    _config = setFrequencyOptionsPerConfig(config, !!editedPaymentDetails.schedule, {
                        isOneOffToRecurrentAllowed,
                        isRecurrentToOneOffAllowed,
                    });
                }
                this.fieldSetupService.injectData(_config.fields, _config.options);
                return _config;
            });
            this.setupPaymentTypes(this.configs);
            this.header = this.createPaymentSetup.getHeader(InitiatePaymentHeaderStates.FORM);
        });
        this.listen();
        if (this.stateService.currentState !== PaymentState.EDIT) {
            this.fieldSetupService.clearPaymentOptions();
            this.shouldResetPaymentOptions = true;
        }
        this.createPaymentService
            .getPaymentOptionsRequest(this.configs)
            .pipe(tap((options) => {
            if (!this.shouldResetPaymentOptions && !(options === null || options === void 0 ? void 0 : options.length)) {
                this.fieldSetupService.setPaymentOptionsError(true);
            }
            this.shouldResetPaymentOptions = false;
            this.onPaymentTypeChange(options);
        }, catchError(() => {
            this.fieldSetupService.setPaymentOptionsError(true);
            return of([]);
        })), takeUntil(this.destroyed$))
            .subscribe();
        triggerPaymentHook(this.createPaymentSetup.hooks, PaymentHooks.onInit);
    }
    ngAfterViewInit() {
        this.stateService.paymentTemplateState$
            .pipe(takeUntil(this.destroyed$))
            .subscribe((template) => {
            if (template) {
                this.onSelectPaymentTemplate(template);
            }
        });
        if (this.editedPaymentDetails) {
            this.setEditFormValues(this.editedPaymentDetails);
            this.stateService.setEditPayment(undefined); // This is to prevent overwrite manual edits on return from review screen
        }
    }
    ngAfterContentInit() {
        this.renderView();
    }
    ngOnDestroy() {
        this.destroyed$.next();
        triggerPaymentHook(this.createPaymentSetup.hooks, PaymentHooks.onDestroy);
    }
    setArrangementBusFunctions(closedFunctions, businessFunction) {
        if ((closedFunctions === null || closedFunctions === void 0 ? void 0 : closedFunctions.length) && businessFunction) {
            // TODO: temporary solution, need to find better way do not mutate object
            const setOfBusFun = new Set([...closedFunctions, businessFunction]);
            closedFunctions = Array.from(setOfBusFun);
            this.paymentOrderHttpService.arrangementBusFunctions =
                closedFunctions.toString();
        }
    }
    setEditFormValues(payment) {
        const form = this.stateService.formInstance;
        const counterparty = form.get(PaymentBaseFields.counterparty);
        registerFormControl(counterparty, CounterPartyFields.schemeName, [], [], 'BBAN');
        registerFormControl(form, 'paymentOrderId', [], [], payment.id);
        this.isPaymentCopyControl = registerFormControl(form, HiddenFields.isPaymentCopy);
        this.isPaymentCopyControl.patchValue(this.options.paymentMode === this.paymentMode.COPY_PAYMENT);
        const editForm = setFormDetailsFromService(form, payment);
        this.stateService.initialEditFormValue = editForm.value;
        this.setForm(editForm);
    }
    setupPaymentTypes(configs) {
        this.paymentTypes = configs.map((config) => config.paymentType).join(',');
        this.paymentOrderHttpService.paymentType = this.paymentTypes;
    }
    renderView() {
        this.outletRef.clear();
        this.outletRef.createEmbeddedView(this.contentRef);
    }
    setTemplateValues(form, paymentTemplate) {
        this.setFormValues(normalisePaymentTemplate(paymentTemplate), form);
        this.paymentTemplate = null;
        this.stateService.setPaymentTemplate(undefined);
    }
    prepareForTemplateApply() {
        const formGroup = new FormGroup({});
        this.formValue = null;
        this.fieldSetupService.setPaymentOptions([]);
        this.templateNameControl = registerFormControl(formGroup, 'templateName');
        this.stateService.saveForm(formGroup);
    }
    getPaymentConfig(paymentType) {
        if (paymentType) {
            return this.configs.filter((paymentConfig) => paymentType === paymentConfig.paymentType)[0];
        }
        return;
    }
    setFormValues({ details, name, id }, form) {
        var _a;
        const _form = form || this.stateService.formInstance;
        const templateForm = setFormDetailsFromResponse(_form, details, {
            name,
            id,
        });
        this.templateSelectorName = name;
        (_a = this.templateNameControl) === null || _a === void 0 ? void 0 : _a.setValue(name);
        this.setForm(templateForm);
        _form.markAllAsTouched();
    }
    listen() {
        this.fetchOptions$
            .pipe(filter((form) => JSON.stringify(CreatePaymentService.getCriticalFieldValues(this.formValue)) !==
            JSON.stringify(CreatePaymentService.getCriticalFieldValues(form.getRawValue()))), switchMap((form) => {
            this.formValue = form.getRawValue();
            return this.fetchPaymentOptions(form);
        }), takeUntil(this.destroyed$))
            .subscribe();
    }
    setForm(formInstance) {
        this.stateService.setPaymentState(PaymentState.EDIT);
        this.stateService.saveForm(formInstance);
        this.renderView();
        this.cdRef.detectChanges();
    }
    /**
     * Callback triggered when the payment type changes
     */
    onPaymentTypeChange(paymentOptions = []) {
        if (paymentOptions && paymentOptions.length) {
            this.fieldSetupService.setPaymentOptionsError(false);
        }
        this.fieldSetupService.setPaymentOptions(paymentOptions);
        this.fetchingPaymentOptions$.next(false);
    }
    validatePayment(form) {
        this.paymentOrderHttpService
            .validatePayment(toPostRequest(form.getRawValue()))
            .pipe(take(1))
            .subscribe((response) => {
            const control = form.get('isIntraLegalEntity') ||
                registerFormControl(form, 'isIntraLegalEntity');
            this.templateNameControl =
                this.templateNameControl ||
                    registerFormControl(form, 'templateName');
            control.setValue(response.isIntraLegalEntityPaymentOrder);
            this.templateNameControl.setValue(this.templateSelectorName);
            this.submitting$.next(false);
            this.navigationService.review();
            this.stateService.canApprove = response.canApprove;
        }, ({ error }) => {
            var _a;
            this.submitting$.next(false);
            this.errors = error.errors;
            if (!this.isP2PLimitError(error)) {
                this.genericError = error.message;
                this.showApiError = true;
                if (((_a = this.errors) === null || _a === void 0 ? void 0 : _a.length) || this.genericError) {
                    const errorObject = {
                        errorResponse: error,
                        errors: this.errors,
                        paymentErrors: this.paymentErrors,
                        notificationHeader: formI18n.validateFailed,
                        genericMessage: this.genericError,
                    };
                    this.paymentOrderHttpService.manageErrorResponse(errorObject);
                }
                else {
                    this.paymentOrderHttpService.showNotification(false, {
                        header: formI18n.unknownErrorHeader,
                        message: formI18n.unknownError,
                        headerContext: error,
                    });
                }
                this.scrollIntoAlertView();
            }
            else {
                this.showApiError = false;
                this.handleP2PErrors(this.errors[0]);
            }
        });
    }
    handleP2PErrors(error) {
        var _a, _b, _c, _d, _e, _f;
        if (error === null || error === void 0 ? void 0 : error.key) {
            const amountGroupConfig = getConfig(RemittanceInfoFields.amountCurrencyGroup, this.configs[0]);
            const validationMsg = (_b = (_a = amountGroupConfig === null || amountGroupConfig === void 0 ? void 0 : amountGroupConfig.options) === null || _a === void 0 ? void 0 : _a.validationMessages) === null || _b === void 0 ? void 0 : _b.find((validationMessage) => validationMessage.name === error.key);
            if (validationMsg === null || validationMsg === void 0 ? void 0 : validationMsg.message) {
                validationMsg.message = validationMsg.message.replace('#amount#', (_c = error.context) === null || _c === void 0 ? void 0 : _c.limit);
                const amountGroup = (_d = this.stateService.formInstance
                    .get(PaymentBaseFields.remittanceInfo)) === null || _d === void 0 ? void 0 : _d.get(RemittanceInfoFields.amountCurrencyGroup);
                amountGroup === null || amountGroup === void 0 ? void 0 : amountGroup.setErrors({ [error.key]: true });
                (_e = amountGroup === null || amountGroup === void 0 ? void 0 : amountGroup.get(RemittanceInfoFields.amount)) === null || _e === void 0 ? void 0 : _e.setErrors({ invalid: true });
                focusErrorElement((_f = this.formEl) === null || _f === void 0 ? void 0 : _f.nativeElement, 'small.bb-input-validation-message');
            }
        }
    }
    scrollIntoAlertView() {
        var _a;
        (_a = this.alertContainer) === null || _a === void 0 ? void 0 : _a.nativeElement.scrollIntoView(false, {
            behavior: 'smooth',
            block: 'start',
        });
    }
    isP2PLimitError(error) {
        var _a;
        if (!Array.isArray(error.errors))
            return false;
        const errKey = (_a = error.errors[0]) === null || _a === void 0 ? void 0 : _a.key;
        return Object.values(P2PLimitErrorKeys).includes(errKey);
    }
    saveTemplate(form) {
        if (this.options.paymentMode === PaymentMode.EDIT_TEMPLATE) {
            this.editPaymentTemplate(form);
        }
        else {
            this.createPaymentTemplate(form);
        }
    }
    editPaymentTemplate(form) {
        var _a, _b;
        const templateName = (_a = form.get(PaymentTemplateFields.templateName)) === null || _a === void 0 ? void 0 : _a.value;
        const paymentTemplateId = (_b = form.get(PaymentTemplateFields.paymentTemplateId)) === null || _b === void 0 ? void 0 : _b.value;
        if (paymentTemplateId) {
            this.paymentOrderHttpService
                .editPaymentTemplate(paymentTemplateId, toPostPaymentTemplate(form.getRawValue()))
                .pipe(takeUntil(this.destroyed$))
                .subscribe(this.saveTemplateSuccessCallback.bind(this, templateName), this.saveTemplateErrorCallback.bind(this));
        }
    }
    createPaymentTemplate(form) {
        var _a;
        const templateName = (_a = form.get(PaymentTemplateFields.templateName)) === null || _a === void 0 ? void 0 : _a.value;
        this.paymentOrderHttpService
            .postPaymentTemplate(toPostPaymentTemplate(form.getRawValue()))
            .pipe(takeUntil(this.destroyed$))
            .subscribe(this.saveTemplateSuccessCallback.bind(this, templateName), this.saveTemplateErrorCallback.bind(this));
    }
    saveTemplateSuccessCallback(templateName) {
        var _a;
        this.paymentOrderHttpService.showNotification(true, {
            header: commonI18n.templateSaveSuccess(templateName),
            headerContext: { name: templateName },
        });
        this.submitting$.next(false);
        if (this.options.isModalView) {
            (_a = this.modalService) === null || _a === void 0 ? void 0 : _a.closeModal();
        }
        else {
            this.stateService.resetForm();
            this.renderView();
        }
        this.eventBus.publish((this.options.successEventName || defaultPaymentSuccessEventName), true);
    }
    saveTemplateErrorCallback(response) {
        const { error } = response;
        this.paymentOrderHttpService.showNotification(false, {
            header: (error === null || error === void 0 ? void 0 : error.message) || commonI18n.templateSaveFailed,
        });
        this.submitting$.next(false);
    }
    onHooksDone(form, success = true) {
        if (success) {
            if (this.options.isTemplateMode) {
                this.saveTemplate(form);
            }
            else {
                this.validatePayment(form);
            }
        }
        else {
            this.submitting$.next(false);
        }
    }
    isEditFormNotChanged(form) {
        return !isEditFormDirty(form.value, this.stateService.initialEditFormValue);
    }
    onSelectPaymentTemplate(paymentTemplateData) {
        const config = this.getPaymentConfig(normalizePaymentType(paymentTemplateData));
        if (this.configs.length > 1 && config) {
            this.prepareForTemplateApply();
            this.paymentTemplate = normalisePaymentTemplate(paymentTemplateData);
            this.shouldApplyTemplate = true;
            this.stateService.setPaymentState(PaymentState.EDIT);
            this.onSelectConfig(config);
            this.renderView();
        }
        else {
            this.setFormValues(paymentTemplateData);
        }
    }
    clearTemplateName() {
        this.templateSelectorName = '';
        if (this.templateNameControl) {
            this.templateNameControl.setValue('');
        }
    }
    onLoadingMoreTemplates(page) {
        this.paymentOrderHttpService.loadMore(page);
    }
    search(text) {
        this.paymentOrderHttpService.search(text);
    }
    onSelectConfig(config) {
        this.createPaymentService.selectPaymentConfig(config);
    }
    onPaymentOptionSelect(paymentOption) {
        this.createPaymentService.selectPaymentOption(paymentOption);
    }
    onApplyTemplate(form) {
        this.shouldApplyTemplate = false;
        if (this.paymentTemplate) {
            this.setTemplateValues(form, this.paymentTemplate);
        }
        else {
            this.stateService.paymentTemplateState$
                .pipe(takeUntil(this.destroyed$))
                .subscribe((template) => {
                if (template) {
                    this.setTemplateValues(form, template);
                }
            });
        }
    }
    /**
     * Fetches the payment options for provided payment details
     */
    fetchPaymentOptions(form) {
        this.fetchingPaymentOptions$.next(true);
        return this.paymentOptionsService.fetchPaymentOptions(mapPaymentOptionRequest(form.getRawValue()));
    }
    discardEditPaymentChanges() {
        var _a;
        (_a = this.modalService) === null || _a === void 0 ? void 0 : _a.closeModal();
    }
    cancelEditPaymentConfirmationDialog() {
        this.isEditPaymentConfirmationDialogOpen = false;
    }
    onSubmit(form) {
        var _a;
        const configVal = this.createPaymentService.selectedPaymentConfigValue;
        if (configVal) {
            this.createPaymentService.resetRedundantFields(configVal, form);
        }
        this.stateService.saveForm(form);
        this.submitting$.next(true);
        if ((_a = this.createPaymentSetup.hooks) === null || _a === void 0 ? void 0 : _a[PaymentHooks.onSave]) {
            triggerPaymentHook(this.createPaymentSetup.hooks, PaymentHooks.onSave, this.onHooksDone.bind(this, form), form);
        }
        else {
            this.onHooksDone(form);
        }
    }
    onClear() {
        this.fieldSetupService.clearPaymentOptions();
        this.stateService.setPaymentState(PaymentState.INITIAL);
        this.stateService.resetForm();
        this.clearTemplateName();
        this.formValue = null;
        this.searchValue = '';
        this.showApiError = false;
        this.renderView();
    }
    onEditCancel(form) {
        var _a;
        if (this.isEditFormNotChanged(form)) {
            (_a = this.modalService) === null || _a === void 0 ? void 0 : _a.closeModal();
        }
        else {
            this.isEditPaymentConfirmationDialogOpen = true;
        }
    }
    onEditSubmit(form) {
        if (this.isEditFormNotChanged(form)) {
            this.editPaymentHasNoChanges = true;
            this.scrollIntoAlertView();
        }
        else {
            this.editPaymentHasNoChanges = false;
            this.onSubmit(form);
        }
    }
    getForm(paymentState) {
        if (paymentState === PaymentState.REVIEW) {
            this.stateService.resetForm();
            this.stateService.setPaymentState(PaymentState.INITIAL);
        }
        return this.stateService.form$;
    }
}
/** @nocollapse */ CreatePaymentFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentFormComponent, deps: [{ token: i1.PaymentOrderHttpService }, { token: i1.PaymentOptionsService }, { token: i2.CreatePaymentService }, { token: i1.NavigationService }, { token: i1.StateService }, { token: i0.ChangeDetectorRef }, { token: i3.CreatePaymentConfigSetupService }, { token: i4.CreatePaymentFieldsSetupService }, { token: i0.ElementRef }, { token: i1.RoutableModalService, optional: true }, { token: PUBSUB }, { token: BB_PAYORD_PAYMENT_ERROR_MESSAGES_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ CreatePaymentFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: CreatePaymentFormComponent, selector: "bb-create-payment-form", providers: [CreatePaymentFieldsSetupService], viewQueries: [{ propertyName: "outletRef", first: true, predicate: ["outlet"], descendants: true, read: ViewContainerRef, static: true }, { propertyName: "contentRef", first: true, predicate: ["content"], descendants: true, read: TemplateRef, static: true }, { propertyName: "alertContainer", first: true, predicate: ["alertContainer"], descendants: true }], ngImport: i0, template: "<bb-header-ui\n  *ngIf=\"header\"\n  headingClasses=\"bb-block bb-block--lg\"\n  headingType=\"h2\"\n  [heading]=\"header\"\n></bb-header-ui>\n<div #alertContainer>\n  <ng-container *ngIf=\"errors?.length; else noSpecificError\">\n    <ng-container *ngFor=\"let error of errors\">\n      <ng-container *ngIf=\"error.message; else noSpecificError\">\n        <bb-alert-ui *ngIf=\"showApiError\" title=\"\" modifier=\"error\">\n          <div class=\"bb-text-bold bb-text-default d-inline-flex\">\n            <ng-container *ngIf=\"isErrorTitleDisplayed\">\n              <span i18n=\"@@initiate-payment-payments-error-alert-title\">\n                Payment data error: </span\n              >&nbsp;\n            </ng-container>\n            <span>{{ $any(error)?.message }}</span>\n          </div>\n        </bb-alert-ui>\n      </ng-container>\n    </ng-container>\n  </ng-container>\n  <ng-template #noSpecificError>\n    <ng-container *ngIf=\"genericError; else unknownError\">\n      <bb-alert-ui *ngIf=\"showApiError\" title=\"\" modifier=\"error\">\n        <div class=\"bb-text-bold bb-text-default\">\n          <ng-container *ngIf=\"isErrorTitleDisplayed\">\n            <span\n              i18n=\"@@initiate-payment-payments-generic-message-alert-title\"\n            >\n              Payment data error:\n            </span>\n          </ng-container>\n          <span>{{ genericError }}</span>\n        </div>\n      </bb-alert-ui>\n    </ng-container>\n  </ng-template>\n  <ng-template #unknownError>\n    <div class=\"bb-text-bold bb-text-default\">\n      <bb-alert-ui\n        *ngIf=\"showApiError\"\n        i18n-title=\"@@initiate-payment-payments-unknown-error-alert-title\"\n        title=\"Server error: Unknown error occurred\"\n        modifier=\"error\"\n      >\n      </bb-alert-ui>\n    </div>\n  </ng-template>\n  <bb-alert-ui\n    *ngIf=\"editPaymentHasNoChanges\"\n    i18n-title=\"\n      @@initiate-payment-payments-edit-paymet-no-changes-warning-alert-title\"\n    title=\"Please make changes to continue.\"\n    modifier=\"warning\"\n  ></bb-alert-ui>\n</div>\n\n<ng-container\n  *ngIf=\"\n    enablePaymentTemplateSelector &&\n    !options?.isTemplateMode &&\n    options?.paymentMode !== paymentMode.EDIT_PAYMENT &&\n    options?.paymentMode !== paymentMode.COPY_PAYMENT\n  \"\n>\n  <bb-payment-template-selector\n    [paymentTemplateSearch]=\"paymentTemplateSearch\"\n    [items]=\"paymentTemplates$\"\n    [loading]=\"loadingTemplates$ | async\"\n    [templateName]=\"templateSelectorName || templateNameControl?.value\"\n    [searchValue]=\"searchValue\"\n    (setValues)=\"onSelectPaymentTemplate($event)\"\n    (loadMoreTemplates)=\"onLoadingMoreTemplates($event)\"\n    (searchTemplates)=\"search($event)\"\n    (clear)=\"clearTemplateName()\"\n  >\n  </bb-payment-template-selector>\n</ng-container>\n\n<ng-container #outlet></ng-container>\n<ng-template #content>\n  <ng-container *ngIf=\"paymentState$ | async as paymentState\">\n    <ng-container *ngIf=\"configs.length === 1; else adaptiveFormTmpl\">\n      <bb-payord-form\n        [config]=\"configs[0]\"\n        [formItem]=\"getForm(paymentState) | async\"\n        [submitting]=\"submitting$ | async\"\n        [isModalView]=\"options.isModalView\"\n        [isTemplateMode]=\"options.isTemplateMode\"\n        [isDebitPayment]=\"options.isDebitPayment\"\n        [paymentMode]=\"options.paymentMode\"\n        [templateModeType]=\"options.templateModeType\"\n        (clear)=\"onClear()\"\n        (submitted)=\"onSubmit($event)\"\n        (editPaymentCancel)=\"onEditCancel($event)\"\n        (editPaymentSubmit)=\"onEditSubmit($event)\"\n      >\n      </bb-payord-form>\n\n      <bb-confirmation-dialog\n        data-role=\"discard-payment-edit-confirmation-dialog\"\n        confirmButtonColor=\"danger\"\n        (confirm)=\"discardEditPaymentChanges()\"\n        [isOpen]=\"isEditPaymentConfirmationDialogOpen\"\n        (cancel)=\"cancelEditPaymentConfirmationDialog()\"\n      >\n        <span title i18n=\"@@confirmation-dialog.edit.payment.title.discard\"\n          >Discard edited data?</span\n        >\n        <span body i18n=\"@@confirmation-dialog.edit.payment.body.discard\">\n          Are you sure you want to exit and discard all changes? Edited data\n          will be lost.\n        </span>\n        <span\n          confirmActionName\n          i18n=\"@@confirmation-dialog.edit.payment.action.discard.confirm\"\n          >Discard</span\n        >\n        <span\n          cancelActionName\n          i18n=\"@@confirmation-dialog.edit.payment.action.discard.cancel\"\n          >Not now</span\n        >\n      </bb-confirmation-dialog>\n    </ng-container>\n    <ng-template #adaptiveFormTmpl>\n      <bb-adaptive-form\n        [formItem]=\"getForm(paymentState) | async\"\n        [paymentState]=\"paymentState\"\n        [paymentTypes]=\"configs\"\n        [baseFields]=\"baseFields$ | async\"\n        [fetchOptions$]=\"fetchOptions$\"\n        [fetchingOptions]=\"fetchingPaymentOptions$ | async\"\n        [paymentOptions$]=\"paymentOptions$\"\n        [paymentOptionsError]=\"paymentOptionsError$ | async\"\n        [selectedPaymentConfig]=\"selectedPaymentConfig$ | async\"\n        [selectedPaymentOption]=\"selectedPaymentOption$ | async\"\n        [fetchPaymentOptionsListener]=\"fetchPaymentOptionsListener$ | async\"\n        [shouldApplyTemplate]=\"shouldApplyTemplate\"\n        [checkClosedPaymentsAccess]=\"!!options.checkClosedPaymentsAccess\"\n        [submitting]=\"submitting$ | async\"\n        [isModalView]=\"options.isModalView\"\n        [isDebitPayment]=\"options.isDebitPayment\"\n        (selectConfig)=\"onSelectConfig($event)\"\n        (submitted)=\"onSubmit($event)\"\n        (selectPaymentOption)=\"onPaymentOptionSelect($event)\"\n        (clear)=\"onClear()\"\n        (applyPaymentTemplate)=\"onApplyTemplate($event)\"\n      ></bb-adaptive-form>\n    </ng-template>\n  </ng-container>\n</ng-template>\n", components: [{ type: i5.HeaderComponent, selector: "bb-header-ui", inputs: ["headingClasses", "headingType", "heading"] }, { type: i6.AlertComponent, selector: "bb-alert-ui", inputs: ["modifier", "dismissible", "title", "message"], outputs: ["close"] }, { type: i1.ӨPaymentTemplateSelectorComponent, selector: "bb-payment-template-selector", inputs: ["items", "templatesList", "paymentTemplateSearch", "loading", "templateName", "searchValue"], outputs: ["setValues", "loadMoreTemplates", "searchTemplates", "clear"] }, { type: i7.ӨPayordFormComponent, selector: "bb-payord-form", inputs: ["config", "isModalView", "isTemplateMode", "isDebitPayment", "isEditPaymentModal", "templateModeType", "formItem", "submitting", "paymentMode"], outputs: ["submitted", "clear", "editPaymentCancel", "editPaymentSubmit"] }, { type: i1.ӨConfirmationDialogComponent, selector: "bb-confirmation-dialog", inputs: ["confirmButtonColor", "cancelButtonColor", "isOpen", "confirmActionPayload", "attachComment", "commentFieldLabel"], outputs: ["confirm", "cancel"] }, { type: i7.ӨAdaptiveFormComponent, selector: "bb-adaptive-form", inputs: ["formItem", "baseFields", "paymentTypes", "paymentState", "isDebitPayment", "selectedPaymentConfig", "selectedPaymentOption", "paymentOptionsError", "checkClosedPaymentsAccess", "paymentOptions$", "fetchingOptions", "fetchPaymentOptionsListener", "submitting", "fetchOptions$", "shouldApplyTemplate", "isModalView"], outputs: ["applyPaymentTemplate", "submitted", "selectPaymentOption", "clear", "selectConfig"] }], directives: [{ type: i8.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i8.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i8.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-create-payment-form',
                    templateUrl: './create-payment-form.component.html',
                    providers: [CreatePaymentFieldsSetupService],
                }]
        }], ctorParameters: function () { return [{ type: i1.PaymentOrderHttpService }, { type: i1.PaymentOptionsService }, { type: i2.CreatePaymentService }, { type: i1.NavigationService }, { type: i1.StateService }, { type: i0.ChangeDetectorRef }, { type: i3.CreatePaymentConfigSetupService }, { type: i4.CreatePaymentFieldsSetupService }, { type: i0.ElementRef }, { type: i1.RoutableModalService, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [BB_PAYORD_PAYMENT_ERROR_MESSAGES_TOKEN]
                }] }]; }, propDecorators: { outletRef: [{
                type: ViewChild,
                args: ['outlet', { read: ViewContainerRef, static: true }]
            }], contentRef: [{
                type: ViewChild,
                args: ['content', { read: TemplateRef, static: true }]
            }], alertContainer: [{
                type: ViewChild,
                args: ['alertContainer']
            }] } });
//# sourceMappingURL=create-payment-form.component.js.map