import { Injectable } from '@angular/core';
import { mapPaymentOptions, PaymentOptionsService, } from '@backbase/payment-orders-ang';
import { BehaviorSubject, EMPTY } from 'rxjs';
import { distinctUntilChanged, filter, map } from 'rxjs/operators';
import { resetBankDetails, resetBeneficiaryAddress, } from '../helpers/payment-options-mappers';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/payment-orders-ang";
export class CreatePaymentService {
    constructor(paymentOptionsService) {
        this.paymentOptionsService = paymentOptionsService;
        this.selectedPaymentOptionSub$ = new BehaviorSubject(undefined);
        this.selectedPaymentConfigSub$ = new BehaviorSubject(undefined);
        this.selectedPaymentOption$ = this.selectedPaymentOptionSub$
            .asObservable()
            .pipe(distinctUntilChanged());
        this.selectedPaymentConfig$ = this.selectedPaymentConfigSub$
            .asObservable()
            .pipe(distinctUntilChanged());
    }
    get selectedPaymentConfigValue() {
        return this.selectedPaymentConfigSub$.value;
    }
    static getCriticalFieldValues(formValue) {
        var _a, _b;
        const { initiator, counterparty, remittanceInfo } = formValue || {};
        return {
            debitAccountNumber: initiator === null || initiator === void 0 ? void 0 : initiator.accountNumber,
            creditAccountNumber: counterparty === null || counterparty === void 0 ? void 0 : counterparty.accountNumber,
            amount: remittanceInfo === null || remittanceInfo === void 0 ? void 0 : remittanceInfo.amountGroup,
            country: (_b = (_a = counterparty === null || counterparty === void 0 ? void 0 : counterparty.creditorBank) === null || _a === void 0 ? void 0 : _a.postalAddress) === null || _b === void 0 ? void 0 : _b.country,
        };
    }
    selectPaymentConfig(config) {
        this.selectedPaymentConfigSub$.next(config);
    }
    selectPaymentOption(paymentOption) {
        this.selectedPaymentOptionSub$.next(paymentOption);
    }
    getPaymentOptionsRequest(configs) {
        let optionsReq;
        if (configs.length === 1) {
            const config = configs[0];
            // TODO: find a better solution for this
            if (config.paymentType !== 'INTERNATIONAL_TRANSFER') {
                return EMPTY;
            }
            optionsReq = this.paymentOptionsService
                .getPaymentOptionsRecordByPaymentType(config.paymentType)
                .pipe(map((response) => mapPaymentOptions(response, { [config.paymentType]: config.name })));
        }
        else {
            optionsReq = this.paymentOptionsService.paymentOptions$.pipe(filter((options) => !!options), map((options) => mapPaymentOptions(options || [])));
        }
        return optionsReq;
    }
    resetRedundantFields(paymentTypeConfig, form) {
        resetBeneficiaryAddress(paymentTypeConfig, form);
        resetBankDetails(paymentTypeConfig, form);
    }
}
/** @nocollapse */ CreatePaymentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentService, deps: [{ token: i1.PaymentOptionsService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ CreatePaymentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.PaymentOptionsService }]; } });
//# sourceMappingURL=create-payment.service.js.map