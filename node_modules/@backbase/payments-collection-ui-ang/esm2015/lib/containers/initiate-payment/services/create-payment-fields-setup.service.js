import { __rest } from "tslib";
import { Injectable } from '@angular/core';
import { accMap, BeneficiaryList, handleCurrenciesList, InitiatorFields, mapArrangementList, mapConnectedAccounts, PaymentComponents, PaymentOptionsService, PaymentOrderHttpService, ScheduleFields, shouldLoadTabContent, PaymentMode, CounterPartyFields, } from '@backbase/payment-orders-ang';
import { BehaviorSubject, combineLatest, of, Subject } from 'rxjs';
import { catchError, filter, map, shareReplay, switchMap, takeUntil, tap, } from 'rxjs/operators';
import { HttpErrorResponse } from '@angular/common/http';
import { CreatePaymentConfigSetupService } from './create-payment-config-setup.service';
import * as i0 from "@angular/core";
import * as i1 from "./create-payment-config-setup.service";
import * as i2 from "@backbase/payment-orders-ang";
export class CreatePaymentFieldsSetupService {
    constructor(createPaymentSetup, paymentOptionsService, paymentOrderHttpService) {
        this.createPaymentSetup = createPaymentSetup;
        this.paymentOptionsService = paymentOptionsService;
        this.paymentOrderHttpService = paymentOrderHttpService;
        this.destroyed$ = new Subject();
        this.fetchDebitItemPermissions$ = new Subject();
        this.fetchBeneficiaries$ = new Subject();
        this.paymentOptionsSub$ = new BehaviorSubject([]);
        this.paymentOptionsErrorSub$ = new BehaviorSubject(false);
        this.exchangeRate$ = new Subject();
        this.getExchangeRate$ = new Subject();
        this.exchangeRateError$ = new Subject();
        this.frequencyFieldSub$ = new Subject();
        this.countries$ = this.loadSanctionedCountries();
        this.currencies$ = this.loadSanctionedCurrencies();
        this.fetchDebitAccounts$ = new Subject();
        this.fetchCreditAccounts$ = new Subject();
        this.connectedAccounts$ = this.paymentOrderHttpService.connectedAccounts$.pipe(map((accounts) => accounts === null || accounts === void 0 ? void 0 : accounts.map(mapConnectedAccounts)));
        this.totalContacts = 0; // x-total-count from response header
        this.totalCreditAccounts = 0;
        this.totalContactsItemsCount = 0; // total count of items in response before extracting sub accounts
        this.checkClosedPaymentsAccess = false;
        this.paymentOptions$ = this.paymentOptionsSub$.asObservable();
        this.paymentOptionsError$ = this.paymentOptionsErrorSub$.asObservable();
        this.frequencyField$ = this.frequencyFieldSub$.asObservable();
        this.fetchDebitItemPermissions$
            .pipe(takeUntil(this.destroyed$))
            .subscribe((dataItemId) => {
            this.paymentOrderHttpService.loadDataItemPermissions(dataItemId);
        });
        this.fetchBeneficiaries$
            .pipe(takeUntil(this.destroyed$))
            .subscribe(({ params, type }) => {
            this.paymentOrderHttpService.fetchBeneficiaries(Object.assign(Object.assign({}, params), { size: this.options.pageSize }), type);
        });
        this.getExchangeRate$
            .pipe(filter(({ fromCurrency, toCurrency }) => {
            const isExchangeValid = fromCurrency !== toCurrency;
            if (!isExchangeValid) {
                // If fromCurrency and toCurrency are same, don't fetch exchange rate
                this.exchangeRate$.next(0);
            }
            return isExchangeValid;
        }), switchMap(({ fromCurrency, toCurrency }) => this.paymentOrderHttpService.getCurrencyExchangeRate(fromCurrency, toCurrency)), tap((exchangeRate) => {
            this.exchangeRateError$.next(!exchangeRate);
            this.exchangeRate$.next((exchangeRate === null || exchangeRate === void 0 ? void 0 : exchangeRate.rate) || 0);
        }), takeUntil(this.destroyed$))
            .subscribe();
        this.fetchDebitAccounts$
            .pipe(takeUntil(this.destroyed$))
            .subscribe((params) => {
            this.paymentOrderHttpService.loadMoreDebitAccounts(Object.assign(Object.assign({}, params), { merge: true, size: this.options.pageSize }));
        });
        this.fetchCreditAccounts$
            .pipe(takeUntil(this.destroyed$))
            .subscribe((_a) => {
            var { from } = _a, params = __rest(_a, ["from"]);
            this.paymentOrderHttpService.loadMoreCreditAccounts(from, Object.assign(Object.assign({}, params), { merge: true, size: this.options.pageSize }));
        });
    }
    get debitAccounts$() {
        return this.paymentOrderHttpService
            .getDebitAccounts({ size: this.options.pageSize })
            .pipe(accMap(this.options.defaultScheme));
    }
    get creditAccountList$() {
        return this.paymentOrderHttpService
            .getCreditAccounts({ size: this.options.pageSize })
            .pipe(map((arrangements) => ({
            items: mapArrangementList(arrangements, this.options.defaultScheme),
            count: arrangements.count,
        })));
    }
    get options() {
        return this.createPaymentSetup.options;
    }
    get configs() {
        return this.createPaymentSetup.configs;
    }
    ngOnDestroy() {
        this.destroyed$.next();
    }
    loadSanctionedCountries() {
        var _a;
        return this.paymentOptionsService
            .getSanctionedCountries((_a = this.options) === null || _a === void 0 ? void 0 : _a.defaultCountry)
            .pipe(shareReplay(1), catchError((_) => {
            this.paymentOrderHttpService.showNotification(false, {
                header: $localize `:omni-payment-get-countries-failed:Failed to load countries list. Please try again later.`,
            });
            return of([]);
        }));
    }
    loadSanctionedCurrencies() {
        var _a;
        return this.paymentOptionsService
            .getSanctionedCurrencies((_a = this.options) === null || _a === void 0 ? void 0 : _a.defaultCountry)
            .pipe(map((response) => {
            const result = {};
            if ('labeled' in response) {
                const { currencies, dividerIndex } = handleCurrenciesList(response);
                result.currencies = currencies;
                result.dividerIndex = dividerIndex;
            }
            return result;
        }), shareReplay(1), catchError((err) => {
            this.paymentOrderHttpService.showNotification(false, {
                header: $localize `:@omni-payment-get-countries-failed:Failed to load currencies list. Please try again later.`,
            });
            return of(err);
        }));
    }
    loadAccountByAccountId(id, accountNumber) {
        return this.paymentOrderHttpService
            .getAccountByAccountId(id, accountNumber)
            .pipe(map((item) => ({
            count: 1,
            items: [item],
        })), accMap(this.options.defaultScheme), map((list) => list[0]), catchError(() => of(undefined)));
    }
    getContacts() {
        return this.paymentOrderHttpService
            .getContacts({ size: this.options.pageSize, query: '' })
            .pipe(tap((data) => {
            if (!(data instanceof HttpErrorResponse)) {
                this.totalContacts = data.count;
                this.totalContactsItemsCount =
                    data.itemsCount && data.isLoadMore
                        ? this.totalContactsItemsCount + data.itemsCount
                        : data.itemsCount || 0;
            }
            else {
                this.totalContacts = 0;
            }
        }), map((value) => !(value instanceof HttpErrorResponse) ? value.items : value));
    }
    getCreditAccounts() {
        return this.paymentOrderHttpService
            .getCreditAccounts({ size: this.options.pageSize, searchTerm: '' })
            .pipe(tap((data) => {
            this.totalCreditAccounts = !(data instanceof HttpErrorResponse)
                ? data.count
                : 0;
        }), map((value) => !(value instanceof HttpErrorResponse)
            ? mapArrangementList(value, this.options.defaultScheme)
            : value));
    }
    getDebitAccounts() {
        return this.paymentOrderHttpService
            .getDebitAccounts({ size: this.options.pageSize, searchTerm: '' })
            .pipe(map((arrangements) => ({
            items: mapArrangementList(arrangements, this.options.defaultScheme),
            count: arrangements.count,
        })));
    }
    loadCreditorDetails(options) {
        this.contacts$ = shouldLoadTabContent(BeneficiaryList.CONTACTS, options)
            ? this.getContacts()
            : of([]);
        this.creditAccounts$ = shouldLoadTabContent(BeneficiaryList.ACCOUNTS, options)
            ? this.getCreditAccounts()
            : of([]);
        return combineLatest([this.creditAccounts$, this.contacts$]).pipe(map(([accounts, contacts]) => ({
            accounts,
            contacts,
            totalCreditAccounts: this.totalCreditAccounts,
            totalContacts: this.totalContacts,
            totalContactsItemsCount: this.totalContactsItemsCount,
        })));
    }
    setPaymentOptions(options) {
        this.paymentOptionsSub$.next(options);
    }
    setPaymentOptionsError(error) {
        this.paymentOptionsErrorSub$.next(error);
    }
    clearPaymentOptions() {
        this.paymentOptionsService.resetPaymentOptions();
        this.setPaymentOptionsError(false);
    }
    injectData(fields, paymentTypeOptions) {
        fields.forEach((field) => {
            var _a, _b, _c;
            field.options = field.options || {};
            field.options.isTemplateMode = this.options.isTemplateMode;
            field.options.templateModeType = this.options.templateModeType;
            field.options.isModalView = this.options.isModalView;
            field.options.checkClosedPaymentsAccess =
                (_a = this.options.checkClosedPaymentsAccess) !== null && _a !== void 0 ? _a : this.checkClosedPaymentsAccess;
            field.options.isWizardMode = ((_b = this.configs) === null || _b === void 0 ? void 0 : _b.length) > 1;
            if (field.fields instanceof Array) {
                this.injectData(field.fields, paymentTypeOptions);
            }
            else {
                switch (field.type) {
                    case PaymentComponents.debitAccountSelector:
                        field.options.items$ = this.getDebitAccounts();
                        field.options.fetchItems$ = this.fetchDebitAccounts$;
                        field.options.loadAccountByAccountId =
                            this.loadAccountByAccountId.bind(this);
                        field.options.fetchArrangementPermissions$ =
                            this.fetchDebitItemPermissions$;
                        field.options.arrangementPermissions$ =
                            this.paymentOrderHttpService.arrangementUserPermissions$;
                        field.options.checkClosedPaymentsAccess =
                            this.options.checkClosedPaymentsAccess;
                        break;
                    case PaymentComponents.beneficiarySelector:
                        field.options.items$ = this.loadCreditorDetails(field.options);
                        field.options.fetchItems$ = this.fetchBeneficiaries$;
                        break;
                    case PaymentComponents.internalAccountSelector:
                        field.options.paymentTypeOptions = paymentTypeOptions;
                        field.options.connectedItems$ = this.connectedAccounts$;
                        field.options.items$ =
                            field.name === InitiatorFields.initiatorAccountGroup
                                ? this.debitAccounts$
                                : this.getCreditAccounts();
                        break;
                    case PaymentComponents.accountSelector:
                        field.options.paymentTypeOptions = paymentTypeOptions;
                        field.options.connectedItems$ = this.connectedAccounts$;
                        if (field.name === CounterPartyFields.counterPartyAccountGroup ||
                            this.options.isDebitPayment) {
                            field.options.fetchItems$ = this.fetchCreditAccounts$;
                            field.options.items$ = this.creditAccountList$;
                        }
                        else {
                            field.options.items$ = this.getDebitAccounts();
                            field.options.fetchItems$ = this.fetchDebitAccounts$;
                        }
                        break;
                    case PaymentComponents.contactSelector:
                        field.options.items$ = this.getContacts();
                        field.options.fetchItems$ = this.fetchBeneficiaries$;
                        break;
                    case PaymentComponents.selectPaymentOption:
                        field.options.items$ = this.paymentOptions$;
                        break;
                    case PaymentComponents.sanctionedCountrySelector:
                    case PaymentComponents.address:
                        field.options.items$ = this.countries$;
                        break;
                    case PaymentComponents.sanctionedCurrencyAmount:
                        field.options.items$ = this.currencies$;
                        field.options.getExchangeRate$ = this.getExchangeRate$;
                        field.options.exchangeRate$ = this.exchangeRate$;
                        field.options.exchangeRateError$ = this.exchangeRateError$;
                        break;
                    case PaymentComponents.select:
                        if (field.name === ScheduleFields.frequency &&
                            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.paymentMode) === PaymentMode.EDIT_PAYMENT) {
                            this.frequencyFieldSub$.next(field);
                        }
                        break;
                }
            }
        });
    }
}
/** @nocollapse */ CreatePaymentFieldsSetupService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentFieldsSetupService, deps: [{ token: i1.CreatePaymentConfigSetupService }, { token: i2.PaymentOptionsService }, { token: i2.PaymentOrderHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ CreatePaymentFieldsSetupService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentFieldsSetupService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: CreatePaymentFieldsSetupService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.CreatePaymentConfigSetupService }, { type: i2.PaymentOptionsService }, { type: i2.PaymentOrderHttpService }]; } });
//# sourceMappingURL=create-payment-fields-setup.service.js.map