import { Observable } from 'rxjs';
import { CapabilityData } from '../challenge/challenge.model';
import { AsyncPollingOptions, TransactionSigningOptions } from './helper.model';
import * as i0 from "@angular/core";
export declare class TransactionSigningHelperService {
    private readonly defaultPollInterval;
    private readonly defaultMaxRetries;
    private readonly defaultStatusMap;
    /**
     * Determines if the response was returned from the Transaction Signing flow.
     * @param response the data returned after a possible transaction signing request.
     * @returns boolean
     */
    isTransactionSigningResponse(response: CapabilityData): boolean;
    /**
     * Polls a fetch function. Designed to run after transaction signing has occurred.
     * @param data  this is passed to the fetchFn as param.
     * @param fetchFn a function that triggers an http call.
     * @param pollOptions options to configure the polling such as pollInterval, maxRetries etc.
     * @param pendingStatuses array of statuses which determines if the polling should continue.
     * @returns an Observable that sequencially emits a value based on configured time interval.
     */
    setupPolling(data: any, fetchFn: (param: any) => Observable<any>, pollOptions: AsyncPollingOptions, pendingStatuses: string[]): Observable<any>;
    /**
     * Handles scenarios after signing a transaction and triggers appropriate callbacks.
     * @param options Configuration for determining different flows of the transaction.
     */
    getTransactionInfo(options: TransactionSigningOptions): void;
    private defaultPollUntilFn;
    private handleAsyncPollingFlow;
    private handleGenericFlow;
    private triggerTransactionCallback;
    static ɵfac: i0.ɵɵFactoryDeclaration<TransactionSigningHelperService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TransactionSigningHelperService>;
}
