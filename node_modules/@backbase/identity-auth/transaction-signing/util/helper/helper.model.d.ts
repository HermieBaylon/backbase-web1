import { Observable, Subject } from 'rxjs';
export declare enum ProgressStatus {
    CONFIRMATION_PENDING = "CONFIRMATION_PENDING",
    USER_DECLINED = "USER_DECLINED",
    SYSTEM_DECLINED = "SYSTEM_DECLINED",
    PENDING_APPROVAL = "PENDING_APPROVAL",
    SENDING = "SENDING",
    ACCEPTED = "ACCEPTED",
    REJECTED = "REJECTED",
    PROCESSED = "PROCESSED",
    NO_PROGRESS = "NO_PROGRESS"
}
export declare enum TransactionStatus {
    success = "success",
    rejected = "rejected",
    declined = "declined",
    pending = "pending"
}
export declare type TransactionStatusMap = {
    [key in keyof typeof TransactionStatus]: Array<string>;
};
export declare type TransactionCallbackFn = (param: TransactionCallbackParam) => void;
export interface TransactionCallbackParam {
    status: string;
    data?: any;
}
export interface TransactionSigningOptions {
    /**
     * Data that is passed as param to the fetchFn
     */
    data: any;
    /**
     * Options to configure polling flow.
     */
    asyncPollingOptions?: AsyncPollingOptions;
    /**
     * A hashmap that contains different mapped statuses for success, rejected, declined, or pending.
     * This map is used to determine the callback to trigger based on the status returned
     * from `fetchFn`.
     */
    statusMap?: TransactionStatusMap;
    /**
     * A function that is fetches the status of the transaction.
     * This is used for polling when `asyncPollingOptions` are provided
     */
    fetchFn?: (param?: any) => Observable<any>;
    /**
     * A callback function that is triggered on transaction success.
     */
    onSuccess: TransactionCallbackFn;
    /**
     * A callback function that is triggered on transaction reject.
     */
    onRejected: TransactionCallbackFn;
    /**
     * A callback function that is triggered on transaction decline.
     */
    onDeclined: TransactionCallbackFn;
    /**
     * A callback function that is triggered on invalid statuses or error.
     */
    onError: (error: any) => void;
}
export interface AsyncPollingOptions {
    /**
     * Number of times to retry polling in case of error.
     * Defaults to 3.
     */
    maxRetries?: number;
    /**
     * Time interval (in ms) between each polling request.
     * Defaults to 1000.
     */
    pollInterval?: number;
    /**
     * The function that determines when the polling should be stopped.
     * It receives the output of `fetchFn` as param.
     */
    pollUntilFn?: (param?: any) => boolean;
    /**
     * A subject that determines when the polling should be completed
     * if the transaction in not yet fulfilled.
     * This is required to stop polling when the user navigates to a different route.
     */
    complete$: Subject<any>;
}
