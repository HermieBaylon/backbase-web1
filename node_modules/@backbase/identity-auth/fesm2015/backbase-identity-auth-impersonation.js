import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Injectable, Optional, NgModule } from '@angular/core';
import * as i1 from '@backbase/ui-ang/mode-header';
import { ModeHeaderModule } from '@backbase/ui-ang/mode-header';
import * as i2 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import { filter, first, switchMap, map, tap } from 'rxjs/operators';
import * as i1$1 from '@backbase/data-ang/impersonation-v1';
import * as i2$1 from '@backbase/data-ang/user';
import { __awaiter } from 'tslib';
import { BehaviorSubject } from 'rxjs';
import * as i2$2 from '@backbase/identity-auth';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';

class ImpersonationBannerLayoutComponent {
    constructor() {
        /**
         * Emits when the impersonation session stop button is clicked.
         */
        this.stop = new EventEmitter();
    }
}
/** @nocollapse */ ImpersonationBannerLayoutComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationBannerLayoutComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ ImpersonationBannerLayoutComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.15", type: ImpersonationBannerLayoutComponent, selector: "bb-impersonation-banner-layout", inputs: { user: "user" }, outputs: { stop: "stop" }, ngImport: i0, template: "<bb-mode-header-ui\n  i18n-title=\"\n    Header that displays who is being emulated when the banner appears during an emulation session\n    @@bb-impersonation-banner.layout.title\"\n  title=\"Emulating {{ user?.fullName }}\"\n  data-role=\"impersonation-banner\"\n  [showCloseButton]=\"false\"\n>\n  <button\n    mode-header-status\n    bbButton\n    type=\"button\"\n    buttonSize=\"sm\"\n    color=\"danger\"\n    data-role=\"impersonation-banner-stop-button\"\n    i18n=\"Stop button used to end the emulation session @@bb-impersonation-banner.layout.button.stop\"\n    (click)=\"stop.emit()\"\n  >\n    Stop\n  </button>\n</bb-mode-header-ui>\n", components: [{ type: i1.ModeHeaderComponent, selector: "bb-mode-header-ui", inputs: ["title", "secondaryTitle", "showCloseButton", "closeButtonAriaLabel", "reverseTitleOrder"], outputs: ["close"] }], directives: [{ type: i2.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationBannerLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-impersonation-banner-layout',
                    templateUrl: 'banner-layout.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { user: [{
                type: Input
            }], stop: [{
                type: Output
            }] } });

class ImpersonationDataService {
    constructor(identityImpersonationService, userService) {
        this.identityImpersonationService = identityImpersonationService;
        this.userService = userService;
    }
    getImpersonationUrl(accessToken, targetUserId, targetWebApp) {
        return this.identityImpersonationService.getImpersonationTokenReference({
            tokenReferenceRequest: {
                targetUserId,
                targetWebApp,
                sourceWebApp: window.location.origin + window.location.pathname,
                accessToken,
            },
        });
    }
    getAccessToken(ref, client, realm) {
        return this.identityImpersonationService.getImpersonationAccessToken({
            accessTokenRequest: {
                realm,
                client,
                ref,
            },
        });
    }
    getOwnUser() {
        return this.userService.getOwnUser();
    }
}
/** @nocollapse */ ImpersonationDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationDataService, deps: [{ token: i1$1.IdentityImpersonationService }, { token: i2$1.UserManagementService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ImpersonationDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationDataService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationDataService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.IdentityImpersonationService }, { type: i2$1.UserManagementService }]; } });

const impersonationCodeParam = 'impersonation_code';
const storageKeys = {
    impersonation: 'is_impersonated',
    accessToken: 'access_token',
    refreshToken: 'refresh_token',
};

class ImpersonationService {
    /** @internal */
    constructor(dataService, oidcAuthService) {
        this.dataService = dataService;
        this.oidcAuthService = oidcAuthService;
        this.isImpersonated$$ = new BehaviorSubject(this.storedState);
        /**
         * Flag to determine if the current user is being impersonated.
         */
        this.isImpersonated$ = this.isImpersonated$$.asObservable();
        /**
         * Contacts the Identity Impersonation service to obtain an impersonation url for the
         * input user and target web app.
         * @param targetUserId the id of the user to be impersonated.
         * @param targetWebApp the url of the app to impersonate the user in.
         * @returns a url for the target app containing an impersonation code.
         */
        this.getImpersonationUrl = (targetUserId, targetWebApp) => this.oidcAuthService.accessToken$.pipe(filter((token) => !!token), first(), switchMap(({ raw }) => this.dataService.getImpersonationUrl(raw, targetUserId, targetWebApp)), map(({ ref }) => this.appendParamToUrl(targetWebApp, ref)));
        /**
         * Checks the current URL for an `impersonation_code` reference.
         * @returns a promise that resolves when the impersonation state is determined.
         */
        this.checkImpersonationStatus = () => __awaiter(this, void 0, void 0, function* () {
            const impersonationToken = this.getImpersonationCode();
            if (!impersonationToken) {
                return;
            }
            const accessTokenResponse = yield this.dataService
                .getAccessToken(impersonationToken, this.getClientId(), this.getRealm())
                .toPromise();
            this.setAccessTokenToOAuthStorage(accessTokenResponse);
            this.stripParamFromUrl();
            this.storedState = true;
            yield this.oidcAuthService.loadDiscoveryDocument();
            yield this.oidcAuthService.refresh();
        });
        if (!oidcAuthService) {
            throw new Error(`In order to use ImpersonationService, please include IdentityAuthModule to your application module`);
        }
        this.clearImpersonationStateOnLogout();
    }
    get storedState() {
        return !!this.oidcAuthService.storage.getItem(storageKeys.impersonation);
    }
    set storedState(value) {
        this.isImpersonated$$.next(value);
        if (value) {
            this.oidcAuthService.storage.setItem(storageKeys.impersonation, value.toString());
        }
        else {
            this.oidcAuthService.storage.removeItem(storageKeys.impersonation);
        }
    }
    stripParamFromUrl() {
        const url = new URL(window.location.href);
        url.searchParams.delete(impersonationCodeParam);
        window.history.replaceState(window.history.state, '', url.toString());
    }
    appendParamToUrl(targetWebAppUrl, value) {
        const url = new URL(targetWebAppUrl);
        url.searchParams.append(impersonationCodeParam, value);
        return url.toString();
    }
    setAccessTokenToOAuthStorage(response) {
        this.oidcAuthService.storage.setItem(storageKeys.accessToken, response.access_token || '');
        this.oidcAuthService.storage.setItem(storageKeys.refreshToken, response.refresh_token || '');
    }
    getClientId() {
        return this.oidcAuthService.authConfig.clientId || '';
    }
    getRealm() {
        const issuer = this.oidcAuthService.authConfig.issuer;
        if (!issuer) {
            return '';
        }
        return new URL(issuer).pathname.split('/').pop() || '';
    }
    clearImpersonationStateOnLogout() {
        this.oidcAuthService.events$
            .pipe(filter((event) => ['logout', 'session_terminated'].includes(event.type)), first())
            .subscribe({
            next: () => (this.storedState = false),
        });
    }
    getImpersonationCode() {
        return new URLSearchParams(location.search).get(impersonationCodeParam);
    }
}
/** @nocollapse */ ImpersonationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationService, deps: [{ token: ImpersonationDataService }, { token: i2$2.ɵɵOidcAuthService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ImpersonationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ImpersonationDataService }, { type: i2$2.ɵɵOidcAuthService, decorators: [{
                    type: Optional
                }] }]; } });

class ImpersonationBannerComponent {
    /** @internal */
    constructor(impersonationService, dataService, renderer) {
        this.impersonationService = impersonationService;
        this.dataService = dataService;
        this.renderer = renderer;
        /**
         * Event Emitted when stop impersonation button is pressed.
         * Please logout the user as your app requires.
         */
        this.stopImpersonation = new EventEmitter();
        this.impersonatedClass = 'impersonated';
        this.user$ = this.impersonationService.isImpersonated$.pipe(tap((state) => this.setImpersonationClass(state)), filter((state) => !!state), switchMap(() => this.dataService.getOwnUser()));
        this.setImpersonationClass = (state) => state
            ? this.renderer.addClass(document.body, this.impersonatedClass)
            : this.renderer.removeClass(document.body, this.impersonatedClass);
    }
}
/** @nocollapse */ ImpersonationBannerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationBannerComponent, deps: [{ token: ImpersonationService }, { token: ImpersonationDataService }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ ImpersonationBannerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.15", type: ImpersonationBannerComponent, selector: "bb-impersonation-banner", outputs: { stopImpersonation: "stopImpersonation" }, ngImport: i0, template: "<bb-impersonation-banner-layout\n  *ngIf=\"user$ | async as user\"\n  [user]=\"user\"\n  (stop)=\"this.stopImpersonation.emit()\"\n></bb-impersonation-banner-layout>\n", components: [{ type: ImpersonationBannerLayoutComponent, selector: "bb-impersonation-banner-layout", inputs: ["user"], outputs: ["stop"] }], directives: [{ type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i4.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationBannerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-impersonation-banner',
                    templateUrl: 'banner.component.html',
                }]
        }], ctorParameters: function () { return [{ type: ImpersonationService }, { type: ImpersonationDataService }, { type: i0.Renderer2 }]; }, propDecorators: { stopImpersonation: [{
                type: Output
            }] } });

class ImpersonationModule {
}
/** @nocollapse */ ImpersonationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ ImpersonationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationModule, declarations: [ImpersonationBannerLayoutComponent, ImpersonationBannerComponent], imports: [CommonModule, ModeHeaderModule, ButtonModule], exports: [ImpersonationBannerComponent] });
/** @nocollapse */ ImpersonationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationModule, imports: [[CommonModule, ModeHeaderModule, ButtonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ModeHeaderModule, ButtonModule],
                    declarations: [ImpersonationBannerLayoutComponent, ImpersonationBannerComponent],
                    exports: [ImpersonationBannerComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ImpersonationBannerComponent, ImpersonationBannerLayoutComponent, ImpersonationDataService, ImpersonationModule, ImpersonationService };
//# sourceMappingURL=backbase-identity-auth-impersonation.js.map
