import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, Optional, NgModule } from '@angular/core';
import { Subject, ReplaySubject, from } from 'rxjs';
import * as i1 from 'angular-oauth2-oidc';
import { OAuthStorage, AuthConfig } from 'angular-oauth2-oidc';
import { map, filter, mapTo, take } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

const ACTIVITY_MONITOR_CONFIG = new InjectionToken('activity-monitor-config');

const WINDOW = new InjectionToken('Window');

/**
 * Service for monitoring user activity
 */
class ActivityMonitorService {
    // https://angular.io/guide/aot-metadata-errors#could-not-resolve-type
    constructor(_window, _config) {
        this.events$ = new Subject();
        this.isActive = false;
        this.lastActiveEpoch = 0;
        this.config = {
            maxInactivityDuration: 180,
            countdownDuration: 30,
        };
        this.listenerCallback = this.setLastActiveEpoch.bind(this);
        this.countdownActive = false;
        this.events = this.events$.asObservable();
        this.window = _window;
        Object.assign(this.config, _config || {});
    }
    /**
     * Starts activity monitoring.
     */
    start(_config = {}) {
        Object.assign(this.config, _config);
        if (this.isActive) {
            this.stop();
        }
        this.listen(true, { passive: true, capture: true });
    }
    // Stops activity monitoring.
    stop() {
        if (this.isActive) {
            this.listen(false, true);
        }
    }
    getInactivityDuration() {
        const now = Math.floor(Date.now() / 1000);
        const last = Math.floor(this.lastActiveEpoch / 1000);
        return Math.floor(now - last);
    }
    setLastActiveEpoch() {
        this.lastActiveEpoch = Date.now();
    }
    listen(activate, options) {
        this.isActive = activate;
        const func = activate ? this.window.document.addEventListener : this.window.document.removeEventListener;
        this.setLastActiveEpoch();
        func('mousemove', this.listenerCallback, options);
        func('mousedown', this.listenerCallback, options);
        func('keydown', this.listenerCallback, options);
        func('mousewheel', this.listenerCallback, options);
        func('touchmove', this.listenerCallback, options);
        if (activate) {
            this.intervalId = this.window.setInterval(this.onEverySecond.bind(this), 1000);
        }
        else {
            this.window.clearInterval(this.intervalId);
            if (this.countdownActive) {
                this.countdownActive = false;
                this.events$.next({ type: 'reset' });
            }
        }
    }
    onEverySecond() {
        const ttl = this.config.maxInactivityDuration - this.getInactivityDuration();
        if (ttl > -1 && ttl <= this.config.countdownDuration) {
            if (!this.countdownActive) {
                this.countdownActive = true;
                this.events$.next({ type: 'start' });
                this.events$.next({ type: 'tick', remaining: ttl });
                return;
            }
            if (ttl > 0) {
                this.events$.next({ type: 'tick', remaining: ttl });
            }
            else {
                this.countdownActive = false;
                this.events$.next({ type: 'end' });
                this.stop();
            }
        }
        else if (this.countdownActive) {
            this.countdownActive = false;
            this.events$.next({ type: 'reset' });
        }
    }
}
/** @nocollapse */ ActivityMonitorService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ActivityMonitorService, deps: [{ token: WINDOW }, { token: ACTIVITY_MONITOR_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ActivityMonitorService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ActivityMonitorService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ActivityMonitorService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ACTIVITY_MONITOR_CONFIG]
                }] }]; } });

/** @internal */
class ɵɵOidcAuthService {
    // https://angular.io/guide/aot-metadata-errors#could-not-resolve-type
    constructor(oAuthService, oAuthStorage, oAuthConfig, _window) {
        var _a;
        this.oAuthService = oAuthService;
        this.oAuthStorage = oAuthStorage;
        this.oAuthConfig = oAuthConfig;
        this._window = _window;
        this.authenticated$$ = new ReplaySubject();
        this.storage = this.oAuthStorage;
        this.authConfig = this.oAuthConfig;
        this.events$ = (_a = this.oAuthService) === null || _a === void 0 ? void 0 : _a.events;
        this.isAuthenticated$ = this.authenticated$$.pipe(map(() => this.oAuthService.hasValidAccessToken()));
        this.accessToken$ = this.isAuthenticated$.pipe(filter((loaded) => loaded), map(() => {
            const raw = this.oAuthService.getAccessToken();
            return {
                raw,
                parsed: this.parseJwt(raw),
            };
        }));
        if (!oAuthService) {
            throw new Error(`In order to use ɵɵOidcAuthService, please include OAuthModule.forRoot() to your application module`);
        }
        this.window = this._window;
        this.oAuthService.events.subscribe((event) => {
            switch (event.type) {
                case 'discovery_document_loaded':
                case 'token_received':
                case 'logout':
                    this.authenticated$$.next();
                    break;
                default:
                    break;
            }
        });
    }
    logout(redirectUri) {
        if (redirectUri) {
            this.oAuthService.postLogoutRedirectUri = redirectUri;
        }
        this.oAuthService.logOut();
        return this.oAuthService.events
            .pipe(filter((event) => event.type === 'logout'), mapTo(undefined), take(1))
            .toPromise();
    }
    timeToLive() {
        const expiration = this.oAuthService.getAccessTokenExpiration();
        if (expiration) {
            return expiration - Math.ceil(new Date().getTime() / 1000) + (this.oAuthService.clockSkewInSec || 0);
        }
        return -1;
    }
    refresh() {
        this.oAuthService.refreshToken();
        return this.oAuthService.events
            .pipe(filter((event) => event.type === 'token_refreshed'), mapTo(undefined), take(1))
            .toPromise();
    }
    loadDiscoveryDocument() {
        return this.oAuthService.loadDiscoveryDocument();
    }
    authorizationHeader() {
        return this.oAuthService.authorizationHeader();
    }
    createReauthLoginUrl(scope, acr_values) {
        return from(this.oAuthService.createLoginUrl('', // state
        '', // login hint
        location.href, // custom redirect uri
        false, // no prompt
        {
            acr_values,
            response_mode: 'fragment',
        })).pipe(map((preUrl) => {
            const urlParsed = new URL(preUrl);
            urlParsed.searchParams.set('scope', `${urlParsed.searchParams.get('scope')} ${scope}`);
            return urlParsed.href;
        }));
    }
    parseJwt(token) {
        try {
            const base64Url = token.split('.')[1];
            const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
            return JSON.parse(this.window.atob(base64));
        }
        catch (e) {
            return undefined;
        }
    }
}
/** @nocollapse */ ɵɵOidcAuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ɵɵOidcAuthService, deps: [{ token: i1.OAuthService, optional: true }, { token: OAuthStorage }, { token: AuthConfig }, { token: WINDOW }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ɵɵOidcAuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ɵɵOidcAuthService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ɵɵOidcAuthService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.OAuthService, decorators: [{
                    type: Optional
                }] }, { type: i1.OAuthStorage, decorators: [{
                    type: Inject,
                    args: [OAuthStorage]
                }] }, { type: i1.AuthConfig, decorators: [{
                    type: Inject,
                    args: [AuthConfig]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [WINDOW]
                }] }]; } });

class AuthService {
    constructor(oidcAuthService) {
        this.oidcAuthService = oidcAuthService;
        this.isAuthenticated$ = this.oidcAuthService.isAuthenticated$;
    }
}
/** @nocollapse */ AuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AuthService, deps: [{ token: ɵɵOidcAuthService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ AuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AuthService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: ɵɵOidcAuthService }]; } });

function _window() {
    return window;
}
class IdentityAuthModule {
}
/** @nocollapse */ IdentityAuthModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: IdentityAuthModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ IdentityAuthModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: IdentityAuthModule, imports: [CommonModule] });
/** @nocollapse */ IdentityAuthModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: IdentityAuthModule, providers: [
        {
            provide: WINDOW,
            useValue: _window,
        },
        AuthService,
        ɵɵOidcAuthService,
        ActivityMonitorService,
    ], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: IdentityAuthModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    providers: [
                        {
                            provide: WINDOW,
                            useValue: _window,
                        },
                        AuthService,
                        ɵɵOidcAuthService,
                        ActivityMonitorService,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { ACTIVITY_MONITOR_CONFIG, ActivityMonitorService, AuthService, IdentityAuthModule, ɵɵOidcAuthService };
//# sourceMappingURL=backbase-identity-auth.js.map
