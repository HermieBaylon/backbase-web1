{"version":3,"file":"countdown.service.js","sourceRoot":"","sources":["../../../../../../../libs/identity-auth/transaction-signing/util/countdown/countdown.service.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAC3C,OAAO,EAAE,eAAe,EAAE,QAAQ,EAAc,OAAO,EAAE,MAAM,MAAM,CAAC;AACtE,OAAO,EAAE,GAAG,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAC;;AAKhD,MAAM,OAAO,gBAAgB;IAH7B;QAImB,YAAO,GAA4B,IAAI,eAAe,CAAC,CAAC,CAAC,CAAC;QAC1D,aAAQ,GAAkB,IAAI,OAAO,EAAE,CAAC;QAIzC,mBAAc,GAAuB,IAAI,CAAC,OAAO,CAAC,YAAY,EAAE,CAAC;KA2BlF;IAzBS,aAAa,CAAC,MAAc;QAClC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,GAAG,MAAM,GAAG,IAAI,CAAC;IACtD,CAAC;IAED,IAAY,aAAa;QACvB,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;IACjE,CAAC;IAED,KAAK,CAAC,MAAc;QAClB,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;QAC3B,QAAQ,CAAC,IAAI,CAAC;aACX,IAAI,CACH,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,EACxB,GAAG,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,aAAa,CAAC,CAC9B;aACA,SAAS,CAAC,CAAC,aAAa,EAAE,EAAE;YAC3B,IAAI,aAAa,GAAG,CAAC,EAAE;gBACrB,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;aAClC;iBAAM;gBACL,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;aACtB;QACH,CAAC,CAAC,CAAC;IACP,CAAC;;iIAhCU,gBAAgB;qIAAhB,gBAAgB,cAFf,MAAM;4FAEP,gBAAgB;kBAH5B,UAAU;mBAAC;oBACV,UAAU,EAAE,MAAM;iBACnB","sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, interval, Observable, Subject } from 'rxjs';\nimport { map, takeUntil } from 'rxjs/operators';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class CountdownService {\n  private readonly counter: BehaviorSubject<number> = new BehaviorSubject(0);\n  private readonly finished: Subject<void> = new Subject();\n\n  private dueTime!: number;\n\n  public readonly remainingTime$: Observable<number> = this.counter.asObservable();\n\n  private registerStart(period: number): void {\n    this.counter.next(period);\n    this.dueTime = new Date().getTime() + period * 1000;\n  }\n\n  private get remainingTime(): number {\n    return Math.ceil((this.dueTime - new Date().getTime()) / 1000);\n  }\n\n  start(period: number): void {\n    this.registerStart(period);\n    interval(1000)\n      .pipe(\n        takeUntil(this.finished),\n        map(() => this.remainingTime),\n      )\n      .subscribe((remainingTime) => {\n        if (remainingTime > 0) {\n          this.counter.next(remainingTime);\n        } else {\n          this.counter.next(0);\n          this.finished.next();\n        }\n      });\n  }\n}\n"]}