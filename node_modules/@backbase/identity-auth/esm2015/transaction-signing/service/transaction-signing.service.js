import { __rest } from "tslib";
import { Location } from '@angular/common';
import { HttpClient, HttpErrorResponse, HttpResponse } from '@angular/common/http';
import { Inject, Injectable, Optional } from '@angular/core';
import { ɵɵOidcAuthService } from '@backbase/identity-auth';
import { Observable, ReplaySubject, throwError } from 'rxjs';
import { catchError, first, mapTo, switchMap, withLatestFrom } from 'rxjs/operators';
import { hasStatusWithHeaderValue, TRANSACTION_SIGNING_CONFIG, } from '../util';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "@angular/common";
import * as i3 from "@backbase/identity-auth";
/**
 * Angular Service used to instigate and manage transaction signing for an action.
 */
export class TransactionSigningService {
    /** @internal */
    constructor(httpClient, location, oidcAuthService, serviceConfig) {
        this.httpClient = httpClient;
        this.location = location;
        this.oidcAuthService = oidcAuthService;
        this.serviceConfig = serviceConfig;
        /**
         * A subject that emits when a new transaction signing event occurs.
         * The subject will emit an object containing the initial challenge from
         * the Identity Auth Server. To respond to this challenge use the
         * `respondToChallenge` endpoint provided.
         */
        this.requestSubject = new ReplaySubject(1);
        this.actionSubject = new ReplaySubject(1);
        this.observerSubject = new ReplaySubject(1);
        this.isHandlingTransaction = false;
        this.authHeaderKey = 'www-authenticate';
        this.authHeaderValue = 'Bearer challenge_types=reauth';
        this.authStatus = 401;
        this.onAuthError = (err) => {
            if (err.error && err.error.challenges) {
                const _a = err.error.challenges[0], { challengeType, actionUrl } = _a, challengeData = __rest(_a, ["challengeType", "actionUrl"]);
                this.actionSubject.next(this.getActionUrl(actionUrl));
                return throwError({
                    challengeType,
                    challengeData,
                });
            }
            return throwError(this.getErrorResponse(err));
        };
        if (!oidcAuthService) {
            throw new Error(`In order to use ImpersonationService, please include IdentityAuthModule to your application module`);
        }
    }
    /** @internal */
    initiateTransactionSigning(error) {
        if (!hasStatusWithHeaderValue(error, this.authStatus, this.authHeaderKey, this.authHeaderValue) ||
            this.isHandlingTransaction) {
            return throwError(error);
        }
        const body = error.error || {};
        const challenge = this.getFirstChallenge(body);
        return challenge ? this.authenticateUser(challenge, body.data) : throwError(error);
    }
    /**
     * Method that supports the response to an issued challenge.
     * @param data The data to be submitted in response to the challenge.
     * @returns an observable that will either be successful or throw a new challenge
     */
    respondToChallenge(data) {
        return this.actionSubject.pipe(first(), switchMap((url) => this.postResponse(url, data)));
    }
    /**
     * Method that will announce to the initiating widget that the transaction signing
     * process is complete, and that the process was successful.
     * The widget will be updated with an HttpResponse object containing the initial
     * transaction data in the body.
     */
    completeWithSuccess() {
        this.observerSubject.pipe(withLatestFrom(this.requestSubject), first()).subscribe({
            next: ([observer, request]) => {
                observer.next(new HttpResponse({ body: request.transactionData }));
                observer.complete();
                this.isHandlingTransaction = false;
            },
        });
    }
    /**
     * Method that will announce to the initiating widget that the transaction signing
     * process is complete, and that the process failed.
     * The widget will be updated with an HttpErrorResponse object containing the initial
     * transaction data and the error reason.
     */
    completeWithFailure(error) {
        this.observerSubject.pipe(withLatestFrom(this.requestSubject), first()).subscribe({
            next: ([observer, request]) => {
                observer.error(new HttpErrorResponse({
                    status: 401,
                    statusText: error.message,
                    error: {
                        error,
                        data: request.transactionData,
                    },
                }));
                this.isHandlingTransaction = false;
            },
        });
    }
    getFirstChallenge(body) {
        const challenges = body.challenges || [];
        return challenges.find((c) => c.scope !== undefined);
    }
    authenticateUser(challenge, transactionData) {
        return this.reauthenticate(challenge).pipe(first(), mapTo(new HttpResponse({ body: transactionData })), catchError((response) => {
            return new Observable((observer) => {
                this.isHandlingTransaction = true;
                this.requestSubject.next({
                    challenge: response,
                    transactionData,
                });
                this.observerSubject.next(observer);
            });
        }));
    }
    reauthenticate(challenge) {
        const { acrValues, scope } = challenge;
        return this.oidcAuthService.createReauthLoginUrl(scope, acrValues).pipe(switchMap((url) => {
            if (this.serviceConfig && this.serviceConfig.useRedirectFlow) {
                this.location.go(url);
            }
            return this.requestChallenge(url);
        }));
    }
    requestChallenge(url) {
        return this.httpClient
            .get(url, this.getRequestOptions())
            .pipe(catchError(this.onAuthError));
    }
    postResponse(url, data) {
        return this.httpClient
            .post(url, data, this.getRequestOptions())
            .pipe(catchError(this.onAuthError));
    }
    getRequestOptions() {
        return {
            headers: {
                Accept: '*/*',
                'X-Convert-Redirects': 'true',
                Authentication: this.oidcAuthService.authorizationHeader(),
            },
            withCredentials: true,
            observe: 'response',
        };
    }
    getErrorResponse(error) {
        const url = new URL(error.headers.get('location') || error.headers.get('Location') || '');
        const params = new URLSearchParams(url.search);
        return {
            error: {
                errorCode: params.get('error') || 'unknown_error',
                errorDescription: params.get('error_description') || undefined,
            },
        };
    }
    getActionUrl(url) {
        const idp = new URL(this.oidcAuthService.authConfig.issuer || '');
        return url.startsWith('/auth') ? `${idp.origin}${url}` : `${idp.origin}/auth${url}`;
    }
}
/** @nocollapse */ TransactionSigningService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningService, deps: [{ token: i1.HttpClient }, { token: i2.Location }, { token: i3.ɵɵOidcAuthService, optional: true }, { token: TRANSACTION_SIGNING_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ TransactionSigningService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.HttpClient }, { type: i2.Location }, { type: i3.ɵɵOidcAuthService, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TRANSACTION_SIGNING_CONFIG]
                }] }]; } });
//# sourceMappingURL=transaction-signing.service.js.map