import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import * as i1$1 from '@ngrx/store';
import { createAction, props, createFeatureSelector, createSelector, createReducer, on, StoreModule } from '@ngrx/store';
import * as i1 from '@ngrx/effects';
import { createEffect, ofType, EffectsModule } from '@ngrx/effects';
import { of, throwError, merge } from 'rxjs';
import { switchMap, map, catchError, groupBy, mergeMap, first } from 'rxjs/operators';
import * as i3 from '@backbase/actions-common-ang';
import { EMPTY_RESPONSE_ERROR, getMappedRecurrenceResponse, parseActionRecipeFormItem, ActionsCommonModule, mergeSpecificationsWithActionRecipes } from '@backbase/actions-common-ang';
import * as i4 from '@backbase/ui-ang/notification';

const loadActionRecipes = createAction('[ACT Action Recipes] Load Action Recipes', props());
const loadActionRecipesSuccess = createAction('[ACT Action Recipes] Load Action Recipes Success', props());
const loadActionRecipesFailed = createAction('[ACT Action Recipes] Load Action Recipes Failed', props());
const saveActionRecipe = createAction('[ACT Action Recipes] Save Action Recipe', props());
const saveActionRecipeSuccess = createAction('[ACT Action Recipes] Save Action Recipe Success', props());
const saveActionRecipeFailure = createAction('[ACT Action Recipes] Save Action Recipe Failure', props());

const selectActionRecipesState = createFeatureSelector('actionRecipes');
const actionRecipes = createSelector(selectActionRecipesState, (state) => state.data);
const actionRecipesLoading = createSelector(selectActionRecipesState, state => state.loading);
const actionRecipesError = createSelector(selectActionRecipesState, state => state.error);
const actionRecipesSpecificationIds = createSelector(selectActionRecipesState, state => state.specificationIds);

class ActionsRecipesEffects {
    constructor(actions$, store, dataService, notificationService) {
        this.actions$ = actions$;
        this.store = store;
        this.dataService = dataService;
        this.notificationService = notificationService;
        this.actionRecipes$ = createEffect(() => this.actions$.pipe(ofType(loadActionRecipes), switchMap(({ specificationIds, arrangementId }) => this.dataService.getActionRecipes(arrangementId).pipe(map(data => (specificationIds ? data.filter(({ specificationId: id }) => specificationIds.has(id)) : data)), map(data => arrangementId ? data.filter(item => !item.arrangementId || item.arrangementId === arrangementId) : data), map(data => loadActionRecipesSuccess({
            actionRecipes: data || [],
            specificationIds,
        })), catchError(error => of(loadActionRecipesFailed({ error })))))));
        this.saveActionRecipe$ = createEffect(() => this.actions$.pipe(ofType(saveActionRecipe), groupBy(({ actionRecipe }) => actionRecipe.specificationId), mergeMap(group => group.pipe(switchMap(({ actionRecipe, arrangementId, warningNotification, successNotification }) => this.dataService.saveActionRecipe(actionRecipe, arrangementId).pipe(switchMap(({ actionRecipes }) => {
            if (!actionRecipes || !actionRecipes.length)
                return throwError(EMPTY_RESPONSE_ERROR);
            return of(saveActionRecipeSuccess(Object.assign({ actionRecipe: Object.assign(Object.assign({}, actionRecipes[0]), (actionRecipes[0].recurrence && {
                    recurrence: getMappedRecurrenceResponse(actionRecipes[0].recurrence, actionRecipe),
                })) }, (successNotification && { notification: successNotification }))));
        }), catchError(err => {
            if (err.status === 409) {
                return this.store.select(actionRecipesSpecificationIds).pipe(first(), map(specificationIds => loadActionRecipes({
                    arrangementId,
                    specificationIds,
                })));
            }
            return of(saveActionRecipeFailure(Object.assign({ actionRecipe: parseActionRecipeFormItem(actionRecipe) }, (warningNotification && { notification: warningNotification }))));
        })))))));
        this.showNotification$ = createEffect(() => merge(this.actions$.pipe(ofType(saveActionRecipeSuccess)), this.actions$.pipe(ofType(saveActionRecipeFailure))).pipe(map(({ notification }) => {
            if (notification) {
                this.notificationService.showNotification(notification);
            }
        })), { dispatch: false });
    }
}
ActionsRecipesEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsRecipesEffects, deps: [{ token: i1.Actions }, { token: i1$1.Store }, { token: i3.NotificationsPreferencesBaseDataService }, { token: i4.NotificationService }], target: i0.ɵɵFactoryTarget.Injectable });
ActionsRecipesEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsRecipesEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsRecipesEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i1$1.Store }, { type: i3.NotificationsPreferencesBaseDataService }, { type: i4.NotificationService }]; } });

const loadSpecifications = createAction('[ACT Specifications] Load Specifications', props());
const loadSpecificationsSuccess = createAction('[ACT Specifications] Load Specifications Success', props());
const loadSpecificationsFailed = createAction('[ACT Specifications] Load Specifications Failed', props());

class ActionsSpecificationsEffects {
    constructor(actions$, dataService) {
        this.actions$ = actions$;
        this.dataService = dataService;
        this.specifications$ = createEffect(() => this.actions$.pipe(ofType(loadSpecifications), switchMap(({ specificationIds }) => this.dataService.getSpecifications().pipe(map(data => (specificationIds ? data.filter(({ id }) => !!id && specificationIds.has(id)) : data)), map(data => loadSpecificationsSuccess({ specifications: data || [] })), catchError(() => of(loadSpecificationsFailed({ error: true })))))));
    }
}
ActionsSpecificationsEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsSpecificationsEffects, deps: [{ token: i1.Actions }, { token: i3.NotificationsPreferencesBaseDataService }], target: i0.ɵɵFactoryTarget.Injectable });
ActionsSpecificationsEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsSpecificationsEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsSpecificationsEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i3.NotificationsPreferencesBaseDataService }]; } });

const actionRecipeInitialState = {
    data: [],
    loading: false,
    error: undefined,
    specificationIds: undefined,
};

const _actionRecipesReducer = createReducer(actionRecipeInitialState, on(loadActionRecipes, state => (Object.assign(Object.assign({}, state), { loading: true, error: undefined, specificationIds: undefined }))), on(loadActionRecipesSuccess, (state, action) => (Object.assign(Object.assign({}, state), { data: action.actionRecipes, loading: false, specificationIds: action.specificationIds }))), on(loadActionRecipesFailed, (state, action) => (Object.assign(Object.assign({}, state), { error: action.error, loading: false }))), on(saveActionRecipeSuccess, (state, action) => {
    const { actionRecipe: recipe } = action;
    const { data } = state;
    const targetIndex = data.findIndex(({ specificationId }) => specificationId === recipe.specificationId);
    const isAppend = targetIndex === -1;
    return Object.assign(Object.assign({}, state), { data: isAppend ? [...data, recipe] : insertActionRecipe(data, recipe, targetIndex) });
}), on(saveActionRecipeFailure, (state, action) => {
    const { actionRecipe: recipe } = action;
    const { data } = state;
    const targetIndex = data.findIndex(({ specificationId }) => specificationId === recipe.specificationId);
    const isAppend = targetIndex === -1;
    return Object.assign(Object.assign({}, state), { data: isAppend
            ? [...data, Object.assign(Object.assign({}, recipe), { active: false })]
            : insertActionRecipe(data, Object.assign({}, data[targetIndex]), targetIndex) });
}));
function actionRecipesReducer(state, action) {
    return _actionRecipesReducer(state, action);
}
const insertActionRecipe = (data, actionRecipe, index) => [
    ...data.slice(0, index),
    actionRecipe,
    ...data.slice(index + 1),
];

const specificationsInitialState = {
    data: [],
    loading: false,
    error: false,
};

const initialState = {
    specifications: specificationsInitialState,
    actionRecipes: actionRecipeInitialState,
};

const _specificationsReducer = createReducer(initialState.specifications, on(loadSpecifications, state => (Object.assign(Object.assign({}, state), { loading: true, error: false }))), on(loadSpecificationsSuccess, (state, action) => (Object.assign(Object.assign({}, state), { data: action.specifications, loading: false }))), on(loadSpecificationsFailed, (state, action) => (Object.assign(Object.assign({}, state), { error: action.error, loading: false }))));
function specificationsReducer(state, action) {
    return _specificationsReducer(state, action);
}

class ActionsStoreModule {
}
ActionsStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
ActionsStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModule, imports: [CommonModule,
        ActionsCommonModule, i1$1.StoreFeatureModule, i1$1.StoreFeatureModule, i1.EffectsFeatureModule] });
ActionsStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModule, providers: [ActionsRecipesEffects, ActionsSpecificationsEffects], imports: [[
            CommonModule,
            ActionsCommonModule,
            StoreModule.forFeature('actionRecipes', actionRecipesReducer),
            StoreModule.forFeature('specifications', specificationsReducer),
            EffectsModule.forFeature([ActionsRecipesEffects, ActionsSpecificationsEffects]),
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [ActionsRecipesEffects, ActionsSpecificationsEffects],
                    imports: [
                        CommonModule,
                        ActionsCommonModule,
                        StoreModule.forFeature('actionRecipes', actionRecipesReducer),
                        StoreModule.forFeature('specifications', specificationsReducer),
                        EffectsModule.forFeature([ActionsRecipesEffects, ActionsSpecificationsEffects]),
                    ],
                }]
        }] });

const selectSpecificationsState = createFeatureSelector('specifications');
const specifications = createSelector(selectSpecificationsState, state => state.data);
const specificationsLoading = createSelector(selectSpecificationsState, state => state.loading);
const specificationsError = createSelector(selectSpecificationsState, state => state.error);

const specificationsWithActionRecipe = createSelector(specifications, actionRecipes, (specs, recipes) => mergeSpecificationsWithActionRecipes(specs, recipes));

class ActionsStoreModel {
    constructor(store) {
        this.store = store;
        /**
         * Stream of specifications.
         */
        this.specifications$ = this.store.select(specifications);
        /**
         * Stream of specifications loading flags.
         */
        this.specificationsLoading$ = this.store.select(specificationsLoading);
        /**
         * Stream of specifications errors.
         */
        this.specificationsError$ = this.store.select(specificationsError);
        /**
         * Stream of action recipes.
         */
        this.actionRecipes$ = this.store.select(actionRecipes);
        /**
         * Stream of action recipes loading flags.
         */
        this.actionRecipesLoading$ = this.store.select(actionRecipesLoading);
        /**
         * Stream of action recipes errors.
         */
        this.actionRecipesError$ = this.store.select(actionRecipesError);
        /**
         * Stream of specifications with action recipe.
         */
        this.specificationsWithActionRecipe$ = this.store.select(specificationsWithActionRecipe);
    }
    /**
     * Method to dispatch load specifications.
     *
     * @param payload - load specifications payload
     */
    dispatchLoadSpecifications(payload) {
        this.store.dispatch(loadSpecifications(payload));
    }
    /**
     * Method to dispatch load action recipes.
     *
     * @param payload - load specifications payload
     */
    dispatchLoadActionRecipes(payload) {
        this.store.dispatch(loadActionRecipes(payload));
    }
    /**
     * Method to dispatch save action recipe.
     *
     * @param payload - action recipe payload
     */
    dispatchSaveActionRecipe(payload) {
        this.store.dispatch(saveActionRecipe(payload));
    }
}
ActionsStoreModel.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModel, deps: [{ token: i1$1.Store }], target: i0.ɵɵFactoryTarget.Injectable });
ActionsStoreModel.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModel });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: ActionsStoreModel, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Store }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { ActionsStoreModel, ActionsStoreModule };
//# sourceMappingURL=backbase-actions-store-ang.js.map
