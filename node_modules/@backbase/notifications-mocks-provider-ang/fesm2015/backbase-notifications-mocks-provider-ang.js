import { HttpResponse, HttpHeaders, HttpErrorResponse, HTTP_INTERCEPTORS } from '@angular/common/http';
import * as i0 from '@angular/core';
import { Injectable } from '@angular/core';
import { throwError } from 'rxjs';
import { map } from 'rxjs/operators';
import { toISOExtendedFormat } from '@backbase/notifications-common-ang';

const notification = {
    createdOn: '2017-08-06T14:01:36Z',
    id: '1234-5678-9022',
    level: 'ALERT',
    message: 'Your payment to A. Smith was rejected due to insufficient funds on your current account.',
    origin: 'Transaction',
    read: false,
    title: 'Payment rejected',
};

const DEFAULT_FREQUENCY = 20000;
const notificationReadRegexp = /\/notifications\/(.*)\/read\/?$/;
function getGenerationFrequency(frequency) {
    const freq = frequency && parseInt(frequency, 10);
    return freq || DEFAULT_FREQUENCY;
}
function createNotificationsPage(notifications, options) {
    const { from, size } = options;
    const start = from * size;
    const end = start + size;
    return notifications.slice(start, end);
}
const quietNotificationsStrategy = {
    STICKY_LIMIT: 1,
    POPUPS_LIMIT: 1,
};
const noLimitsNotificationsStrategy = {
    STICKY_LIMIT: Infinity,
    POPUPS_LIMIT: Infinity,
};
const noNotificationsStrategy = {
    STICKY_LIMIT: 0,
    POPUPS_LIMIT: 0,
};
class NotificationsInterceptor {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.areMocksEnabled = localStorage.getItem('enableMocks') === 'true';
        this.isEmptyNotificationsEnabled = localStorage.getItem('noNotifications') === 'true';
        this.isNoLimitsNotificationsEnabled = localStorage.getItem('noLimitsNotifications') === 'true';
        this.liveNotificationFreq = localStorage.getItem('liveNotificationFreq');
        this.mockStrategy = this.getMockStrategy();
        this.readNotifications = {};
        this.newNotifications = [];
        this.popupsCount = 0;
        this.notificationsStreamHandled = false;
        this.notificationRequestUnreadIds = []; // from spec examples
        if (this.mockStrategy && this.liveNotificationFreq) {
            this.ngZone.runOutsideAngular(() => {
                setInterval(() => {
                    this.newNotifications.unshift(Object.assign(Object.assign({}, notification), { id: (345679 + this.newNotifications.length).toString(), title: `New Notification ${this.newNotifications.length + 1}`, createdOn: new Date().toISOString() }));
                }, getGenerationFrequency(this.liveNotificationFreq));
            });
        }
    }
    intercept(req, next) {
        if (!this.mockStrategy) {
            return next.handle(req);
        }
        if (req.url.endsWith('notifications/unread-count')) {
            return this.handleUnreadCountRequest(req, next);
        }
        if (req.url.endsWith('notifications/read')) {
            return this.handleReadAllNotificationRequest(req, next);
        }
        if (req.url.endsWith('read') && req.method === 'PUT') {
            return this.handleReadNotificationRequest(req, next);
        }
        if (req.url.endsWith('notifications')) {
            return this.handleNotificationsRequest(req, next);
        }
        if (req.url.endsWith('notifications/stream')) {
            return this.handleNotificationsStreamRequest(req, next);
        }
        return next.handle(req);
    }
    handleUnreadCountRequest(req, next) {
        if (this.mockStrategy === noNotificationsStrategy) {
            return next.handle(req).pipe(map((event) => {
                if (event instanceof HttpResponse) {
                    return event.clone({
                        body: {
                            unread: 0,
                        },
                    });
                }
                return event;
            }));
        }
        return next.handle(req).pipe(map((event) => {
            if (event instanceof HttpResponse) {
                return event.clone({
                    body: {
                        unread: this.newNotifications.length +
                            event.body.unread +
                            this.popupsCount -
                            Object.keys(this.readNotifications).length,
                    },
                });
            }
            return event;
        }));
    }
    handleNotificationsRequest(req, next) {
        if (this.mockStrategy === noNotificationsStrategy) {
            return next.handle(req).pipe(map((event) => {
                if (event instanceof HttpResponse) {
                    return event.clone({
                        body: [],
                    });
                }
                return event;
            }));
        }
        return next.handle(req).pipe(map((event) => {
            if (event instanceof HttpResponse) {
                const from = Number(req.params.get('from'));
                const size = Number(req.params.get('size'));
                const toDate = req.params.get('toDate');
                if (!this.notificationRequestUnreadIds.length) {
                    this.notificationRequestUnreadIds.push(
                    //@ts-ignore
                    ...event.body.filter((item) => !item.read).map((item) => item.id));
                }
                let notifications = [...this.newNotifications, ...event.body];
                if (toDate) {
                    notifications = notifications.filter(({ createdOn }) => new Date(toISOExtendedFormat(createdOn)).getTime() <= new Date(toDate).getTime());
                }
                const notificationsPage = createNotificationsPage(notifications, { from, size });
                return event.clone({
                    body: notificationsPage.map((n) => (Object.assign(Object.assign({}, n), { read: this.readNotifications[n.id] || n.read }))),
                    headers: new HttpHeaders({
                        'x-total-count': String(notifications.length),
                        'x-cursor': notificationsPage[notificationsPage.length - 1].id,
                    }),
                });
            }
            return event;
        }));
    }
    handleReadAllNotificationRequest(req, next) {
        this.newNotifications.forEach(item => (this.readNotifications[item.id] = true));
        this.notificationRequestUnreadIds.forEach(id => (this.readNotifications[id] = true));
        return next.handle(req);
    }
    handleReadNotificationRequest(req, next) {
        const [, notificationId] = notificationReadRegexp.exec(req.url);
        if (notificationId === '1234-5678-9022') {
            return throwError(new HttpErrorResponse({
                status: 500,
                statusText: '',
            }));
        }
        this.readNotifications[notificationId] = true;
        return next.handle(req);
    }
    handleNotificationsStreamRequest(req, next) {
        return next.handle(req).pipe(map((event) => {
            if (event instanceof HttpResponse) {
                const popupsLimit = this.mockStrategy === quietNotificationsStrategy && !this.notificationsStreamHandled
                    ? 0
                    : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        this.mockStrategy.POPUPS_LIMIT;
                const popups = event.body
                    .filter((item) => !item.expiresOn && !this.readNotifications[item.id])
                    .slice(0, popupsLimit)
                    .map((item) => (Object.assign({}, item)));
                const sticky = event.body
                    .filter((item) => !!item.expiresOn)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    .slice(0, this.mockStrategy.STICKY_LIMIT)
                    .filter((item) => !this.readNotifications[item.id]);
                const randomPopups = popups.slice(0, Math.ceil(Math.random() * popups.length));
                this.popupsCount = event.body.length;
                this.notificationsStreamHandled = true;
                return event.clone({
                    body: [...sticky, ...randomPopups],
                });
            }
            return event;
        }));
    }
    getMockStrategy() {
        if (!this.areMocksEnabled)
            return undefined;
        if (this.isEmptyNotificationsEnabled)
            return noNotificationsStrategy;
        if (this.isNoLimitsNotificationsEnabled)
            return noLimitsNotificationsStrategy;
        return quietNotificationsStrategy;
    }
}
NotificationsInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: NotificationsInterceptor, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
NotificationsInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: NotificationsInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.14", ngImport: i0, type: NotificationsInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; } });

const NotificationsMocksProvider = {
    provide: HTTP_INTERCEPTORS,
    useClass: NotificationsInterceptor,
    multi: true,
};

/**
 * Generated bundle index. Do not edit.
 */

export { NotificationsInterceptor, NotificationsMocksProvider };
//# sourceMappingURL=backbase-notifications-mocks-provider-ang.js.map
