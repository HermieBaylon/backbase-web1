{"version":3,"sources":["../source/getNumberType.js"],"names":["get_number_type","is_of_type","sort_out_arguments","check_number_length_for_type","merge_arrays","non_fixed_line_types","arg_1","arg_2","arg_3","arg_4","input","options","metadata","country","hasCountry","Error","nationalNumber","v2","phone","nationalNumberPattern","type","pattern","_type","possibleLengths","indexOf","length","is_object","TypeError","type_info","possible_lengths","mobile_type","actual_length","minimum_length","_","a","b","merged","slice","element","push","sort"],"mappings":"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","file":"getNumberType.js","sourcesContent":["import parse, { is_viable_phone_number } from './parse'\n\nimport { matches_entirely } from './common'\n\nimport Metadata from './metadata'\n\nconst non_fixed_line_types =\n[\n\t'MOBILE',\n\t'PREMIUM_RATE',\n\t'TOLL_FREE',\n\t'SHARED_COST',\n\t'VOIP',\n\t'PERSONAL_NUMBER',\n\t'PAGER',\n\t'UAN',\n\t'VOICEMAIL'\n]\n\n// Finds out national phone number type (fixed line, mobile, etc)\nexport default function get_number_type(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { input, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\t// When `parse()` returned `{}`\n\t// meaning that the phone number is not a valid one.\n\tif (!input.country)\n\t{\n\t\treturn\n\t}\n\n\tif (!metadata.hasCountry(input.country))\n\t{\n\t\tthrow new Error(`Unknown country: ${input.country}`)\n\t}\n\n\tconst nationalNumber = options.v2 ? input.nationalNumber : input.phone\n\tmetadata.country(input.country)\n\n\t// The following is copy-pasted from the original function:\n\t// https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835\n\n\t// Is this national number even valid for this country\n\tif (!matches_entirely(nationalNumber, metadata.nationalNumberPattern()))\n\t{\n\t\treturn\n\t}\n\n\t// Is it fixed line number\n\tif (is_of_type(nationalNumber, 'FIXED_LINE', metadata))\n\t{\n\t\t// Because duplicate regular expressions are removed\n\t\t// to reduce metadata size, if \"mobile\" pattern is \"\"\n\t\t// then it means it was removed due to being a duplicate of the fixed-line pattern.\n\t\t//\n\t\tif (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '')\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// v1 metadata.\n\t\t// Legacy.\n\t\t// Deprecated.\n\t\tif (!metadata.type('MOBILE'))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\t// Check if the number happens to qualify as both fixed line and mobile.\n\t\t// (no such country in the minimal metadata set)\n\t\t/* istanbul ignore if */\n\t\tif (is_of_type(nationalNumber, 'MOBILE', metadata))\n\t\t{\n\t\t\treturn 'FIXED_LINE_OR_MOBILE'\n\t\t}\n\n\t\treturn 'FIXED_LINE'\n\t}\n\n\tfor (const _type of non_fixed_line_types)\n\t{\n\t\tif (is_of_type(nationalNumber, _type, metadata))\n\t\t{\n\t\t\treturn _type\n\t\t}\n\t}\n}\n\nexport function is_of_type(nationalNumber, type, metadata)\n{\n\ttype = metadata.type(type)\n\n\tif (!type || !type.pattern())\n\t{\n\t\treturn false\n\t}\n\n\t// Check if any possible number lengths are present;\n\t// if so, we use them to avoid checking\n\t// the validation pattern if they don't match.\n\t// If they are absent, this means they match\n\t// the general description, which we have\n\t// already checked before a specific number type.\n\tif (type.possibleLengths() &&\n\t\ttype.possibleLengths().indexOf(nationalNumber.length) < 0)\n\t{\n\t\treturn false\n\t}\n\n\treturn matches_entirely(nationalNumber, type.pattern())\n}\n\n// Sort out arguments\nexport function sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n{\n\tlet input\n\tlet options = {}\n\tlet metadata\n\n\t// If the phone number is passed as a string.\n\t// `getNumberType('88005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\t// If \"default country\" argument is being passed\n\t\t// then convert it to an `options` object.\n\t\t// `getNumberType('88005553535', 'RU', metadata)`.\n\t\tif (typeof arg_2 !== 'object')\n\t\t{\n\t\t\tif (arg_4)\n\t\t\t{\n\t\t\t\toptions = arg_3\n\t\t\t\tmetadata = arg_4\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmetadata = arg_3\n\t\t\t}\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(arg_1))\n\t\t\t{\n\t\t\t\tinput = parse(arg_1, arg_2, metadata)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinput = {}\n\t\t\t}\n\t\t}\n\t\t// No \"resrict country\" argument is being passed.\n\t\t// International phone number is passed.\n\t\t// `getNumberType('+78005553535', metadata)`.\n\t\telse\n\t\t{\n\t\t\tif (arg_3)\n\t\t\t{\n\t\t\t\toptions = arg_2\n\t\t\t\tmetadata = arg_3\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmetadata = arg_2\n\t\t\t}\n\n\t\t\t// `parse` extracts phone numbers from raw text,\n\t\t\t// therefore it will cut off all \"garbage\" characters,\n\t\t\t// while this `validate` function needs to verify\n\t\t\t// that the phone number contains no \"garbage\"\n\t\t\t// therefore the explicit `is_viable_phone_number` check.\n\t\t\tif (is_viable_phone_number(arg_1))\n\t\t\t{\n\t\t\t\tinput = parse(arg_1, metadata)\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinput = {}\n\t\t\t}\n\t\t}\n\t}\n\t// If the phone number is passed as a parsed phone number.\n\t// `getNumberType({ phone: '88005553535', country: 'RU' }, ...)`.\n\telse if (is_object(arg_1))\n\t{\n\t\tinput = arg_1\n\n\t\tif (arg_3)\n\t\t{\n\t\t\toptions = arg_2\n\t\t\tmetadata = arg_3\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_2\n\t\t}\n\t}\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\n\n\treturn { input, options, metadata: new Metadata(metadata) }\n}\n\n// Should only be called for the \"new\" metadata which has \"possible lengths\".\nexport function check_number_length_for_type(nationalNumber, type, metadata)\n{\n\tconst type_info = metadata.type(type)\n\n\t// There should always be \"<possiblePengths/>\" set for every type element.\n\t// This is declared in the XML schema.\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\n\t// so we fall back to the \"general description\". Where no numbers of the type\n\t// exist at all, there is one possible length (-1) which is guaranteed\n\t// not to match the length of any real phone number.\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\n\t// let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\n\n\tif (type === 'FIXED_LINE_OR_MOBILE')\n\t{\n\t\t// No such country in metadata.\n\t\t/* istanbul ignore next */\n\t\tif (!metadata.type('FIXED_LINE'))\n\t\t{\n\t\t\t// The rare case has been encountered where no fixedLine data is available\n\t\t\t// (true for some non-geographical entities), so we just check mobile.\n\t\t\treturn check_number_length_for_type(nationalNumber, 'MOBILE', metadata)\n\t\t}\n\n\t\tconst mobile_type = metadata.type('MOBILE')\n\n\t\tif (mobile_type)\n\t\t{\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\n\t\t\t// Note that when adding the possible lengths from mobile, we have\n\t\t\t// to again check they aren't empty since if they are this indicates\n\t\t\t// they are the same as the general desc and should be obtained from there.\n\t\t\tpossible_lengths = merge_arrays(possible_lengths, mobile_type.possibleLengths())\n\t\t\t// The current list is sorted; we need to merge in the new list and\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\n\t\t\t// the lists are very small.\n\n\t\t\t// if (local_lengths)\n\t\t\t// {\n\t\t\t// \tlocal_lengths = merge_arrays(local_lengths, mobile_type.possibleLengthsLocal())\n\t\t\t// }\n\t\t\t// else\n\t\t\t// {\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\n\t\t\t// }\n\t\t}\n\t}\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\n\telse if (type && !type_info)\n\t{\n\t\treturn 'INVALID_LENGTH'\n\t}\n\n\tconst actual_length = nationalNumber.length\n\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\n\t// // This is safe because there is never an overlap beween the possible lengths\n\t// // and the local-only lengths; this is checked at build time.\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\n\t// {\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\n\t// }\n\n\tconst minimum_length = possible_lengths[0]\n\n\tif (minimum_length === actual_length)\n\t{\n\t\treturn 'IS_POSSIBLE'\n\t}\n\n\tif (minimum_length > actual_length)\n\t{\n\t\treturn 'TOO_SHORT'\n\t}\n\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length)\n\t{\n\t\treturn 'TOO_LONG'\n\t}\n\n\t// We skip the first element since we've already checked it.\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\n}\n\n// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */\nconst is_object = _ => typeof _ === 'object'\n\nexport function merge_arrays(a, b)\n{\n\tconst merged = a.slice()\n\n\tfor (const element of b)\n\t{\n\t\tif (a.indexOf(element) < 0)\n\t\t{\n\t\t\tmerged.push(element)\n\t\t}\n\t}\n\n\treturn merged.sort((a, b) => a - b)\n\n\t// ES6 version, requires Set polyfill.\n\t// let merged = new Set(a)\n\t// for (const element of b)\n\t// {\n\t// \tmerged.add(i)\n\t// }\n\t// return Array.from(merged).sort((a, b) => a - b)\n}"]}