{"version":3,"sources":["../source/parse.js"],"names":["extractCountryCallingCode","VALID_DIGITS","VALID_PUNCTUATION","PLUS_CHARS","MAX_LENGTH_FOR_NSN","matches_entirely","create_extension_pattern","parseIncompletePhoneNumber","Metadata","getCountryCallingCode","get_number_type","check_number_length_for_type","is_possible_number","parseRFC3966","PhoneNumber","MIN_LENGTH_FOR_NSN","MAX_INPUT_STRING_LENGTH","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERN","RegExp","MIN_LENGTH_PHONE_NUMBER_PATTERN","VALID_PHONE_NUMBER","VALID_PHONE_NUMBER_PATTERN","PHONE_NUMBER_START_PATTERN","AFTER_PHONE_NUMBER_END_PATTERN","default_options","country","parse","arg_1","arg_2","arg_3","arg_4","sort_out_arguments","text","options","metadata","defaultCountry","hasCountry","v2","Error","parse_input","formatted_phone_number","number","ext","parse_phone_number","nationalNumber","national_number","countryCallingCode","carrierCode","selectedCountry","length","phoneNumber","valid","nationalNumberPattern","extended","result","possible","possibleLengths","undefined","phone","is_viable_phone_number","test","extract_formatted_phone_number","starts_at","search","slice","replace","strip_national_prefix_and_carrier_code","nationalPrefixForParsing","national_prefix_pattern","national_prefix_matcher","exec","national_significant_number","captured_groups_count","nationalPrefixTransformRule","find_country_code","country_calling_code","national_phone_number","possible_countries","countryCallingCodes","_find_country_code","leadingDigits","TypeError","strip_extension","start","number_without_extension","matches","match","i","indexOf","with_extension_stripped","default_country","chooseCountryByCountryCallingCode","parse_national_number","carrier_code","exactCountry","potential_national_number"],"mappings":"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","file":"parse.js","sourcesContent":["// This is a port of Google Android `libphonenumber`'s\n// `phonenumberutil.js` of 17th November, 2016.\n//\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\n\nimport\n{\n\textractCountryCallingCode,\n\tVALID_DIGITS,\n\tVALID_PUNCTUATION,\n\tPLUS_CHARS,\n\tMAX_LENGTH_FOR_NSN,\n\tmatches_entirely,\n\tcreate_extension_pattern\n}\nfrom './common'\n\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\n\nimport Metadata from './metadata'\n\nimport getCountryCallingCode from './getCountryCallingCode'\n\nimport get_number_type, { check_number_length_for_type } from './getNumberType'\n\nimport { is_possible_number } from './isPossibleNumber'\n\nimport { parseRFC3966 } from './RFC3966'\n\nimport PhoneNumber from './PhoneNumber'\n\n// The minimum length of the national significant number.\nconst MIN_LENGTH_FOR_NSN = 2\n\n// We don't allow input strings for parsing to be longer than 250 chars.\n// This prevents malicious input from consuming CPU.\nconst MAX_INPUT_STRING_LENGTH = 250\n\n/**\n * Regexp of all possible ways to write extensions, for use when parsing. This\n * will be run as a case-insensitive regexp match. Wide character versions are\n * also provided after each ASCII version. There are three regular expressions\n * here. The first covers RFC 3966 format, where the extension is added using\n * ';ext='. The second more generic one starts with optional white space and\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\n * /commas and then the numbers themselves. The other one covers the special\n * case of American numbers where the extension is written with a hash at the\n * end, such as '- 503#'. Note that the only capturing groups should be around\n * the digits that you want to capture as part of the extension, or else parsing\n * will fail! We allow two options for representing the accented o - the\n * character itself, and one in the unicode decomposed form with the combining\n * acute accent.\n */\nconst EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\n\n// Regexp of all known extension prefixes used by different regions followed by\n// 1 or more valid digits, for use when parsing.\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\n\n//  Regular expression of viable phone numbers. This is location independent.\n//  Checks we have at least three leading digits, and only valid punctuation,\n//  alpha characters and digits in the phone number. Does not include extension\n//  data. The symbol 'x' is allowed here as valid punctuation since it is often\n//  used as a placeholder for carrier codes, for example in Brazilian phone\n//  numbers. We also allow multiple '+' characters at the start.\n//\n//  Corresponds to the following:\n//  [digits]{minLengthNsn}|\n//  plus_sign*\n//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*\n//\n//  The first reg-ex is to allow short numbers (two digits long) to be parsed if\n//  they are entered as \"15\" etc, but only if there is no punctuation in them.\n//  The second expression restricts the number of digits to three or more, but\n//  then allows them to be in international form, and to have alpha-characters\n//  and punctuation. We split up the two reg-exes here and combine them when\n//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it\n//  with ^ and append $ to each branch.\n//\n//  \"Note VALID_PUNCTUATION starts with a -,\n//   so must be the first in the range\" (c) Google devs.\n//  (wtf did they mean by saying that; probably nothing)\n//\nconst MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + VALID_DIGITS + ']{' + MIN_LENGTH_FOR_NSN + '}'\n//\n// And this is the second reg-exp:\n// (see MIN_LENGTH_PHONE_NUMBER_PATTERN for a full description of this reg-exp)\n//\nconst VALID_PHONE_NUMBER =\n\t'[' + PLUS_CHARS + ']{0,1}' +\n\t'(?:' +\n\t\t'[' + VALID_PUNCTUATION + ']*' +\n\t\t'[' + VALID_DIGITS + ']' +\n\t'){3,}' +\n\t'[' +\n\t\tVALID_PUNCTUATION +\n\t\tVALID_DIGITS +\n\t']*'\n\n// The combined regular expression for valid phone numbers:\n//\nconst VALID_PHONE_NUMBER_PATTERN = new RegExp\n(\n\t// Either a short two-digit-only phone number\n\t'^' +\n\t\tMIN_LENGTH_PHONE_NUMBER_PATTERN +\n\t'$' +\n\t'|' +\n\t// Or a longer fully parsed phone number (min 3 characters)\n\t'^' +\n\t\tVALID_PHONE_NUMBER +\n\t\t// Phone number extensions\n\t\t'(?:' + EXTN_PATTERNS_FOR_PARSING + ')?' +\n\t'$'\n,\n'i')\n\n// This consists of the plus symbol, digits, and arabic-indic digits.\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\n\n// Regular expression of trailing characters that we want to remove.\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + ']+$')\n\nconst default_options =\n{\n\tcountry: {}\n}\n\n// `options`:\n//  {\n//    country:\n//    {\n//      restrict - (a two-letter country code)\n//                 the phone number must be in this country\n//\n//      default - (a two-letter country code)\n//                default country to use for phone number parsing and validation\n//                (if no country code could be derived from the phone number)\n//    }\n//  }\n//\n// Returns `{ country, number }`\n//\n// Example use cases:\n//\n// ```js\n// parse('8 (800) 555-35-35', 'RU')\n// parse('8 (800) 555-35-35', 'RU', metadata)\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\n// parse('+7 800 555 35 35')\n// parse('+7 800 555 35 35', metadata)\n// ```\n//\nexport default function parse(arg_1, arg_2, arg_3, arg_4)\n{\n\tconst { text, options, metadata } = sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n\n\t// Validate `defaultCountry`.\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry))\n\t{\n\t\tif (options.v2) {\n\t\t\tthrow new Error('INVALID_COUNTRY')\n\t\t}\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\n\t}\n\n\t// Parse the phone number.\n\tconst { number: formatted_phone_number, ext } = parse_input(text, options.v2)\n\n\t// If the phone number is not viable then return nothing.\n\tif (!formatted_phone_number)\n\t{\n\t\tif (options.v2) {\n\t\t\tthrow new Error('NOT_A_NUMBER')\n\t\t}\n\t\treturn {}\n\t}\n\n\tconst\n\t{\n\t\tcountry,\n\t\tnational_number : nationalNumber,\n\t\tcountryCallingCode,\n\t\tcarrierCode\n\t}\n\t= parse_phone_number\n\t(\n\t\tformatted_phone_number,\n\t\toptions.defaultCountry,\n\t\tmetadata\n\t)\n\n\tif (!metadata.selectedCountry())\n\t{\n\t\tif (options.v2) {\n\t\t\tthrow new Error('INVALID_COUNTRY')\n\t\t}\n\t\treturn {}\n\t}\n\n\t// Validate national (significant) number length.\n\tif (nationalNumber.length < MIN_LENGTH_FOR_NSN) {\n\t\t// Won't throw here because the regexp already demands length > 1.\n\t\t/* istanbul ignore if */\n\t\tif (options.v2) {\n\t\t\tthrow new Error('TOO_SHORT')\n\t\t}\n\t\t// Google's demo just throws an error in this case.\n\t\treturn {}\n\t}\n\n\t// Validate national (significant) number length.\n\t//\n\t// A sidenote:\n\t//\n\t// They say that sometimes national (significant) numbers\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\n\t// Such numbers will just be discarded.\n\t//\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\n\t\tif (options.v2) {\n\t\t\tthrow new Error('TOO_LONG')\n\t\t}\n\t\t// Google's demo just throws an error in this case.\n\t\treturn {}\n\t}\n\n\tif (options.v2)\n\t{\n\t\tconst phoneNumber = new PhoneNumber(\n\t\t\tcountryCallingCode,\n\t\t\tnationalNumber,\n\t\t\tmetadata.metadata\n\t\t)\n\n\t\tif (country) {\n\t\t\tphoneNumber.country = country\n\t\t}\n\t\tif (carrierCode) {\n\t\t\tphoneNumber.carrierCode = carrierCode\n\t\t}\n\t\tif (ext) {\n\t\t\tphoneNumber.ext = ext\n\t\t}\n\n\t\treturn phoneNumber\n\t}\n\n\t// Check if national phone number pattern matches the number\n\t// National number pattern is different for each country,\n\t// even for those ones which are part of the \"NANPA\" group.\n\tconst valid = country && matches_entirely(nationalNumber, metadata.nationalNumberPattern()) ? true : false\n\n\tif (!options.extended)\n\t{\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\n\t}\n\n\treturn {\n\t\tcountry,\n\t\tcountryCallingCode,\n\t\tcarrierCode,\n\t\tvalid,\n\t\tpossible : valid ? true : (options.extended === true) && metadata.possibleLengths() && is_possible_number(nationalNumber, countryCallingCode !== undefined, metadata),\n\t\tphone : nationalNumber,\n\t\text\n\t}\n}\n\n// Checks to see if the string of characters could possibly be a phone number at\n// all. At the moment, checks to see that the string begins with at least 2\n// digits, ignoring any punctuation commonly found in phone numbers. This method\n// does not require the number to be normalized in advance - but does assume\n// that leading non-number symbols have been removed, such as by the method\n// `extract_possible_number`.\n//\nexport function is_viable_phone_number(number)\n{\n\treturn number.length >= MIN_LENGTH_FOR_NSN &&\n\t\tVALID_PHONE_NUMBER_PATTERN.test(number)\n}\n\n/**\n * Extracts a parseable phone number.\n * @param  {string} text - Input.\n * @return {string}.\n */\nexport function extract_formatted_phone_number(text, v2)\n{\n\tif (!text)\n\t{\n\t\treturn\n\t}\n\n\tif (text.length > MAX_INPUT_STRING_LENGTH)\n\t{\n\t\tif (v2) {\n\t\t\tthrow new Error('TOO_LONG')\n\t\t}\n\t\treturn\n\t}\n\n\t// Attempt to extract a possible number from the string passed in\n\n\tconst starts_at = text.search(PHONE_NUMBER_START_PATTERN)\n\n\tif (starts_at < 0)\n\t{\n\t\treturn\n\t}\n\n\treturn text\n\t\t// Trim everything to the left of the phone number\n\t\t.slice(starts_at)\n\t\t// Remove trailing non-numerical characters\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\n}\n\n// Strips any national prefix (such as 0, 1) present in the number provided.\n// \"Carrier codes\" are only used  in Colombia and Brazil,\n// and only when dialing within those countries from a mobile phone to a fixed line number.\nexport function strip_national_prefix_and_carrier_code(number, metadata)\n{\n\tif (!number || !metadata.nationalPrefixForParsing())\n\t{\n\t\treturn { number }\n\t}\n\n\t// Attempt to parse the first digits as a national prefix\n\tconst national_prefix_pattern = new RegExp('^(?:' + metadata.nationalPrefixForParsing() + ')')\n\tconst national_prefix_matcher = national_prefix_pattern.exec(number)\n\n\t// If no national prefix is present in the phone number,\n\t// but the national prefix is optional for this country,\n\t// then consider this phone number valid.\n\t//\n\t// Google's reference `libphonenumber` implementation\n\t// wouldn't recognize such phone numbers as valid,\n\t// but I think it would perfectly make sense\n\t// to consider such phone numbers as valid\n\t// because if a national phone number was originally\n\t// formatted without the national prefix\n\t// then it must be parseable back into the original national number.\n\t// In other words, `parse(format(number))`\n\t// must always be equal to `number`.\n\t//\n\tif (!national_prefix_matcher)\n\t{\n\t\treturn { number }\n\t}\n\n\tlet national_significant_number\n\n\t// `national_prefix_for_parsing` capturing groups\n\t// (used only for really messy cases: Argentina, Brazil, Mexico, Somalia)\n\tconst captured_groups_count = national_prefix_matcher.length - 1\n\n\t// If the national number tranformation is needed then do it.\n\t//\n\t// I don't know what did they mean by `&& national_prefix_matcher[captured_groups_count]`.\n\t// https://github.com/googlei18n/libphonenumber/blob/d978e59c2e6b1ddfb6816cd190e1b62d9a96bc3b/javascript/i18n/phonenumbers/phonenumberutil.js#L3885\n\t// https://github.com/googlei18n/libphonenumber/blob/d978e59c2e6b1ddfb6816cd190e1b62d9a96bc3b/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2906\n\t//\n\tif (metadata.nationalPrefixTransformRule() && national_prefix_matcher[captured_groups_count])\n\t{\n\t\tnational_significant_number = number.replace(national_prefix_pattern, metadata.nationalPrefixTransformRule())\n\t}\n\t// Else, no transformation is necessary,\n\t// and just strip the national prefix.\n\telse\n\t{\n\t\tnational_significant_number = number.slice(national_prefix_matcher[0].length)\n\t}\n\n\tlet carrierCode\n\tif (captured_groups_count > 0)\n\t{\n\t\tcarrierCode = national_prefix_matcher[1]\n\t}\n\n\t// The following is done in `get_country_and_national_number_for_local_number()` instead.\n\t//\n\t// // Verify the parsed national (significant) number for this country\n\t// const national_number_rule = new RegExp(metadata.nationalNumberPattern())\n\t// //\n\t// // If the original number (before stripping national prefix) was viable,\n\t// // and the resultant number is not, then prefer the original phone number.\n\t// // This is because for some countries (e.g. Russia) the same digit could be both\n\t// // a national prefix and a leading digit of a valid national phone number,\n\t// // like `8` is the national prefix for Russia and both\n\t// // `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\t// if (matches_entirely(number, national_number_rule) &&\n\t// \t\t!matches_entirely(national_significant_number, national_number_rule))\n\t// {\n\t// \treturn number\n\t// }\n\n\t// Return the parsed national (significant) number\n   return {\n   \tnumber: national_significant_number,\n   \tcarrierCode\n   }\n}\n\nexport function find_country_code(country_calling_code, national_phone_number, metadata)\n{\n\t// Is always non-empty, because `country_calling_code` is always valid\n\tconst possible_countries = metadata.countryCallingCodes()[country_calling_code]\n\n\t// If there's just one country corresponding to the country code,\n\t// then just return it, without further phone number digits validation.\n\tif (possible_countries.length === 1)\n\t{\n\t\treturn possible_countries[0]\n\t}\n\n\treturn _find_country_code(possible_countries, national_phone_number, metadata.metadata)\n}\n\n// Changes `metadata` `country`.\nfunction _find_country_code(possible_countries, national_phone_number, metadata)\n{\n\tmetadata = new Metadata(metadata)\n\n\tfor (const country of possible_countries)\n\t{\n\t\tmetadata.country(country)\n\n\t\t// Leading digits check would be the simplest one\n\t\tif (metadata.leadingDigits())\n\t\t{\n\t\t\tif (national_phone_number &&\n\t\t\t\tnational_phone_number.search(metadata.leadingDigits()) === 0)\n\t\t\t{\n\t\t\t\treturn country\n\t\t\t}\n\t\t}\n\t\t// Else perform full validation with all of those\n\t\t// fixed-line/mobile/etc regular expressions.\n\t\telse if (get_number_type({ phone: national_phone_number, country }, metadata.metadata))\n\t\t{\n\t\t\treturn country\n\t\t}\n\t}\n}\n\n// Sort out arguments\nfunction sort_out_arguments(arg_1, arg_2, arg_3, arg_4)\n{\n\tlet text\n\tlet options\n\tlet metadata\n\n\t// If the phone number is passed as a string.\n\t// `parse('88005553535', ...)`.\n\tif (typeof arg_1 === 'string')\n\t{\n\t\ttext = arg_1\n\t}\n\telse throw new TypeError('A phone number for parsing must be a string.')\n\n\t// If \"default country\" argument is being passed\n\t// then move it to `options`.\n\t// `parse('88005553535', 'RU', [options], metadata)`.\n\tif (typeof arg_2 !== 'object')\n\t{\n\t\tif (arg_4)\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2, ...arg_3 }\n\t\t\tmetadata = arg_4\n\t\t}\n\t\telse\n\t\t{\n\t\t\toptions = { defaultCountry: arg_2 }\n\t\t\tmetadata = arg_3\n\t\t}\n\t}\n\t// No \"default country\" argument is being passed.\n\t// International phone number is passed.\n\t// `parse('+78005553535', [options], metadata)`.\n\telse\n\t{\n\t\tif (arg_3)\n\t\t{\n\t\t\toptions  = arg_2\n\t\t\tmetadata = arg_3\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmetadata = arg_2\n\t\t}\n\t}\n\n\t// Apply default options.\n\tif (options)\n\t{\n\t\toptions = { ...default_options, ...options }\n\t}\n\telse\n\t{\n\t\toptions = default_options\n\t}\n\n\treturn { text, options, metadata: new Metadata(metadata) }\n}\n\n// Strips any extension (as in, the part of the number dialled after the call is\n// connected, usually indicated with extn, ext, x or similar) from the end of\n// the number, and returns it.\nfunction strip_extension(number)\n{\n\tconst start = number.search(EXTN_PATTERN)\n\tif (start < 0)\n\t{\n\t\treturn {}\n\t}\n\n\t// If we find a potential extension, and the number preceding this is a viable\n\t// number, we assume it is an extension.\n\tconst number_without_extension = number.slice(0, start)\n\t/* istanbul ignore if - seems a bit of a redundant check */\n\tif (!is_viable_phone_number(number_without_extension))\n\t{\n\t\treturn {}\n\t}\n\n\tconst matches = number.match(EXTN_PATTERN)\n\tlet i = 1\n\twhile (i < matches.length)\n\t{\n\t\tif (matches[i] != null && matches[i].length > 0)\n\t\t{\n\t\t\treturn {\n\t\t\t\tnumber : number_without_extension,\n\t\t\t\text    : matches[i]\n\t\t\t}\n\t\t}\n\t\ti++\n\t}\n}\n\n/**\n * @param  {string} text - Input.\n * @return {object} `{ ?number, ?ext }`.\n */\nfunction parse_input(text, v2)\n{\n\t// Parse RFC 3966 phone number URI.\n\tif (text && text.indexOf('tel:') === 0)\n\t{\n\t\treturn parseRFC3966(text)\n\t}\n\n\tlet number = extract_formatted_phone_number(text, v2)\n\n\t// If the phone number is not viable, then abort.\n\tif (!number || !is_viable_phone_number(number))\n\t{\n\t\treturn {}\n\t}\n\n\t// Attempt to parse extension first, since it doesn't require region-specific\n\t// data and we want to have the non-normalised number here.\n\tconst with_extension_stripped = strip_extension(number)\n\tif (with_extension_stripped.ext)\n\t{\n\t\treturn with_extension_stripped\n\t}\n\n\treturn { number }\n}\n\n/**\n * Creates `parse()` result object.\n */\nfunction result(country, national_number, ext)\n{\n\tconst result =\n\t{\n\t\tcountry,\n\t\tphone : national_number\n\t}\n\n\tif (ext)\n\t{\n\t\tresult.ext = ext\n\t}\n\n\treturn result\n}\n\n/**\n * Parses a viable phone number.\n * Returns `{ country, countryCallingCode, national_number }`.\n */\nfunction parse_phone_number(formatted_phone_number, default_country, metadata)\n{\n\tlet { countryCallingCode, number } = extractCountryCallingCode(formatted_phone_number, default_country, metadata.metadata)\n\n\tif (!number) {\n\t\treturn { countryCallingCode }\n\t}\n\n\tlet country\n\n\tif (countryCallingCode)\n\t{\n\t\tmetadata.chooseCountryByCountryCallingCode(countryCallingCode)\n\t}\n\telse if (default_country)\n\t{\n\t\tmetadata.country(default_country)\n\t\tcountry = default_country\n\t\tcountryCallingCode = getCountryCallingCode(default_country, metadata.metadata)\n\t}\n\telse return {}\n\n\tconst { national_number, carrier_code } = parse_national_number(number, metadata)\n\n\t// Sometimes there are several countries\n\t// corresponding to the same country phone code\n\t// (e.g. NANPA countries all having `1` country phone code).\n\t// Therefore, to reliably determine the exact country,\n\t// national (significant) number should have been parsed first.\n\t//\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\n\t// get their countries populated with the full set of\n\t// \"phone number type\" regular expressions.\n\t//\n\tconst exactCountry = find_country_code(countryCallingCode, national_number, metadata)\n\tif (exactCountry)\n\t{\n\t\tcountry = exactCountry\n\t\tmetadata.country(country)\n\t}\n\n\treturn {\n\t\tcountry,\n\t\tcountryCallingCode,\n\t\tnational_number,\n\t\tcarrierCode: carrier_code\n\t}\n}\n\nfunction parse_national_number(number, metadata)\n{\n\tlet national_number = parseIncompletePhoneNumber(number)\n\tlet carrier_code\n\n\t// Only strip national prefixes for non-international phone numbers\n\t// because national prefixes can't be present in international phone numbers.\n\t// Otherwise, while forgiving, it would parse a NANPA number `+1 1877 215 5230`\n\t// first to `1877 215 5230` and then, stripping the leading `1`, to `877 215 5230`,\n\t// and then it would assume that's a valid number which it isn't.\n\t// So no forgiveness for grandmas here.\n\t// The issue asking for this fix:\n\t// https://github.com/catamphetamine/libphonenumber-js/issues/159\n\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(national_number, metadata)\n\n\t// If metadata has \"possible lengths\" then employ the new algorythm.\n\tif (metadata.possibleLengths())\n\t{\n\t\t// We require that the NSN remaining after stripping the national prefix and\n\t\t// carrier code be long enough to be a possible length for the region.\n\t\t// Otherwise, we don't do the stripping, since the original number could be\n\t\t// a valid short number.\n\t\tswitch (check_number_length_for_type(potential_national_number, undefined, metadata))\n\t\t{\n\t\t\tcase 'TOO_SHORT':\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\n\t\t\tcase 'INVALID_LENGTH':\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tnational_number = potential_national_number\n\t\t\t\tcarrier_code = carrierCode\n\t\t}\n\t}\n\telse\n\t{\n\t\t// If the original number (before stripping national prefix) was viable,\n\t\t// and the resultant number is not, then prefer the original phone number.\n\t\t// This is because for some countries (e.g. Russia) the same digit could be both\n\t\t// a national prefix and a leading digit of a valid national phone number,\n\t\t// like `8` is the national prefix for Russia and both\n\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\n\t\tif (matches_entirely(national_number, metadata.nationalNumberPattern()) &&\n\t\t\t\t!matches_entirely(potential_national_number, metadata.nationalNumberPattern()))\n\t\t{\n\t\t\t// Keep the number without stripping national prefix.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnational_number = potential_national_number\n\t\t\tcarrier_code = carrierCode\n\t\t}\n\t}\n\n\treturn {\n\t\tnational_number,\n\t\tcarrier_code\n\t}\n}\n\n// Determines the country for a given (possibly incomplete) phone number.\n// export function get_country_from_phone_number(number, metadata)\n// {\n// \treturn parse_phone_number(number, null, metadata).country\n// }"]}