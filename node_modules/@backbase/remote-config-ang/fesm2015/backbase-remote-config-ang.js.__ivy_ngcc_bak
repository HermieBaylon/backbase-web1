import { Injectable, InjectionToken, Inject, NgModule } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { __awaiter } from 'tslib';

class RemoteConfigFetcherService {
    constructor(http) {
        this.http = http;
    }
    fetch(requestParameters) {
        return this.http
            .get(requestParameters.url, {
            headers: requestParameters.headers,
        })
            .toPromise();
    }
}
RemoteConfigFetcherService.decorators = [
    { type: Injectable }
];
RemoteConfigFetcherService.ctorParameters = () => [
    { type: HttpClient }
];

class ParseSuccess {
    constructor(result) {
        this.result = result;
    }
    static create(result) {
        return new ParseSuccess(result);
    }
}
class ParseFailure {
    constructor(reason) {
        this.reason = reason;
    }
    static create(reason) {
        return new ParseFailure(reason);
    }
}

var ValueType;
(function (ValueType) {
    ValueType["Array"] = "array";
    ValueType["Boolean"] = "boolean";
    ValueType["Object"] = "object";
    ValueType["Null"] = "null";
    ValueType["Number"] = "number";
    ValueType["String"] = "string";
})(ValueType || (ValueType = {}));
class ArrayValueTypeDescriptor {
    constructor() {
        this.type = ValueType.Array;
    }
}
class ObjectValueTypeDescriptor {
    constructor(properties) {
        this.properties = properties;
        this.type = ValueType.Object;
    }
}
class PrimitiveValueTypeDescriptor {
    constructor(type) {
        this.type = type;
    }
}

const isArray = (arg) => Array.isArray(arg);
const isBoolean = (arg) => typeof arg === 'boolean';
const isNull = (arg) => arg === null;
const isNullOrUndefined = (arg) => isNull(arg) || isUndefined(arg);
const isNumber = (arg) => typeof arg === 'number';
const isString = (arg) => typeof arg === 'string';
const isObject = (arg) => typeof arg === 'object' && arg !== null && Array.isArray(arg) === false;
const isUndefined = (arg) => typeof arg === 'undefined';

var ParseError;
(function (ParseError) {
    ParseError["TypeMismatch"] = "TypeMismatch";
    ParseError["UnknownPropertyType"] = "UnknownPropertyType";
})(ParseError || (ParseError = {}));
class ValueParser {
    parseAs(rawValue, valueType) {
        if (valueType instanceof ArrayValueTypeDescriptor) {
            return this.parseArray(rawValue);
        }
        if (valueType instanceof ObjectValueTypeDescriptor) {
            return this.parseObjectAs(rawValue, valueType);
        }
        return this.parsePrimitiveAs(rawValue, valueType);
    }
    parseArray(value) {
        return isArray(value) ? ParseSuccess.create(value) : ParseFailure.create(ParseError.TypeMismatch);
    }
    parseObjectAs(rawValue, valueType) {
        if (!isObject(rawValue)) {
            return ParseFailure.create(ParseError.TypeMismatch);
        }
        const objectRawValue = rawValue;
        const result = {};
        for (const propertyName of Object.keys(valueType.properties)) {
            const propertyValueType = valueType.properties[propertyName];
            const propertyValueParseResult = this.parseAs(objectRawValue[propertyName], propertyValueType);
            if (propertyValueParseResult instanceof ParseFailure) {
                return ParseFailure.create(propertyValueParseResult.reason);
            }
            result[propertyName] = propertyValueParseResult.result;
        }
        return ParseSuccess.create(result);
    }
    parsePrimitiveAs(value, valueType) {
        if (valueType.type === ValueType.Boolean) {
            return isBoolean(value) ? ParseSuccess.create(value) : ParseFailure.create(ParseError.TypeMismatch);
        }
        if (valueType.type === ValueType.Number) {
            return isNumber(value) ? ParseSuccess.create(value) : ParseFailure.create(ParseError.TypeMismatch);
        }
        if (valueType.type === ValueType.Null) {
            return isNull(value) ? ParseSuccess.create(value) : ParseFailure.create(ParseError.TypeMismatch);
        }
        return isString(value) ? ParseSuccess.create(value) : ParseFailure.create(ParseError.TypeMismatch);
    }
}

class TypeExtractor {
    static throwInvalidSourceError(source) {
        throw new TypeError('[remote-config] Could not extract the types: Expected to receive an object, ' + `but got ${typeof source}`);
    }
    static extractObjectType(value) {
        const properties = {};
        for (const propertyName of Object.keys(value)) {
            const propertyValue = value[propertyName];
            const propertyValueType = TypeExtractor.extractType(propertyValue);
            if (propertyValueType) {
                properties[propertyName] = propertyValueType;
            }
        }
        return new ObjectValueTypeDescriptor(properties);
    }
    static extractType(value) {
        if (isUndefined(value)) {
            return null;
        }
        if (isArray(value)) {
            return new ArrayValueTypeDescriptor();
        }
        if (isBoolean(value)) {
            return new PrimitiveValueTypeDescriptor(ValueType.Boolean);
        }
        if (isNull(value)) {
            return new PrimitiveValueTypeDescriptor(ValueType.Null);
        }
        if (isNumber(value)) {
            return new PrimitiveValueTypeDescriptor(ValueType.Number);
        }
        if (isString(value)) {
            return new PrimitiveValueTypeDescriptor(ValueType.String);
        }
        return TypeExtractor.extractObjectType(value);
    }
    extractTypes(source) {
        if (!isObject(source)) {
            TypeExtractor.throwInvalidSourceError(source);
        }
        return TypeExtractor.extractObjectType(source);
    }
}

const hasOwnProperty = Object.prototype.hasOwnProperty;
const hasProperty = (obj, propertyName) => hasOwnProperty.call(obj, propertyName);

const trim = (str) => String(str || '').trim();

const valueParser = new ValueParser();
const typeExtractor = new TypeExtractor();
class RemoteConfig {
    constructor(configFetcher, context, defaults) {
        this.configFetcher = configFetcher;
        this.tags = new Set();
        const normalizedContext = RemoteConfig.normalizeContext(context);
        RemoteConfig.validateContext(normalizedContext);
        this.context = normalizedContext;
        this.defaultConfig = Object.assign({}, defaults);
        this.extractedType = typeExtractor.extractTypes(defaults);
    }
    static normalizeTag(tag) {
        return trim(tag);
    }
    static normalizeContext(context) {
        const appName = trim(context.appName);
        const appVersion = trim(context.appVersion);
        const projectName = trim(context.projectName);
        const serviceRoot = trim(context.serviceRoot).replace(/\/$/, '');
        return {
            appName,
            appVersion,
            projectName,
            serviceRoot,
        };
    }
    static validateContext(context) {
        if (context.appName.length === 0) {
            throw new TypeError(`[remote-config] Could not instantiate Remove Config client: ` + `The provided appName is empty.`);
        }
        if (context.appVersion.length === 0) {
            throw new TypeError(`[remote-config] Could not instantiate Remove Config client: ` + `The provided appVersion is empty.`);
        }
    }
    activate() {
        this.activatedConfig = Object.assign({}, this.fetchedConfig);
    }
    addCustomTag(tag) {
        const normalizedTag = RemoteConfig.normalizeTag(tag);
        if (normalizedTag.length === 0) {
            console.warn(`[remote-config] Could not add the tag: ` + `A tag must be a non-empty string.`);
            return;
        }
        this.tags.add(normalizedTag);
    }
    removeCustomTag(tag) {
        const normalizedTag = RemoteConfig.normalizeTag(tag);
        if (normalizedTag.length === 0) {
            console.warn(`[remote-config] Could not delete the tag: ` + `A tag must be a non-empty string.`);
            return false;
        }
        return this.tags.delete(normalizedTag);
    }
    clearCustomTags() {
        this.tags.clear();
    }
    fetch() {
        return __awaiter(this, void 0, void 0, function* () {
            const projectName = this.context.projectName;
            const serviceRoot = this.context.serviceRoot;
            const url = `${serviceRoot}/client-api/v1/projects/${projectName}/parameters`;
            const headers = {
                'Application-Name': this.context.appName,
                'Application-Version': this.context.appVersion,
                'Custom-Tags': Array.from(this.tags).join(','),
            };
            try {
                this.fetchedConfig = yield this.configFetcher.fetch({
                    headers,
                    url,
                });
            }
            catch (error) {
                console.warn(`[remote-config] Could not fetch the remote config:`, error);
            }
        });
    }
    fetchAndActivate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.fetch();
            this.activate();
        });
    }
    getValue(parameterName) {
        const remoteValue = this.getRemoteValue(parameterName);
        if (remoteValue instanceof ParseSuccess) {
            return remoteValue.result;
        }
        if (remoteValue instanceof ParseFailure) {
            console.warn(`[remote-config] Failed to parse the remote value ` +
                `of the parameter "${parameterName}". ` +
                `Reason: ${remoteValue.reason}`);
        }
        return this.getDefaultValue(parameterName);
    }
    getDefaultValue(parameterName) {
        if (hasProperty(this.defaultConfig, parameterName)) {
            const defaultValue = this.defaultConfig[parameterName];
            return isNullOrUndefined(defaultValue) ? null : defaultValue;
        }
        console.warn(`[remote-config] Could not get a default value. ` +
            `The parameter '${parameterName}' is not present in the default config.`);
        return null;
    }
    getRawRemoteValue(parameterName) {
        if (this.activatedConfig && hasProperty(this.activatedConfig, parameterName)) {
            return this.activatedConfig[parameterName];
        }
        return undefined;
    }
    getRemoteValue(parameterName) {
        const rawRemoteValue = this.getRawRemoteValue(parameterName);
        return !isUndefined(rawRemoteValue) ? this.parseRemoteValue(rawRemoteValue, parameterName) : null;
    }
    parseRemoteValue(rawRemoteValue, parameterName) {
        const valueType = this.extractedType.properties[parameterName];
        if (!valueType) {
            return ParseFailure.create(ParseError.UnknownPropertyType);
        }
        return valueParser.parseAs(rawRemoteValue, valueType);
    }
}

const RemoteConfigConfigurationToken = new InjectionToken('@backbase/remote-config-ang: RemoteConfigConfigurationToken');
class RemoteConfigService {
    constructor(configuration, configFetcher) {
        this.configuration = configuration;
        this.configFetcher = configFetcher;
        this.remoteConfigClient = new RemoteConfig(this.configFetcher, {
            appName: configuration.appName,
            appVersion: configuration.appVersion,
            projectName: configuration.projectName,
            serviceRoot: configuration.serviceRoot,
        }, configuration.defaults);
        this.disabled = Boolean(configuration.disabled);
    }
    addCustomTag(tag) {
        this.remoteConfigClient.addCustomTag(tag);
    }
    clearCustomTags() {
        this.remoteConfigClient.clearCustomTags();
    }
    getValue(parameterName) {
        return this.remoteConfigClient.getValue(parameterName);
    }
    fetchAndActivate() {
        if (this.disabled) {
            return Promise.resolve();
        }
        return this.remoteConfigClient.fetchAndActivate();
    }
    removeCustomTag(tag) {
        return this.remoteConfigClient.removeCustomTag(tag);
    }
}
RemoteConfigService.decorators = [
    { type: Injectable }
];
RemoteConfigService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [RemoteConfigConfigurationToken,] }] },
    { type: RemoteConfigFetcherService }
];

class RemoteConfigModule {
    static forRoot(configuration) {
        return {
            ngModule: RemoteConfigModule,
            providers: [
                {
                    provide: RemoteConfigConfigurationToken,
                    useValue: configuration,
                },
            ],
        };
    }
}
RemoteConfigModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [],
                providers: [RemoteConfigFetcherService, RemoteConfigService],
                exports: [],
            },] }
];

class ConfigFetcher {
}

/**
 * Generated bundle index. Do not edit.
 */

export { ConfigFetcher, RemoteConfig, RemoteConfigConfigurationToken, RemoteConfigModule, RemoteConfigService, RemoteConfigFetcherService as ɵb, trim as ɵc };
//# sourceMappingURL=backbase-remote-config-ang.js.map
