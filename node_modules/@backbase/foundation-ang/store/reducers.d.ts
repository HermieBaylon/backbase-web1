import { ActionReducer } from '@ngrx/store';
import { Action, ActionCreator, ChannelAction } from './actions';
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare const InitializeStateActionType = "[Backbase Reducer] INITIALIZE REDUCER";
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare class InitializeState implements Action {
    readonly type = "[Backbase Reducer] INITIALIZE REDUCER";
}
/**
 * @deprecated Will be removed in v7.0.0
 * Generate a new state (`T`) based on a previous state in response to an action (`V`)
 */
export declare type Reducer<T, V> = (state: T | undefined, action: V) => T;
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare type MetaReducer<T, V extends Action = Action> = (reducer: Reducer<T, V>) => Reducer<T, V>;
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare const metaChannelReducer: <T, V extends Action = Action>(channels: Array<string>) => (reducer: Reducer<T, V>) => Reducer<T, ChannelAction<V>>;
export { createReducer, on } from '@ngrx/store';
export { ActionReducer };
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare type OnReducer<S, C extends Array<ActionCreator>> = (state: S, action: ActionType<C[number]>) => S;
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface On<S> {
    reducer: ActionReducer<S>;
    types: Array<string>;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare type ActionType<A> = A extends ActionCreator<infer T, infer C> ? ReturnType<C> & {
    type: T;
} : never;
