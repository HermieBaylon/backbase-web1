{"version":3,"file":"store-broker.service.d.ts","sources":["store-broker.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Injector } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { Reducer, MetaReducer } from './reducers';\nimport { Action, Channel } from './actions';\nimport { NgrxEffectsInstance, EffectsInjectionToken } from './effects';\nimport { Selector } from './selectors';\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport declare const InitializeStoreActionType = \"[Backbase Reducer] INITIALIZE REDUCER\";\n/**\n * @deprecated Will be removed in v7.0.0\n * An `Action` that is dispatched to a `Store` when it is created to allow the store to initialize\n * its initial state\n */\nexport declare class InitializeStoreAction implements Action {\n    readonly type = \"[Backbase Reducer] INITIALIZE REDUCER\";\n}\n/**\n * @deprecated Will be removed in v7.0.0\n * Stream operator to filter the `Actions` stream to only pass the `InitializeStoreAction`.\n * This can be used to write `Reducer`s or `Effect`s that are only run when their `Store` is\n * initially created.\n */\nexport declare const ofStoreInit: () => (source: Observable<Action>) => Observable<InitializeStoreAction>;\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport declare type BranchName = string;\n/**\n * @deprecated Will be removed in v7.0.0\n * The name of the store used to segregate the Store states within the application state branch.\n */\nexport declare type StoreName = string;\n/**\n * @deprecated Will be removed in v7.0.0\n * A Store that maintains internal state which can be queried and acted upon.\n */\nexport interface Store<State, V extends Action> {\n    /**\n     * Dispatch an action to the store.\n     * This may result in changes in state and/or external effects.\n     */\n    dispatch: (action: V) => void;\n    /**\n     * Select a projection of the internal state.\n     */\n    select: <R>(selector: Selector<State, R>) => Observable<R>;\n}\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface ReducerManager {\n    addFeature<T, V extends Action>(featureDef: {\n        key: string;\n        reducers: Reducer<T, V>;\n        reducerFactory: () => never;\n        metaReducers: Array<MetaReducer<T, V>>;\n    }): void;\n}\nexport interface EffectSources<V extends Action> {\n    addEffects(effects: NgrxEffectsInstance<V>): void;\n}\n/**\n * @internal\n */\nexport declare class StoreBroker {\n    private readonly superstore;\n    private readonly actions;\n    private readonly reducerManager;\n    private readonly effectsSources;\n    private readonly injector;\n    private readonly initializedStores;\n    constructor(superstore: Store<any, Action>, actions: Observable<Action>, reducerManager: ReducerManager, effectsSources: EffectSources<any>, injector: Injector);\n    initStore<T, V extends Action>(storeName: StoreName, reducer: Reducer<T, V>, effects: Array<EffectsInjectionToken<V>>, branchName: BranchName, dispatchChannel: Channel, inputChannels?: Array<Channel>, widgetInjector?: Injector): Store<T, V>;\n    private createStore;\n    /**\n     * Dispatches an action scoped on a channel just for this store.\n     */\n    private dispatchForStore;\n    private dispatchOnChannel;\n    private isStoreInitialized;\n    private setStoreInitialized;\n    private addReducer;\n    private addEffects;\n    private privateBranch;\n    private privateChannel;\n}\n"]}