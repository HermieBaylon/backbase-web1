import { Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { Reducer, MetaReducer } from './reducers';
import { Action, Channel } from './actions';
import { NgrxEffectsInstance, EffectsInjectionToken } from './effects';
import { Selector } from './selectors';
/**
 * @deprecated Will be removed in v7.0.0
 */
import * as ɵngcc0 from '@angular/core';
export declare const InitializeStoreActionType = "[Backbase Reducer] INITIALIZE REDUCER";
/**
 * @deprecated Will be removed in v7.0.0
 * An `Action` that is dispatched to a `Store` when it is created to allow the store to initialize
 * its initial state
 */
export declare class InitializeStoreAction implements Action {
    readonly type = "[Backbase Reducer] INITIALIZE REDUCER";
}
/**
 * @deprecated Will be removed in v7.0.0
 * Stream operator to filter the `Actions` stream to only pass the `InitializeStoreAction`.
 * This can be used to write `Reducer`s or `Effect`s that are only run when their `Store` is
 * initially created.
 */
export declare const ofStoreInit: () => (source: Observable<Action>) => Observable<InitializeStoreAction>;
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare type BranchName = string;
/**
 * @deprecated Will be removed in v7.0.0
 * The name of the store used to segregate the Store states within the application state branch.
 */
export declare type StoreName = string;
/**
 * @deprecated Will be removed in v7.0.0
 * A Store that maintains internal state which can be queried and acted upon.
 */
export interface Store<State, V extends Action> {
    /**
     * Dispatch an action to the store.
     * This may result in changes in state and/or external effects.
     */
    dispatch: (action: V) => void;
    /**
     * Select a projection of the internal state.
     */
    select: <R>(selector: Selector<State, R>) => Observable<R>;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface ReducerManager {
    addFeature<T, V extends Action>(featureDef: {
        key: string;
        reducers: Reducer<T, V>;
        reducerFactory: () => never;
        metaReducers: Array<MetaReducer<T, V>>;
    }): void;
}
export interface EffectSources<V extends Action> {
    addEffects(effects: NgrxEffectsInstance<V>): void;
}
/**
 * @internal
 */
export declare class StoreBroker {
    private readonly superstore;
    private readonly actions;
    private readonly reducerManager;
    private readonly effectsSources;
    private readonly injector;
    private readonly initializedStores;
    constructor(superstore: Store<any, Action>, actions: Observable<Action>, reducerManager: ReducerManager, effectsSources: EffectSources<any>, injector: Injector);
    initStore<T, V extends Action>(storeName: StoreName, reducer: Reducer<T, V>, effects: Array<EffectsInjectionToken<V>>, branchName: BranchName, dispatchChannel: Channel, inputChannels?: Array<Channel>, widgetInjector?: Injector): Store<T, V>;
    private createStore;
    /**
     * Dispatches an action scoped on a channel just for this store.
     */
    private dispatchForStore;
    private dispatchOnChannel;
    private isStoreInitialized;
    private setStoreInitialized;
    private addReducer;
    private addEffects;
    private privateBranch;
    private privateChannel;
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<StoreBroker, never>;
}

//# sourceMappingURL=store-broker.service.d.ts.map