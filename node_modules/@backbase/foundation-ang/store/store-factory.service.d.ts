import { Action, Channel } from './actions';
import { InjectionToken, Injector } from '@angular/core';
import { Store, StoreBroker, BranchName, StoreName } from './store-broker.service';
import { Reducer } from './reducers';
import { EffectsInjectionToken } from './effects';
import { AvailableFeature, FeaturesService } from '@backbase/foundation-ang/future';
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare const ENFORCE_INJECTOR_FOR_CREATE_STORE: AvailableFeature;
/**
 * @deprecated Will be removed in v7.0.0
 * Configuration token that defines the "branch" of the application state that the store is responsible for.
 *
 * @internal
 */
export declare const STORE_BRANCH: InjectionToken<string>;
/**
 * @deprecated Will be removed in v7.0.0
 * Configuration token that defines the "channel" on which the store will dispatch any events it produces.
 *
 * @internal
 */
export declare const STORE_DISPATCH_CHANNEL: InjectionToken<string>;
export { Store };
/**
 * @deprecated Will be removed in v7.0.0
 * Create a scoped store on a particular branch/channel
 */
export declare class StoreFactory {
    private readonly storeBroker;
    private readonly branch;
    private readonly dispatchChannel;
    private featuresService;
    constructor(storeBroker: StoreBroker, branch: BranchName, dispatchChannel: Channel, featuresService: FeaturesService);
    /**
     * @deprecated you have to provide widget injector for createStore to make sure your widget support lazy loading.
     * Create a `Store` that maintains state (`T`) and responds to `Action`s (`V`).
     * @param storeName The name of the store - this should be unique within the `branch`.
     * @param reducer The reducers that update the `Store`s state based on `Action`s dispatched to the `Store`.
     * @param effects The `Effect`s that trigger external effects and/or produce new `Action`s based on the `Action`s dispatched to the `Store`.
     **/
    createStore<T, V extends Action = Action>(storeName: StoreName, reducer: Reducer<T, V>, effects: Array<EffectsInjectionToken<V>>): Store<T, V>;
    /**
     * Create a `Store` that maintains state (`T`) and responds to `Action`s (`V`).
     * @param storeName The name of the store - this should be unique within the `branch`.
     * @param reducer The reducers that update the `Store`s state based on `Action`s dispatched to the `Store`.
     * @param effects The `Effect`s that trigger external effects and/or produce new `Action`s based on the `Action`s dispatched to the `Store`.
     * @param injector widget injector is required to support lazy loading.
     **/
    createStore<T, V extends Action = Action>(storeName: StoreName, reducer: Reducer<T, V>, effects: Array<EffectsInjectionToken<V>>, injector: Injector): Store<T, V>;
}
