{"version":3,"file":"backbase-foundation-ang-auth.js","sources":["../../../../projects/backbase/foundation-ang/auth/src/deprecated/auth.service.ts","../../../../projects/backbase/foundation-ang/auth/src/deprecated/auth.guard.ts","../../../../projects/backbase/foundation-ang/auth/src/deprecated/auth.interceptor.ts","../../../../projects/backbase/foundation-ang/auth/src/auto-refresh.ts","../../../../projects/backbase/foundation-ang/auth/src/auth-utils.ts","../../../../projects/backbase/foundation-ang/auth/src/invalid-token.interceptor.ts","../../../../projects/backbase/foundation-ang/auth/src/backbase-foundation-ang-auth.ts"],"names":[],"mappings":"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","sourcesContent":["import { forwardRef, Inject, Injectable, Optional } from '@angular/core';\nimport {\n  LOGOUT,\n  LogoutService,\n  REAUTHENTICATE,\n  ReauthenticateService,\n  SESSION,\n  SessionService,\n  ɵAUTH_EVENTS,\n  ɵAuthEvents,\n} from '@backbase/foundation-ang/web-sdk';\nimport { BehaviorSubject, Observable, merge } from 'rxjs';\nimport { distinctUntilChanged, filter, map, mapTo, pluck, switchMap } from 'rxjs/operators';\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface AccessToken {\n  raw: string;\n  parsed: any;\n}\n\n/**\n * @internal\n */\nexport interface AuthSuccessPayload {\n  currentAccessToken: AccessToken;\n}\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface LoginOptions {\n  /**\n   * Url for redirecting to after login is done with the authorisation result.\n   */\n  redirectUri?: string;\n}\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface LogoutOptions {\n  /**\n   * Url for redirecting to after logout is done.\n   */\n  redirectUri?: string;\n}\n\nexport interface ReauthenticateOptions {\n  /*\n   * The scope to use for the reauthentication request.\n   *\n   * For example, the scope can be returned by the server when challenging a request for a resource, such\n   * as requiring multifactor authentication.\n   */\n  scope: string;\n  /**\n   * The acr (Authentication Context Class Reference) claim and associated acr_values request parameter\n   * are defined by the OpenID Connect Core 1.0 specification.\n   *\n   * The value provided here is used as the `acr_values` in the reauthentication request.\n   *\n   * For example, the acrValues may be returned by the server when challenging a request for a resource, such\n   * as requiring multifactor authentication.\n   */\n  acrValues: string;\n  /**\n   * Whether to redirect the user or perform a request.\n   */\n  redirect?: boolean;\n  /**\n   * Url to return to following reauthentication redirect.\n   */\n  redirectUri?: string;\n}\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface CountdownOptions {\n  /**\n   * Configures when the countdown will start.\n   *\n   * The countdown will `start` once the TTL equals (or is less than) the `duration`.\n   */\n  duration?: number;\n  /**\n   * Called once the countdown begins (when `TTL < duration`).\n   */\n  start: () => void;\n  /**\n   * Called once the session is reset (and `TTL > duration`)\n   */\n  reset: () => void;\n  /**\n   * Called once the session expires (TTL = 0)\n   */\n  end: () => void;\n  /**\n   * Called every second between `start` and `end`.\n   *\n   * The `remaining` param is the number of seconds remaining until TTL = 0.\n   */\n  tick?: (remaining: number) => void;\n}\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\n@Injectable({\n  providedIn: 'root',\n  // eslint-disable-next-line  no-use-before-define, @typescript-eslint/no-use-before-define\n  useClass: forwardRef(() => AuthServiceImpl), // Default implementation (allows mocking / replacing)\n})\nexport abstract class AuthService {\n  abstract readonly accessToken: Observable<AccessToken | undefined>;\n  abstract readonly isAuthenticated: Observable<boolean>;\n  abstract login(loginOptions?: LoginOptions): void;\n  abstract logout(logoutOptions?: LogoutOptions): Promise<void>;\n  abstract reauthenticate(reauthenticateOptions: ReauthenticateOptions): Promise<void>;\n  abstract registerSessionCountdown(countdown: CountdownOptions): void;\n  abstract timeToLive(): number;\n  abstract refresh(): Promise<void>;\n  abstract isImpersonated(): boolean;\n}\n\nexport class AuthServiceImpl implements AuthService {\n  private readonly logoutService: LogoutService;\n  private readonly reauthenticateService: ReauthenticateService;\n  private readonly sessionService: SessionService;\n  private readonly authEvents: ɵAuthEvents;\n\n  private readonly accessTokenSubject = new BehaviorSubject<AccessToken | undefined>(undefined);\n  private readonly isLoadingSubject = new BehaviorSubject<boolean>(true);\n\n  /**\n   * The current access token for the session, or `undefined` if there is no session.\n   *\n   * The first token will be emitted after the session is initialised. So if the user is logged\n   * in already then the first emission will be an access token.\n   *\n   * This is a hot observable, so subscribing to it won't trigger anything.\n   *\n   * The latest value will be replayed to late subscribers.\n   */\n  public readonly accessToken: Observable<AccessToken | undefined> = this.isLoadingSubject.pipe(\n    filter(loading => !loading),\n    distinctUntilChanged(),\n    switchMap(() => this.accessTokenSubject),\n  );\n\n  /**\n   * Track whether the current user is authenticated.\n   *\n   * This is a hot observable, so subscribing to it won't trigger anything.\n   *\n   * The latest value will be replayed to late subscribers.\n   */\n  public readonly isAuthenticated: Observable<boolean> = this.accessToken.pipe(map(token => !!token));\n\n  constructor(\n    @Optional() @Inject(LOGOUT) logoutService?: LogoutService,\n    @Optional() @Inject(REAUTHENTICATE) reauthenticateService?: ReauthenticateService,\n    @Optional() @Inject(SESSION) sessionService?: SessionService,\n    @Optional() @Inject(ɵAUTH_EVENTS) authEvents?: ɵAuthEvents,\n  ) {\n    if (!logoutService || !reauthenticateService || !sessionService || !authEvents) {\n      throw new Error(\n        'In order to use the @backbase/foundation-ang/auth, please include *either* the ' +\n          'WebSdkModule.forRoot(...) in your AppModule (for CDN deployment) or WebSdkApiModule ' +\n          '(for CX deployment)',\n      );\n    }\n\n    this.logoutService = logoutService;\n    this.reauthenticateService = reauthenticateService;\n    this.sessionService = sessionService;\n    this.authEvents = authEvents;\n\n    this.handleAuthEvents();\n  }\n\n  /**\n   * Redirect the user to the login page.\n   *\n   * @param loginOptions\n   */\n  login(loginOptions?: LoginOptions) {\n    this.logoutService.goToLoginPage(loginOptions?.redirectUri);\n  }\n\n  /**\n   * Log out the current user.\n   *\n   * @param logoutOptions\n   */\n  logout(logoutOptions?: LogoutOptions): Promise<void> {\n    return this.logoutService.logout(logoutOptions?.redirectUri);\n  }\n\n  /**\n   * Register a set of callbacks that will be called as the user's session gets close to expiring.\n   *\n   * @param countdown\n   */\n  registerSessionCountdown(countdown: CountdownOptions) {\n    this.sessionService.registerCountdown(countdown);\n  }\n\n  /**\n   * Return the time to live (TTL) in seconds of the user's session.\n   *\n   * Returns -1 if the TTL can't be determined.\n   */\n  timeToLive(): number {\n    return this.sessionService.timeToLive();\n  }\n\n  /**\n   * Returns whether the user is being impersonated.\n   * @returns true if the user is being impersonated.\n   */\n  isImpersonated(): boolean {\n    return this.sessionService.isImpersonated;\n  }\n\n  /**\n   * Reauthenticate the current user.\n   *\n   * This can be used when the backend responds with a 401 and the current user needs to\n   * reauthenticate.\n   *\n   * @usageNotes\n   *\n   * You can use this service to create an interceptor which will automatically redirect the\n   * user when the backend responds with a 401. Useful when the backend responds with a challenge\n   * (eg: for step-up multifactor authentication):\n   *\n   * ```\n   * import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpResponse } from '@angular/common/http';\n   * import { from, Observable } from 'rxjs';\n   * import { catchError, first, mapTo } from 'rxjs/operators';\n   * import { AuthService } from '@backbase/foundation-ang/auth';\n   *\n   * export class ReauthenticateInterceptor implements HttpInterceptor {\n   *   constructor(private readonly authService: AuthService) {}\n   *   intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n   *     return next.handle(request).pipe(\n   *       // When any HTTP request fails (you could check status & headers here to only catch some failures).\n   *       catchError(error => {\n   *         // Retreive the challenge from the server's response.\n   *         const challenge: { scope: string; acrValues: string } = (error.error.challenges || []).find(\n   *           c => c.scope !== undefined,\n   *         );\n   *         // Reauthenticate the user with the requested scope & acr values and redirect back to here.\n   *         return from(\n   *           this.authService.reauthenticate({\n   *             scope: challenge.scope,\n   *             acrValues: challenge.acrValues,\n   *             redirect: true,\n   *             redirectUri: location.href,\n   *           }),\n   *           // Retry the orignal request\n   *         ).pipe(first(), mapTo(new HttpResponse({ body: error.error.data })));\n   *       }),\n   *     );\n   *   }\n   * }\n   * ```\n   *\n   * @param reauthenticateOptions\n   */\n  reauthenticate(reauthenticateOptions: ReauthenticateOptions): Promise<void> {\n    return this.reauthenticateService.reauthenticate(\n      reauthenticateOptions.scope,\n      reauthenticateOptions.acrValues,\n      reauthenticateOptions,\n    );\n  }\n\n  /**\n   * Refreshes the session.\n   */\n  refresh(): Promise<void> {\n    return this.sessionService.refresh();\n  }\n\n  private handleAuthEvents() {\n    merge(\n      this.authEvents.success.pipe(pluck('currentAccessToken')),\n      this.authEvents.init.pipe(pluck('currentAccessToken')),\n      this.authEvents.end.pipe(mapTo(undefined)),\n      this.authEvents.error.pipe(mapTo(undefined)),\n    )\n      .pipe(distinctUntilChanged((t1, t2) => t1?.raw === t2?.raw))\n      .subscribe(token => {\n        this.accessTokenSubject.next(token);\n        this.isLoadingSubject.next(false);\n      });\n  }\n}\n","import { Inject, Injectable } from '@angular/core';\nimport { DOCUMENT, Location } from '@angular/common';\nimport { CanActivate, CanActivateChild, CanLoad } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { take, tap } from 'rxjs/operators';\nimport { AuthService } from './auth.service';\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\n@Injectable({\n  providedIn: 'root',\n})\nexport class AuthGuard implements CanActivate, CanLoad, CanActivateChild {\n  constructor(private auth: AuthService, private location: Location, @Inject(DOCUMENT) private document: any) {}\n\n  canLoad(): Observable<boolean> {\n    return this.auth.isAuthenticated.pipe(take(1));\n  }\n\n  canActivate(): Observable<boolean> {\n    return this.redirectIfUnauthenticated();\n  }\n\n  canActivateChild(): Observable<boolean> {\n    return this.redirectIfUnauthenticated();\n  }\n\n  private redirectIfUnauthenticated(): Observable<boolean> {\n    return this.auth.isAuthenticated.pipe(\n      tap(loggedIn => {\n        if (!loggedIn) {\n          // Use an actual location path with hash instead of `RouterStateSnapshot.url`\n          // because `Keycloak` uses `history.replaceState` on initialization to remove\n          // auth data from the path.\n          const actualPath = this.location.path(true);\n\n          this.auth.login({\n            redirectUri: this.document.location.origin + this.location.prepareExternalUrl(actualPath),\n          });\n        }\n      }),\n    );\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { HttpEvent, HttpInterceptor, HttpHandler, HttpRequest } from '@angular/common/http';\n\nimport { Observable } from 'rxjs';\nimport { AuthService } from './auth.service';\nimport { switchMap, take } from 'rxjs/operators';\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(private authService: AuthService) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return this.authService.accessToken.pipe(\n      take(1),\n      switchMap(token => {\n        if (!token) {\n          return next.handle(req);\n        }\n        const newReq = req.clone({\n          headers: req.headers.append('Authorization', `Bearer ${token.raw}`),\n        });\n        return next.handle(newReq);\n      }),\n    );\n  }\n}\n","import { Observable, from } from 'rxjs';\nimport { HttpClient, HttpEvent, HttpRequest } from '@angular/common/http';\nimport { AuthService } from './deprecated/auth.service';\nimport { tap, switchMap } from 'rxjs/operators';\n\nexport interface AutoRefreshService {\n  failed: boolean;\n  refreshAndRepeat: (req: HttpRequest<unknown>) => Observable<HttpEvent<any>>;\n}\n\nexport function createAutoRefresh(authService: AuthService, httpClient: HttpClient) {\n  let refresh$: Observable<void> | undefined;\n  let refreshFailed = false;\n\n  function refreshAndRepeat(req: HttpRequest<unknown>): Observable<HttpEvent<any>> {\n    if (!refresh$) {\n      refresh$ = from(authService.refresh()).pipe(\n        tap(\n          // after successful refresh remove reference as access token can expire again in the future\n          () => (refresh$ = undefined),\n          // flag refresh failure so we will not try auto refresh again\n          () => (refreshFailed = true),\n        ),\n      );\n    }\n    return refresh$.pipe(\n      switchMap(() => {\n        // repeat request (presume that access token is updated after refresh)\n        return httpClient.request(req.clone());\n      }),\n    );\n  }\n\n  return {\n    failed: refreshFailed,\n    refreshAndRepeat,\n  };\n}\n","import { HttpErrorResponse, HttpHeaders } from '@angular/common/http';\n\nexport interface Scheme {\n  [key: string]: string;\n}\nexport const UNKNOWN_SCHEME = 'unknown';\n\n/**\n * See https://datatracker.ietf.org/doc/html/rfc6750#section-3\n * See https://www.rfc-editor.org/rfc/rfc7235.html#section-4.1\n * See https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html\n * See https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.1\n */\nexport function getWwwAuthenticate(headers: HttpHeaders): { [schemeName: string]: Scheme } {\n  let currentScheme = UNKNOWN_SCHEME;\n  const schemes = { [currentScheme]: {} };\n  const headerName = headers.keys().find(key => key.toLowerCase() === 'www-authenticate');\n  if (!headerName) {\n    return schemes;\n  }\n  const value = (headers.get(headerName) as string).toLowerCase().trim();\n  if (!value) {\n    return schemes;\n  }\n  const matches = value.match(/(?:[^\\s,\"]+|\"[^\"]*\")+/g);\n  if (!matches) {\n    schemes[currentScheme] = value;\n    return schemes;\n  }\n  return matches.reduce((acc: { [schemeName: string]: Scheme }, match: string) => {\n    const nameVal = match.split('=').map(v => v.trim());\n    if (nameVal.length === 1) {\n      currentScheme = nameVal[0];\n      acc[currentScheme] = {};\n    } else if (nameVal.length === 2) {\n      acc[currentScheme][nameVal[0]] = nameVal[1].replace(/\"/g, '');\n    }\n    return acc;\n  }, schemes);\n}\n\n/**\n * The 401 (Unauthorized) status code indicates that the request has not\n * been applied because it lacks valid authentication credentials for\n * the target resource.  The server generating a 401 response MUST send\n * a WWW-Authenticate header field (Section 4.1) containing at least one\n * challenge applicable to the target resource.\n */\nexport function is401AndNotReauth(error: HttpErrorResponse) {\n  if (error.status !== 401) {\n    return false;\n  }\n  const bearer = getWwwAuthenticate(error.headers).bearer;\n  if (!bearer) {\n    return false;\n  }\n  if (bearer.challenge_types && bearer.challenge_types !== 'reauth') {\n    return false;\n  }\n  return bearer.error === 'invalid_token';\n}\n","import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';\nimport {\n  HttpEvent,\n  HttpInterceptor,\n  HttpHandler,\n  HttpRequest,\n  HttpClient,\n  HttpErrorResponse,\n} from '@angular/common/http';\n\nimport { Observable, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { AuthService } from './deprecated/auth.service';\n\nimport { createAutoRefresh } from './auto-refresh';\nimport { is401AndNotReauth } from './auth-utils';\nimport { DOCUMENT } from '@angular/common';\n\n// invalid token interceptor configuration\nexport interface InvalidTokenConfig {\n  // if true, responses with 401 status will be repeated after session refresh\n  enableAutoRefresh?: boolean;\n  // redirect\n  redirectToLoginPage?: boolean;\n}\n\nexport const INVALID_TOKEN_CONFIG = new InjectionToken<InvalidTokenConfig>('invalid-token-config');\n\n@Injectable()\nexport class InvalidTokenInterceptor implements HttpInterceptor {\n  private config: Required<InvalidTokenConfig> = {\n    enableAutoRefresh: false,\n    redirectToLoginPage: true,\n  };\n  private autoRefresh = createAutoRefresh(this.authService, this.httpClient);\n\n  constructor(\n    private authService: AuthService,\n    private httpClient: HttpClient,\n    @Optional() @Inject(INVALID_TOKEN_CONFIG) private injectedConfig: InvalidTokenConfig,\n    @Inject(DOCUMENT) private document: any,\n  ) {\n    this.config = {\n      ...this.config,\n      ...(this.injectedConfig || {}),\n    };\n  }\n\n  private checkRedirect() {\n    if (this.config.redirectToLoginPage) {\n      this.authService.logout({ redirectUri: this.document.location.href });\n    }\n  }\n\n  private tryRefresh(req: HttpRequest<unknown>, err: HttpErrorResponse) {\n    return this.autoRefresh.refreshAndRepeat(req).pipe(\n      catchError(() => {\n        this.checkRedirect();\n        return throwError(err);\n      }),\n    );\n  }\n\n  intercept(req: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req).pipe(\n      catchError((err: HttpErrorResponse) => {\n        if (is401AndNotReauth(err)) {\n          if (this.config.enableAutoRefresh && !this.autoRefresh.failed) {\n            return this.tryRefresh(req, err);\n          }\n          this.checkRedirect();\n        }\n        return throwError(err);\n      }),\n    );\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n\nexport {AuthServiceImpl as ɵa} from './deprecated/auth.service';"]}