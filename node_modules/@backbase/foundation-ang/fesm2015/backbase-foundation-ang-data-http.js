import * as i0 from '@angular/core';
import { Injectable, InjectionToken, NgModule, Injector, Optional, Inject, APP_BOOTSTRAP_LISTENER, isDevMode } from '@angular/core';
import { HTTP_INTERCEPTORS, HttpParams, HttpErrorResponse, HttpResponse } from '@angular/common/http';
import { PAGE_CONFIG } from '@backbase/foundation-ang/web-sdk';
import { FutureFeaturesModule, FeaturesService } from '@backbase/foundation-ang/core';
import { throwError, of } from 'rxjs';
import { materialize, delay, dematerialize, tap } from 'rxjs/operators';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@backbase/foundation-ang/core';
class CacheControlInterceptor {
    intercept(req, next) {
        const updatedRequest = req.clone({
            setHeaders: {
                'Cache-Control': 'no-cache, no-store, must-revalidate',
                Pragma: 'no-cache',
            },
        });
        return next.handle(updatedRequest);
    }
}
CacheControlInterceptor.ɵfac = function CacheControlInterceptor_Factory(t) { return new (t || CacheControlInterceptor)(); };
CacheControlInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CacheControlInterceptor, factory: CacheControlInterceptor.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CacheControlInterceptor, [{
        type: Injectable
    }], null, null); })();
const cacheControlInterceptorProvider = [
    {
        provide: HTTP_INTERCEPTORS,
        useClass: CacheControlInterceptor,
        multi: true,
    },
];

/**
 * This token can be used to inject default DataHttpConfig
 */
const DATA_HTTP_CONFIG = new InjectionToken('DataHttpConfig');
const DATA_HTTP_CUSTOM_CONFIG = new InjectionToken('DataHttpCustomConfig');
/**
 * Returns merged service data http configuration
 * @param globalConfig Default service configuration object
 * @param serviceConfig Service configuration object to be merge on default
 */
function createServiceDataHttpConfig(globalConfig, serviceConfig) {
    return Object.assign(Object.assign({}, globalConfig), serviceConfig);
}

const second = 1000;
class RequestCacheService {
    constructor() {
        this.ttl = 1 * second;
        this.results = new Map();
    }
    get(req) {
        this.garbageCollect();
        const cached = this.results.get(this.key(req));
        if (cached === undefined) {
            return undefined;
        }
        return cached.value;
    }
    set(request, response) {
        this.results.set(this.key(request), this.value(response));
    }
    key(request) {
        return JSON.stringify({
            url: request.urlWithParams,
        });
    }
    value(response) {
        return {
            expireAt: this.expiryTime(),
            value: response,
        };
    }
    expiryTime() {
        return Date.now() + this.ttl;
    }
    isExpired(value) {
        return Date.now() > value.expireAt;
    }
    garbageCollect() {
        this.results.forEach((value, key) => {
            if (this.isExpired(value)) {
                this.results.delete(key);
            }
        });
    }
}
RequestCacheService.ɵfac = function RequestCacheService_Factory(t) { return new (t || RequestCacheService)(); };
RequestCacheService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RequestCacheService, factory: RequestCacheService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RequestCacheService, [{
        type: Injectable
    }], function () { return []; }, null); })();

class RequestCacheInterceptor {
    constructor(cache) {
        this.cache = cache;
    }
    intercept(req, next) {
        if (!this.isCachable(req)) {
            return next.handle(req);
        }
        return this.cachedResponse(req) || this.refreshResponse(req, next);
    }
    isCachable(req) {
        return req.method === 'GET';
    }
    cachedResponse(req) {
        return this.cache.get(req);
    }
    refreshResponse(req, next) {
        const response = next.handle(req);
        this.cache.set(req, response);
        return response;
    }
}
RequestCacheInterceptor.ɵfac = function RequestCacheInterceptor_Factory(t) { return new (t || RequestCacheInterceptor)(ɵngcc0.ɵɵinject(RequestCacheService)); };
RequestCacheInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RequestCacheInterceptor, factory: RequestCacheInterceptor.ɵfac });
RequestCacheInterceptor.ctorParameters = () => [
    { type: RequestCacheService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RequestCacheInterceptor, [{
        type: Injectable
    }], function () { return [{ type: RequestCacheService }]; }, null); })();
const requestCacheInterceptorProvider = [
    RequestCacheService,
    {
        provide: HTTP_INTERCEPTORS,
        useClass: RequestCacheInterceptor,
        multi: true,
    },
];

const normalizeHttpParameter = (accum, [key, value]) => {
    if (value === undefined) {
        return accum;
    }
    if (typeof value === 'number') {
        return Object.assign(Object.assign({}, accum), { [key]: String(value) });
    }
    return Object.assign(Object.assign({}, accum), { [key]: value });
};
const EXTRA_ENCODE_URI_PARAMS = {
    name: 'EXTRA_ENCODE_URI_PARAMS',
    description: 'Correctly encode certain symbols in data module http params (eg encode "+" to "%2B) to fix a known angular bug (#18261)',
};
/**
 * Filter undefined params, and convert numbers to strings.
 */
const normalizeHttpParameters = (params) => Object.entries(params).reduce(normalizeHttpParameter, {});
class CustomEncoder {
    encodeKey(key) {
        return encodeURIComponent(key);
    }
    encodeValue(value) {
        return encodeURIComponent(value);
    }
    decodeKey(key) {
        return decodeURIComponent(key);
    }
    decodeValue(value) {
        return decodeURIComponent(value);
    }
}
/**
 * Injection token for the `HttpParamsFactory` utility function.
 *
 * @usageNotes
 *
 * ### Example
 *
 * ```
 * export class MyDataService {
 *   constructor(private readonly http: HttpClient,
 *   @Inject(HTTP_PARAMS_FACTORY)
 *   private readonly toHttpParams: HttpParamsFactory,
 *   ){}
 *
 *   makeRequest(params: HttpParameters): Observable<HttpResponse<any>> {
 *     return this.http.request('get', '/api', {
 *       params: this.toHttpParams(params),
 *     });
 *   }
 * }
 * ```
 */
const HTTP_PARAMS_FACTORY = new InjectionToken('Http Param Factory');
const httpParamsFactoryFactory = (featuresService) => {
    // We can't type options correctly, because angular is not exporting HttpParamsOptions
    // https://github.com/angular/angular/issues/20276
    const httpParamsOptions = featuresService.isEnabled(EXTRA_ENCODE_URI_PARAMS) ? { encoder: new CustomEncoder() } : {};
    return (fromObject) => new HttpParams(Object.assign(Object.assign({}, httpParamsOptions), { fromObject: normalizeHttpParameters(fromObject) }));
};

/**
 * Returns merged data http configuration object
 * @param pageConfigService
 * @param config
 */
function dataHttpConfigFactory(pageConfigService, config = {}) {
    return Object.assign({ headers: {}, apiRoot: pageConfigService.apiRoot }, config);
}
const ɵ0$1 = httpParamsFactoryFactory;
class DataHttpModule {
    /**
     * Creates a module with http configuration for data modules.
     *
     * @usageNotes
     *
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [
     *     DataHttpModule.forRoot({
     *       rootApi: '/custom-base-url/',
     *       headers: {
     *         'X-custom': 'foo',
     *       }
     *     })
     *   ]
     * })
     * class MyAppModule {}
     * ```
     */
    static forRoot(config = {}) {
        return {
            ngModule: DataHttpModule,
            providers: [
                requestCacheInterceptorProvider,
                cacheControlInterceptorProvider,
                {
                    provide: DATA_HTTP_CUSTOM_CONFIG,
                    useValue: config,
                },
                {
                    provide: DATA_HTTP_CONFIG,
                    useFactory: dataHttpConfigFactory,
                    deps: [PAGE_CONFIG, DATA_HTTP_CUSTOM_CONFIG],
                },
            ],
        };
    }
}
DataHttpModule.ɵfac = function DataHttpModule_Factory(t) { return new (t || DataHttpModule)(); };
DataHttpModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: DataHttpModule });
DataHttpModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        {
            provide: DATA_HTTP_CONFIG,
            useFactory: dataHttpConfigFactory,
            deps: [PAGE_CONFIG]
        },
        {
            provide: HTTP_PARAMS_FACTORY,
            useFactory: ɵ0$1,
            deps: [FeaturesService]
        },
    ], imports: [[FutureFeaturesModule.allowOptIn([EXTRA_ENCODE_URI_PARAMS])]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataHttpModule, [{
        type: NgModule,
        args: [{
                imports: [FutureFeaturesModule.allowOptIn([EXTRA_ENCODE_URI_PARAMS])],
                providers: [
                    {
                        provide: DATA_HTTP_CONFIG,
                        useFactory: dataHttpConfigFactory,
                        deps: [PAGE_CONFIG]
                    },
                    {
                        provide: HTTP_PARAMS_FACTORY,
                        useFactory: ɵ0$1,
                        deps: [FeaturesService]
                    },
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DataHttpModule, { imports: [ɵngcc1.FutureFeaturesModule] }); })();

const DEFAULT_RETURN_STATUS = 200;
var MocksItem;
(function (MocksItem) {
    const placeholderPattern = /\{[^\}]*\}/g;
    function placeholdersCount(item) {
        return (item.urlPattern.match(placeholderPattern) || []).length;
    }
    function placeholderIndex(item) {
        const regex = new RegExp(placeholderPattern);
        const found = regex.exec(item.urlPattern);
        return found == null ? item.urlPattern.length : found.index;
    }
    function comparePlaceHolderCount(a, b) {
        return placeholdersCount(a) - placeholdersCount(b);
    }
    function comparePlaceholderIndex(a, b) {
        return placeholderIndex(b) - placeholderIndex(a);
    }
    function compareSpecificity(a, b) {
        return comparePlaceHolderCount(a, b) || comparePlaceholderIndex(a, b);
    }
    MocksItem.compareSpecificity = compareSpecificity;
})(MocksItem || (MocksItem = {}));
function fromExamples(examples) {
    return examples.map(exampleItemToMockItem).sort(MocksItem.compareSpecificity);
}
function exampleItemToMockItem(example) {
    let defaultResponseItem;
    if (example.responses && example.responses.length) {
        defaultResponseItem =
            example.responses.find((response) => isSuccessStatus(response.status)) ||
                example.responses[0];
    }
    return Object.assign({ statusToReturn: defaultResponseItem ? defaultResponseItem.status : DEFAULT_RETURN_STATUS }, example);
}
function isSuccessStatus(status) {
    return status >= 200 && status <= 299;
}
const MOCKS_EXAMPLES = new InjectionToken(`@backbase/foundation Mocks Examples`);

const hasProtocol = (url) => !!url.match(/^[^/:]+:\/{2,}$/);
const addTrailingSlash = (url) => url.replace(/([^\/])$/, '$1/');
const ɵ0 = addTrailingSlash;
const removeLeadingSlash = (str) => str.replace(/^[\/]+/, '');
const ɵ1 = removeLeadingSlash;
const removeTrailingSlash = (str) => str.replace(/[\/]+$/, '');
const ɵ2 = removeTrailingSlash;
/**
 * Join URL parts together into a single URL string.
 *
 * Ensures URL get joined together by a single slash.
 *
 * @internal
 * @usageNotes
 *
 * ### Example
 *
 * ```
 * joinUrl('a', 'b'); // returns 'a/b'
 * joinUrl('/a/', '/b/'); // returns '/a/b/'
 * joinUrl('http://www.example.com/', '/a/b', 'c'); // returns 'http://www.example.com/a/b/c'
 * ```
 */
const joinUrl = (...urlParts) => {
    // Much of this is taken from https://github.com/jfromaniello/url-join/blob/master/lib/url-join.js
    if (urlParts.length < 2) {
        return urlParts[0] || '';
    }
    // If the first part is a plain protocol, we combine it with the next part.
    if (hasProtocol(urlParts[0])) {
        const first = urlParts.shift(); // it is assured by above check
        urlParts[0] = addTrailingSlash(first) + removeLeadingSlash(urlParts[0]);
    }
    const resultParts = urlParts.filter(Boolean).map((part, index) => {
        if (index > 0) {
            // Removing the starting slashes for each component but the first.
            part = removeLeadingSlash(part);
        }
        if (index < urlParts.length - 1) {
            // Removing the ending slashes for each component but the last.
            part = removeTrailingSlash(part);
        }
        return part;
    });
    // All parts now start and end without slashes (exceptions for the first and last).
    return resultParts.join('/');
};

const DEFAULT_CONFIG_TOKEN = new InjectionToken(`@backbase/foundation default config token`);
class DataModulesManager {
    constructor(injector, mockData) {
        this.injector = injector;
        this._mocks = [];
        this.modulesConfig = new Map();
        this.addMockExamples(mockData || []);
    }
    setModuleConfig(token, config) {
        if (this.modulesConfig.has(token)) {
            const current = this.modulesConfig.get(token);
            this.modulesConfig.set(token, Object.assign(Object.assign({}, current), { config }));
        }
        else {
            this.modulesConfig.set(token, {
                config,
            });
        }
        this.updateMocks();
    }
    getMocks() {
        return this._mocks;
    }
    addMockExamples(mockData) {
        var _a, _b, _c;
        for (const { token, examples } of mockData) {
            const configToken = token || DEFAULT_CONFIG_TOKEN;
            const config = (_a = this.injector.get(configToken, null)) !== null && _a !== void 0 ? _a : undefined;
            const allExamples = configToken === DEFAULT_CONFIG_TOKEN
                ? examples.concat((_c = (_b = this.modulesConfig.get(configToken)) === null || _b === void 0 ? void 0 : _b.examples) !== null && _c !== void 0 ? _c : [])
                : examples;
            this.modulesConfig.set(configToken, {
                examples: allExamples,
                config,
            });
        }
        this.updateMocks();
    }
    updateMocks() {
        const mockExamples = [];
        for (const { config, examples } of this.modulesConfig.values()) {
            mockExamples.push(...(examples || []).map(example => this.createURL(example, config)));
        }
        this._mocks = fromExamples(mockExamples);
    }
    createURL(example, serviceConfig) {
        return serviceConfig
            ? Object.assign(Object.assign({}, example), { urlPattern: joinUrl(serviceConfig.apiRoot, serviceConfig.servicePath, example.urlPattern) }) : example;
    }
}
DataModulesManager.ɵfac = function DataModulesManager_Factory(t) { return new (t || DataModulesManager)(ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(MOCKS_EXAMPLES, 8)); };
DataModulesManager.ɵprov = i0.ɵɵdefineInjectable({ factory: function DataModulesManager_Factory() { return new DataModulesManager(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(MOCKS_EXAMPLES, 8)); }, token: DataModulesManager, providedIn: "root" });
DataModulesManager.ctorParameters = () => [
    { type: Injector },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [MOCKS_EXAMPLES,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DataModulesManager, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc0.Injector }, { type: Array, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [MOCKS_EXAMPLES]
            }] }]; }, null); })();

const DEFAULT_OPTIONS = {
    responseDelay: 300,
    enableMocksStorageKey: 'enableMocks',
};
class MocksInterceptor {
    /*
     * this class is constructed in createMocksInterceptor
     function so make sure to updated it too if you have changes in the dependancy list
     */
    constructor(dataModuleManager) {
        this.dataModuleManager = dataModuleManager;
        this.options = DEFAULT_OPTIONS;
    }
    urlMatchesPattern(url, pattern) {
        const regexp = new RegExp(pattern
            .replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // escape regex characters in URL pattern
            .replace(/\\{[^\}]*\}/g, '[^/]*') // convert template {placeholders} to regex
            .concat('$'));
        // fixes bug with older versions of data modules, where they could have ended up
        // with double slashes in the request URL, depending on the environment
        // by replacing multiple slashes with a single slash (except after ":" - e.g. in "http://")
        const normalUrl = url.replace(/([^:]\/)\/+/g, '$1');
        return regexp.test(normalUrl);
    }
    findRequestMock(request) {
        const urlAndMethodMatch = (item) => {
            return request.method === item.method && this.urlMatchesPattern(request.url, item.urlPattern);
        };
        return this.dataModuleManager.getMocks().find(urlAndMethodMatch);
    }
    toResponseObject(mockItem) {
        const response = mockItem.responses.find(resp => resp.status === mockItem.statusToReturn);
        if (!response) {
            return throwError(new HttpErrorResponse({
                status: 500,
                statusText: 'No Mock Defined',
            }));
        }
        if (isSuccessStatus(response.status)) {
            return of(new HttpResponse(response));
        }
        else {
            return throwError(new HttpErrorResponse(response));
        }
    }
    getMockItemFromStorage(urlPattern) {
        try {
            return JSON.parse(localStorage.getItem(urlPattern) || '{}');
        }
        catch (_a) {
            console.warn(`[MOCK] Invalid json for the "${urlPattern}" local storage item`);
            return {};
        }
    }
    processRequest(request, next) {
        const mock = this.findRequestMock(request);
        if (mock) {
            return this.toResponseObject(Object.assign(Object.assign({}, mock), this.getMockItemFromStorage(mock.urlPattern)));
        }
        return next.handle(request);
    }
    intercept(request, next) {
        if (localStorage.getItem(this.options.enableMocksStorageKey) !== 'true') {
            return next.handle(request);
        }
        return this.processRequest(request, next).pipe(materialize(), delay(this.options.responseDelay), dematerialize(), tap(response => {
            // eslint-disable-next-line  no-console
            console.log('[MOCK]', request, response);
        }));
    }
}
MocksInterceptor.ɵfac = function MocksInterceptor_Factory(t) { return new (t || MocksInterceptor)(ɵngcc0.ɵɵinject(DataModulesManager)); };
MocksInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function MocksInterceptor_Factory() { return new MocksInterceptor(i0.ɵɵinject(DataModulesManager)); }, token: MocksInterceptor, providedIn: "root" });
MocksInterceptor.ctorParameters = () => [
    { type: DataModulesManager }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MocksInterceptor, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: DataModulesManager }]; }, null); })();
/**
 * Create a HTTP_INTERCEPTOR to return mock responses for data modules.
 */
function createMocksInterceptor() {
    return [
        {
            provide: HTTP_INTERCEPTORS,
            useClass: MocksInterceptor,
            deps: [DataModulesManager],
            multi: true,
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useValue: bootstrapMocksInterceptor,
            multi: true,
        },
    ];
}
function bootstrapMocksInterceptor() {
    if (!isDevMode()) {
        console.warn('Mocks should not be enabled in a production environment.');
    }
}
/**
 * @internal
 * @deprecated
 */
function createMockInterceptor(examples) {
    return createMocks(examples);
}
/**
 * Create mocks
 *
 * @param examples
 * @param serviceConfigToken
 */
function createMocks(examples, serviceConfigToken) {
    return {
        provide: MOCKS_EXAMPLES,
        useValue: { examples, token: serviceConfigToken },
        multi: true,
    };
}

var PageParams;
(function (PageParams) {
    function equal(a, b) {
        return a.size === b.size && a.from === b.from;
    }
    PageParams.equal = equal;
    function toHttpParams(params) {
        return new HttpParams({
            fromObject: {
                from: Math.floor(params.from).toString(),
                size: Math.floor(params.size).toString(),
            },
        });
    }
    PageParams.toHttpParams = toHttpParams;
})(PageParams || (PageParams = {}));
var CursorParams;
(function (CursorParams) {
    function equal(a, b) {
        return a.size === b.size && a.cursor === b.cursor;
    }
    CursorParams.equal = equal;
    function toHttpParams(params) {
        return new HttpParams({
            fromObject: Object.assign({ from: params.cursor }, (params.size ? { size: Math.floor(params.size).toString() } : {})),
        });
    }
    CursorParams.toHttpParams = toHttpParams;
})(CursorParams || (CursorParams = {}));
var PaginationParams;
(function (PaginationParams) {
    function equal(a, b) {
        const cursorsEqual = isCursorParams(a) && isCursorParams(b) && CursorParams.equal(a, b);
        const pagesEqual = isPageParams(a) && isPageParams(b) && PageParams.equal(a, b);
        return cursorsEqual || pagesEqual;
    }
    PaginationParams.equal = equal;
    function isPageParams(params) {
        return params.from !== undefined;
    }
    PaginationParams.isPageParams = isPageParams;
    function isCursorParams(params) {
        return params.cursor !== undefined;
    }
    PaginationParams.isCursorParams = isCursorParams;
    function toHttpParams(params) {
        return isPageParams(params) ? PageParams.toHttpParams(params) : CursorParams.toHttpParams(params);
    }
    PaginationParams.toHttpParams = toHttpParams;
})(PaginationParams || (PaginationParams = {}));

/**
 * Generated bundle index. Do not edit.
 */

export { DATA_HTTP_CONFIG, DataHttpModule, DataModulesManager, HTTP_PARAMS_FACTORY, MocksItem, PaginationParams, createMockInterceptor, createMocks, createMocksInterceptor, createServiceDataHttpConfig, dataHttpConfigFactory as ɵa, DATA_HTTP_CUSTOM_CONFIG as ɵb, MocksInterceptor as ɵc, bootstrapMocksInterceptor as ɵd, MOCKS_EXAMPLES as ɵf, EXTRA_ENCODE_URI_PARAMS as ɵg, httpParamsFactoryFactory as ɵh, RequestCacheInterceptor as ɵi, requestCacheInterceptorProvider as ɵj, RequestCacheService as ɵk, CacheControlInterceptor as ɵl, cacheControlInterceptorProvider as ɵm };

//# sourceMappingURL=backbase-foundation-ang-data-http.js.map