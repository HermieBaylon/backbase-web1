import { Injectable, InjectionToken, Inject, APP_INITIALIZER, NgModule } from '@angular/core';
import { CommunicationDefinition, serializerDeserializer } from '@backbase/communication-property';
import { first, map } from 'rxjs/operators';
import { ӨRootContainerService, ӨItemNavigationService, BackbaseCoreModule } from '@backbase/foundation-ang/core';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@backbase/foundation-ang/core';
function initIntents(intentBridgeService) {
    return intentBridgeService.handleIncomingIntent.bind(intentBridgeService);
}
class IntentNavigation {
    go(url) {
        location.href = url;
    }
}
IntentNavigation.ɵfac = function IntentNavigation_Factory(t) { return new (t || IntentNavigation)(); };
IntentNavigation.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: IntentNavigation, factory: IntentNavigation.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IntentNavigation, [{
        type: Injectable
    }], null, null); })();
class IntentStorage {
    get() {
        const storedIntent = sessionStorage.getItem(IntentStorage.STORE_KEY) || undefined;
        if (storedIntent === undefined) {
            return;
        }
        const intent = JSON.parse(storedIntent);
        if (!isAnIntent(intent)) {
            return;
        }
        return intent;
    }
    clear() {
        sessionStorage.removeItem(IntentStorage.STORE_KEY);
    }
    set(intent) {
        sessionStorage.setItem(IntentStorage.STORE_KEY, JSON.stringify(intent));
    }
}
IntentStorage.ɵfac = function IntentStorage_Factory(t) { return new (t || IntentStorage)(); };
IntentStorage.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: IntentStorage, factory: IntentStorage.ɵfac });
IntentStorage.STORE_KEY = 'lib-bb-intent:navigated-intent';
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IntentStorage, [{
        type: Injectable
    }], null, null); })();
// Incoming
function isAnIntent(intent) {
    if (typeof intent !== 'object' || intent === null) {
        return false;
    }
    const assumedIntent = intent;
    const hasName = typeof assumedIntent.name === 'string';
    const hasParameters = typeof assumedIntent.parameters === 'object' && assumedIntent.parameters !== null;
    return hasName && hasParameters;
}
function intentHandler(guard, handle) {
    return intent => {
        if (!guard(intent)) {
            return undefined;
        }
        return handle(intent.parameters);
    };
}
const INTENT_INCOMING_MAPPING = new InjectionToken('INTENT_INCOMING_MAPPING');
class IntentBridgeService {
    constructor(rootModel, itemNavigation, store, handlers) {
        this.rootModel = rootModel;
        this.itemNavigation = itemNavigation;
        this.store = store;
        this.handlers = handlers;
    }
    handleIntentFromStorage(handlers) {
        const intent = this.store.get();
        if (!intent) {
            return;
        }
        for (const handle of handlers) {
            const handling = handle(intent);
            if (handling) {
                this.store.clear();
                return handling;
            }
        }
        return;
    }
    handleIncomingIntent() {
        this.handleIntentFromStorage(this.handlers.map(({ guard, group, extract }) => intentHandler(guard, parameters => {
            const params = { [group]: extract(parameters) };
            return this.rootModel
                .commonAncestor(new CommunicationDefinition('route-param', group))
                .pipe(first(), map(commonAncestor => {
                if (commonAncestor === undefined) {
                    return console.warn('No Inputs configured to receive route param');
                }
                this.itemNavigation.navigateToItem(commonAncestor.name, params);
            }))
                .toPromise();
        })));
    }
}
IntentBridgeService.ɵfac = function IntentBridgeService_Factory(t) { return new (t || IntentBridgeService)(ɵngcc0.ɵɵinject(ɵngcc1.ӨRootContainerService), ɵngcc0.ɵɵinject(ɵngcc1.ӨItemNavigationService), ɵngcc0.ɵɵinject(IntentStorage), ɵngcc0.ɵɵinject(INTENT_INCOMING_MAPPING)); };
IntentBridgeService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: IntentBridgeService, factory: IntentBridgeService.ɵfac });
IntentBridgeService.ctorParameters = () => [
    { type: ӨRootContainerService },
    { type: ӨItemNavigationService },
    { type: IntentStorage },
    { type: Array, decorators: [{ type: Inject, args: [INTENT_INCOMING_MAPPING,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IntentBridgeService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.ӨRootContainerService }, { type: ɵngcc1.ӨItemNavigationService }, { type: IntentStorage }, { type: Array, decorators: [{
                type: Inject,
                args: [INTENT_INCOMING_MAPPING]
            }] }]; }, null); })();
// Outgoing
const TAG = 'intent';
/**
 * @deprecated Will be removed in v7.0.0
 * Intent Communication Transport
 *
 * Can be used in standalone development to configure communication using Intents.
 *
 * Note: This Transport does not currently support Input handling. Incoming Intents can be handled
 * by mapping them to a RouteParam by providing an `IncomingIntentMapping`
 */
class IntentIO {
    /**
     * Generate a serialized communication configuration suitable for use as a Widget Output property value.
     *
     * @param group The name of the communication group to which the Output belongs
     */
    static toProperty(group) {
        return serializerDeserializer.toProperty(new CommunicationDefinition(TAG, group));
    }
}
const INTENTS_OUTGOING_MAPPING = new InjectionToken('OutgoingIntentMapping');
class IntentPipeline {
    constructor(navigator, storage, outgoingMappings) {
        this.navigator = navigator;
        this.storage = storage;
        this.outgoingMappings = outgoingMappings;
    }
    sink(group) {
        return (stdin) => {
            const creator = this.outgoingMappings.find(mapping => mapping.group === group);
            if (!creator) {
                return;
            }
            void stdin.subscribe((value) => {
                const parameters = creator.parameters(value);
                const intent = {
                    name: creator.intent,
                    parameters,
                };
                this.storage.set(intent);
                this.navigator.go(creator.targetUrl);
            });
        };
    }
}
function createIntentPipeline(navigator, storage, creators) {
    return new IntentPipeline(navigator, storage, creators);
}
const intentProcessorConfig = {
    name: TAG,
    provider: {
        provide: new InjectionToken('Intents pipeline handler'),
        useFactory: createIntentPipeline,
        deps: [IntentNavigation, IntentStorage, INTENTS_OUTGOING_MAPPING],
    },
};
/**
 * @deprecated Will be removed in v7.0.0
 */
class IntentsBridgeModule {
    static forRoot(config) {
        return {
            ngModule: IntentsBridgeModule,
            providers: [
                {
                    provide: INTENTS_OUTGOING_MAPPING,
                    useValue: config.outgoing,
                },
                {
                    provide: INTENT_INCOMING_MAPPING,
                    useValue: config.incoming,
                },
                IntentBridgeService,
                {
                    provide: APP_INITIALIZER,
                    useFactory: initIntents,
                    deps: [IntentBridgeService],
                    multi: true,
                },
                IntentStorage,
                IntentNavigation,
            ],
        };
    }
}
IntentsBridgeModule.ɵfac = function IntentsBridgeModule_Factory(t) { return new (t || IntentsBridgeModule)(); };
IntentsBridgeModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: IntentsBridgeModule });
IntentsBridgeModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[
            BackbaseCoreModule.withConfig({
                pipelineProcessors: [intentProcessorConfig]
            }),
        ]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(IntentsBridgeModule, [{
        type: NgModule,
        args: [{
                imports: [
                    BackbaseCoreModule.withConfig({
                        pipelineProcessors: [intentProcessorConfig]
                    }),
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(IntentsBridgeModule, { imports: [ɵngcc1.BackbaseCoreModule] }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { IntentIO, IntentsBridgeModule, initIntents as ɵa, IntentNavigation as ɵb, IntentStorage as ɵc, INTENT_INCOMING_MAPPING as ɵd, IntentBridgeService as ɵe, INTENTS_OUTGOING_MAPPING as ɵf, IntentPipeline as ɵg, createIntentPipeline as ɵh, intentProcessorConfig as ɵi };

//# sourceMappingURL=backbase-foundation-ang-migration.js.map