{"version":3,"file":"backbase-foundation-ang-migration.js","sources":["../../../../projects/backbase/foundation-ang/migration/src/intents.ts","../../../../projects/backbase/foundation-ang/migration/src/backbase-foundation-ang-migration.ts"],"sourcesContent":["import { Inject, Injectable, InjectionToken, ModuleWithProviders, NgModule, APP_INITIALIZER } from '@angular/core';\nimport { CommunicationDefinition, serializerDeserializer } from '@backbase/communication-property';\nimport { Observable } from 'rxjs';\nimport { first, map } from 'rxjs/operators';\n\nimport {\n  BackbaseCoreModule,\n  PipelineSink,\n  Sink,\n  PipelineProcessorConfig,\n  ӨItemNavigationService,\n  ӨRootContainerService,\n} from '@backbase/foundation-ang/core';\n\nexport function initIntents(intentBridgeService: IntentBridgeService) {\n  return intentBridgeService.handleIncomingIntent.bind(intentBridgeService);\n}\n\n/**\n * @deprecated Will be removed in v7.0.0\n * A WA2 compatible Intent\n *\n * This is the interoperable format that is supported by both sides of the communication\n */\nexport interface Intent<T extends object = object> {\n  /** The name of the Intent used to identify it */\n  name: string;\n  /** Any extra data associated with the intent that can be used by the receiving side */\n  parameters: T;\n}\n\n@Injectable()\nexport class IntentNavigation {\n  go(url: string) {\n    location.href = url;\n  }\n}\n\n@Injectable()\nexport class IntentStorage {\n  static STORE_KEY = 'lib-bb-intent:navigated-intent';\n\n  get(): Intent | undefined {\n    const storedIntent: string | undefined = sessionStorage.getItem(IntentStorage.STORE_KEY) || undefined;\n    if (storedIntent === undefined) {\n      return;\n    }\n    const intent: unknown = JSON.parse(storedIntent);\n    if (!isAnIntent(intent)) {\n      return;\n    }\n    return intent;\n  }\n\n  clear(): void {\n    sessionStorage.removeItem(IntentStorage.STORE_KEY);\n  }\n\n  set(intent: Intent): void {\n    sessionStorage.setItem(IntentStorage.STORE_KEY, JSON.stringify(intent));\n  }\n}\n\n// Incoming\n\nfunction isAnIntent(intent: unknown): intent is Intent {\n  if (typeof intent !== 'object' || intent === null) {\n    return false;\n  }\n  const assumedIntent = intent as Intent;\n  const hasName = typeof assumedIntent.name === 'string';\n  const hasParameters = typeof assumedIntent.parameters === 'object' && assumedIntent.parameters !== null;\n  return hasName && hasParameters;\n}\n\nfunction intentHandler<T extends Intent>(\n  guard: (intent: Intent) => intent is T,\n  handle: (t: T['parameters']) => Promise<void>,\n): (intent: Intent) => undefined | Promise<void> {\n  return intent => {\n    if (!guard(intent)) {\n      return undefined;\n    }\n    return handle(intent.parameters);\n  };\n}\n\n/**\n * @deprecated Will be removed in v7.0.0\n * Describe the mapping of an incoming Intent to a RouteParam communication\n */\nexport interface IncomingIntentMapping<I extends Intent> {\n  /**\n   * Determine if the incoming intent can be handled by this mapper\n   *\n   * This will likely involve checking the name of the intent and that any required parameters were sent\n   */\n  guard: (intent: I) => intent is I;\n  /**\n   * Extract the value from the Intents parameters to be passed to the RouteParam communication group\n   */\n  extract: (parameters: I['parameters']) => string;\n  /**\n   * The name of the communication group that is the target of the resulting RouteParam communication\n   */\n  group: string;\n}\n\nexport const INTENT_INCOMING_MAPPING = new InjectionToken('INTENT_INCOMING_MAPPING');\n\n@Injectable()\nexport class IntentBridgeService {\n  constructor(\n    private readonly rootModel: ӨRootContainerService,\n    private readonly itemNavigation: ӨItemNavigationService,\n    private readonly store: IntentStorage,\n    @Inject(INTENT_INCOMING_MAPPING) private readonly handlers: Array<IncomingIntentMapping<Intent<any>>>,\n  ) {}\n\n  private handleIntentFromStorage(handlers: Array<(intent: Intent) => undefined | Promise<void>>) {\n    const intent = this.store.get();\n    if (!intent) {\n      return;\n    }\n\n    for (const handle of handlers) {\n      const handling = handle(intent);\n      if (handling) {\n        this.store.clear();\n        return handling;\n      }\n    }\n    return;\n  }\n\n  handleIncomingIntent(): void {\n    this.handleIntentFromStorage(\n      this.handlers.map(({ guard, group, extract }) =>\n        intentHandler(guard, parameters => {\n          const params = { [group]: extract(parameters) };\n          return this.rootModel\n            .commonAncestor(new CommunicationDefinition('route-param', group))\n            .pipe(\n              first(),\n              map(commonAncestor => {\n                if (commonAncestor === undefined) {\n                  return console.warn('No Inputs configured to receive route param');\n                }\n                this.itemNavigation.navigateToItem(commonAncestor.name, params);\n              }),\n            )\n            .toPromise();\n        }),\n      ),\n    );\n  }\n}\n\n// Outgoing\n\nconst TAG = 'intent';\n\n/**\n * @deprecated Will be removed in v7.0.0\n * Intent Communication Transport\n *\n * Can be used in standalone development to configure communication using Intents.\n *\n * Note: This Transport does not currently support Input handling. Incoming Intents can be handled\n * by mapping them to a RouteParam by providing an `IncomingIntentMapping`\n */\nexport class IntentIO {\n  /**\n   * Generate a serialized communication configuration suitable for use as a Widget Output property value.\n   *\n   * @param group The name of the communication group to which the Output belongs\n   */\n  static toProperty(group: string): string {\n    return serializerDeserializer.toProperty(new CommunicationDefinition(TAG, group));\n  }\n}\n\nexport const INTENTS_OUTGOING_MAPPING = new InjectionToken('OutgoingIntentMapping');\n\n/**\n * @deprecated Will be removed in v7.0.0\n * Describe the mapping of an Output to an Intent\n */\nexport interface OutgoingIntentMapping<Output, I extends Intent> {\n  /** The name of the communication group targeted by the intent output */\n  group: string;\n  /** The URL on which the target is hosted */\n  targetUrl: string;\n  /** The name of the intent that will be created from the emitted output value */\n  intent: I['name'];\n  /** Create the intent parameters based on the emitted output value */\n  parameters: (output: Output) => I['parameters'];\n}\n\nexport class IntentPipeline<Output> implements PipelineSink<Output> {\n  constructor(\n    private readonly navigator: IntentNavigation,\n    private readonly storage: IntentStorage,\n    private readonly outgoingMappings: Array<OutgoingIntentMapping<Output, Intent>>,\n  ) {}\n\n  sink(group: string): Sink<Output> {\n    return (stdin: Observable<Output>): void => {\n      const creator = this.outgoingMappings.find(mapping => mapping.group === group);\n      if (!creator) {\n        return;\n      }\n      void stdin.subscribe((value: Output) => {\n        const parameters = creator.parameters(value);\n        const intent: Intent = {\n          name: creator.intent,\n          parameters,\n        };\n        this.storage.set(intent);\n        this.navigator.go(creator.targetUrl);\n      });\n    };\n  }\n}\n\nexport function createIntentPipeline<Output>(\n  navigator: IntentNavigation,\n  storage: IntentStorage,\n  creators: Array<OutgoingIntentMapping<Output, Intent>>,\n) {\n  return new IntentPipeline(navigator, storage, creators);\n}\n\nexport const intentProcessorConfig: PipelineProcessorConfig<'intent'> = {\n  name: TAG,\n  provider: {\n    provide: new InjectionToken('Intents pipeline handler'),\n    useFactory: createIntentPipeline,\n    deps: [IntentNavigation, IntentStorage, INTENTS_OUTGOING_MAPPING],\n  },\n};\n\n/**\n * @deprecated Will be removed in v7.0.0\n */\n@NgModule({\n  imports: [\n    BackbaseCoreModule.withConfig({\n      pipelineProcessors: [intentProcessorConfig],\n    }),\n  ],\n})\nexport class IntentsBridgeModule {\n  static forRoot(config: {\n    incoming: Array<IncomingIntentMapping<Intent<any>>>;\n    outgoing: Array<OutgoingIntentMapping<any, any>>;\n  }): ModuleWithProviders<IntentsBridgeModule> {\n    return {\n      ngModule: IntentsBridgeModule,\n      providers: [\n        {\n          provide: INTENTS_OUTGOING_MAPPING,\n          useValue: config.outgoing,\n        },\n        {\n          provide: INTENT_INCOMING_MAPPING,\n          useValue: config.incoming,\n        },\n        IntentBridgeService,\n        {\n          provide: APP_INITIALIZER,\n          useFactory: initIntents,\n          deps: [IntentBridgeService],\n          multi: true,\n        },\n        IntentStorage,\n        IntentNavigation,\n      ],\n    };\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n\nexport {INTENTS_OUTGOING_MAPPING as ɵf,INTENT_INCOMING_MAPPING as ɵd,IntentBridgeService as ɵe,IntentNavigation as ɵb,IntentPipeline as ɵg,IntentStorage as ɵc,createIntentPipeline as ɵh,initIntents as ɵa,intentProcessorConfig as ɵi} from './intents';"],"names":[],"mappings":"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"}