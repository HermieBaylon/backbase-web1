import * as i0 from '@angular/core';
import { Injectable, forwardRef, Optional, Inject, InjectionToken } from '@angular/core';
import * as i1 from '@backbase/foundation-ang/web-sdk';
import { LOGOUT, REAUTHENTICATE, SESSION, ɵAUTH_EVENTS } from '@backbase/foundation-ang/web-sdk';
import { BehaviorSubject, merge, from, throwError } from 'rxjs';
import { filter, distinctUntilChanged, switchMap, map, pluck, mapTo, take, tap, catchError } from 'rxjs/operators';
import * as i2 from '@angular/common';
import { Location, DOCUMENT } from '@angular/common';
import { HttpClient } from '@angular/common/http';

/**
 * @deprecated Will be removed in v7.0.0
 */
class AuthService {
}
AuthService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthServiceImpl(i0.ɵɵinject(i1.LOGOUT, 8), i0.ɵɵinject(i1.REAUTHENTICATE, 8), i0.ɵɵinject(i1.SESSION, 8), i0.ɵɵinject(i1.ɵAUTH_EVENTS, 8)); }, token: AuthService, providedIn: "root" });
AuthService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
                // eslint-disable-next-line  no-use-before-define, @typescript-eslint/no-use-before-define
                useClass: forwardRef(() => AuthServiceImpl), // Default implementation (allows mocking / replacing)
            },] }
];
class AuthServiceImpl {
    constructor(logoutService, reauthenticateService, sessionService, authEvents) {
        this.accessTokenSubject = new BehaviorSubject(undefined);
        this.isLoadingSubject = new BehaviorSubject(true);
        /**
         * The current access token for the session, or `undefined` if there is no session.
         *
         * The first token will be emitted after the session is initialised. So if the user is logged
         * in already then the first emission will be an access token.
         *
         * This is a hot observable, so subscribing to it won't trigger anything.
         *
         * The latest value will be replayed to late subscribers.
         */
        this.accessToken = this.isLoadingSubject.pipe(filter(loading => !loading), distinctUntilChanged(), switchMap(() => this.accessTokenSubject));
        /**
         * Track whether the current user is authenticated.
         *
         * This is a hot observable, so subscribing to it won't trigger anything.
         *
         * The latest value will be replayed to late subscribers.
         */
        this.isAuthenticated = this.accessToken.pipe(map(token => !!token));
        if (!logoutService || !reauthenticateService || !sessionService || !authEvents) {
            throw new Error('In order to use the @backbase/foundation-ang/auth, please include *either* the ' +
                'WebSdkModule.forRoot(...) in your AppModule (for CDN deployment) or WebSdkApiModule ' +
                '(for CX deployment)');
        }
        this.logoutService = logoutService;
        this.reauthenticateService = reauthenticateService;
        this.sessionService = sessionService;
        this.authEvents = authEvents;
        this.handleAuthEvents();
    }
    /**
     * Redirect the user to the login page.
     *
     * @param loginOptions
     */
    login(loginOptions) {
        this.logoutService.goToLoginPage(loginOptions === null || loginOptions === void 0 ? void 0 : loginOptions.redirectUri);
    }
    /**
     * Log out the current user.
     *
     * @param logoutOptions
     */
    logout(logoutOptions) {
        return this.logoutService.logout(logoutOptions === null || logoutOptions === void 0 ? void 0 : logoutOptions.redirectUri);
    }
    /**
     * Register a set of callbacks that will be called as the user's session gets close to expiring.
     *
     * @param countdown
     */
    registerSessionCountdown(countdown) {
        this.sessionService.registerCountdown(countdown);
    }
    /**
     * Return the time to live (TTL) in seconds of the user's session.
     *
     * Returns -1 if the TTL can't be determined.
     */
    timeToLive() {
        return this.sessionService.timeToLive();
    }
    /**
     * Returns whether the user is being impersonated.
     * @returns true if the user is being impersonated.
     */
    isImpersonated() {
        return this.sessionService.isImpersonated;
    }
    /**
     * Reauthenticate the current user.
     *
     * This can be used when the backend responds with a 401 and the current user needs to
     * reauthenticate.
     *
     * @usageNotes
     *
     * You can use this service to create an interceptor which will automatically redirect the
     * user when the backend responds with a 401. Useful when the backend responds with a challenge
     * (eg: for step-up multifactor authentication):
     *
     * ```
     * import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpResponse } from '@angular/common/http';
     * import { from, Observable } from 'rxjs';
     * import { catchError, first, mapTo } from 'rxjs/operators';
     * import { AuthService } from '@backbase/foundation-ang/auth';
     *
     * export class ReauthenticateInterceptor implements HttpInterceptor {
     *   constructor(private readonly authService: AuthService) {}
     *   intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
     *     return next.handle(request).pipe(
     *       // When any HTTP request fails (you could check status & headers here to only catch some failures).
     *       catchError(error => {
     *         // Retreive the challenge from the server's response.
     *         const challenge: { scope: string; acrValues: string } = (error.error.challenges || []).find(
     *           c => c.scope !== undefined,
     *         );
     *         // Reauthenticate the user with the requested scope & acr values and redirect back to here.
     *         return from(
     *           this.authService.reauthenticate({
     *             scope: challenge.scope,
     *             acrValues: challenge.acrValues,
     *             redirect: true,
     *             redirectUri: location.href,
     *           }),
     *           // Retry the orignal request
     *         ).pipe(first(), mapTo(new HttpResponse({ body: error.error.data })));
     *       }),
     *     );
     *   }
     * }
     * ```
     *
     * @param reauthenticateOptions
     */
    reauthenticate(reauthenticateOptions) {
        return this.reauthenticateService.reauthenticate(reauthenticateOptions.scope, reauthenticateOptions.acrValues, reauthenticateOptions);
    }
    /**
     * Refreshes the session.
     */
    refresh() {
        return this.sessionService.refresh();
    }
    handleAuthEvents() {
        merge(this.authEvents.success.pipe(pluck('currentAccessToken')), this.authEvents.init.pipe(pluck('currentAccessToken')), this.authEvents.end.pipe(mapTo(undefined)), this.authEvents.error.pipe(mapTo(undefined)))
            .pipe(distinctUntilChanged((t1, t2) => (t1 === null || t1 === void 0 ? void 0 : t1.raw) === (t2 === null || t2 === void 0 ? void 0 : t2.raw)))
            .subscribe(token => {
            this.accessTokenSubject.next(token);
            this.isLoadingSubject.next(false);
        });
    }
}
AuthServiceImpl.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LOGOUT,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [REAUTHENTICATE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SESSION,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ɵAUTH_EVENTS,] }] }
];

/**
 * @deprecated Will be removed in v7.0.0
 */
class AuthGuard {
    constructor(auth, location, document) {
        this.auth = auth;
        this.location = location;
        this.document = document;
    }
    canLoad() {
        return this.auth.isAuthenticated.pipe(take(1));
    }
    canActivate() {
        return this.redirectIfUnauthenticated();
    }
    canActivateChild() {
        return this.redirectIfUnauthenticated();
    }
    redirectIfUnauthenticated() {
        return this.auth.isAuthenticated.pipe(tap(loggedIn => {
            if (!loggedIn) {
                // Use an actual location path with hash instead of `RouterStateSnapshot.url`
                // because `Keycloak` uses `history.replaceState` on initialization to remove
                // auth data from the path.
                const actualPath = this.location.path(true);
                this.auth.login({
                    redirectUri: this.document.location.origin + this.location.prepareExternalUrl(actualPath),
                });
            }
        }));
    }
}
AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(AuthService), i0.ɵɵinject(i2.Location), i0.ɵɵinject(i2.DOCUMENT)); }, token: AuthGuard, providedIn: "root" });
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
AuthGuard.ctorParameters = () => [
    { type: AuthService },
    { type: Location },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * @deprecated Will be removed in v7.0.0
 */
class AuthInterceptor {
    constructor(authService) {
        this.authService = authService;
    }
    intercept(req, next) {
        return this.authService.accessToken.pipe(take(1), switchMap(token => {
            if (!token) {
                return next.handle(req);
            }
            const newReq = req.clone({
                headers: req.headers.append('Authorization', `Bearer ${token.raw}`),
            });
            return next.handle(newReq);
        }));
    }
}
AuthInterceptor.decorators = [
    { type: Injectable }
];
AuthInterceptor.ctorParameters = () => [
    { type: AuthService }
];

function createAutoRefresh(authService, httpClient) {
    let refresh$;
    let refreshFailed = false;
    function refreshAndRepeat(req) {
        if (!refresh$) {
            refresh$ = from(authService.refresh()).pipe(tap(
            // after successful refresh remove reference as access token can expire again in the future
            () => (refresh$ = undefined), 
            // flag refresh failure so we will not try auto refresh again
            () => (refreshFailed = true)));
        }
        return refresh$.pipe(switchMap(() => {
            // repeat request (presume that access token is updated after refresh)
            return httpClient.request(req.clone());
        }));
    }
    return {
        failed: refreshFailed,
        refreshAndRepeat,
    };
}

const UNKNOWN_SCHEME = 'unknown';
/**
 * See https://datatracker.ietf.org/doc/html/rfc6750#section-3
 * See https://www.rfc-editor.org/rfc/rfc7235.html#section-4.1
 * See https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html
 * See https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.1
 */
function getWwwAuthenticate(headers) {
    let currentScheme = UNKNOWN_SCHEME;
    const schemes = { [currentScheme]: {} };
    const headerName = headers.keys().find(key => key.toLowerCase() === 'www-authenticate');
    if (!headerName) {
        return schemes;
    }
    const value = headers.get(headerName).toLowerCase().trim();
    if (!value) {
        return schemes;
    }
    const matches = value.match(/(?:[^\s,"]+|"[^"]*")+/g);
    if (!matches) {
        schemes[currentScheme] = value;
        return schemes;
    }
    return matches.reduce((acc, match) => {
        const nameVal = match.split('=').map(v => v.trim());
        if (nameVal.length === 1) {
            currentScheme = nameVal[0];
            acc[currentScheme] = {};
        }
        else if (nameVal.length === 2) {
            acc[currentScheme][nameVal[0]] = nameVal[1].replace(/"/g, '');
        }
        return acc;
    }, schemes);
}
/**
 * The 401 (Unauthorized) status code indicates that the request has not
 * been applied because it lacks valid authentication credentials for
 * the target resource.  The server generating a 401 response MUST send
 * a WWW-Authenticate header field (Section 4.1) containing at least one
 * challenge applicable to the target resource.
 */
function is401AndNotReauth(error) {
    if (error.status !== 401) {
        return false;
    }
    const bearer = getWwwAuthenticate(error.headers).bearer;
    if (!bearer) {
        return false;
    }
    if (bearer.challenge_types && bearer.challenge_types !== 'reauth') {
        return false;
    }
    return bearer.error === 'invalid_token';
}

const INVALID_TOKEN_CONFIG = new InjectionToken('invalid-token-config');
class InvalidTokenInterceptor {
    constructor(authService, httpClient, injectedConfig, document) {
        this.authService = authService;
        this.httpClient = httpClient;
        this.injectedConfig = injectedConfig;
        this.document = document;
        this.config = {
            enableAutoRefresh: false,
            redirectToLoginPage: true,
        };
        this.autoRefresh = createAutoRefresh(this.authService, this.httpClient);
        this.config = Object.assign(Object.assign({}, this.config), (this.injectedConfig || {}));
    }
    checkRedirect() {
        if (this.config.redirectToLoginPage) {
            this.authService.logout({ redirectUri: this.document.location.href });
        }
    }
    tryRefresh(req, err) {
        return this.autoRefresh.refreshAndRepeat(req).pipe(catchError(() => {
            this.checkRedirect();
            return throwError(err);
        }));
    }
    intercept(req, next) {
        return next.handle(req).pipe(catchError((err) => {
            if (is401AndNotReauth(err)) {
                if (this.config.enableAutoRefresh && !this.autoRefresh.failed) {
                    return this.tryRefresh(req, err);
                }
                this.checkRedirect();
            }
            return throwError(err);
        }));
    }
}
InvalidTokenInterceptor.decorators = [
    { type: Injectable }
];
InvalidTokenInterceptor.ctorParameters = () => [
    { type: AuthService },
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INVALID_TOKEN_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { AuthGuard, AuthInterceptor, AuthService, INVALID_TOKEN_CONFIG, InvalidTokenInterceptor, AuthServiceImpl as ɵa };
//# sourceMappingURL=backbase-foundation-ang-auth.js.map
