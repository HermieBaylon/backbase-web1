import * as i0 from '@angular/core';
import { Injectable, Inject, Injector, InjectionToken, NgModule } from '@angular/core';
import * as i2 from '@ngrx/effects';
import { createEffect, Actions, EffectSources, EffectsModule } from '@ngrx/effects';
import * as i1 from '@ngrx/store';
import { Store, ReducerManager, StoreModule as StoreModule$1 } from '@ngrx/store';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from 'rxjs';
import * as ɵngcc2 from '@backbase/foundation-ang/future';
import * as ɵngcc3 from '@ngrx/effects';
import * as ɵngcc4 from '@ngrx/store';
export { createAction, createReducer, on, props } from '@ngrx/store';
import { FeaturesService, FutureFeaturesModule } from '@backbase/foundation-ang/future';
import { Observable } from 'rxjs';
import { filter, map } from 'rxjs/operators';

/**
 * @deprecated Will be removed in v7.0.0
 */
const createChannelAction = (action, channel) => ({
    type: action.type,
    channel,
    action,
});
const isChannelAction = (action) => 'channel' in action && 'action' in action;
const ɵ0$1 = isChannelAction;
/**
 * @deprecated Will be removed in v7.0.0
 */
const toChannelAction = (action) => isChannelAction(action) ? action : createChannelAction(action);
/**
 * @deprecated Will be removed in v7.0.0
 */
const isActionForChannel = (action, channels) => {
    return !isChannelAction(action) || action.channel === undefined || channels.includes(action.channel);
};
/**
 * @deprecated Will be removed in v7.0.0
 * Stream operator to filter the `Actions` stream to only pass `Action`s that match the given `type`.
 */
const ofType = (type) => typeof type === 'string'
    ? (actions) => actions.pipe(filter((action) => action.type === type))
    : (actions) => actions.pipe(filter((action) => action.type === type.type));
/**
 * @deprecated Will be removed in v7.0.0
 */
const typePropertyIsNotAllowedMsg = 'type property is not allowed in action creators';

/**
 * @deprecated Will be removed in v7.0.0
 */
const InitializeStateActionType = '[Backbase Reducer] INITIALIZE REDUCER';
/**
 * @deprecated Will be removed in v7.0.0
 */
class InitializeState {
    constructor() {
        this.type = InitializeStateActionType;
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 */
const metaChannelReducer = (channels) => {
    // create a meta reducer (takes a reducer, and returns a new reducer)
    return (reducer) => {
        // create a function to initialize the state for this reducer
        const initializeState = () => reducer(undefined, new InitializeState());
        // return the new reducer, which filters actions not for this "channel"
        return (state = initializeState(), action) => {
            const channelAction = toChannelAction(action);
            if (isActionForChannel(action, channels)) {
                return reducer(state, channelAction.action);
            }
            return state;
        };
    };
};

const METADATA_KEY = '@backbase/store effect metadata';
const setEffectActionMetadata = (sourceProto, entries) => {
    const constructor = sourceProto.constructor;
    const meta = constructor.hasOwnProperty(METADATA_KEY)
        ? constructor[METADATA_KEY]
        : Object.defineProperty(constructor, METADATA_KEY, { value: [] })[METADATA_KEY];
    Array.prototype.push.apply(meta, entries);
};
const ɵ0 = setEffectActionMetadata;
const getEffectsMetadata = (sourceProto) => sourceProto.constructor.hasOwnProperty(METADATA_KEY) ? sourceProto.constructor[METADATA_KEY] : [];
const ɵ1 = getEffectsMetadata;
/**
 * @deprecated Will be removed in v7.0.0
 * Method decorator to mark a method as an effect. Effects can be registered with a `Store` to perform external
 * effects such as fetching data or navigating the browser.
 *
 * The decorated method must be `(actions: Observable<Action>, store?: Store) => Observable<Action>`.
 */
const Effect = () => {
    return function (target, methodName) {
        const metadata = {
            propertyName: methodName,
        };
        setEffectActionMetadata(target, [metadata]);
    };
};
const hasEffectActionMetadata = (instance) => getEffectsMetadata(instance).length > 0;
const ɵ2 = hasEffectActionMetadata;
const outputChannel = (channel) => (source) => source.pipe(map((action) => createChannelAction(action, channel)));
const ɵ3 = outputChannel;
const ofChannel = (channels) => (source) => source.pipe(map(action => toChannelAction(action)), filter((action) => isActionForChannel(action, channels)), map(channelAction => channelAction.action));
const ɵ4 = ofChannel;
/**
 * @deprecated Will be removed in v7.0.0
 */
const createMetaChannelEffects = (store, actions, effects, dispatchChannel, listenChannels) => {
    if (!hasEffectActionMetadata(effects)) {
        throw new Error('Effect class has no effects');
    }
    const proto = function () { };
    Object.defineProperty(proto, 'name', { value: `Effect${dispatchChannel}`, writable: false });
    const effectInstance = Object.create(proto);
    return getEffectsMetadata(effects).reduce((instance, effect) => {
        instance[effect.propertyName] = createEffect(() => effects[effect.propertyName](actions.pipe(ofChannel(listenChannels)), store).pipe(outputChannel(dispatchChannel)));
        return instance;
    }, effectInstance);
};

/**
 * @deprecated Will be removed in v7.0.0
 */
const InitializeStoreActionType = '[Backbase Reducer] INITIALIZE REDUCER';
/**
 * @deprecated Will be removed in v7.0.0
 * An `Action` that is dispatched to a `Store` when it is created to allow the store to initialize
 * its initial state
 */
class InitializeStoreAction {
    constructor() {
        this.type = InitializeStoreActionType;
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Stream operator to filter the `Actions` stream to only pass the `InitializeStoreAction`.
 * This can be used to write `Reducer`s or `Effect`s that are only run when their `Store` is
 * initially created.
 */
const ofStoreInit = () => (source) => source.pipe(filter((action) => action.type === InitializeStoreActionType));
/**
 * @internal
 */
class StoreBroker {
    constructor(superstore, actions, reducerManager, effectsSources, injector) {
        this.superstore = superstore;
        this.actions = actions;
        this.reducerManager = reducerManager;
        this.effectsSources = effectsSources;
        this.injector = injector;
        this.initializedStores = new Map();
    }
    initStore(storeName, reducer, effects, branchName, dispatchChannel, inputChannels = [], widgetInjector) {
        if (this.isStoreInitialized(branchName, storeName)) {
            return this.createStore(storeName, branchName, dispatchChannel);
        }
        const allInputChannels = [this.privateChannel(storeName, dispatchChannel), ...inputChannels];
        this.addReducer(storeName, branchName, reducer, allInputChannels);
        this.setStoreInitialized(branchName, storeName);
        const store = this.createStore(storeName, branchName, dispatchChannel);
        effects
            .map(token => (widgetInjector || this.injector).get(token))
            .forEach((effectInstance) => {
            this.addEffects(store, effectInstance, this.privateChannel(storeName, dispatchChannel), allInputChannels);
        });
        store.dispatch(new InitializeStoreAction());
        return store;
    }
    createStore(storeName, branchName, dispatchChannel) {
        return {
            select: (selector) => {
                return this.superstore.select(state => state[this.privateBranch(storeName, branchName)]).pipe(map(selector));
            },
            dispatch: (action) => {
                this.dispatchForStore(storeName, dispatchChannel, action);
            },
        };
    }
    /**
     * Dispatches an action scoped on a channel just for this store.
     */
    dispatchForStore(storeName, dispatchChannel, action) {
        this.dispatchOnChannel(this.privateChannel(storeName, dispatchChannel), action);
    }
    dispatchOnChannel(channel, action) {
        this.superstore.dispatch(createChannelAction(action, channel));
    }
    isStoreInitialized(branchName, storeName) {
        const storesInBranch = this.initializedStores.get(branchName);
        return !!(storesInBranch && storesInBranch.find(name => name === storeName));
    }
    setStoreInitialized(branchName, storeName) {
        let storesInBranch = this.initializedStores.get(branchName);
        if (storesInBranch === undefined) {
            storesInBranch = [];
            this.initializedStores.set(branchName, storesInBranch);
        }
        storesInBranch.push(storeName);
    }
    addReducer(storeName, branchName, reducer, inputChannels) {
        this.reducerManager.addFeature({
            key: this.privateBranch(storeName, branchName),
            reducers: metaChannelReducer(inputChannels)(reducer),
            reducerFactory: () => {
                throw new Error('No reducer factory');
            },
            metaReducers: [], //[createMetaChannelReducer(inputChannels)],
        });
    }
    addEffects(store, effects, dispatchChannel, listenChannels) {
        this.effectsSources.addEffects(createMetaChannelEffects(store, this.actions, effects, dispatchChannel, listenChannels));
    }
    privateBranch(storeName, branchName) {
        return `${storeName}/${branchName}`;
    }
    privateChannel(storeName, dispatchChannel) {
        return `${storeName}/${dispatchChannel}`;
    }
}
StoreBroker.ɵfac = function StoreBroker_Factory(t) { return new (t || StoreBroker)(ɵngcc0.ɵɵinject(Store), ɵngcc0.ɵɵinject(Actions), ɵngcc0.ɵɵinject(ReducerManager), ɵngcc0.ɵɵinject(EffectSources), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
StoreBroker.ɵprov = i0.ɵɵdefineInjectable({ factory: function StoreBroker_Factory() { return new StoreBroker(i0.ɵɵinject(i1.Store), i0.ɵɵinject(i2.Actions), i0.ɵɵinject(i1.ReducerManager), i0.ɵɵinject(i2.EffectSources), i0.ɵɵinject(i0.INJECTOR)); }, token: StoreBroker, providedIn: "root" });
StoreBroker.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [Store,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [Actions,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [ReducerManager,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [EffectSources,] }] },
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StoreBroker, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [Store]
            }] }, { type: ɵngcc1.Observable, decorators: [{
                type: Inject,
                args: [Actions]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [ReducerManager]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [EffectSources]
            }] }, { type: ɵngcc0.Injector }]; }, null); })();

/**
 * @deprecated Will be removed in v7.0.0
 */
const ENFORCE_INJECTOR_FOR_CREATE_STORE = {
    name: 'ENFORCE_INJECTOR_FOR_CREATE_STORE',
    description: 'you have to provide widget injector for createStore to make sure your widget support lazy loading',
};
/**
 * @deprecated Will be removed in v7.0.0
 * Configuration token that defines the "branch" of the application state that the store is responsible for.
 *
 * @internal
 */
const STORE_BRANCH = new InjectionToken('@backbase store branch');
/**
 * @deprecated Will be removed in v7.0.0
 * Configuration token that defines the "channel" on which the store will dispatch any events it produces.
 *
 * @internal
 */
const STORE_DISPATCH_CHANNEL = new InjectionToken('@backbase store dispatch channel');
/**
 * @deprecated Will be removed in v7.0.0
 * Create a scoped store on a particular branch/channel
 */
class StoreFactory {
    constructor(storeBroker, branch, dispatchChannel, featuresService) {
        this.storeBroker = storeBroker;
        this.branch = branch;
        this.dispatchChannel = dispatchChannel;
        this.featuresService = featuresService;
    }
    createStore(storeName, reducer, effects, injector) {
        if (!injector && this.featuresService.isEnabled(ENFORCE_INJECTOR_FOR_CREATE_STORE)) {
            throw new Error(ENFORCE_INJECTOR_FOR_CREATE_STORE.description);
        }
        if (!injector) {
            console.warn(ENFORCE_INJECTOR_FOR_CREATE_STORE.description);
        }
        return this.storeBroker.initStore(storeName, reducer, effects, this.branch, this.dispatchChannel, undefined, injector);
    }
}
StoreFactory.ctorParameters = () => [
    { type: StoreBroker },
    { type: undefined, decorators: [{ type: Inject, args: [STORE_BRANCH,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [STORE_DISPATCH_CHANNEL,] }] },
    { type: FeaturesService }
];

/**
 * @deprecated Will be removed in v7.0.0
 */
const ALLOW_NGRX_IN_ROOT = {
    name: 'ALLOW_NGRX_IN_ROOT',
    description: 'StoreModule is deprecated - use BackbaseStoreModule instead',
};
/**
 * @deprecated
 */
class StoreModule {
    constructor(featuresService) {
        if (featuresService.isEnabled(ALLOW_NGRX_IN_ROOT)) {
            throw new Error('StoreModule is deprecated - use BackbaseStoreModule instead');
        }
    }
}
StoreModule.ɵfac = function StoreModule_Factory(t) { return new (t || StoreModule)(ɵngcc0.ɵɵinject(ɵngcc2.FeaturesService)); };
StoreModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: StoreModule });
StoreModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [StoreBroker], imports: [[
            EffectsModule.forRoot([]),
            StoreModule$1.forRoot({}),
            FutureFeaturesModule.allowOptIn([ALLOW_NGRX_IN_ROOT, ENFORCE_INJECTOR_FOR_CREATE_STORE]),
        ]] });
StoreModule.ctorParameters = () => [
    { type: FeaturesService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StoreModule, [{
        type: NgModule,
        args: [{
                imports: [
                    EffectsModule.forRoot([]),
                    StoreModule$1.forRoot({}),
                    FutureFeaturesModule.allowOptIn([ALLOW_NGRX_IN_ROOT, ENFORCE_INJECTOR_FOR_CREATE_STORE]),
                ],
                providers: [StoreBroker]
            }]
    }], function () { return [{ type: ɵngcc2.FeaturesService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StoreModule, { imports: [ɵngcc3.EffectsRootModule, ɵngcc4.StoreRootModule, ɵngcc2.FutureFeaturesModule] }); })();
/**
 * @deprecated Will be removed in v7.0.0
 */
class BackbaseStoreModule {
}
BackbaseStoreModule.ɵfac = function BackbaseStoreModule_Factory(t) { return new (t || BackbaseStoreModule)(); };
BackbaseStoreModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BackbaseStoreModule });
BackbaseStoreModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[EffectsModule, StoreModule$1, FutureFeaturesModule.allowOptIn([ENFORCE_INJECTOR_FOR_CREATE_STORE])]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BackbaseStoreModule, [{
        type: NgModule,
        args: [{
                imports: [EffectsModule, StoreModule$1, FutureFeaturesModule.allowOptIn([ENFORCE_INJECTOR_FOR_CREATE_STORE])]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BackbaseStoreModule, { imports: function () { return [EffectsModule, StoreModule$1, ɵngcc2.FutureFeaturesModule]; } }); })();

/**
 * Generated bundle index. Do not edit.
 */

export { BackbaseStoreModule, Effect, InitializeStoreAction, StoreFactory, ofStoreInit, ofType, typePropertyIsNotAllowedMsg, STORE_BRANCH as ɵSTORE_BRANCH, STORE_DISPATCH_CHANNEL as ɵSTORE_DISPATCH_CHANNEL, StoreBroker as ɵStoreBroker, ENFORCE_INJECTOR_FOR_CREATE_STORE as ɵa };

//# sourceMappingURL=backbase-foundation-ang-store.js.map