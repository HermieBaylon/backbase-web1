import { LocationStrategy, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { InjectionToken, isDevMode, Injectable, Optional, Inject, NgZone, Component, Injector, ComponentFactoryResolver, HostBinding, Input, NgModuleFactory, Compiler, ViewChild, ViewContainerRef, ChangeDetectionStrategy, Directive, ElementRef, Renderer2, HostListener, Attribute, ContentChildren, EventEmitter, ChangeDetectorRef, Output, ANALYZE_FOR_ENTRY_COMPONENTS, NgModule, APP_BOOTSTRAP_LISTENER, TemplateRef } from '@angular/core';
import { ActivatedRoute, PRIMARY_OUTLET, UrlSegment, UrlSegmentGroup, Router, NavigationEnd, RouterOutlet, ChildrenOutletContexts, RouterModule } from '@angular/router';
import { of, BehaviorSubject, combineLatest, merge, Subject, ReplaySubject, from, throwError, race, asyncScheduler } from 'rxjs';
import { PAGE_CONFIG, PUBSUB, ɵEXTERNAL_SERVICES } from '@backbase/foundation-ang/web-sdk';
import { switchMap, map as map$1, scan, shareReplay, distinctUntilChanged, startWith, pluck, filter, publishReplay, take, mapTo, debounceTime, first, withLatestFrom, takeUntil, tap, mergeMap, pairwise, last, catchError, flatMap as flatMap$1, skip, concatMap } from 'rxjs/operators';
import { serializerDeserializer, CommunicationDefinition } from '@backbase/communication-property';
import { __awaiter } from 'tslib';
import { FeaturesService, LOG_DEPRECATIONS_CONFIG, ENABLED_FEATURES_CONFIG, DeprecationsService } from '@backbase/foundation-ang/future';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/router';
import * as ɵngcc2 from '@angular/common';

function RouteComponent_ng_container_0_router_outlet_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "router-outlet");
} }
function RouteComponent_ng_container_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "bb-chrome", 3);
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().ngIf;
    ɵngcc0.ɵɵproperty("item", item_r1);
} }
function RouteComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, RouteComponent_ng_container_0_router_outlet_1_Template, 1, 0, "router-outlet", 1);
    ɵngcc0.ɵɵtemplate(2, RouteComponent_ng_container_0_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.ngIf;
    const _r3 = ɵngcc0.ɵɵreference(3);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isModule(item_r1.value))("ngIfElse", _r3);
} }
function AreaComponent_ng_container_0_router_outlet_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "router-outlet");
} }
function AreaComponent_ng_container_0_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "bb-chrome", 3);
} if (rf & 2) {
    const item_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("item", item_r1);
} }
function AreaComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, AreaComponent_ng_container_0_router_outlet_1_Template, 1, 0, "router-outlet", 1);
    ɵngcc0.ɵɵtemplate(2, AreaComponent_ng_container_0_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainer(4);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r1 = ctx.$implicit;
    const _r3 = ɵngcc0.ɵɵreference(3);
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.isModule(item_r1.value))("ngIfElse", _r3);
} }
const _c0 = ["vc"];
const _c1 = ["stepupContainer"];
const _c2 = ["sessionTimeoutContainer"];
export { DeprecationsService, FeaturesService, FutureFeaturesModule } from '@backbase/foundation-ang/future';
import { ɵSTORE_BRANCH, ɵSTORE_DISPATCH_CHANNEL, StoreFactory, ɵStoreBroker } from '@backbase/foundation-ang/store';
import { HttpClient, HTTP_INTERCEPTORS } from '@angular/common/http';

/**
 * @deprecated Will be removed in v7.0.0
 */
const CONFIG_ASSETS = new InjectionToken('@backbase/foundation Assets Service Configuration');
const DEFAULT_STATIC_ROOT = '/';
const DEFAULT_STATIC_ITEM_NAME = '';
/**
 * @deprecated Will be removed in v7.0.0
 */
class AssetsService {
    constructor(pageConfig, assetsConfig) {
        this.pageConfig = pageConfig;
        this.assetsConfig = assetsConfig;
        if (!pageConfig && isDevMode()) {
            console.warn(`pageConfig is not provided which may impact the path that is resolving assets
         please include *either* the 'WebSdkModule.forRoot(...)' in your AppModule (for CDN deployment) or WebSdkApiModule
          (for CX deployment)`);
        }
    }
    createAssetsResolver(config) {
        const widgetName = config.widgetName;
        const assetsIdResolver = config.getURIFromAssetID;
        const staticRoot = this.pageConfig ? this.pageConfig.staticResourcesRoot : DEFAULT_STATIC_ROOT;
        const staticItemName = this.assetsConfig ? this.assetsConfig.assetsStaticItemName : DEFAULT_STATIC_ITEM_NAME;
        return (assetId) => {
            if (!assetId.length) {
                return of('');
            }
            return of([staticRoot, staticItemName, 'assets', widgetName, assetsIdResolver(assetId)]
                .filter(Boolean)
                .map(str => str.replace(/\/$/, ''))
                .join('/'));
        };
    }
}
AssetsService.ɵfac = function AssetsService_Factory(t) { return new (t || AssetsService)(ɵngcc0.ɵɵinject(PAGE_CONFIG, 8), ɵngcc0.ɵɵinject(CONFIG_ASSETS, 8)); };
AssetsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: AssetsService, factory: AssetsService.ɵfac });
AssetsService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [PAGE_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG_ASSETS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AssetsService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [PAGE_CONFIG]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CONFIG_ASSETS]
            }] }]; }, null); })();

function equal(a, b) {
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
    return a === b;
}
/**
 * Allow the processing of Properties as an array of pairs.
 *
 * @param process The processing to apply to the property pairs; mapping, filtering, etc.
 * @param properties
 */
const propertiesAsPairs = (process, properties) => {
    const pairs = process(Object.entries(properties));
    return pairs.reduce((acc, [name, value]) => (Object.assign(Object.assign({}, acc), { [name]: value })), {});
};
/**
 * Returns a subset of the properties that start
 * with a given prefix, and also removes the prefix from the name
 * of the property.
 *
 * @param prefix
 * @param properties
 */
const propertiesByPrefix = (prefix, properties) => propertiesAsPairs(pairs => pairs
    .filter(([name]) => name.startsWith(prefix))
    .map(([name, value]) => [name.substring(prefix.length), value]), properties);

class AppConfigService {
    constructor() {
        this.config = new BehaviorSubject({});
        this.propertyPrefix = 'AppConfig.';
    }
    get prefix() {
        return this.propertyPrefix;
    }
    getConfig() {
        return this.config.asObservable();
    }
    setConfig(config) {
        this.config.next(config);
    }
}
AppConfigService.ɵfac = function AppConfigService_Factory(t) { return new (t || AppConfigService)(); };
AppConfigService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AppConfigService_Factory() { return new AppConfigService(); }, token: AppConfigService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AppConfigService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

const map = (callbackfn, arr) => arr.map(callbackfn);
const flatten = (arr) => arr.reduce((acc, a) => [...acc, ...a], []);
const flatMap = (callbackfn, arr) => flatten(map(callbackfn, arr));
const uniq = (array) => Array.from(new Set(array));
const hasDuplicates = (array) => array.length !== uniq(array).length;
/**
 * Creates a new list out of the two supplied by pairing up equally-positioned
 * items from both lists. The returned list is the length of the longer of two
 * lists. If one of the lists is shorter, the values will be set to "undefined".
 *
 * @param left
 * @param right
 */
const pairs = (left, right) => {
    const max = Math.max(left.length, right.length);
    let idx = 0;
    const returnZip = [];
    while (idx < max) {
        returnZip[idx] = [left[idx], right[idx]];
        idx++;
    }
    return returnZip;
};
/**
 * This helper checks if the value is array of strings.
 * @param value a value to be evaluated
 * @returns true for array of strings and false for any other values
 */
const isArrayOfStrings = (value) => Array.isArray(value) && value.every(item => typeof item === 'string');

/**
 * This helper determines container objects from any other ones.
 * @param item an item to be evaluated
 * @returns true for containers and false for widgets and any other objects
 */
const isContainer = (item) => 'name' in item && 'properties' in item && 'children' in item;
/**
 * Returns the elements of a tree with the children that meet the condition specified in a predicate function.
 * @param item an item whose children need to be filtered
 * @param predicate the filter method called for each child. It should return boolean
 */
const filterChildren = (item, predicate) => {
    return isContainer(item)
        ? Object.assign(Object.assign({}, item), { children: item.children.map(child => filterChildren(child, predicate)).filter(predicate) }) : item;
};

const treeValue = (t) => t.value;
const ɵ0$f = treeValue;
/**
 * Abstract tree representation.
 */
class Tree {
    constructor(
    /**
     * The value of this node
     */
    value, 
    /**
     * The children of this node
     */
    children) {
        this.value = value;
        this.children = children;
    }
    map(callbackfn) {
        const newChildren = this.children.map(childTree => childTree.map(callbackfn));
        return new Tree(callbackfn(this.value, this.children.map(treeValue), newChildren.map(treeValue)), newChildren);
    }
    /**
     * Flattens the tree into a flat array of tree nodes.
     *
     * The tree is flattened by in order of depth-first-preorder-traversal.
     */
    flatten() {
        return [this, ...flatMap(child => child.flatten(), this.children)];
    }
    pathTo(value) {
        if (this.value === value) {
            return [this.value];
        }
        else {
            for (const child of this.children) {
                const childPath = child.pathTo(value);
                if (childPath.length !== 0) {
                    return [this.value, ...childPath];
                }
            }
            return [];
        }
    }
    lowestCommonAncestor(left, right) {
        const leftPath = new Set(this.pathTo(left));
        return this.pathTo(right)
            .reverse()
            .find(candidate => leftPath.has(candidate));
    }
}
/**
 * @description
 * This is an operator that can be used with an Observable's `pipe`.
 *
 * The piped observable should be an observable of an array.
 *
 * The source array is mapped over with the provided callback function, and the
 * callback function should take an item (T) from the source array, and return an
 * *observable* of a new item (R).
 *
 * The result is a new observable of an array the same length as the source array
 * but with the Ts mapped to Rs.
 *
 * This is useful for mapping over the observable children of node in the model tree.
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * const children: ObservableTree<ItemModel> = this.model.children;
 * const titleProperties: Observable<Array<string>> = this.model.children.pipe(
 *   mapObservableArray(item => item.value.property<string>('title', 'Default Title'))
 * );
 * ```
 * @param callback Function that produces an *observable* element of the new Array
 */
const mapObservableArray = function (callback) {
    return (source) => {
        return source.pipe(switchMap((tArray) => combineLatest(tArray.map(callback))));
    };
};
/**
 * An tree where each node's children are observable.
 */
class ObservableTree {
    constructor(
    /**
     * The value of this node
     */
    value, initialChildren, insertions, removals) {
        this.value = value;
        this.insertions = insertions;
        this.removals = removals;
        // Reducers to update children state
        this.initialChildren = of((acc) => acc); // identity reducer for initial value
        this.insertUpdates = this.insertions.pipe(map$1(({ item, index }) => (children) => [...children.slice(0, index), item, ...children.slice(index)]));
        this.removalUpdates = this.removals.pipe(map$1((index) => (children) => {
            const newChildren = [...children];
            newChildren.splice(index, 1);
            return newChildren;
        }));
        // Combine reducers to a single stream
        this.reducers = merge(this.initialChildren, this.insertUpdates, this.removalUpdates);
        this.children = this.reducers.pipe(scan((currentChildren, updateFn) => updateFn(currentChildren), initialChildren), shareReplay(1));
    }
    /**
     * Find a node in the tree. Returns the result as an observable.
     *
     * If the element is found it is emitted, otherwise, the result emits undefined.
     *
     * The result observable will only emit again if the found node changes (ie: if
     * it is added or removed, or if it finds a different node).
     *
     * @param predicate predicate is called once for each node of the tree, until a
     * node is found. The predicate will be called again every time the tree changes
     * (ie: a node in the tree is added or removed). The predicate is called in order
     * of depth-first-preorder-traversal.
     */
    find(predicate) {
        return this.flatten().pipe(map$1(nodes => nodes.find(node => predicate(node.value))), distinctUntilChanged());
    }
    pathTo(value) {
        return this.toTree().pipe(map$1((tree) => tree.pathTo(value)), distinctUntilChanged());
    }
    lowestCommonAncestor(left, right) {
        return this.toTree().pipe(map$1((tree) => tree.lowestCommonAncestor(left, right)), distinctUntilChanged());
    }
    filter(predicate) {
        return this.flatten().pipe(map$1(nodes => nodes.filter(node => predicate(node.value))), distinctUntilChanged());
    }
    /**
     * Flattens a tree into a single array of nodes. The result nodes are still trees.
     *
     * The tree is flattened in order of depth-first-preorder-traversal.
     *
     * The result is returned as an observable and re-emits every time a node is added
     * or removed from the tree.
     */
    flatten() {
        return this.children.pipe(switchMap(children => (children.length === 0 ? of([]) : combineLatest(children.map(child => child.flatten())))), map$1(flatten), map$1(flat => [this, ...flat]));
    }
    /**
     * Takes a snapshot of the tree.
     */
    toTree() {
        return this.children.pipe(switchMap(children => {
            const mappedChildren$ = children.length === 0 ? of([]) : combineLatest(children.map(child => child.toTree()));
            return mappedChildren$.pipe(map$1((mappedChildren) => new Tree(this.value, mappedChildren)));
        }));
    }
}
/**
 * Like combineLatest in rxjs, but for a tree of observables, instead of
 * an array of observables.
 */
function combineTree(tree) {
    // Convert children from Array<Tree<Observable<T>>> to Observable<Array<Tree<T>>>
    const children$ = tree.children.length === 0 ? of([]) : combineLatest(tree.children.map(combineTree));
    return combineLatest([tree.value, children$]).pipe(map$1(([value, children]) => new Tree(value, children)));
}
/**
 * Extracts a branch from a tree that starts at the root, and ends at the leaf
 * node, as determined by the predicate (returns a linked list).
 *
 * If the element is not found, the result is undefined.
 *
 * @param predicate predicate is called once for each node of the tree, until a
 * node is found. The predicate is called in order of depth-first-preorder-traversal.
 */
const treeBranch = (tree, predicate) => {
    const walkTree = (treeInner, index, parentTree) => {
        if (predicate(treeInner, index, parentTree)) {
            return {
                value: treeInner,
            };
        }
        if (!treeInner.children) {
            return undefined;
        }
        for (let i = 0; i < treeInner.children.length; i++) {
            const foundInChild = walkTree(treeInner.children[i], i, treeInner);
            if (foundInChild) {
                return {
                    value: treeInner,
                    next: foundInChild,
                };
            }
        }
        return undefined;
    };
    return walkTree(tree);
};

/**
 * @deprecated Will be removed in v7.0.0
 */
class ItemModel {
    constructor(name, initialProperties, propertyUpdates) {
        this.name = name;
        const applyPropertyUpdate = (currentProperties, update) => {
            return Object.assign(Object.assign({}, currentProperties), update);
        };
        this.properties = propertyUpdates.pipe(startWith(initialProperties), scan(applyPropertyUpdate), shareReplay(1));
        if (initialProperties.classId === undefined) {
            throw new Error(`Missing classId property for ${name}`);
        }
        this.ɵclassId = initialProperties.classId;
        this.ɵoutputProperties = this.outputProperties(initialProperties);
        this.ɵinputProperties = this.inputProperties(initialProperties);
        this.ɵproperties = this.nonIOProperties(initialProperties);
    }
    property(propertyName, defaultValue) {
        return this.properties.pipe(pluck(propertyName), map$1(propertyValue => (propertyValue === undefined || propertyValue === null ? defaultValue : propertyValue)), distinctUntilChanged((a, b) => {
            if (a === undefined && b === undefined) {
                return true;
            }
            if (a === undefined) {
                return false;
            }
            if (b === undefined) {
                return false;
            }
            return equal(a, b);
        }));
    }
    outputProperties(properties) {
        return propertiesByPrefix('output.', properties);
    }
    inputProperties(properties) {
        return propertiesByPrefix('input.', properties);
    }
    nonIOProperties(properties) {
        return propertiesAsPairs(pairs => pairs.filter(([name]) => !name.startsWith('input.') && !name.startsWith('output.')), properties);
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 */
class ItemModelTree extends ObservableTree {
}

const ROOT_COMPONENT_CLASS_ID = 'RootComponent';
const DEFAULT_ROOT_NAME = 'bb-root-empty';
const isInsert = (update) => !!(update.item && update.itemLocation);
const isPropertyUpdate = (update) => !!(update.name && update.properties);
const isRemovalUpdate = (update) => !!(update && 'parentName' in update && 'index' in update);
class CommunicationInputs {
    constructor(properties) {
        this.properties = properties;
    }
    static fromProperties(properties) {
        return new CommunicationInputs(new Map(Object.entries(properties)
            .filter((property) => typeof property[1] === 'string')
            .map(([propertyName, propertyValue]) => [propertyName, serializerDeserializer.fromProperty(propertyValue)])
            .filter((property) => property[1] !== undefined)));
    }
    hasInputFor(communicationDefinition) {
        return (Array.from(this.properties.values()).find(candidate => communicationDefinition.equals(candidate)) !== undefined);
    }
}
/**
 * The root container is basically the page model, but we don't assume that the
 * angular app is the entire page. It could just be a subset of the page model,
 * hence we call it "root container"
 *
 * @internal
 */
class ӨRootContainerService {
    constructor() {
        // The websdk commands mapped to observables.
        this.propertyUpdates = new Subject();
        this.inserts = new Subject();
        this.removals = new Subject();
        this.modelUpdates = merge(this.propertyUpdates, this.inserts, this.removals);
        this.defaultValue = {
            name: DEFAULT_ROOT_NAME,
            properties: { classId: ROOT_COMPONENT_CLASS_ID },
            children: [],
        };
        this.rootContainerItem = new BehaviorSubject(this.defaultValue);
        this.model = this.rootContainerItem.pipe(filter(container => !this.isDefaultContainer(container.name)), // skip the empty state
        map$1(c => this.createInitialModelState(c)), shareReplay(1));
    }
    createInitialModelState({ name, properties, children }) {
        const initialRootContainerProperties = Object.assign(Object.assign({}, properties), { classId: ROOT_COMPONENT_CLASS_ID });
        return this.createModelStateNode({
            name,
            properties: initialRootContainerProperties,
            children,
        });
    }
    createModelStateNode(item) {
        // Filter property updates to just the updates for this item.
        const propertyUpdates = this.propertyUpdates.pipe(filter(update => update.name === item.name), pluck('properties'));
        // Recursively create the children.
        const childNodes = isContainer(item)
            ? item.children.map(this.createModelStateNode.bind(this))
            : [];
        let insertions;
        let removals;
        if (isContainer(item)) {
            // Filter container updates for this item (inserts and removes)
            insertions = this.inserts.pipe(filter(insert => !!insert.itemLocation && insert.itemLocation.parentName === item.name), map$1(insert => ({
                item: this.createModelStateNode(insert.item),
                index: insert.itemLocation ? insert.itemLocation.index : 0,
            })));
            removals = this.removals.pipe(filter((removal) => !!removal && removal.parentName === item.name), pluck('index'));
        }
        else {
            insertions = of();
            removals = of();
        }
        // Create the node itself.
        return new ObservableTree(new ItemModel(item.name, item.properties, propertyUpdates), childNodes, insertions, removals);
    }
    get rootName() {
        return this.rootContainerItem.getValue().name;
    }
    isDefaultContainer(name) {
        return name === DEFAULT_ROOT_NAME;
    }
    isBootstrapped() {
        return !this.isDefaultContainer(this.rootName);
    }
    updateItem(name, properties) {
        this.propertyUpdates.next({ name, properties: properties });
    }
    insertItem(item, itemLocation) {
        if (!this.isBootstrapped()) {
            this.rootContainerItem.next(item);
        }
        else {
            this.inserts.next({ item, itemLocation });
        }
    }
    removeItem(itemName, itemLocation) {
        if (this.rootName === itemName) {
            this.rootContainerItem.next(this.defaultValue);
        }
        else {
            this.removals.next(itemLocation);
        }
    }
    filter(predicate) {
        return this.model.pipe(switchMap(model => model.filter(predicate)));
    }
    getCommunicationGroupItems(groupDefinition) {
        return this.filter((item) => CommunicationInputs.fromProperties(item.ɵinputProperties).hasInputFor(groupDefinition)).pipe(map$1(nodes => nodes.map(node => node.value)));
    }
    // The only case where there will not be a common ancestor (i.e. return `undefined`) is if there are
    // no items with inputs in the communication group.
    commonAncestor(groupDefinition) {
        return combineLatest([
            this.model.pipe(switchMap(model => model.toTree())),
            this.getCommunicationGroupItems(groupDefinition),
        ]).pipe(map$1(([tree, [first, ...items]]) => {
            let lowest = first;
            for (const item of items) {
                const newLowest = tree.lowestCommonAncestor(lowest, item);
                if (newLowest === undefined) {
                    return undefined;
                }
                else {
                    lowest = newLowest;
                }
            }
            return lowest;
        }));
    }
}
ӨRootContainerService.ɵfac = function ӨRootContainerService_Factory(t) { return new (t || ӨRootContainerService)(); };
ӨRootContainerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ӨRootContainerService_Factory() { return new ӨRootContainerService(); }, token: ӨRootContainerService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ӨRootContainerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

var LifecycleEventKind;
(function (LifecycleEventKind) {
    LifecycleEventKind["Create"] = "create";
    LifecycleEventKind["Remove"] = "remove";
})(LifecycleEventKind || (LifecycleEventKind = {}));
class ItemLifecycleService {
    constructor() {
        this.lifecycleEvents = new Subject();
    }
    onCreate(itemModel, component) {
        this.lifecycleEvents.next({
            kind: LifecycleEventKind.Create,
            itemModel,
            component,
        });
    }
    onRemove(itemModel, component) {
        this.lifecycleEvents.next({
            kind: LifecycleEventKind.Remove,
            itemModel,
            component,
        });
    }
    fromItem(name) {
        return this.lifecycleEvents.pipe(filter((lcEvent) => name === lcEvent.itemModel.value.name));
    }
    whenCreate(name) {
        const nameFilter = name ? (currentName) => currentName === name : () => true;
        return this.lifecycleEvents.pipe(filter((lcEvent) => LifecycleEventKind.Create === lcEvent.kind && nameFilter(lcEvent.itemModel.value.name)));
    }
    whenRemove(name) {
        const nameFilter = name ? (currentName) => currentName === name : () => true;
        return this.lifecycleEvents.pipe(filter((lcEvent) => LifecycleEventKind.Remove === lcEvent.kind && nameFilter(lcEvent.itemModel.value.name)));
    }
}
ItemLifecycleService.ɵfac = function ItemLifecycleService_Factory(t) { return new (t || ItemLifecycleService)(); };
ItemLifecycleService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ItemLifecycleService_Factory() { return new ItemLifecycleService(); }, token: ItemLifecycleService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemLifecycleService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

/**
 * @deprecated Will be removed in v7.0.0
 */
const isRootContainerItem = (item) => !item.properties || !item.properties.classId;
/**
 * @deprecated Will be removed in v7.0.0
 */
class BackbaseConnector {
    /**
     * BackbaseConnectorService constructor
     * @param zone NgZone to be used for manipulations with an item
     * @param componentInjectors Backbase core components injector service to handle the model
     */
    constructor(zone, appConfig, rootContainer, lifeCycle) {
        this.zone = zone;
        this.appConfig = appConfig;
        this.rootContainer = rootContainer;
        this.lifeCycle = lifeCycle;
    }
    filterItem(item) {
        const features = propertiesByPrefix(this.appConfig.prefix, item.properties);
        this.appConfig.setConfig(features);
        return filterChildren(item, child => {
            const itemFeatures = child.properties.features;
            return (!itemFeatures ||
                !isArrayOfStrings(itemFeatures) ||
                itemFeatures.some(requiredFeature => features[requiredFeature] !== false));
        });
    }
    /**
     * Bootstrap function to be called on page model initialization,
     * and when new item added to the model (dropped on the page).
     * @param item Item to bootstrap
     * @param itemLocation Location of the item
     */
    bootstrap(item, itemLocation) {
        return this.zone.run(() => {
            let event;
            if (isRootContainerItem(item)) {
                event = this.lifeCycle.whenCreate(undefined).pipe(publishReplay(1));
            }
            else {
                event = this.lifeCycle.fromItem(item.name).pipe(publishReplay(1));
            }
            event.connect();
            const itemToInsert = this.rootContainer.isBootstrapped() ? item : this.filterItem(item);
            this.rootContainer.insertItem(itemToInsert, itemLocation);
            return event.pipe(take(1), mapTo(true)).toPromise();
        });
    }
    /**
     * Update function will be called when properties are changed for
     * one of the existing items on a page.
     * @param item Updated item
     * @param itemLocation Location of the item
     * @param changes Object which contains only changed properties and their values
     */
    update(item, _, itemProperties) {
        return this.zone.run(() => {
            this.rootContainer.updateItem(item.name, itemProperties);
            return this.lifeCycle.fromItem(item.name).pipe(take(1), mapTo(undefined)).toPromise();
        });
    }
    /**
     * Remove function will be called when existing item is removed from the page.
     * @param item Item to remove
     * @param itemLocation Location of the item
     */
    remove(item, itemLocation) {
        return this.zone.run(() => {
            this.rootContainer.removeItem(item.name, itemLocation);
            return this.lifeCycle.whenRemove().pipe(debounceTime(20), take(1), mapTo(undefined)).toPromise();
        });
    }
}
BackbaseConnector.ɵfac = function BackbaseConnector_Factory(t) { return new (t || BackbaseConnector)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(AppConfigService), ɵngcc0.ɵɵinject(ӨRootContainerService), ɵngcc0.ɵɵinject(ItemLifecycleService)); };
BackbaseConnector.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: BackbaseConnector, factory: BackbaseConnector.ɵfac });
BackbaseConnector.ctorParameters = () => [
    { type: NgZone },
    { type: AppConfigService },
    { type: ӨRootContainerService },
    { type: ItemLifecycleService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BackbaseConnector, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: AppConfigService }, { type: ӨRootContainerService }, { type: ItemLifecycleService }]; }, null); })();

const LAZY_MAP = new InjectionToken('Lazy load map');

/**
 * ComponentRegistry configuration injection token
 */
const CONFIG_COMPONENT_CLASS_MAP = new InjectionToken('@backbase/foundation Components Registry');
/**
 * ItemRegistryService stores a hashMap
 * of the components included into the app and
 * avaliable for usage. It's meant to be an extension
 * point which is used by a developer.
 */
class ItemRegistryService {
    /**
     * ItemRegistryService constructor which allows to define components
     * included into application
     * @param ComponentRegistry a hashMap of the component classes to be added
     */
    constructor(classMaps, lazyConfig) {
        this.itemRegistry = new BehaviorSubject(new Map(classMaps
            ? classMaps.reduce((acc, classMap) => [...acc, ...Object.entries(classMap)], [])
            : undefined));
        this.lazyModuleConfig = (lazyConfig || []).filter(isLazyModuleConfig);
    }
    entries() {
        return Array.from(this.itemRegistry.value.entries());
    }
    add(classId, componentClass) {
        this.itemRegistry.next(new Map([...this.entries(), [classId, componentClass]]));
    }
    has(classId) {
        return this.itemRegistry.value.has(classId);
    }
    /**
     * This method allows to retrieve Component by it's classId
     * @param classId classId key to get a component class
     * @returns componentType to be used by a ComponentFactoryResolver
     */
    getComponentValue(classId) {
        return this.itemRegistry.value.get(classId);
    }
    getComponent(classId) {
        return this.itemRegistry
            .pipe(map$1(registry => registry.get(classId)), filter((componentClass) => componentClass !== undefined), take(1))
            .toPromise();
    }
    getModuleLoader(classId) {
        const lazyModuleConfigItem = this.lazyModuleConfig.find(config => config.module === classId);
        return lazyModuleConfigItem && lazyModuleConfigItem.loadChildren;
    }
}
ItemRegistryService.ɵfac = function ItemRegistryService_Factory(t) { return new (t || ItemRegistryService)(ɵngcc0.ɵɵinject(CONFIG_COMPONENT_CLASS_MAP, 8), ɵngcc0.ɵɵinject(LAZY_MAP, 8)); };
ItemRegistryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ItemRegistryService, factory: ItemRegistryService.ɵfac });
ItemRegistryService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CONFIG_COMPONENT_CLASS_MAP,] }, { type: Optional }] },
    { type: Array, decorators: [{ type: Inject, args: [LAZY_MAP,] }, { type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemRegistryService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [CONFIG_COMPONENT_CLASS_MAP]
            }, {
                type: Optional
            }] }, { type: Array, decorators: [{
                type: Inject,
                args: [LAZY_MAP]
            }, {
                type: Optional
            }] }]; }, null); })();
function isLazyModuleConfig(config) {
    return !!config.module;
}

class RouteComponent {
    constructor(route, tree, itemRegistry) {
        this.route = route;
        this.tree = tree;
        this.itemRegistry = itemRegistry;
        this.item = this.route.data.pipe(pluck('renderChild'), switchMap(renderChild => this.tree.find(item => item.name === renderChild)), filter((a) => a !== undefined));
    }
    static isItemInRoute(itemName, route) {
        if (!route.data || !route.data.renderChild) {
            throw new Error(`@backbase/foundation Invalid route for RouteComponent. Missing data renderChild: ${route}`);
        }
        return route.data.renderChild === itemName;
    }
    /**
     * @internal
     */
    isModule(model) {
        return !!this.itemRegistry.getModuleLoader(model.ɵclassId);
    }
}
RouteComponent.ɵfac = function RouteComponent_Factory(t) { return new (t || RouteComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ItemModelTree), ɵngcc0.ɵɵdirectiveInject(ItemRegistryService)); };
RouteComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RouteComponent, selectors: [["bb-route"]], decls: 2, vars: 3, consts: [[4, "ngIf"], [4, "ngIf", "ngIfElse"], ["renderModel", ""], [3, "item"]], template: function RouteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, RouteComponent_ng_container_0_Template, 4, 2, "ng-container", 0);
        ɵngcc0.ɵɵpipe(1, "async");
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.item));
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc1.RouterOutlet, ChromeComponent]; }, pipes: function () { return [ɵngcc2.AsyncPipe]; }, encapsulation: 2 });
RouteComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: ItemModelTree },
    { type: ItemRegistryService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouteComponent, [{
        type: Component,
        args: [{
                selector: 'bb-route',
                template: `
    <ng-container *ngIf="item | async as item">
      <router-outlet *ngIf="isModule(item.value); else renderModel"></router-outlet>
      <ng-template #renderModel><bb-chrome [item]="item"></bb-chrome></ng-template>
    </ng-container>
  `
            }]
    }], function () { return [{ type: ɵngcc1.ActivatedRoute }, { type: ItemModelTree }, { type: ItemRegistryService }]; }, null); })();

class DefaultContainerStrategy {
    itemRoutePath(route, index) {
        if (route) {
            return route;
        }
        return (index + 1).toString();
    }
    // routes is guaranteed to have 1 item, but I don't know how to type that
    defaultRoute(routes) {
        const defaultRoute = routes[0];
        // Default behaviour, redirect to the first tab (primary route).
        return {
            path: '',
            redirectTo: defaultRoute.path,
            pathMatch: 'full',
        };
    }
    itemRoute(child, childrenRoutes, index) {
        return {
            path: this.itemRoutePath(child.route, index),
            component: RouteComponent,
            canActivate: child.canActivate,
            data: {
                renderChild: child.name,
                custom: child.routeData,
            },
            children: childrenRoutes,
        };
    }
    findChildrenRoutes(childrenItemRoutes, item) {
        const itemRoutes = childrenItemRoutes.find(child => child.item === item.name);
        return itemRoutes ? itemRoutes.routes : [];
    }
    childrenRoutes(children, childrenItemRoutes) {
        return children.map((child, index) => this.itemRoute(child, this.findChildrenRoutes(childrenItemRoutes, child), index));
    }
    getRoutes(item, children, childrenRoutes) {
        const childRoutes = this.childrenRoutes(children, childrenRoutes);
        const defaultRoutes = childRoutes.length && item.hasDefault ? [this.defaultRoute(childRoutes)] : [];
        const routes = [...childRoutes, ...defaultRoutes];
        if (item.canActivateChild.length) {
            return [
                {
                    path: '',
                    canActivateChild: item.canActivateChild,
                    children: routes,
                },
            ];
        }
        else {
            return routes;
        }
    }
}

class StaticRoutesStrategy {
    constructor(routes = []) {
        this.routes = routes;
    }
    getRoutes() {
        return this.routes;
    }
}

/**
 * Symbol used to keep internal Backbase routing information
 * in an Angular component class
 */
const routingStrategyField = Symbol('ΩRoutingStrategy');
/**
 * RoutingStrategyToken enum with routing strategy tokens
 */
var RoutingStrategyToken;
(function (RoutingStrategyToken) {
    RoutingStrategyToken["STATIC"] = "StaticRoutesStrategy";
    RoutingStrategyToken["CONTAINERS"] = "DefaultContainerStrategy";
})(RoutingStrategyToken || (RoutingStrategyToken = {}));
/**
 * RoutableContainer decorator is used to mark an item as
 * routable. It makes the routing config service to use default
 * strategy for containers.
 */
function RoutableContainer() {
    return function (constructor) {
        constructor[routingStrategyField] = {
            token: RoutingStrategyToken.CONTAINERS,
        };
        return constructor;
    };
}
/**
 * RoutableWidget decorator is used to define widget's internal routes.
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * @Component({
 *   selector: 'bb-todo-widget',
 *   template: `
 *     <bb-router-outlet></bb-router-outlet>
 *   `,
 *   changeDetection: ChangeDetectionStrategy.OnPush,
 *   providers: [RouterService, TodoNavigationService],
 * })
 * @RoutableWidget({
 *   routes: [
 *     { path: '', component: TodoListContainerComponent },
 *     { path: ':id', component: TodoDetailContainerComponent },
 *     { path: 'edit/:id', component: TodoFormContainerComponent },
 *   ],
 * })
 * export class TodoWidgetComponent {}
 * ```
 *
 * @param config Configuration object of the RoutableWidget decorator
 */
function RoutableWidget(config) {
    return function (constructor) {
        constructor[routingStrategyField] = {
            token: RoutingStrategyToken.STATIC,
            routes: config.routes,
        };
        return constructor;
    };
}
const createRouteComponentStrategy = (component) => {
    const isItemInRoute = component === RouteComponent ? component.isItemInRoute : () => false;
    return {
        isItemInRoute,
    };
};
const createRoutingStrategy = (componentClass) => {
    const strategy = componentClass[routingStrategyField];
    if (strategy === undefined) {
        return undefined;
    }
    switch (strategy.token) {
        case RoutingStrategyToken.CONTAINERS:
            return new DefaultContainerStrategy();
        case RoutingStrategyToken.STATIC:
            return new StaticRoutesStrategy(strategy.routes);
        default:
            return undefined;
    }
};
const isRoutableItem = (componentClass) => {
    const strategy = componentClass[routingStrategyField];
    return (!!strategy &&
        strategy.token &&
        (strategy.token === RoutingStrategyToken.CONTAINERS || strategy.token === RoutingStrategyToken.STATIC));
};
/**
 * CopyRoutes decorator is used to re-use the internal routing configuration from an existing widget.
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * @Component({
 *   selector: 'my-todo-widget',
 *   template: `
 *     <h1>My Custom Todo Widget</h1>
 *     <bb-router-outlet></bb-router-outlet>
 *   `,
 * })
 * @CopyRoutes(TodoWidgetComponent)
 * export class MyTodoWidgetComponent {}
 * ```
 *
 * @param from The Widget Component class from which to copy the routing configuration
 */
// Note: `from` should be `{ [routingStrategyField]: RoutingStrategyDefinition }` but the type checker
// can't resolve properties dynamically added by decorators.
function CopyRoutes(componentClass, customize = routes => routes) {
    return function (constructor) {
        const definition = componentClass[routingStrategyField];
        if (definition === undefined || definition.token !== RoutingStrategyToken.STATIC) {
            return constructor;
        }
        constructor[routingStrategyField] = {
            token: RoutingStrategyToken.STATIC,
            routes: customize(definition.routes),
        };
        return constructor;
    };
}

/**
 * Special type to flag an outlet as having a collision. This
 * enables us to create the outlet tree, and name the outlet, but
 * also flag the item as having a collision with another item.
 */
class OutletCollision {
    constructor(outletName, itemName, collisionWith) {
        this.outletName = outletName;
        this.itemName = itemName;
        this.collisionWith = collisionWith;
    }
}
const isValidOutlet = (outlet) => outlet !== undefined && outlet !== '';
const ɵ0$e = isValidOutlet;
const outletCollision = (outletItem, collisionWith) => {
    return {
        item: outletItem.item,
        outlet: new OutletCollision(`ɵ${outletItem.item}`, outletItem.item, collisionWith.item),
    };
};
const ɵ1$a = outletCollision;
const flattenOutletTreeNode = (node) => {
    const flattenedChildren = flatMap(flattenOutletTreeNode, node.children);
    if (node.value.outlet !== undefined) {
        // not routable
        // Don't flatten this node (just it's children)
        return [new Tree({ item: node.value.name, outlet: node.value.outlet }, flattenedChildren)];
    }
    else {
        // Flatten this node
        return flattenedChildren.reduce((acc, nextChild) => {
            const collisionWith = acc.find(child => child.value.outlet === nextChild.value.outlet);
            const newChild = collisionWith
                ? new Tree(outletCollision(nextChild.value, collisionWith.value), nextChild.children)
                : nextChild;
            return [...acc, newChild];
        }, []);
    }
};
const ɵ2$6 = flattenOutletTreeNode;
/**
 * Special case for flattening the root node. If it can't be flattened into a tree with a single
 * root node, we create a special root node, so there is only ever a single tree.
 */
const flattenOutletTree = (outletTree) => {
    return {
        rootItem: outletTree.value.name,
        children: flattenOutletTreeNode(outletTree),
    };
};
const ɵ3$6 = flattenOutletTree;
const mapItemToOutlet = (item) => {
    if (!item.routingStrategy) {
        return {
            name: item.name,
            outlet: undefined,
        };
    }
    return {
        name: item.name,
        outlet: isValidOutlet(item.outlet) ? item.outlet : PRIMARY_OUTLET,
    };
};
const ɵ4$3 = mapItemToOutlet;
const outletTreeToMap = (outletTree) => {
    const entries = flatMap(tree => tree.flatten(), outletTree.children) // flatten and merge the root outlet trees
        .map((node) => [node.value.item, node.value.outlet]);
    return new Map(entries);
};
const ɵ5$1 = outletTreeToMap;
const outletMap = (itemTree) => {
    return outletTreeToMap(flattenOutletTree(itemTree.map(mapItemToOutlet)));
};

const CONFIG_ROUTE_GUARDS = new InjectionToken('@backbase/foundation Route Guards');
/**
 * @deprecated Will be removed in v7.0.0
 */
class RouteGuardsRegistryService {
    constructor(configs) {
        this.canActivate = new Map();
        this.canActivateChild = new Map();
        configs.forEach(handlerMap => {
            Object.entries(handlerMap.canActivate || {})
                .filter((entry) => 'canActivate' in entry[1].prototype)
                .forEach(([key, guard]) => {
                this.canActivate.set(key, guard);
            });
            Object.entries(handlerMap.canActivateChild || {}).forEach(([key, guard]) => {
                this.canActivateChild.set(key, guard);
            });
        });
    }
}
RouteGuardsRegistryService.ɵfac = function RouteGuardsRegistryService_Factory(t) { return new (t || RouteGuardsRegistryService)(ɵngcc0.ɵɵinject(CONFIG_ROUTE_GUARDS)); };
RouteGuardsRegistryService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RouteGuardsRegistryService, factory: RouteGuardsRegistryService.ɵfac });
RouteGuardsRegistryService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [CONFIG_ROUTE_GUARDS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouteGuardsRegistryService, [{
        type: Injectable
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [CONFIG_ROUTE_GUARDS]
            }] }]; }, null); })();

class TemplateRegistry {
    constructor() {
        this.registry = new Map();
    }
    set(id, entry) {
        const entry$ = this.registry.get(id) || this.initEntry(id);
        entry$.next(entry);
    }
    get(id) {
        const entry$ = this.registry.get(id) || this.initEntry(id);
        return entry$.pipe(first());
    }
    initEntry(id) {
        const entry = new ReplaySubject();
        this.registry.set(id, entry);
        return entry;
    }
}
TemplateRegistry.ɵfac = function TemplateRegistry_Factory(t) { return new (t || TemplateRegistry)(); };
TemplateRegistry.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: TemplateRegistry, factory: TemplateRegistry.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TemplateRegistry, [{
        type: Injectable
    }], function () { return []; }, null); })();

function journeyItemModelFactory(route) {
    return route.snapshot.data.item;
}
function storeNameFactory(route) {
    return route.snapshot.data.item.name;
}
class JourneyComponent {
}
JourneyComponent.ɵfac = function JourneyComponent_Factory(t) { return new (t || JourneyComponent)(); };
JourneyComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: JourneyComponent, selectors: [["bb-journey"]], features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: ItemModel,
                useFactory: journeyItemModelFactory,
                deps: [ActivatedRoute]
            },
            TemplateRegistry,
            {
                provide: ɵSTORE_BRANCH,
                useFactory: storeNameFactory,
                deps: [ActivatedRoute]
            },
            {
                provide: ɵSTORE_DISPATCH_CHANNEL,
                useFactory: storeNameFactory,
                deps: [ActivatedRoute]
            },
            {
                provide: StoreFactory,
                useClass: StoreFactory,
                deps: [ɵStoreBroker, ɵSTORE_BRANCH, ɵSTORE_DISPATCH_CHANNEL, FeaturesService]
            },
        ])], decls: 1, vars: 0, template: function JourneyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "router-outlet");
    } }, directives: [ɵngcc1.RouterOutlet], encapsulation: 2 });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(JourneyComponent, [{
        type: Component,
        args: [{
                selector: 'bb-journey',
                template: ` <router-outlet></router-outlet> `,
                providers: [
                    {
                        provide: ItemModel,
                        useFactory: journeyItemModelFactory,
                        deps: [ActivatedRoute]
                    },
                    TemplateRegistry,
                    {
                        provide: ɵSTORE_BRANCH,
                        useFactory: storeNameFactory,
                        deps: [ActivatedRoute]
                    },
                    {
                        provide: ɵSTORE_DISPATCH_CHANNEL,
                        useFactory: storeNameFactory,
                        deps: [ActivatedRoute]
                    },
                    {
                        provide: StoreFactory,
                        useClass: StoreFactory,
                        deps: [ɵStoreBroker, ɵSTORE_BRANCH, ɵSTORE_DISPATCH_CHANNEL, FeaturesService]
                    },
                ]
            }]
    }], null, null); })();

const CUSTOM_DATA_PREFIX = 'route.data.custom.';
var RouteModelProperty;
(function (RouteModelProperty) {
    /**
     * Each child of a RoutableContainer may have a property for "route",
     * else the route will be the index of the child plus 1.
     */
    RouteModelProperty["ROUTE"] = "route";
    /**
     * RoutableContainers and RoutableWidget can have an optional "outletName"
     * property to dynamically set the outlet name for the bb-router-outlet.
     */
    RouteModelProperty["OUTLET"] = "outletName";
    /**
     * `CanActivate` route guards can be added to generated child routes by including a
     * `route.canActivate` property in the child's model. These guards must be registered with the
     * `RouteGuardsRegistryService` via the `guards` option passed to `BackbaseCore.withConfig`.
     */
    RouteModelProperty["CAN_ACTIVATE"] = "route.canActivate";
    /**
     * `CanActivateChild` route guards can be added to generated routes by including a
     * `route.canActivateChild` property in the item's model. These guards must be registered with the
     * `RouteGuardsRegistryService` via the `guards` option passed to `BackbaseCore.withConfig`.
     */
    RouteModelProperty["CAN_ACTIVATE_CHILD"] = "route.canActivateChild";
    /**
     * RoutableContainer's can have a "disableDefault" property which will disable the
     * default behaviour of containers where an empty path route will be created to
     * redirect to the first child's route.
     */
    RouteModelProperty["DISABLE_DEFAULT"] = "disableDefault";
})(RouteModelProperty || (RouteModelProperty = {}));
const getRoutingStrategy = (itemRegistry, item) => {
    const loadModuleFunction = itemRegistry.getModuleLoader(item.ɵclassId);
    if (loadModuleFunction) {
        return of(createJourneyStrategy(item, loadModuleFunction));
    }
    const component = itemRegistry.getComponentValue(item.ɵclassId);
    if (component) {
        return of(createRoutingStrategy(component));
    }
    return from(itemRegistry.getComponent(item.ɵclassId)).pipe(map$1(createRoutingStrategy), startWith(undefined));
};
const ɵ0$d = getRoutingStrategy;
const getCanActivateRouteGuards = (guardRegistry, guards) => guards
    .map(guardName => guardRegistry.canActivate.get(guardName))
    .filter((guard) => guard !== undefined);
const ɵ1$9 = getCanActivateRouteGuards;
const getCanActivateChildRouteGuards = (guardRegistry, guards) => guards
    .map(guardName => guardRegistry.canActivateChild.get(guardName))
    .filter((guard) => guard !== undefined);
const ɵ2$5 = getCanActivateChildRouteGuards;
const toRoutableItem = (item, routeGuards, routeProperties, routingStrategy) => {
    return {
        name: item.name,
        routingStrategy,
        route: routeProperties[RouteModelProperty.ROUTE],
        outlet: routeProperties[RouteModelProperty.OUTLET],
        canActivate: getCanActivateRouteGuards(routeGuards, (routeProperties[RouteModelProperty.CAN_ACTIVATE] || [])),
        canActivateChild: getCanActivateChildRouteGuards(routeGuards, (routeProperties[RouteModelProperty.CAN_ACTIVATE_CHILD] || [])),
        hasDefault: routingStrategy ? true !== routeProperties[RouteModelProperty.DISABLE_DEFAULT] : undefined,
        routeData: propertiesByPrefix(CUSTOM_DATA_PREFIX, routeProperties),
    };
};
const ɵ3$5 = toRoutableItem;
// @fixme: don't re-emit unless properties we care about change
const routableItem = (itemRegistry, routeGuards) => (item) => combineLatest([item.properties, getRoutingStrategy(itemRegistry, item)]).pipe(map$1(([routeProperties, routingStrategy]) => toRoutableItem(item, routeGuards, routeProperties, routingStrategy)));
const ɵ4$2 = routableItem;
function createJourneyStrategy(item, loadChildren) {
    return {
        getRoutes() {
            return [
                {
                    path: '',
                    component: JourneyComponent,
                    data: { item },
                    loadChildren,
                },
            ];
        },
    };
}
const routableItemTree = (itemRegistry, routeGuards, modelTree) => combineTree(modelTree.map(routableItem(itemRegistry, routeGuards)));

class OutletCollisionComponent {
    constructor(route) {
        this.route = route;
        this.me = this.route.data.pipe(pluck('item'));
        this.collisionWith = this.route.data.pipe(pluck('collisionWith'));
    }
}
OutletCollisionComponent.ɵfac = function OutletCollisionComponent_Factory(t) { return new (t || OutletCollisionComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ActivatedRoute)); };
OutletCollisionComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: OutletCollisionComponent, selectors: [["bb-outlet-collision"]], decls: 9, vars: 6, template: function OutletCollisionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "p");
        ɵngcc0.ɵɵtext(1, "You have dropped a routable item next to another routable item.");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "p");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵpipe(4, "async");
        ɵngcc0.ɵɵelementStart(5, "strong");
        ɵngcc0.ɵɵtext(6);
        ɵngcc0.ɵɵpipe(7, "async");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtext(8, " to ensure the routes don't conflict. ");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate1(" You need to give this item (", ɵngcc0.ɵɵpipeBind1(4, 2, ctx.me), ") a unique \"outletName\" from ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(7, 4, ctx.collisionWith));
    } }, pipes: [ɵngcc2.AsyncPipe], encapsulation: 2 });
OutletCollisionComponent.ctorParameters = () => [
    { type: ActivatedRoute }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OutletCollisionComponent, [{
        type: Component,
        args: [{
                selector: 'bb-outlet-collision',
                template: `
    <p>You have dropped a routable item next to another routable item.</p>
    <p>
      You need to give this item ({{ me | async }}) a unique "outletName" from
      <strong>{{ collisionWith | async }}</strong> to ensure the routes don't conflict.
    </p>
  `
            }]
    }], function () { return [{ type: ɵngcc1.ActivatedRoute }]; }, null); })();

const isRoutable = (itemRoutes) => itemRoutes.outletName !== undefined;
const isAbsolute = (routePath) => routePath.startsWith('/');
const ɵ0$c = isAbsolute;
const isMatchingRedirect = (redirectTo) => (route) => route.path !== undefined && route.path === redirectTo;
const ɵ1$8 = isMatchingRedirect;
/**
 * Applies an outlet name to a route
 * @param outlet
 * @param route
 * @param oldRoutes
 */
const namedOutletRoute = (outlet, route, oldRoutes) => {
    // Add outlet name
    let newRoute = route.component ? Object.assign(Object.assign({}, route), { outlet }) : route;
    // Convert redirects to duplicated routes (can't redirect to a named outlet easily).
    if (newRoute.redirectTo !== undefined && !isAbsolute(newRoute.redirectTo)) {
        // If it's not absolute, we try and make it a default route instead (no path)
        const routeTo = oldRoutes.find(isMatchingRedirect(newRoute.redirectTo));
        if (!routeTo) {
            // Coudn't find a route that they're redirecting too, so we remove the route, as it won't work.
            throw new Error(`Couldn't redirect to ${newRoute.redirectTo}`);
        }
        newRoute = Object.assign(Object.assign({}, routeTo), { // @fixme: child routes with empty path redirects won't actually do the redirect
            outlet, path: '' });
    }
    return newRoute;
};
const ɵ2$4 = namedOutletRoute;
const applyOutletName = (item, outlet, routes) => {
    if (outlet === PRIMARY_OUTLET) {
        return routes;
    }
    else if (outlet instanceof OutletCollision) {
        return [
            {
                path: '',
                component: OutletCollisionComponent,
                outlet: outlet.outletName,
                data: {
                    item: item.name,
                    collisionWith: outlet.collisionWith,
                },
            },
        ];
    }
    return routes.map((route, _, oldRoutes) => namedOutletRoute(`${outlet}`, route, oldRoutes));
};
const ɵ3$4 = applyOutletName;
const mapItemToRoutes = (outlets) => (item, children, childRoutes) => {
    const outletName = outlets.get(item.name);
    const routes = item.routingStrategy ? item.routingStrategy.getRoutes(item, children, childRoutes) : undefined;
    if (outletName === undefined || routes === undefined) {
        // Flatten non-routable items
        return {
            item: item.name,
            outletName: undefined,
            routes: flatMap(childRoute => childRoute.routes, childRoutes),
        };
    }
    return {
        item: item.name,
        routes: applyOutletName(item, outletName, routes),
        outletName,
    };
};
const ɵ4$1 = mapItemToRoutes;
/**
 * Create a tree of the components with routes. This is a direct map of the
 * component tree. Each node in the tree holds all routes for the nodes beneath
 * it. So the root node in the returned tree will hold all the routes for the
 * entire component tree.
 */
const routingTree = (tree, outlets) => tree.map(mapItemToRoutes(outlets));

class AbstractRouterConfigService {
}

/**
 * @deprecated Will be removed in v7.0.0
 */
class RouterConfigService extends AbstractRouterConfigService {
    constructor(itemRegistry, routeGuardsRegistry, rootContainer) {
        super();
        this.itemRegistry = itemRegistry;
        this.routeGuardsRegistry = routeGuardsRegistry;
        this.rootContainer = rootContainer;
        this.routableItemTree = this.rootContainer.model.pipe(switchMap(model => model.toTree()), switchMap(model => routableItemTree(this.itemRegistry, this.routeGuardsRegistry, model)), shareReplay(1));
        this.outlets = this.routableItemTree.pipe(map$1(outletMap), shareReplay(1));
        /**
         * Convert the component tree to a routing tree
         *
         * @internal
         */
        this.ɵrouteTree = this.outlets.pipe(withLatestFrom(this.routableItemTree), map$1(([outlets, tree]) => routingTree(tree, outlets)), shareReplay(1));
        /**
         * The dynamically generated Angular routes for the SPA, based on the model of the app.
         */
        this.routes = this.ɵrouteTree.pipe(map$1((routeTrees) => routeTrees.value.routes), shareReplay(1));
    }
    /**
     * Get the router-outlet name for the given item in the model tree.
     *
     * @internal
     */
    ɵitemOutletName(item) {
        return this.outlets.pipe(map$1(outlets => outlets.get(item.name)), map$1(outlet => (outlet instanceof OutletCollision ? outlet.outletName : outlet)), distinctUntilChanged());
    }
}
RouterConfigService.ɵfac = function RouterConfigService_Factory(t) { return new (t || RouterConfigService)(ɵngcc0.ɵɵinject(ItemRegistryService), ɵngcc0.ɵɵinject(RouteGuardsRegistryService), ɵngcc0.ɵɵinject(ӨRootContainerService)); };
RouterConfigService.ɵprov = i0.ɵɵdefineInjectable({ factory: function RouterConfigService_Factory() { return new RouterConfigService(i0.ɵɵinject(ItemRegistryService), i0.ɵɵinject(RouteGuardsRegistryService), i0.ɵɵinject(ӨRootContainerService)); }, token: RouterConfigService, providedIn: "root" });
RouterConfigService.ctorParameters = () => [
    { type: ItemRegistryService },
    { type: RouteGuardsRegistryService },
    { type: ӨRootContainerService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterConfigService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ItemRegistryService }, { type: RouteGuardsRegistryService }, { type: ӨRootContainerService }]; }, null); })();

/**
 * Creates a new LinkedList with the results of calling a provided function on
 * every element in the provided LinkedList.
 *
 * @param list
 * @param fn
 */
const mapLinkedList = (list, fn) => ({
    value: fn(list.value),
    next: list.next === undefined ? undefined : mapLinkedList(list.next, fn),
});
/**
 * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
 * to TAIL, where the new HEAD is determined by the first "true" result of calling the predicate
 * on each node in the list.
 *
 * The search is done by iterating over each element in the linked list
 * in the order from HEAD to TAIL.
 *
 * If not found, returns undefined.
 *
 * @param list
 * @param predicate
 */
const linkedListFind = (list, predicate) => {
    if (predicate(list.value)) {
        return list;
    }
    return list.next ? linkedListFind(list.next, predicate) : undefined;
};
/**
 * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
 * to TAIL, where the new HEAD is determined by the first "true" result of calling the predicate
 * on each node in the list.
 *
 * The search is done by iterating over each element in the linked list
 * in the order from TAIL to HEAD.
 *
 * If not found, returns undefined.
 *
 * @param list
 * @param predicate
 */
const linkedListFindLast = (list, predicate) => {
    const foundChild = list.next ? linkedListFindLast(list.next, predicate) : undefined;
    if (foundChild) {
        return foundChild;
    }
    return predicate(list.value) ? list : undefined;
};
/**
 * Returns a shallow copy of a portion of a linked list into a new linked list,
 * selected from HEAD (inclusive) to the first element to return true (exclusive).
 * So the new TAIL will be the parent of the first element to return true.
 *
 * The search is done by iterating over each element in the linked list in the
 * order from HEAD to TAIL.
 *
 * If not found, returns undefined.
 *
 * @param list
 * @param predicate
 */
const linkedListSliceTail = (list, predicate) => {
    if (predicate(list.value)) {
        return undefined;
    }
    return {
        value: list.value,
        next: list.next ? linkedListSliceTail(list.next, predicate) : undefined,
    };
};
const ɵ0$b = linkedListSliceTail;
/**
 * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
 * to TAIL, where the new HEAD is determined by the first "true" result of calling the "begin"
 * predicate and the new TAIL is determined by the first "true" result of calling the "end"
 * predicate.
 *
 * If no "begin" predicate is sent, the HEAD will be the current HEAD.
 *
 * If no "end" predicate is sent, the TAIL will be the current TAIL.
 *
 * The search is done by iterating over each element in the linked list
 * in the order from HEAD to TAIL until both predicates return true.
 *
 * If not both found, returns undefined.
 *
 * @param list
 * @param predicate
 */
const linkedListSlice = (list, begin, end) => {
    const head = begin ? linkedListFind(list, begin) : list;
    if (!head) {
        return undefined;
    }
    return end ? linkedListSliceTail(head, end) : head;
};
const linkedListToArray = (list) => [
    list.value,
    ...(list.next ? linkedListToArray(list.next) : []),
];
const linkedListFromArray = (arr) => arr.reduceRight((next, value) => ({ value, next }), undefined);
const linkedListLast = (list) => (list.next ? linkedListLast(list.next) : list);

const hasNamedOutlet = (node) => node.outlet !== PRIMARY_OUTLET;
const ɵ0$a = hasNamedOutlet;
const routeSegmentToUrlSegment = (node) => new UrlSegment(node.path, node.params || {});
const ɵ1$7 = routeSegmentToUrlSegment;
class RouterNavigationService {
    constructor(router) {
        this.router = router;
    }
    /**
     * Set (merge) the params on a given `ActivatedRoute`, preserving the active children's states.
     *
     * This allows updating the params in an arbitrary route in the active route
     * tree without needing to know the state of every child route.
     *
     * @param params The route params that should be set on the given route
     * @param from The route to set the params on
     * @returns The new URLTree
     */
    setParams(params, from) {
        const snapshot = from instanceof ActivatedRoute ? from.snapshot : from;
        const navigationRoute = linkedListFromArray(flatMap((route) => route.url.map((url) => ({
            path: url.path,
            outlet: route.outlet,
            params: url.parameters,
        })), snapshot.pathFromRoot));
        if (!navigationRoute) {
            throw new Error('No route to set params on');
        }
        const last = linkedListLast(navigationRoute);
        last.value.params = last.value.params ? Object.assign(Object.assign({}, last.value.params), params) : params;
        return this.createUrlTree(navigationRoute);
    }
    createUrlTree(routeBranch) {
        const tree = this.router.parseUrl('/'); // @todo: is there no better way to make a tree?
        const rootRouteSegment = routeBranch.value;
        tree.root.children[rootRouteSegment.outlet] = this.urlSegmentGroupForRoute(routeBranch);
        return tree;
    }
    /*
     * A segment group is a node in the UrlTree. The node itself is an array
     * of segments, which are all considered on the "primary" outlet.
     * The children of this node are the paths on the "non-primary" outlets.
     * There will only be a single "child" for the NavigationRoute (as it
     * represents a single branch through a UrlTree).
     */
    urlSegmentGroupForRoute(routeBranch) {
        // Find all paths up to the first non-primary outlet - these will be the segments.
        const routeSegments = {
            value: routeBranch.value,
            next: routeBranch.next ? linkedListSlice(routeBranch.next, undefined, hasNamedOutlet) : undefined,
        };
        const segments = linkedListToArray(routeSegments).map(routeSegmentToUrlSegment);
        // Find the first non-primary outlet - this will be the child.
        const nextOutlet = routeBranch.next && linkedListFind(routeBranch.next, hasNamedOutlet);
        const segmentGroupChildren = nextOutlet
            ? { [nextOutlet.value.outlet]: this.urlSegmentGroupForRoute(nextOutlet) }
            : {};
        return new UrlSegmentGroup(segments, segmentGroupChildren);
    }
    /**
     * Merge a new `UrlTree` into the current active `UrlTree`.
     *
     * @param newTree
     */
    navigate(newTree) {
        const activeTree = this.router.parseUrl(this.router.url);
        const mergedTree = this.router.parseUrl('/');
        mergedTree.root.children = this.mergeUrlSegmentGroupChildren(activeTree.root.children, newTree.root.children);
        return this.router.navigateByUrl(mergedTree);
    }
    /**
     * Merge new children of a `UrlSegmentGroup` children into the children of the
     * current active `UrlSegmentGroup`.
     *
     * @param activeChildren
     * @param newChildren
     */
    mergeUrlSegmentGroupChildren(activeChildren, newChildren) {
        const mergedChildren = Object.keys(newChildren).reduce((acc, outletName) => {
            if (!activeChildren[outletName]) {
                return acc;
            }
            return Object.assign(Object.assign({}, acc), { [outletName]: this.mergeUrlTreeSegmentGroup(activeChildren[outletName], newChildren[outletName]) });
        }, newChildren);
        /**
         * Sibling routes can be preserved, or not.
         *
         * Because the current active route is a tree (for example, when you have multiple named
         * outlets and they are active) when you navigate to a new route it is possible to preserve
         * active routes that are siblings to the route you're navigating to.
         *
         * For example, when navigating from URL `/a/(b//x:c)` to `/a/c`, should the `x:c` or `b`
         * be preserved. The URL can be visualised as a tree (where a double slash `//` shows siblings
         * in the tree):
         *
         * ```
         *  -a
         *   `- b
         *   `- x:c
         * ```
         *
         * When set to true, all sibling will be preserved. For example, when navigating to `/a/d`
         * the `x:c` branch will be preserved and the new URL will be `/a/(d//x:c)`. Similarly,
         * when navigating to `/a/(x:e)`, the `b` branch will be preserved and the new URL will
         * be `/a/(b//x:e)`.
         *
         * Merging is disabled by default, but can be enabled with a feature flag.
         */
        return Object.assign(Object.assign({}, activeChildren), mergedChildren);
    }
    /**
     * Merge a new `UrlSegmentGroup` into the current active `UrlSegmentGroup`.
     *
     * @param activeSegmentGroup
     * @param newSegmentGroup
     */
    mergeUrlTreeSegmentGroup(activeSegmentGroup, newSegmentGroup) {
        return new UrlSegmentGroup(this.mergeUrlSegments(activeSegmentGroup.segments, newSegmentGroup.segments), this.mergeUrlSegmentGroupChildren(activeSegmentGroup.children, newSegmentGroup.children));
    }
    /**
     * Merge an array of new `UrlSegment` into the current active `UrlSegment` array.
     *
     * @param activeSegments
     * @param newSegments
     */
    mergeUrlSegments(activeSegments, newSegments) {
        // Determine if any params are being set.
        const preserveActiveTailSegments = !!newSegments.find(segment => Object.keys(segment.parameters).length > 0);
        // When the new segments change path from the active segment, then they
        // should no longer be preserved, so they get set to undefined.
        const removeActiveSegments = () => {
            let matches = true;
            return ([activeSegment, newSegment]) => {
                if (matches && activeSegment && newSegment) {
                    matches = activeSegment.path === newSegment.path;
                }
                return [matches ? activeSegment : undefined, newSegment];
            };
        };
        // pair the segments into a single array
        return pairs(activeSegments, newSegments)
            .map(removeActiveSegments())
            .map(([activeSegment, newSegment]) => this.mergeUrlSegment(activeSegment, newSegment, preserveActiveTailSegments))
            .filter((a) => a !== undefined);
    }
    /**
     * Merge a new `UrlSegment` into the current active `UrlSegment`.
     *
     * If there is both an active and new segment it is assumed that the path
     * is the same already.
     *
     * @param activeSegment
     * @param newSegment
     * @param isSettingParams
     */
    mergeUrlSegment(activeSegment, newSegment, preserveActiveTailSegments) {
        /**
         * There are 3 different strategies for how to preserve any "tail" segments in
         * the route: 'never' | 'on-param-set' | 'always'.
         *
         * This is only relevant when any route branch you're navigating to is a subset
         * of a current active route. For example, when navigating from URL `/a/b` to
         * `/a`, should `b` be preserved?
         *
         * When set to 'never' the children will be discarded, and the new URL will simply
         * be `/a`.
         *
         * When set to 'always' the children will always be preserved (this means it would
         * be impossible to navigate to a parent route).
         *
         * When set to 'on-param-set' the children will only be preserved if params are being
         * set on the route. For example, when navigating from `/a/b` to
         * `/a;data=foo` then the new URL will be `/a:data=foo/b`.
         *
         * This is implemented using the 'never' OR 'on-param-set' strategy depending on the
         * `preserveActiveTailSegments` flag.
         */
        if (activeSegment && !newSegment && preserveActiveTailSegments) {
            return new UrlSegment(activeSegment.path, activeSegment.parameters);
        }
        else if (newSegment) {
            const activeSegmentParams = (activeSegment && activeSegment.parameters) || {};
            return new UrlSegment(newSegment.path, this.mergeUrlSegmentParams(activeSegmentParams, newSegment.parameters));
        }
        return undefined;
    }
    mergeUrlSegmentParams(activeSegmentParams, newSegmentParams) {
        /**
         * There 3 different strategies for how to preserve any route-parameters in the
         * route: 'never' | 'overwrite' | 'merge'.
         *
         * For example, when navigating from URL `/a;data=foo/b` to `/a;x=y/c`, should the
         * 'data' param be preserved.
         *
         * When `never` the params will be discarded, and the new URL will simply be `/a;x=y/c`.
         *
         * When `merge`, then the params will be preserved, and the new URL will be
         * `/a;data=foo;x=y/c`.
         *
         * When 'overwrite', then the params will be only be preserved if there are no *other*
         * params being set on that segment. For example, when navigating instead to:
         * `/a/c;foo=bar`, the new URL will be `/a;data=foo/c;foo=bar`.
         *
         * This is implemented using the "overwrite" strategy.
         */
        return Object.keys(newSegmentParams).length === 0 ? activeSegmentParams : newSegmentParams;
    }
}
RouterNavigationService.ɵfac = function RouterNavigationService_Factory(t) { return new (t || RouterNavigationService)(ɵngcc0.ɵɵinject(ɵngcc1.Router)); };
RouterNavigationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RouterNavigationService, factory: RouterNavigationService.ɵfac });
RouterNavigationService.ctorParameters = () => [
    { type: Router }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterNavigationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Router }]; }, null); })();

/**
 * Extracts a tree branch from the component route tree up to the given item and
 * unwraps the value.
 *
 * It unwraps it so we don't end up with a `LinkedList<Tree>`, where each node
 * would have value`.value`.
 *
 * @param itemRouteTree
 * @param itemName
 */
const itemRoutesBranch = (findRoute, itemRouteTree) => {
    const branch = treeBranch(itemRouteTree, findRoute);
    if (branch === undefined) {
        return undefined;
    }
    return mapLinkedList(branch, tree => tree.value);
};
const ɵ0$9 = itemRoutesBranch;
/**
 * Maps a LinkedList<Route> to a NavigationRoute, to ensure each route is a
 * part of a URL segment.
 */
const mapToNavigationRoute = (routeBranch) => mapLinkedList(routeBranch, route => {
    if (route.path === undefined) {
        throw new Error(`Can't find route to item as route has no path`);
    }
    return {
        path: route.path,
        outlet: route.outlet || PRIMARY_OUTLET,
    };
});
const ɵ1$6 = mapToNavigationRoute;
/**
 * @internal
 */
class ӨItemNavigationService {
    constructor(routerConfig, navigationService) {
        this.routerConfig = routerConfig;
        this.navigationService = navigationService;
    }
    navigateToItem(itemName, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const isItemByName = (tree) => tree.value.item === itemName;
            return this.navigateToRoute(isItemByName, params);
        });
    }
    isItemChild(navigateToParent, childIndex) {
        return (tree, index, parent) => {
            if (parent) {
                const isChild = parent.value.item === navigateToParent;
                const isNthChild = index === childIndex;
                if (isChild && isNthChild) {
                    return true;
                }
                const isLastChild = index === parent.children.length - 1;
                const isIndexOutOfRange = childIndex > parent.children.length - 1;
                if (isChild && isLastChild && isIndexOutOfRange) {
                    return true;
                }
            }
            const noChildren = tree.children.length === 0;
            const isParent = tree.value.item === navigateToParent;
            if (isParent && noChildren) {
                return true;
            }
            return false;
        };
    }
    navigateToChild(navigateToParent, childIndex, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.navigateToRoute(this.isItemChild(navigateToParent, childIndex), params);
        });
    }
    navigateToRoute(findRoute, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const route = yield this.routeToItem(findRoute);
            if (!route) {
                // If there is no route, then this item should already be visible, as it means
                // it's somewhere in the component tree above any routable item.
                if (Object.keys(params).length) {
                    // If trying to pass params, this can't work, so throw
                    return Promise.reject(`Can't pass params to an item that isn't within a routable item`);
                }
                // Otherwise, there is no need to navigate, navigation has failed
                return Promise.resolve(false);
            }
            const navigationRoute = mapToNavigationRoute(route);
            // Set the params on the last path in the route.
            linkedListLast(navigationRoute).value.params = params;
            return this.navigationService.navigate(this.navigationService.createUrlTree(navigationRoute));
        });
    }
    /**
     * Search the component tree for a given item, and return the route to that item.
     *
     * @param itemName The CXP instance name of the item to route to.
     */
    routeToItem(findRoute) {
        // Take a snapshot of the current state of the route tree.
        return this.routerConfig.ɵrouteTree
            .pipe(take(1))
            .toPromise()
            .then((routeTree) => this.findItemRoute(findRoute, routeTree));
    }
    /**
     * Breadth-first-search of routes, to find a route to a given item.
     *
     * 1. Find the branch to this item in the component route tree.
     * 2. Once found, find the closest routable parent.
     * 3. Take the child of the routable parent.
     * 4. For each route in the parent, use the "RouteComponentStrategy" to determine
     *      which route the route-child is rendered in.
     * 5. Once the route is found, flatten the routes of the componentRouteTree up to that route.
     *
     * @param itemName
     * @param routes
     */
    findItemRoute(findRoute, componentRouteTree) {
        // 1. Find the branch containing the item.
        const branch = itemRoutesBranch(findRoute, componentRouteTree);
        if (!branch) {
            // item not in tree
            throw new Error(`No matching route found in model.`);
        }
        const foundNode = linkedListLast(branch);
        // 2. Find the closest *routable* parent (depth-first search, so it searches from TAIL to HEAD)
        const isParent = (node) => node.item !== foundNode.value.item;
        const isRoutableParent = (node) => isRoutable(node) && isParent(node);
        const routableNode = linkedListFindLast(branch, isRoutableParent);
        if (!routableNode) {
            return undefined;
        }
        // 3. Take the child of the routable node.
        const routableNodeChild = routableNode.next;
        // 4. Determine which route the child is rendered in.
        const foundItemInRoute = routableNodeChild &&
            routableNode.value.routes.find(route => this.isItemInRoute(routableNodeChild.value.item, route));
        // 5. Find the branch in the route tree up to that route (similar to step 1).
        // Except that "Routes" is really like an array of trees, so we loop through them.
        for (const rootRoute of componentRouteTree.value.routes) {
            const routeBranch = treeBranch(rootRoute, route => route === foundItemInRoute);
            if (routeBranch) {
                return routeBranch;
            }
        }
        return undefined;
    }
    isItemInRoute(itemName, route) {
        if (!route.component) {
            return false;
        }
        return createRouteComponentStrategy(route.component).isItemInRoute(itemName, route);
    }
}
ӨItemNavigationService.ɵfac = function ӨItemNavigationService_Factory(t) { return new (t || ӨItemNavigationService)(ɵngcc0.ɵɵinject(RouterConfigService), ɵngcc0.ɵɵinject(RouterNavigationService)); };
ӨItemNavigationService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ӨItemNavigationService, factory: ӨItemNavigationService.ɵfac });
ӨItemNavigationService.ctorParameters = () => [
    { type: RouterConfigService },
    { type: RouterNavigationService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ӨItemNavigationService, [{
        type: Injectable
    }], function () { return [{ type: RouterConfigService }, { type: RouterNavigationService }]; }, null); })();

const createComponentPipe = () => ({
    source: (ref, outputName) => () => ref.instance[outputName],
    sink: (ref, inputName) => (stdin) => {
        stdin.subscribe((value) => {
            ref.instance[inputName] = value;
            ref.changeDetectorRef.markForCheck();
        });
    },
});

/**
 * @deprecated Will be removed in v7.0.0
 */
const CONFIG_PIPELINE_PROCESSORS = new InjectionToken('@backbase/foundation Pipeline Handlers');
/**
 * @deprecated Will be removed in v7.0.0
 * Helper service wrapping around CONFIG_PIPELINE_PROCESSORS
 */
class PipelineRegistry {
    constructor(processorsNested) {
        const allProcessors = flatten(processorsNested);
        this.registeredHandlers = new Map(allProcessors.map(({ name, provider }) => [name, provider]));
    }
    getProcessorProvider(name) {
        const provider = this.registeredHandlers.get(name);
        if (provider === undefined) {
            throw new Error(`No provider to pipeline handler ${name}`);
        }
        return Object.assign({ deps: [] }, provider);
    }
    getProcessorProviderToken(name) {
        return this.getProcessorProvider(name).provide;
    }
}
PipelineRegistry.ɵfac = function PipelineRegistry_Factory(t) { return new (t || PipelineRegistry)(ɵngcc0.ɵɵinject(CONFIG_PIPELINE_PROCESSORS)); };
PipelineRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function PipelineRegistry_Factory() { return new PipelineRegistry(i0.ɵɵinject(CONFIG_PIPELINE_PROCESSORS)); }, token: PipelineRegistry, providedIn: "root" });
PipelineRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [CONFIG_PIPELINE_PROCESSORS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PipelineRegistry, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [CONFIG_PIPELINE_PROCESSORS]
            }] }]; }, null); })();
/**
 * @deprecated Will be removed in v7.0.0
 */
function createPipelineProcessorConfig(name, provider) {
    return {
        name,
        provider,
    };
}

const noop$2 = () => { };
const ɵ0$8 = noop$2;
// @see https://github.com/ReactiveX/rxjs/blob/5b82dcc601ed6eae955409ed0995cad61744f102/src/internal/util/pipe.ts
function pipeFromArray(fns) {
    if (!fns) {
        return noop$2;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
    };
}

const noop$1 = () => { };
const ɵ0$7 = noop$1;
const noopSink = (stdin) => {
    stdin.subscribe(noop$1);
};
const ɵ1$5 = noopSink;
const isSourceDefinition = (definition) => definition && 'source' in definition;
const ɵ2$3 = isSourceDefinition;
const isPipeDefinition = (definition) => definition && 'pipe' in definition;
const ɵ3$3 = isPipeDefinition;
const isSinkDefinition = (definition) => definition && 'sink' in definition;
const ɵ4 = isSinkDefinition;
/**
 * @deprecated Will be removed in v7.0.0
 */
class PipelineService {
    constructor(broker, injector) {
        this.broker = broker;
        this.injector = injector;
    }
    createSource(name, args) {
        const instance = this.getInstance(name);
        if (!isSourceDefinition(instance)) {
            throw new Error(`${name} is not a valid source`);
        }
        return instance.source(...args);
    }
    createPipe(name, args) {
        const instance = this.getInstance(name);
        if (!isPipeDefinition(instance)) {
            throw new Error(`${name} is not a valid pipe`);
        }
        return instance.pipe(...args);
    }
    createSink(name, args) {
        const instance = this.getInstance(name);
        if (isSinkDefinition(instance)) {
            return instance.sink(...args);
        }
        else if (isPipeDefinition(instance)) {
            return this.chainSink([instance.pipe(...args)], noopSink);
        }
        throw new Error(`${name} is not a valid sink`);
    }
    getInstance(name) {
        const provide = this.broker.getProcessorProviderToken(name);
        return this.injector.get(provide);
    }
    chainSink(pipes, sink) {
        return (stdin) => {
            sink(stdin.pipe(pipeFromArray(pipes)));
        };
    }
    runPipeline(pipeline, gc) {
        return pipeline.sink(pipeline.source().pipe(takeUntil(gc)));
    }
}
PipelineService.ɵfac = function PipelineService_Factory(t) { return new (t || PipelineService)(ɵngcc0.ɵɵinject(PipelineRegistry), ɵngcc0.ɵɵinject(ɵngcc0.Injector)); };
PipelineService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: PipelineService, factory: PipelineService.ɵfac });
PipelineService.ctorParameters = () => [
    { type: PipelineRegistry },
    { type: Injector }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PipelineService, [{
        type: Injectable
    }], function () { return [{ type: PipelineRegistry }, { type: ɵngcc0.Injector }]; }, null); })();

const parsePipe = (pipeString) => {
    const communicationDefinition = serializerDeserializer.fromProperty(pipeString);
    if (communicationDefinition !== undefined) {
        return {
            processorName: communicationDefinition.transport,
            args: [communicationDefinition.param],
        };
    }
    else {
        const parts = pipeString.split(' ');
        const processorName = parts.shift();
        return {
            processorName,
            args: parts,
        };
    }
};
const ɵ0$6 = parsePipe;
const LEGACY_HANDLERS = ['debug', 'navigation', 'navigation-url', 'route-param', 'model-property'];
const isPipelineConfig = (propertyValue) => {
    const handlerName = propertyValue.split(':')[0];
    return !LEGACY_HANDLERS.includes(handlerName);
};
const ɵ1$4 = isPipelineConfig;
const upgradeToPipelineConfig = (propertyName, propertyValue) => {
    const colonIndex = propertyValue.indexOf(':');
    const hasArg = colonIndex !== -1;
    const handlerName = hasArg ? propertyValue.substr(0, colonIndex) : propertyValue;
    const handlerArg = hasArg ? propertyValue.substr(colonIndex + 1) : '';
    const handlerToPipeMapping = {
        'navigation-url': () => `url ${handlerArg} ${propertyName}`,
        navigation: () => `navigation ${propertyName} ${handlerArg}`,
        'model-property': () => `model ${handlerArg}`,
    };
    return (handlerToPipeMapping[handlerName] || (() => `${handlerName} ${handlerArg}`))().trim();
};
const ɵ2$2 = upgradeToPipelineConfig;
const normalizePropertyValue = (propertyName, value) => {
    if (!isPipelineConfig(value)) {
        return upgradeToPipelineConfig(propertyName, value);
    }
    return value;
};
const ɵ3$2 = normalizePropertyValue;
const parseInputOutputPropertyValue = (propertyName, propertyValue) => {
    const normalPropertyValue = normalizePropertyValue(propertyName, propertyValue);
    const streamHandlers = normalPropertyValue.trim();
    return parsePipe(streamHandlers);
};
const inputOutputProperties = (properties) => Object.entries(properties).map(([propertyName, value]) => ({
    propertyName,
    pipeline: parseInputOutputPropertyValue(propertyName, `${value}`),
}));

function parseProperties(properties) {
    return inputOutputProperties(properties).filter(prop => !!prop.pipeline && !!prop.pipeline.processorName);
}
function getProcessorNames(properties) {
    return parseProperties(properties).map(propertyConfig => propertyConfig.pipeline.processorName);
}

/**
 * The input broker service creates a communication pipeline
 * using the component input as a sink. The source of the pipeline
 * is determined by the item model.
 */
class InputBrokerService {
    constructor(itemLifecycle, pipelineRegistry, componentFactoryResolver, lazyConfig) {
        this.itemLifecycle = itemLifecycle;
        this.pipelineRegistry = pipelineRegistry;
        this.componentFactoryResolver = componentFactoryResolver;
        this.lazyConfig = lazyConfig;
    }
    bootstrap() {
        // Model properties cannot be linked to the Inputs of lazy loaded items
        const lazyLoadedComponents = (this.lazyConfig
            ? this.lazyConfig.filter((config) => !!config.components)
            : []).reduce((acc, config) => [...acc, ...config.components], []);
        this.itemLifecycle.whenCreate().subscribe(({ itemModel, component }) => {
            const gc$ = this.itemLifecycle.whenRemove(itemModel.value.name).pipe(take(1));
            this.runInputPipelines(itemModel, component, gc$);
            if (!lazyLoadedComponents.includes(itemModel.value.ɵclassId)) {
                this.runModelInputs(itemModel, component, gc$);
            }
        });
    }
    runModelInputs(itemModel, ref, gc$) {
        this.componentFactoryResolver.resolveComponentFactory(ref.componentType).inputs.forEach(input => {
            // Abort if there is already an "input." property with the same name
            if (itemModel.value.ɵinputProperties[input.templateName] !== undefined)
                return;
            const modelValue = itemModel.value.ɵproperties[input.templateName];
            if (modelValue === undefined)
                return;
            const source = itemModel.value.property(input.templateName, modelValue);
            const sink = this.inputSink(ref, input.propName);
            return sink(source.pipe(takeUntil(gc$)));
        });
    }
    runInputPipelines(itemModel, ref, gc$) {
        const pipelineService = ref.injector.get(PipelineService);
        parseProperties(itemModel.value.ɵinputProperties).forEach(inputPipesConfig => {
            const sourceCommand = inputPipesConfig.pipeline;
            const sourceFn = pipelineService.createSource(sourceCommand.processorName, sourceCommand.args);
            const pipeline = {
                source: sourceFn,
                sink: this.inputSink(ref, inputPipesConfig.propertyName),
            };
            pipelineService.runPipeline(pipeline, gc$);
        });
    }
    inputSink(ref, inputName) {
        return createComponentPipe().sink(ref, inputName);
    }
    getItemProviders(item) {
        return getProcessorNames(item.ɵinputProperties).map(processorName => {
            try {
                return this.pipelineRegistry.getProcessorProvider(processorName);
            }
            catch (message) {
                throw new Error(`Input '${processorName}' on ${item.name} is misconfigured. ${message}`);
            }
        });
    }
}
InputBrokerService.ɵfac = function InputBrokerService_Factory(t) { return new (t || InputBrokerService)(ɵngcc0.ɵɵinject(ItemLifecycleService), ɵngcc0.ɵɵinject(PipelineRegistry), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(LAZY_MAP, 8)); };
InputBrokerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: InputBrokerService, factory: InputBrokerService.ɵfac });
InputBrokerService.ctorParameters = () => [
    { type: ItemLifecycleService },
    { type: PipelineRegistry },
    { type: ComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [LAZY_MAP,] }, { type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InputBrokerService, [{
        type: Injectable
    }], function () { return [{ type: ItemLifecycleService }, { type: PipelineRegistry }, { type: ɵngcc0.ComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [LAZY_MAP]
            }, {
                type: Optional
            }] }]; }, null); })();
function createInputBootstrap(Broker) {
    return Broker.bootstrap.bind(Broker);
}

/**
 * The output broker service creates a communication pipeline
 * using the component output as a source. The sink of the pipeline
 * is determined by the item model.
 */
class OutputBrokerService {
    constructor(itemLifecycle, pipelineRegistry) {
        this.itemLifecycle = itemLifecycle;
        this.pipelineRegistry = pipelineRegistry;
    }
    bootstrap() {
        this.itemLifecycle.whenCreate().subscribe(({ itemModel, component }) => {
            const gc$ = this.itemLifecycle.whenRemove(itemModel.value.name).pipe(take(1));
            this.runOutputPipelines(itemModel, component, gc$);
        });
    }
    runOutputPipelines(itemModel, ref, gc$) {
        const pipelineService = ref.injector.get(PipelineService);
        parseProperties(itemModel.value.ɵoutputProperties).forEach(outputPipesConfig => {
            const sinkCommand = outputPipesConfig.pipeline;
            const sinkFn = pipelineService.createSink(sinkCommand.processorName, sinkCommand.args);
            const pipeline = {
                source: this.outputSource(ref, outputPipesConfig.propertyName),
                sink: sinkFn,
            };
            if (!pipeline.source()) {
                throw new Error(`${ref.componentType.name} does not have an output named '${outputPipesConfig.propertyName}'`);
            }
            pipelineService.runPipeline(pipeline, gc$);
        });
    }
    outputSource(ref, outputName) {
        return createComponentPipe().source(ref, outputName);
    }
    getItemProviders(item) {
        return getProcessorNames(item.ɵoutputProperties).map(processorName => {
            try {
                return this.pipelineRegistry.getProcessorProvider(processorName);
            }
            catch (message) {
                throw new Error(`Output '${processorName}' on ${item.name} is misconfigured. ${message}`);
            }
        });
    }
}
OutputBrokerService.ɵfac = function OutputBrokerService_Factory(t) { return new (t || OutputBrokerService)(ɵngcc0.ɵɵinject(ItemLifecycleService), ɵngcc0.ɵɵinject(PipelineRegistry)); };
OutputBrokerService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: OutputBrokerService, factory: OutputBrokerService.ɵfac });
OutputBrokerService.ctorParameters = () => [
    { type: ItemLifecycleService },
    { type: PipelineRegistry }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(OutputBrokerService, [{
        type: Injectable
    }], function () { return [{ type: ItemLifecycleService }, { type: PipelineRegistry }]; }, null); })();
function createOutputBootstrap(outputBroker) {
    return outputBroker.bootstrap.bind(outputBroker);
}

const makeDebugPipe = () => ({
    pipe: (debugPrefix = 'DEBUG') => (stdin) => stdin.pipe(tap((value) => {
        // eslint-disable-next-line  no-console
        console.log(`DEBUG ITEM OUTPUT ${debugPrefix}:`, value);
    })),
});
/**
 * Configure the `DebugPipe`.
 *
 * Use the string 'debug' to configure this handler.
 *
 * @usageNotes
 *
 * ```json
 * {
 *   "output.myOutput1": "debug test", // use as sink
 *   "output.myOutput2": "debug > route-param" // use a pipe
 * }
 * ```
 */
const debugProcessorConfig = {
    name: 'debug',
    provider: {
        provide: new InjectionToken('Debug handler'),
        useFactory: makeDebugPipe,
    },
};

const pluckPipe = { pipe: pluck };
const ɵ0$5 = pluckPipe;
/**
 * Configure the `PluckPipe`.
 *
 * Use the string 'pluck' to configure this handler.
 *
 * @usageNotes
 *
 * ```json
 * {
 *   "output.myObject": "pluck id > debug", // transform an output
 *   "input.myInput": "pluck id < some-object-source" // transform an input
 * }
 * ```
 */
const pluckProcessorConfig = {
    name: 'pluck',
    provider: {
        provide: new InjectionToken('Pluck pipeline handler'),
        useValue: ɵ0$5,
    },
};

/**
 * @deprecated Will be removed in v7.0.0
 * Pipeable operator for normalizing value to `RouteParams`.
 *
 * @param paramNameArg
 */
const routeParams = (paramNameArg) => (stdin) => stdin.pipe(map$1((payload) => (paramNameArg ? { [paramNameArg]: `${payload}` } : {})));
const TAG$3 = 'route-param';
/**
 * @deprecated Will be removed in v7.0.0
 * RouteParam Communication Transport
 *
 * Can be used to configure communication using RouteParam.
 *
 * @usageNotes
 *
 * Store some 2-way bound state to the router as "paramName"
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouteParam.toProperty("paramName"),
 *     "input.myInput": RouteParam.toProperty("paramName")
 *   }
 * }
 * ```
 *
 * Navigate to widget-b and pass data via route-param
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouteParam.toProperty("inputName")
 *   }
 * },
 * {
 *   "name": "widget-b",
 *   "properties": {
 *     "input.myInput": RouteParam.toProperty("inputName")
 *   }
 * }
 * ```
 */
class RouteParam {
    /**
     * Generate a serialized communication configuration suitable for use as a Widget Input or Output property value.
     *
     * @param group The name of the communication group to which the Input/Output belongs
     */
    static toProperty(group) {
        return serializerDeserializer.toProperty(new CommunicationDefinition(TAG$3, group));
    }
}
const getActivatedRouteParam = (paramName) => (activatedRoute) => activatedRoute.paramMap.pipe(filter(Boolean), map$1((params) => params.get(paramName)), map$1(param => (param === null ? undefined : param)));
const ɵ0$4 = getActivatedRouteParam;
const walkRoutePath = (activatedRoute) => {
    if (!activatedRoute.parent) {
        return [activatedRoute];
    }
    return [activatedRoute, ...walkRoutePath(activatedRoute.parent)];
};
const ɵ1$3 = walkRoutePath;
/**
 * @deprecated Will be removed in v7.0.0
 */
const getRouteParam = (activatedRoute, group) => {
    const activatedRoutes = walkRoutePath(activatedRoute);
    const allParams$ = activatedRoutes.map(getActivatedRouteParam(group));
    return combineLatest(allParams$).pipe(map$1(allParams => allParams.find(v => v !== undefined)));
};
/**
 * @deprecated Will be removed in v7.0.0
 */
const createRouteParams = (activatedRoute, itemNavigation, rootModel) => ({
    source: (group) => () => getRouteParam(activatedRoute, group).pipe(map$1(deserialize)),
    sink: (group) => {
        return stdin => {
            stdin.pipe(map$1(serialize), routeParams(group)).subscribe(params => {
                rootModel
                    .commonAncestor(new CommunicationDefinition(TAG$3, group))
                    .pipe(first())
                    .subscribe(commonAncestor => {
                    if (commonAncestor === undefined) {
                        return console.warn('No Inputs configured to receive route param');
                    }
                    itemNavigation.navigateToItem(commonAncestor.name, params);
                });
            });
        };
    },
});
/**
 * @deprecated Will be removed in v7.0.0
 */
const routeParamsProcessorConfig = createPipelineProcessorConfig(TAG$3, {
    provide: new InjectionToken('Route param pipeline handler'),
    useFactory: createRouteParams,
    deps: [ActivatedRoute, ӨItemNavigationService, ӨRootContainerService],
});
function serialize(outputValue) {
    return typeof outputValue === 'string' ? outputValue : `"${JSON.stringify(outputValue)}"`;
}
function deserialize(payload) {
    if (payload === undefined) {
        return undefined;
    }
    // not serialized
    if (!(payload.startsWith('"') && payload.endsWith('"'))) {
        return payload;
    }
    // actually attempt to deserialize
    try {
        return JSON.parse(payload.substr(1, payload.length - 2));
    }
    catch (_) {
        return payload;
    }
}

const createRouteParamsMulti = (activatedRoute, routerService, itemNavigation) => ({
    sink: (targetName) => (stdin) => {
        stdin.subscribe(params => {
            if (!targetName) {
                routerService.navigate(routerService.setParams(params, activatedRoute));
            }
            else {
                itemNavigation.navigateToItem(targetName, params);
            }
        });
    },
});
/**
 * Configure the `RouteParamsMultiSink`.
 *
 * Use the string 'route-param-multi' to configure this handler.
 *
 * @usageNotes
 *
 * Store some 2-way bound states to the router as "paramName"
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": "route-param-multi",
 *     "input.myInput": "route-param input1", // assuming input1 is set via myOutput
 *     "input.myInput2": "route-param input2" // assuming input2 is set via myOutput
 *   }
 * }
 * ```
 *
 * Navigate to widget-b and pass data via route-param
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": "route-param-multi widget-b"
 *   }
 * },
 * {
 *   "name": "widget-b",
 *   "properties": {
 *     "input.myInput": "route-param input1",
 *     "input.myInput2": "route-param input2"
 *   }
 * }
 * ```
 *
 * See `RouteParamsMultiSink` for more options.
 *
 * Also see:
 *  - `routeParamsProcessorConfig`
 *  -
 */
const routeParamsMultiProcessorConfig = {
    name: 'route-param-multi',
    provider: {
        provide: new InjectionToken('Route param multi pipeline handler'),
        useFactory: createRouteParamsMulti,
        deps: [ActivatedRoute, RouterNavigationService, ӨItemNavigationService],
    },
};

const createItemNavigate = (itemNavigation) => ({
    sink: (targetName) => (stdin) => {
        stdin.subscribe(() => {
            itemNavigation.navigateToItem(targetName, {});
        });
    },
});
/**
 * Configure the `ItemNavigateSink`.
 *
 * Use the string 'item-navigate' to configure this handler.
 *
 * Note: to pass route params you must use `RouteParamsStore` instead.
 *
 * @usageNotes
 *
 * Navigate between widgets
 *
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": "item-navigate widget-b"
 *   }
 * },
 * {
 *   "name": "widget-b"
 * }
 * ```
 *
 * See `RouteParamsStore` for more options.
 */
const itemNavigateProcessorConfig = {
    name: 'item-navigate',
    provider: {
        provide: new InjectionToken('Item navigation pipeline handler'),
        useFactory: createItemNavigate,
        deps: [ӨItemNavigationService],
    },
};

const createModelSource = (itemModel) => ({
    source: (propertyName) => () => itemModel.property(propertyName),
});
/**
 * Configure the `ModelSource`.
 *
 * Use the string 'model' to configure this handler.
 *
 * @usageNotes
 *
 * ```json
 * {
 *   "modelProperty": "foobar",
 *   "input.myInput": "model modelProperty", // read the value of modelProperty
 * }
 * ```
 */
const modelProcessorConfig = {
    name: 'model',
    provider: {
        provide: new InjectionToken('Model pipeline handler'),
        useFactory: createModelSource,
        deps: [ItemModel],
    },
};

/**
 * @deprecated Will be removed in v7.0.0
 */
const createAppConfigSource = (appConfig) => ({
    source: (configName) => () => appConfig.getConfig().pipe(pluck(configName)),
});
const TAG$2 = 'app-config';
/**
 * @deprecated Will be removed in v7.0.0
 * AppConfig Communication Transport
 *
 * Can be used in standalone development to configure communication using AppConfig
 */
class AppConfig {
    /**
     * Generate a serialized communication configuration suitable for use as a Widget Input property value.
     *
     * @param group The name of the communication group to which the Input belongs
     */
    static toProperty(group) {
        return serializerDeserializer.toProperty(new CommunicationDefinition(TAG$2, group));
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Configure the `AppConfigSource`.
 *
 * Use the `AppConfig.toProperty` helper to configure this handler.
 *
 * @usageNotes
 *
 * ```json
 * {
 *   "input.myInput": "AppConfig.toProperty(configPropertyName)", // read the value of application configuration
 * }
 * ```
 */
const appConfigProcessorConfig = createPipelineProcessorConfig(TAG$2, {
    provide: new InjectionToken('Application configuration pipeline handler'),
    useFactory: createAppConfigSource,
    deps: [AppConfigService],
});

class UrlSinkNavigator {
    go(url) {
        window.location.href = url;
    }
}
const createUrlSink = (navigator = new UrlSinkNavigator()) => ({
    sink: (url, paramName) => (stdin) => {
        stdin.subscribe((payload) => {
            navigator.go(navigationUrlWithParam(url, paramName, payload));
        });
    },
});
function navigationUrlWithParam(navigationUrl, paramName, param) {
    if (!paramName || !param) {
        return navigationUrl;
    }
    const paramSeparator = navigationUrl.indexOf('?') === -1 ? '?' : '&';
    return `${navigationUrl}${paramSeparator}${paramName}=${param}`;
}
/**
 * Configure the `UrlSink`.
 *
 * Use the string 'url' to configure this handler.
 *
 * @usageNotes
 *
 * ```json
 * {
 *   "output.myOutput1": "url http://www.google.com/", // navigate without param
 *   "output.myOutput2": "url http://www.google.com/ query" // navigate with param
 * }
 * ```
 */
const urlProcessorConfig = {
    name: 'url',
    provider: {
        provide: new InjectionToken('Url pipeline handler'),
        useFactory: createUrlSink,
        deps: [],
    },
};

const TAG$1 = 'router.navigate';
const isDefined = (param) => param !== undefined;
const ɵ0$3 = isDefined;
/**
 * @deprecated Will be removed in v7.0.0
 */
const PARAM_PLACEHOLDER_BUILDER = Symbol('Param Placeholder Builder');
/**
 * @deprecated Will be removed in v7.0.0
 * Placeholder to use for a named optional matrix param in `RouterNavigate`.
 *
 * This class is private. Use `RouterNavigateSink.param` to create a placeholder.
 */
class RouterNavigateParamPlaceholder {
    constructor(paramName) {
        this.paramName = paramName;
    }
    /**
     * @internal
     */
    static [PARAM_PLACEHOLDER_BUILDER](name) {
        return new RouterNavigateParamPlaceholder(name);
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Serialize the command generated with TS to pipeline source argument strings for the model.
 *
 * - Path commands are serialized as the path string.
 * - Single named optional params are serialzed as {paramName}
 * @param commands
 */
const serializeCommands = (commands) => {
    // Validate that there is only max one placeholder
    if (commands.filter(command => command instanceof RouterNavigateParamPlaceholder).length > 1) {
        throw new Error('RouterNavigate: Only a single placeholder can be configured');
    }
    return commands.map(command => {
        if (command instanceof RouterNavigateParamPlaceholder) {
            return `{${command.paramName}}`;
        }
        else {
            return command;
        }
    });
};
/**
 * Deserialize the pipeline string arguments to commands for Router.navigate.
 * @param commands
 */
const deserializeCommands = (commands) => commands.map(command => {
    const paramNameMatches = command.match(/^{([^}]+)}$/);
    if (!paramNameMatches) {
        return command;
    }
    return RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER](paramNameMatches[1]);
});
const ɵ1$2 = deserializeCommands;
/**
 * @deprecated Will be removed in v7.0.0
 * Helper to configure output properties to write to the `RouterNavigateStore`
 *
 * @usageNotes
 *
 * To navigate like:
 *
 * ```ts
 * myOutput.subscribe(() => Router.navigate(['items']);)
 * ```
 *
 * Configure your model like:
 *
 * ```json
 *  {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouterNavigateSink.navigate(['items']),
 *   }
 * }
 * ```
 *
 * To navigate to nested paths like:
 *
 * ```ts
 * myOutput.subscribe(() => Router.navigate(['dashboard', 'transactions']);)
 * ```
 *
 * Configure your model like:
 *
 * ```json
 *  {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouterNavigateSink.navigate(['dashboard', 'transactions']),
 *   }
 * }
 * ```
 *
 * To navigate passing [optional route
 * params](https://angular.io/guide/router-tutorial-toh#heroes-list-optionally-selecting-a-hero),
 * eg in Angular it would be:
 *
 * ```ts
 * heroId.subscribe((heroId) => Router.navigate(['heroes', { id: heroId }]));
 * ```
 *
 * Configure your model like:
 *
 * ```json
 * {
 *   "output.heroId": RouterNavigateSink.navigate(['heroes', RouterNavigateSink.param('id')]),
 * }
 * ```
 *
 * To read a param you can connect an input to the `RouterNavigateSource`.
 */
class RouterNavigateSink {
    /**
     * Generate a serialized `PipelineSink` configuration suitable for use as a Widget Output property value.
     *
     * @param commands The commands to use for navigation.
     */
    static navigate(commands) {
        return `${TAG$1} ${serializeCommands(commands).join(' ')}`;
    }
    /**
     * Create a param placeholder to use in a `RouterNavigateSink`.
     *
     * @param paramName
     */
    static param(paramName) {
        if (!paramName) {
            throw new Error('RouterNavigateSink.param: paramName must be set');
        }
        return RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER](paramName);
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Helper to configure input properties to read from the `RouterNavigateStore`
 *
 * @usageNotes
 *
 *
 * To read a param into an input property:
 *
 * ```json
 * {
 *   "input.heroId": RouterNavigateSource.param('id')
 * }
 * ```
 */
class RouterNavigateSource {
    /**
     * Generate a serialized `PipelineSource` configuration suitable for use as a Widget Input property value.
     *
     * @param paramName The name of the param to read from the URL.
     */
    static param(paramName) {
        return `${TAG$1} ${paramName}`;
    }
}
const matrixParam = (param, paramValue) => isDefined(paramValue) ? { [param.paramName]: `${paramValue}` } : paramValue;
const ɵ2$1 = matrixParam;
// Convert configured navigate commands to actual angular Router.navigate commands
const navigateCommands = (commands, paramValue) => commands
    .map(command => (command instanceof RouterNavigateParamPlaceholder ? matrixParam(command, paramValue) : command))
    .filter(isDefined);
const ɵ3$1 = navigateCommands;
/**
 * @deprecated Will be removed in v7.0.0
 */
const createRouterNavigateStore = (router, activatedRoute) => ({
    sink: (...serializedCommands) => {
        const commands = deserializeCommands(serializedCommands);
        return stdin => {
            stdin.subscribe(paramValue => {
                router.navigate(navigateCommands(commands, paramValue));
            });
        };
    },
    source: (paramName) => () => getRouteParam(activatedRoute, paramName),
});
/**
 * @deprecated Will be removed in v7.0.0
 */
const routerNavigateProcessorConfig = createPipelineProcessorConfig(TAG$1, {
    provide: new InjectionToken('Router.Navigate pipeline handler'),
    useFactory: createRouterNavigateStore,
    deps: [Router, ActivatedRoute],
});

/**
 * @deprecated
 */
class Graph {
    constructor() {
        this.vertexes = new Set();
        this.edges = new Map();
    }
    add(vertex) {
        this.vertexes.add(vertex);
    }
    connect(from, to, value) {
        this.add(from);
        this.add(to);
        let vertexEdges = this.edges.get(from);
        if (vertexEdges === undefined) {
            vertexEdges = new Map();
            this.edges.set(from, vertexEdges);
        }
        vertexEdges.set(to, { value });
    }
    getEdge(from, to) {
        const edges = this.edges.get(from);
        const edge = edges === undefined ? undefined : edges.get(to);
        return edge === undefined ? undefined : edge.value;
    }
}

const CONFIG_FLOWS = new InjectionToken('@backbase/foundation Communcation Flow Configuration');
class FlowsService {
    constructor(flowsConfig) {
        this.transitions = new Graph();
        if (flowsConfig !== null) {
            flowsConfig.forEach(flows => {
                flows.forEach(flow => {
                    this.addFlow(flow);
                });
            });
        }
    }
    addFlow(config) {
        const currentEdge = this.transitions.getEdge(config.output.classId, config.input.classId);
        const flow = {
            output: config.output.outputName,
            input: config.input.inputName,
            map: config.mapPayload,
        };
        const edge = currentEdge ? [...currentEdge, flow] : [flow];
        this.transitions.connect(config.output.classId, config.input.classId, edge);
    }
    getFlows(from, fromOutput, to, toInput) {
        const flows = to.reduce((acc, classId) => [...acc, ...(this.transitions.getEdge(from, classId) || [])], []);
        return flows.filter(flow => flow.output === fromOutput && (toInput === undefined || flow.input === undefined || toInput === flow.input));
    }
}
FlowsService.ɵfac = function FlowsService_Factory(t) { return new (t || FlowsService)(ɵngcc0.ɵɵinject(CONFIG_FLOWS, 8)); };
FlowsService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: FlowsService, factory: FlowsService.ɵfac });
FlowsService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG_FLOWS,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FlowsService, [{
        type: Injectable
    }], function () { return [{ type: Array, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [CONFIG_FLOWS]
            }] }]; }, null); })();

class ItemTransitionService {
    constructor(flows, navigationService) {
        this.flows = flows;
        this.navigationService = navigationService;
    }
    transition(fromItem, fromOutput, toItem, toInput, ancestors, payload) {
        // Deprecated
        const flows = this.flows.getFlows(fromItem.ɵclassId, fromOutput, [...ancestors.map(item => item.ɵclassId)], toInput);
        if (flows.length === 0) {
            flows.push({ output: fromOutput, input: toInput });
        }
        const params = this.mapFlows(flows, toInput, payload);
        return this.navigationService.navigateToItem(toItem.name, params);
    }
    mapFlows(flows, toInput, payload) {
        return flows.reduce((acc, flow) => {
            const inputName = toInput || flow.input || flow.output;
            const value = flow.map ? flow.map(payload) : payload;
            if (value === undefined) {
                return acc; // @todo: should it be possible to "clear" a param with undefined?
            }
            // Note: if 2 flows map to the same input, the 2nd will overwrite
            return Object.assign(Object.assign({}, acc), { [inputName]: value });
        }, {});
    }
}
ItemTransitionService.ɵfac = function ItemTransitionService_Factory(t) { return new (t || ItemTransitionService)(ɵngcc0.ɵɵinject(FlowsService), ɵngcc0.ɵɵinject(ӨItemNavigationService)); };
ItemTransitionService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ItemTransitionService, factory: ItemTransitionService.ɵfac });
ItemTransitionService.ctorParameters = () => [
    { type: FlowsService },
    { type: ӨItemNavigationService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemTransitionService, [{
        type: Injectable
    }], function () { return [{ type: FlowsService }, { type: ӨItemNavigationService }]; }, null); })();

const pipeName = 'navigation';
const navigationHandlerToken = new InjectionToken('Navigation handler');
const createNavigationSink = (rootContainer, itemTransition, itemModel) => {
    return {
        sink: (outputName, config) => (stdin) => {
            if (outputName === undefined || config === undefined) {
                return;
            }
            const [targetName, targetInput] = config.split('.');
            const target$ = rootContainer.model.pipe(mergeMap(tree => tree.find(item => item.name === targetName)), filter((a) => a !== undefined));
            const targetAnscestors = target$.pipe(mergeMap(tree => tree.flatten()), map$1(flatNodes => flatNodes.map(node => node.value)));
            combineLatest([target$, targetAnscestors, stdin]).subscribe(([target, anscestors, payload]) => itemTransition.transition(itemModel, outputName, target.value, targetInput, anscestors, payload));
        },
    };
};
const navigationProcessorConfig = {
    name: pipeName,
    provider: {
        provide: navigationHandlerToken,
        useFactory: createNavigationSink,
        deps: [ӨRootContainerService, ItemTransitionService, ItemModel],
    },
};

/**
 * The model of the item at the root of the SPA (ie: the app container).
 */
class RootItemModelService {
    constructor(rootModel) {
        this.rootModel = rootModel;
    }
    /**
     * Find an item by searching the tree of the SPA.
     *
     * Note: Because the model of the SPA can change, this method returns an observable.
     *
     * @param name The instance name of the item to find.
     */
    findByName(name) {
        return this.find(model => model.name === name);
    }
    find(predicate) {
        return this.rootModel.model.pipe(switchMap(model => model.find(predicate)));
    }
}
RootItemModelService.ɵfac = function RootItemModelService_Factory(t) { return new (t || RootItemModelService)(ɵngcc0.ɵɵinject(ӨRootContainerService)); };
RootItemModelService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RootItemModelService, factory: RootItemModelService.ɵfac });
RootItemModelService.ctorParameters = () => [
    { type: ӨRootContainerService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RootItemModelService, [{
        type: Injectable
    }], function () { return [{ type: ӨRootContainerService }]; }, null); })();

/**
 * AreaComponent is a wrapper for ChromeComponent,
 * which defines the area for dynamic components rendering
 */
class AreaComponent {
    constructor(itemRegistry) {
        this.itemRegistry = itemRegistry;
        /**
         * name attribute of the area,
         * represented also as a "data-area"
         * attribute in the corresponding node
         */
        this.name = '0';
        this.children = [];
    }
    /**
     * @internal
     */
    isModule(model) {
        return !!this.itemRegistry.getModuleLoader(model.ɵclassId);
    }
}
AreaComponent.ɵfac = function AreaComponent_Factory(t) { return new (t || AreaComponent)(ɵngcc0.ɵɵdirectiveInject(ItemRegistryService)); };
AreaComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AreaComponent, selectors: [["bb-area"]], hostVars: 1, hostBindings: function AreaComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-area", ctx.name);
    } }, inputs: { name: "name", children: "children" }, decls: 1, vars: 1, consts: [[4, "ngFor", "ngForOf"], [4, "ngIf", "ngIfElse"], ["renderModel", ""], [3, "item"]], template: function AreaComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, AreaComponent_ng_container_0_Template, 5, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.children);
    } }, directives: function () { return [ɵngcc2.NgForOf, ɵngcc2.NgIf, ɵngcc1.RouterOutlet, ChromeComponent]; }, styles: ["[_nghost-%COMP%] { display: block; }"] });
AreaComponent.ctorParameters = () => [
    { type: ItemRegistryService }
];
AreaComponent.propDecorators = {
    name: [{ type: HostBinding, args: ['attr.data-area',] }, { type: Input }],
    children: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AreaComponent, [{
        type: Component,
        args: [{
                selector: 'bb-area',
                template: `
    <ng-container *ngFor="let item of children">
      <router-outlet *ngIf="isModule(item.value); else renderModel"></router-outlet>
      <ng-template #renderModel><bb-chrome [item]="item"></bb-chrome></ng-template>
      <ng-container> </ng-container
    ></ng-container>
  `,
                styles: [':host { display: block; }']
            }]
    }], function () { return [{ type: ItemRegistryService }]; }, { name: [{
            type: HostBinding,
            args: ['attr.data-area']
        }, {
            type: Input
        }], children: [{
            type: Input
        }] }); })();

class RouterService {
    /**
     * Backbase Angular Router abstraction.
     * See https://angular.io/api/router/Router
     *
     * The purpose for Backbase abstracting around the default Angular Router is
     * when linking a to a bb-router-outlet. The outlet name for a bb-router-outlet
     * is dynamically generated by a property on the model, so you can use the
     * Backbase Router service to automatically apply the outletName to the navigation
     * commands.
     *
     * @param router Angular Router
     * @param route Angular ActivatedRoute
     * @param itemModel Model of the Backbase Widget or Container
     */
    constructor(router, route, itemModel, routerConfig) {
        this.router = router;
        this.route = route;
        this.itemModel = itemModel;
        this.routerConfig = routerConfig;
        this.outletName = this.routerConfig.ɵitemOutletName(this.itemModel);
    }
    /**
     * Navigate based on the provided array of commands and a starting point.
     * If no starting route is provided, the navigation is absolute.
     * See Angular Router.navigate
     */
    navigate(commands, extras = {}) {
        return this.createUrlTree(commands, extras).then(urlTree => this.router.navigateByUrl(this.router.serializeUrl(urlTree), extras));
    }
    /**
     * Applies an array of commands to the current url tree and creates a new url tree.
     * See Angular Router.createUrlTree
     */
    createUrlTree(commands, extras = {}) {
        return this.outletName
            .pipe(take(1))
            .toPromise()
            .then(outletName => this.outletCommands(outletName, commands))
            .then(cmnds => this.router.createUrlTree(cmnds, Object.assign({ relativeTo: this.route }, extras)));
    }
    outletCommands(outletName, commands) {
        if (outletName == null || outletName === PRIMARY_OUTLET) {
            return commands;
        }
        else {
            return [{ outlets: { [outletName]: commands } }];
        }
    }
}
RouterService.ɵfac = function RouterService_Factory(t) { return new (t || RouterService)(ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵinject(ItemModel), ɵngcc0.ɵɵinject(AbstractRouterConfigService)); };
RouterService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RouterService, factory: RouterService.ɵfac });
RouterService.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute },
    { type: ItemModel },
    { type: AbstractRouterConfigService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc1.ActivatedRoute }, { type: ItemModel }, { type: AbstractRouterConfigService }]; }, null); })();

class ItemInjectorService {
    constructor(inputBroker, outputBroker) {
        this.inputBroker = inputBroker;
        this.outputBroker = outputBroker;
    }
    createInjector(parent, item) {
        const widgetProvider = {
            provide: ItemModel,
            useValue: item.value,
        };
        const containerProvider = {
            provide: ItemModelTree,
            useValue: item,
        };
        const routerServiceProvider = {
            provide: RouterService,
            deps: [Router, ActivatedRoute, ItemModel, AbstractRouterConfigService],
        };
        /**
         * @todo: consider putting *all* configured handlers on the
         * injector, instead of only handlers used based on the model.
         *
         * This would make it possible to create higher-order handlers
         */
        const communicationPipelineProviders = uniq([
            ...this.inputBroker.getItemProviders(item.value),
            ...this.outputBroker.getItemProviders(item.value),
        ]);
        const pipelineService = {
            provide: PipelineService,
            deps: [PipelineRegistry, Injector],
        };
        return Injector.create({
            providers: [
                widgetProvider,
                containerProvider,
                routerServiceProvider,
                ...communicationPipelineProviders,
                pipelineService,
                {
                    provide: ɵSTORE_BRANCH,
                    useValue: item.value.name,
                },
                {
                    provide: ɵSTORE_DISPATCH_CHANNEL,
                    useValue: item.value.name,
                },
                {
                    provide: StoreFactory,
                    useClass: StoreFactory,
                    deps: [ɵStoreBroker, ɵSTORE_BRANCH, ɵSTORE_DISPATCH_CHANNEL, FeaturesService],
                },
                {
                    provide: TemplateRegistry,
                    useClass: TemplateRegistry,
                    deps: [],
                },
            ],
            parent,
        });
    }
}
ItemInjectorService.ɵfac = function ItemInjectorService_Factory(t) { return new (t || ItemInjectorService)(ɵngcc0.ɵɵinject(InputBrokerService), ɵngcc0.ɵɵinject(OutputBrokerService)); };
ItemInjectorService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: ItemInjectorService, factory: ItemInjectorService.ɵfac });
ItemInjectorService.ctorParameters = () => [
    { type: InputBrokerService },
    { type: OutputBrokerService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemInjectorService, [{
        type: Injectable
    }], function () { return [{ type: InputBrokerService }, { type: OutputBrokerService }]; }, null); })();

class CombinedComponentFactoryResolver {
    constructor(itemRegistry, rootResolver) {
        this.itemRegistry = itemRegistry;
        this.rootResolver = rootResolver;
        this.childResolvers = new Map();
    }
    registerChildResolver(classId, resolver) {
        this.childResolvers.set(classId, resolver);
    }
    resolveComponentFactory(classId) {
        const type = this.itemRegistry.getComponentValue(classId);
        if (!type) {
            throw new Error(`@backbase/foundation No component registered for ${classId}. Did you add it to the classMap?`);
        }
        const resolver = this.childResolvers.get(classId) || this.rootResolver;
        return resolver.resolveComponentFactory(type);
    }
}
CombinedComponentFactoryResolver.ɵfac = function CombinedComponentFactoryResolver_Factory(t) { return new (t || CombinedComponentFactoryResolver)(ɵngcc0.ɵɵinject(ItemRegistryService), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
CombinedComponentFactoryResolver.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: CombinedComponentFactoryResolver, factory: CombinedComponentFactoryResolver.ɵfac });
CombinedComponentFactoryResolver.ctorParameters = () => [
    { type: ItemRegistryService },
    { type: ComponentFactoryResolver }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CombinedComponentFactoryResolver, [{
        type: Injectable
    }], function () { return [{ type: ItemRegistryService }, { type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();

class ItemLoaderService {
    constructor(compiler, parentInjector, itemRegistry, componentFactoryResolver, 
    // @fixme: generate lazy map from the page model?
    lazyConfig) {
        this.compiler = compiler;
        this.parentInjector = parentInjector;
        this.itemRegistry = itemRegistry;
        this.componentFactoryResolver = componentFactoryResolver;
        this.lazyComponentsConfig = lazyConfig
            ? lazyConfig.filter((config) => !!config.components)
            : [];
        if (hasDuplicates(this.lazyComponentsConfig.reduce((acc, config) => [...acc, ...config.components], []))) {
            throw new Error('[LazyConfig] You have added one or more components inside multiple lazy loading bundles. ' +
                "This will make an impact on your app's performance. " +
                'Update your config to have one component included in only one bundle.');
        }
    }
    /**
     * Loads the module this class is in, and adds
     * it to the global item registry, and global component
     * resolver.
     *
     * @param classId
     */
    loadComponent(classId) {
        if (this.itemRegistry.has(classId) || this.lazyComponentsConfig.length === 0) {
            return Promise.resolve();
        }
        const foundBundle = this.lazyComponentsConfig.find(item => item.components.indexOf(classId) !== -1);
        const callback = foundBundle ? foundBundle.loadChildren : undefined;
        if (!callback) {
            return Promise.resolve();
        }
        return callback()
            .then(this.toModuleFactory.bind(this))
            .then(this.loadModule.bind(this))
            .then(this.registerModule.bind(this, classId));
    }
    toModuleFactory(loadedItem) {
        // Depending on compiler, callback can return either module factory or the module itself.
        return loadedItem instanceof NgModuleFactory ? loadedItem : this.compiler.compileModuleSync(loadedItem);
    }
    loadModule(moduleFactory) {
        return moduleFactory.create(this.parentInjector);
    }
    registerModule(classId, ngModule) {
        this.registerComponentClass(classId, ngModule);
        this.registerComponentFactoryResolver(classId, ngModule);
    }
    registerComponentClass(classId, ngModule) {
        const childRegistry = ngModule.injector.get(ItemRegistryService);
        const componentClass = childRegistry.getComponentValue(classId);
        if (!componentClass) {
            throw new Error(`@backbase/foundation No component registered for ${classId}. Did you add it to the classMap?`);
        }
        this.itemRegistry.add(classId, componentClass);
    }
    registerComponentFactoryResolver(classId, ngModule) {
        this.componentFactoryResolver.registerChildResolver(classId, ngModule.componentFactoryResolver);
    }
}
ItemLoaderService.ɵfac = function ItemLoaderService_Factory(t) { return new (t || ItemLoaderService)(ɵngcc0.ɵɵinject(ɵngcc0.Compiler), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ItemRegistryService), ɵngcc0.ɵɵinject(CombinedComponentFactoryResolver), ɵngcc0.ɵɵinject(LAZY_MAP, 8)); };
ItemLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ItemLoaderService_Factory() { return new ItemLoaderService(i0.ɵɵinject(i0.Compiler), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(ItemRegistryService), i0.ɵɵinject(CombinedComponentFactoryResolver), i0.ɵɵinject(LAZY_MAP, 8)); }, token: ItemLoaderService, providedIn: "root" });
ItemLoaderService.ctorParameters = () => [
    { type: Compiler },
    { type: Injector },
    { type: ItemRegistryService },
    { type: CombinedComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [LAZY_MAP,] }, { type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ItemLoaderService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc0.Compiler }, { type: ɵngcc0.Injector }, { type: ItemRegistryService }, { type: CombinedComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [LAZY_MAP]
            }, {
                type: Optional
            }] }]; }, null); })();

/**
 * ChromeComponent represents "chrome element" and
 * implements dynamic components rendering
 */
class ChromeComponent {
    /**
     * ChromeComponent constructor
     * @param componentFactoryResolver Factory which allows chrome component to resolve items
     * @param injectors Injectors map
     * @param components Components Registry Service
     */
    constructor(itemLifecycle, itemInjector, itemLoader, componentFactoryLoader) {
        this.itemLifecycle = itemLifecycle;
        this.itemInjector = itemInjector;
        this.itemLoader = itemLoader;
        this.componentFactoryLoader = componentFactoryLoader;
        this.gc$ = new Subject();
        this.itemValue = new ReplaySubject(1);
        this.component$ = this.itemValue.pipe(switchMap(item => this.createComponent(item)), shareReplay(1));
        this.componentItemModelTuple = this.component$.pipe(withLatestFrom(this.itemValue), map$1(([ref, item]) => ref === undefined ? [undefined, undefined] : [ref, item]), startWith([undefined, undefined]));
    }
    /**
     * Setter (Input) for an item to be bootstrapped
     * @param item Actual item to be bootstrapped
     */
    set item(item) {
        this.name = item.value.name;
        this.itemValue.next(item);
    }
    ngOnInit() {
        // Insert component on create
        this.componentItemModelTuple
            .pipe(pairwise(), takeUntil(this.gc$))
            .subscribe(([[oldComponent, oldItemValue], [component, item]]) => {
            if (!this.vcRef || !component || !item) {
                return;
            }
            if (oldComponent && oldItemValue) {
                this.itemLifecycle.onRemove(oldItemValue, oldComponent);
            }
            this.vcRef.clear();
            this.vcRef.insert(component.hostView);
            this.itemLifecycle.onCreate(item, component);
            component.changeDetectorRef.markForCheck();
        });
    }
    ngOnDestroy() {
        // Cleanup on destroy
        this.componentItemModelTuple.pipe(takeUntil(this.gc$), last()).subscribe(([component, item]) => {
            if (item && component) {
                this.itemLifecycle.onRemove(item, component);
            }
        });
        this.gc$.next();
        this.gc$.complete();
    }
    /**
     * inner helper function which creates components
     * @param item item to be created
     */
    createComponent(item) {
        return this.itemLoader
            .loadComponent(item.value.ɵclassId)
            .then(() => this.componentFactoryLoader.resolveComponentFactory(item.value.ɵclassId))
            .then(componentFactory => {
            // FIXME: @deprecated parentInjector (no replacement)
            const injector = this.itemInjector.createInjector(this.vcRef && this.vcRef.parentInjector, item);
            // Create the component
            return componentFactory.create(injector);
        });
    }
}
ChromeComponent.ɵfac = function ChromeComponent_Factory(t) { return new (t || ChromeComponent)(ɵngcc0.ɵɵdirectiveInject(ItemLifecycleService), ɵngcc0.ɵɵdirectiveInject(ItemInjectorService), ɵngcc0.ɵɵdirectiveInject(ItemLoaderService), ɵngcc0.ɵɵdirectiveInject(CombinedComponentFactoryResolver)); };
ChromeComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: ChromeComponent, selectors: [["bb-chrome"]], viewQuery: function ChromeComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 7, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.vcRef = _t.first);
    } }, hostVars: 1, hostBindings: function ChromeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("data-chrome", ctx.name);
    } }, inputs: { item: "item" }, decls: 2, vars: 0, consts: [["vc", ""]], template: function ChromeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, null, 0);
    } }, encapsulation: 2 });
ChromeComponent.ctorParameters = () => [
    { type: ItemLifecycleService },
    { type: ItemInjectorService },
    { type: ItemLoaderService },
    { type: CombinedComponentFactoryResolver }
];
ChromeComponent.propDecorators = {
    vcRef: [{ type: ViewChild, args: ['vc', { read: ViewContainerRef, static: true },] }],
    name: [{ type: HostBinding, args: ['attr.data-chrome',] }],
    item: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChromeComponent, [{
        type: Component,
        args: [{
                selector: 'bb-chrome',
                template: ` <ng-container #vc></ng-container> `
            }]
    }], function () { return [{ type: ItemLifecycleService }, { type: ItemInjectorService }, { type: ItemLoaderService }, { type: CombinedComponentFactoryResolver }]; }, { item: [{
            type: Input
        }], name: [{
            type: HostBinding,
            args: ['attr.data-chrome']
        }], vcRef: [{
            type: ViewChild,
            args: ['vc', { read: ViewContainerRef, static: true }]
        }] }); })();

/**
 * @deprecated Will be removed in v7.0.0
 */
const createInterceptCallback = (interceptConfig) => (responseError) => {
    return (responseError.status === interceptConfig.statusCode &&
        responseError.headers.get(interceptConfig.headerAttribute) !== null);
};
/**
 * @deprecated Will be removed in v7.0.0
 */
const isInterceptCallback = (interceptConfig) => typeof interceptConfig === 'function';
/**
 * @deprecated Will be removed in v7.0.0
 */
const DEFAULT_STEPUP_CONFIG = {
    retryRequests: {
        headerAttribute: 'X-MFA',
    },
    interceptResponses: {
        statusCode: 401,
        headerAttribute: 'WWW-Authenticate',
    },
};
/**
 * @deprecated Will be removed in v7.0.0
 */
class StepUpInterceptor {
    constructor(stepupService, config, injector) {
        this.stepupService = stepupService;
        this.config = config;
        this.injector = injector;
    }
    intercept(req, next) {
        const shouldIntercept = isInterceptCallback(this.config.interceptResponses)
            ? this.config.interceptResponses
            : createInterceptCallback(this.config.interceptResponses);
        return next.handle(req).pipe(catchError((error) => {
            var _a;
            if (!shouldIntercept(error)) {
                // if it's an error which shouldn't be intercepted propagate the error
                // to as if it wasn't intercepted at all.
                return throwError(error);
            }
            this.mediatorComponent = (_a = this.mediatorComponent) !== null && _a !== void 0 ? _a : this.stepupService.stepupComponent;
            // Errors which are to be intercepted should be "paused" and the stream will be handled according
            // to the event coming from a mediator component. On complete event we are going to retry the request
            // while if any other event was fired by the mediator component, we proceed with the error as usual
            const handleMediatorComponentEvent = ([event, token]) => {
                if (event === 'complete' && token) {
                    // The HttpClient cannot be injected because it is a circular dependency, so we must lazily get it only when required.
                    const http = this.injector.get(HttpClient);
                    return http.request(req.clone({ setHeaders: { [this.config.retryRequests.headerAttribute]: token } }));
                }
                else {
                    return throwError(error);
                }
            };
            // we listen to an event from mediator component in order to be able to amend
            // requests "chain", so we can repeat the request or just propagate the error
            const mediatorComponentResponse = race(this.mediatorComponent.instance.complete.pipe(map$1(value => ['complete', value])), this.mediatorComponent.instance.cancel.pipe(map$1(() => ['cancel', undefined]))).pipe(take(1), switchMap(handleMediatorComponentEvent));
            // and we trigger the component to open
            this.mediatorComponent.instance.open(error);
            return mediatorComponentResponse;
        }));
    }
}

/**
 * @deprecated Will be removed in v7.0.0
 */
const STEPUP_CONFIG = new InjectionToken('Custom step-up configuration injection token');
/**
 * @deprecated Will be removed in v7.0.0
 */
class StepUpService {
    constructor(resolver, stepupConfigParam) {
        this.resolver = resolver;
        this.stepupConfig = Object.assign(Object.assign({}, DEFAULT_STEPUP_CONFIG), stepupConfigParam);
    }
    get stepupComponent() {
        if (this.stepupComponentRef) {
            return this.stepupComponentRef;
        }
        throw new Error('No stepupComponent defined');
    }
    createStepUpComponent(stepupContainer) {
        stepupContainer.clear();
        const factory = this.resolver.resolveComponentFactory(this.stepupConfig.mediatorComponentClass);
        this.stepupComponentRef = stepupContainer.createComponent(factory);
    }
}
StepUpService.ɵfac = function StepUpService_Factory(t) { return new (t || StepUpService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(STEPUP_CONFIG)); };
StepUpService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: StepUpService, factory: StepUpService.ɵfac });
StepUpService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [STEPUP_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepUpService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [STEPUP_CONFIG]
            }] }]; }, null); })();

const SESSION_TIMEOUT_CONFIG = new InjectionToken('Custom session timeout configuration injection token');
/**
 * The session timeout service creates a session timeout component instance within the root.
 */
class SessionTimeoutService {
    constructor(resolver, sessionTimeoutConfig) {
        this.resolver = resolver;
        this.sessionTimeoutConfig = sessionTimeoutConfig;
    }
    get sessionTimeoutComponent() {
        if (this.sessionTimeoutComponentRef) {
            return this.sessionTimeoutComponentRef;
        }
        throw new Error('No sessionTimeoutComponent defined');
    }
    createSessionTimeoutComponent(sessionTimeoutContainer) {
        sessionTimeoutContainer.clear();
        const factory = this.resolver.resolveComponentFactory(this.sessionTimeoutConfig.sessionTimeoutComponentClass);
        this.sessionTimeoutComponentRef = sessionTimeoutContainer.createComponent(factory);
        this.sessionTimeoutComponentRef.instance.inactivityModalTime = this.sessionTimeoutConfig.inactivityModalTime;
    }
}
SessionTimeoutService.ɵfac = function SessionTimeoutService_Factory(t) { return new (t || SessionTimeoutService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(SESSION_TIMEOUT_CONFIG)); };
SessionTimeoutService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: SessionTimeoutService, factory: SessionTimeoutService.ɵfac });
SessionTimeoutService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [SESSION_TIMEOUT_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SessionTimeoutService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: undefined, decorators: [{
                type: Inject,
                args: [SESSION_TIMEOUT_CONFIG]
            }] }]; }, null); })();

class RootComponent {
    constructor(rootContainer, zone, itemNavigation, events, stepupService, sessionTimeoutService) {
        this.rootContainer = rootContainer;
        this.zone = zone;
        this.itemNavigation = itemNavigation;
        this.events = events;
        this.stepupService = stepupService;
        this.sessionTimeoutService = sessionTimeoutService;
        this.children = this.rootContainer.model.pipe(flatMap$1(state => state.children));
        this.eventListener = ({ name }) => {
            // [FIXME] This zone should almost certainly be handled in the EventBus, but can't be currently
            // because we only provide an interface not a wrapper
            this.zone.run(() => {
                this.itemNavigation.navigateToItem(name, {});
            });
        };
    }
    ngOnInit() {
        if (this.events) {
            this.events.subscribe('navigation.viewItem', this.eventListener);
        }
        if (this.stepupService && this.stepupContainer) {
            this.stepupService.createStepUpComponent(this.stepupContainer);
        }
        if (this.sessionTimeoutService && this.sessionTimeoutContainer) {
            this.sessionTimeoutService.createSessionTimeoutComponent(this.sessionTimeoutContainer);
        }
    }
    ngOnDestroy() {
        if (this.events) {
            this.events.unsubscribe('navigation.viewItem', this.eventListener);
        }
    }
}
RootComponent.ɵfac = function RootComponent_Factory(t) { return new (t || RootComponent)(ɵngcc0.ɵɵdirectiveInject(ӨRootContainerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ӨItemNavigationService), ɵngcc0.ɵɵdirectiveInject(PUBSUB, 8), ɵngcc0.ɵɵdirectiveInject(StepUpService, 8), ɵngcc0.ɵɵdirectiveInject(SessionTimeoutService, 8)); };
RootComponent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: RootComponent, selectors: [["bb-root"]], viewQuery: function RootComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c1, 7, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c2, 7, ViewContainerRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.stepupContainer = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sessionTimeoutContainer = _t.first);
    } }, decls: 6, vars: 3, consts: [[3, "children"], ["stepupContainer", ""], ["sessionTimeoutContainer", ""]], template: function RootComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "bb-area", 0);
        ɵngcc0.ɵɵpipe(1, "async");
        ɵngcc0.ɵɵelement(2, "template", null, 1);
        ɵngcc0.ɵɵelement(4, "template", null, 2);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("children", ɵngcc0.ɵɵpipeBind1(1, 1, ctx.children));
    } }, directives: [AreaComponent], pipes: [ɵngcc2.AsyncPipe], encapsulation: 2, changeDetection: 0 });
RootComponent.ctorParameters = () => [
    { type: ӨRootContainerService },
    { type: NgZone },
    { type: ӨItemNavigationService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [PUBSUB,] }] },
    { type: StepUpService, decorators: [{ type: Optional }] },
    { type: SessionTimeoutService, decorators: [{ type: Optional }] }
];
RootComponent.propDecorators = {
    stepupContainer: [{ type: ViewChild, args: ['stepupContainer', { read: ViewContainerRef, static: true },] }],
    sessionTimeoutContainer: [{ type: ViewChild, args: ['sessionTimeoutContainer', { read: ViewContainerRef, static: true },] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RootComponent, [{
        type: Component,
        args: [{
                selector: 'bb-root',
                template: `
    <bb-area [children]="children | async"></bb-area>
    <template #stepupContainer></template>
    <template #sessionTimeoutContainer></template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ӨRootContainerService }, { type: ɵngcc0.NgZone }, { type: ӨItemNavigationService }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [PUBSUB]
            }] }, { type: StepUpService, decorators: [{
                type: Optional
            }] }, { type: SessionTimeoutService, decorators: [{
                type: Optional
            }] }]; }, { stepupContainer: [{
            type: ViewChild,
            args: ['stepupContainer', { read: ViewContainerRef, static: true }]
        }], sessionTimeoutContainer: [{
            type: ViewChild,
            args: ['sessionTimeoutContainer', { read: ViewContainerRef, static: true }]
        }] }); })();

const toCommandsArray = (commands) => {
    if (commands != null) {
        return Array.isArray(commands) ? commands : [commands];
    }
    else {
        return [];
    }
};
const ɵ0$2 = toCommandsArray;
class RouterLinkWithHrefDirective {
    constructor(router, bbRouter, locationStrategy, el, renderer) {
        this.router = router;
        this.bbRouter = bbRouter;
        this.locationStrategy = locationStrategy;
        this.el = el;
        this.renderer = renderer;
        this.commands = [];
        this.subscriptions = [
            router.events.subscribe(s => {
                if (s instanceof NavigationEnd) {
                    this.updateTargetUrlAndHref();
                }
            }),
        ];
    }
    set bbRouterLink(commands) {
        this.commands = toCommandsArray(commands);
    }
    ngOnChanges() {
        this.updateTargetUrlAndHref();
    }
    ngOnDestroy() {
        this.subscriptions.forEach(s => s.unsubscribe());
    }
    onClick(button, ctrlKey, metaKey, shiftKey) {
        if (button !== 0 || ctrlKey || metaKey || shiftKey) {
            return true;
        }
        if (typeof this.target === 'string' && this.target !== '_self') {
            return true;
        }
        const extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
        };
        this.urlTree.then(urlTree => {
            this.router.navigateByUrl(this.router.serializeUrl(urlTree), extras);
        });
        return false;
    }
    updateTargetUrlAndHref() {
        this.urlTree.then(urlTree => {
            this.renderer.setAttribute(this.el.nativeElement, 'href', this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(urlTree)));
        });
    }
    get urlTree() {
        return this.bbRouter.createUrlTree(this.commands, Object.assign(Object.assign({ queryParams: this.queryParams, fragment: this.fragment }, (attrBoolValue(this.preserve) ? { queryParamsHandling: 'preserve' } : {})), { queryParamsHandling: this.queryParamsHandling, preserveFragment: attrBoolValue(this.preserveFragment) }));
    }
}
RouterLinkWithHrefDirective.ɵfac = function RouterLinkWithHrefDirective_Factory(t) { return new (t || RouterLinkWithHrefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router), ɵngcc0.ɵɵdirectiveInject(RouterService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocationStrategy), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
RouterLinkWithHrefDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RouterLinkWithHrefDirective, selectors: [["a", "bbRouterLink", ""]], hostVars: 1, hostBindings: function RouterLinkWithHrefDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLinkWithHrefDirective_click_HostBindingHandler($event) { return ctx.onClick($event.button, $event.ctrlKey, $event.metaKey, $event.shiftKey); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("target", ctx.target);
    } }, inputs: { bbRouterLink: "bbRouterLink", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
RouterLinkWithHrefDirective.ctorParameters = () => [
    { type: Router },
    { type: RouterService },
    { type: LocationStrategy },
    { type: ElementRef },
    { type: Renderer2 }
];
RouterLinkWithHrefDirective.propDecorators = {
    target: [{ type: HostBinding, args: ['attr.target',] }, { type: Input }],
    queryParams: [{ type: Input }],
    fragment: [{ type: Input }],
    queryParamsHandling: [{ type: Input }],
    preserveFragment: [{ type: Input }],
    skipLocationChange: [{ type: Input }],
    replaceUrl: [{ type: Input }],
    bbRouterLink: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterLinkWithHrefDirective, [{
        type: Directive,
        args: [{ selector: 'a[bbRouterLink]' }]
    }], function () { return [{ type: ɵngcc1.Router }, { type: RouterService }, { type: ɵngcc2.LocationStrategy }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { bbRouterLink: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']]
        }], target: [{
            type: HostBinding,
            args: ['attr.target']
        }, {
            type: Input
        }], queryParams: [{
            type: Input
        }], fragment: [{
            type: Input
        }], queryParamsHandling: [{
            type: Input
        }], preserveFragment: [{
            type: Input
        }], skipLocationChange: [{
            type: Input
        }], replaceUrl: [{
            type: Input
        }] }); })();
class RouterLinkDirective {
    constructor(router, route, tabIndex, renderer, el, bbRouter) {
        this.router = router;
        this.route = route;
        this.bbRouter = bbRouter;
        this.commands = [];
        if (tabIndex == null) {
            renderer.setAttribute(el.nativeElement, 'tabindex', '0');
        }
    }
    set bbRouterLink(commands) {
        this.commands = toCommandsArray(commands);
    }
    onClick() {
        const extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
        };
        this.urlTree.then(urlTree => {
            this.router.navigateByUrl(this.router.serializeUrl(urlTree), extras);
        });
        return true;
    }
    get urlTree() {
        return this.bbRouter.createUrlTree(this.commands, Object.assign(Object.assign({ relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment }, (attrBoolValue(this.preserve) ? { queryParamsHandling: 'preserve' } : {})), { queryParamsHandling: this.queryParamsHandling, preserveFragment: attrBoolValue(this.preserveFragment) }));
    }
}
RouterLinkDirective.ɵfac = function RouterLinkDirective_Factory(t) { return new (t || RouterLinkDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ActivatedRoute), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(RouterService)); };
RouterLinkDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RouterLinkDirective, selectors: [["", "bbRouterLink", "", 5, "a"]], hostBindings: function RouterLinkDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function RouterLinkDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } }, inputs: { bbRouterLink: "bbRouterLink", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl" } });
RouterLinkDirective.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute },
    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: RouterService }
];
RouterLinkDirective.propDecorators = {
    queryParams: [{ type: Input }],
    fragment: [{ type: Input }],
    queryParamsHandling: [{ type: Input }],
    preserveFragment: [{ type: Input }],
    skipLocationChange: [{ type: Input }],
    replaceUrl: [{ type: Input }],
    bbRouterLink: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterLinkDirective, [{
        type: Directive,
        args: [{ selector: ':not(a)[bbRouterLink]' }]
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc1.ActivatedRoute }, { type: String, decorators: [{
                type: Attribute,
                args: ['tabindex']
            }] }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: RouterService }]; }, { bbRouterLink: [{
            type: Input
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], queryParams: [{
            type: Input
        }], fragment: [{
            type: Input
        }], queryParamsHandling: [{
            type: Input
        }], preserveFragment: [{
            type: Input
        }], skipLocationChange: [{
            type: Input
        }], replaceUrl: [{
            type: Input
        }] }); })();
function attrBoolValue(s) {
    return s === '' || !!s;
}

/**
 *
 * @description
 *
 * Lets you add a CSS class and `aria-current` attribute to an element when the link's route becomes active.
 *
 * This directive lets you add a CSS class and `aria-current` attribute to an element when the link's route
 * becomes active.
 *
 * Consider the following example:
 *
 * ```
 * <a bbRouterLink="/user/bob" bbRouterLinkActive="active-link">Bob</a>
 * ```
 *
 * When the url is either '/user' or '/user/bob', the active-link class will
 * be added to the `a` tag. If the url changes, the class Will be removed.
 *
 * You can set more than one class, as follows:
 *
 * ```
 * <a bbRouterLink="/user/bob" bbRouterLinkActive="class1 class2">Bob</a>
 * <a bbRouterLink="/user/bob" [bbRouterLinkActive]="['class1', 'class2']">Bob</a>
 * ```
 *
 * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
 * only when the url matches the link exactly.
 *
 * ```
 * <a bbRouterLink="/user/bob" bbRouterLinkActive="active-link" [bbRouterLinkActiveOptions]="{exact:
 * true}">Bob</a>
 * ```
 *
 * You can configure RouterLinkActive to set `aria-current` attribute for all links. If option is defined,
 * value will be added to the active link and `aria-current="false"` to the other links.
 *
 * ```
 * <a bbRouterLink="/user/bob" bbRouterLinkActive="active-link" [bbRouterLinkActiveOptions]="{ariaCurrent: 'page'}">
 *  Bob
 * </a>
 * ```
 *
 * You can assign the RouterLinkActive instance to a template variable and directly check
 * the `isActive` status.
 * ```
 * <a bbRouterLink="/user/bob" bbRouterLinkActive #rla="bbRouterLinkActive">
 *   Bob {{ rla.isActive ? '(already open)' : ''}}
 * </a>
 * ```
 *
 * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
 *
 * ```
 * <div bbRouterLinkActive="active-link" [bbRouterLinkActiveOptions]="{exact: true}">
 *   <a bbRouterLink="/user/jim">Jim</a>
 *   <a bbRouterLink="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * This will set the active-link class on the div tag if the url is either '/user/jim' or
 * '/user/bob'.
 *
 * @ngModule RouterModule
 *
 */
class RouterLinkActiveDirective {
    constructor(router, element, renderer, link, linkWithHref) {
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.link = link;
        this.linkWithHref = linkWithHref;
        this.classes = [];
        this.isActive = false;
        this.bbRouterLinkActiveOptions = {};
        this.subscription = router.events.subscribe((s) => {
            if (s instanceof NavigationEnd) {
                this.update();
            }
        });
    }
    ngAfterContentInit() {
        if (!this.links || !this.linksWithHrefs)
            return;
        this.links.changes.subscribe(_ => this.update());
        this.linksWithHrefs.changes.subscribe(_ => this.update());
        this.update();
    }
    set bbRouterLinkActive(data) {
        const classes = Array.isArray(data) ? data : data.split(' ');
        this.classes = classes.filter(c => !!c);
    }
    ngOnChanges() {
        this.update();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    updateClasses(hasActiveLinks) {
        this.classes.forEach(c => {
            if (hasActiveLinks) {
                this.renderer.addClass(this.element.nativeElement, c);
            }
            else {
                this.renderer.removeClass(this.element.nativeElement, c);
            }
        });
    }
    updateAria(hasActiveLinks) {
        const ariaAttr = 'aria-current';
        if (this.bbRouterLinkActiveOptions.ariaCurrent) {
            this.renderer.setAttribute(this.element.nativeElement, ariaAttr, hasActiveLinks ? this.bbRouterLinkActiveOptions.ariaCurrent : 'false');
        }
        else {
            this.renderer.removeAttribute(this.element.nativeElement, ariaAttr);
        }
    }
    update() {
        if (!this.links || !this.linksWithHrefs || !this.router.navigated)
            return;
        this.hasActiveLinks().then(hasActiveLinks => {
            if (this.isActive !== hasActiveLinks) {
                this.isActive = hasActiveLinks;
                this.updateAria(hasActiveLinks);
                this.updateClasses(hasActiveLinks);
            }
        });
    }
    isLinkActive(router) {
        return (link) => link.urlTree.then(urlTree => router.isActive(urlTree, !!this.bbRouterLinkActiveOptions.exact));
    }
    hasActiveLinks() {
        if (!this.links || !this.linksWithHrefs)
            return Promise.resolve(false);
        return Promise.all([
            this.link ? this.isLinkActive(this.router)(this.link) : Promise.resolve(false),
            this.linkWithHref ? this.isLinkActive(this.router)(this.linkWithHref) : Promise.resolve(false),
            ...this.links.map(this.isLinkActive(this.router)),
            ...this.linksWithHrefs.map(this.isLinkActive(this.router)),
        ]).then((liveActives) => liveActives.some(a => a));
    }
}
RouterLinkActiveDirective.ɵfac = function RouterLinkActiveDirective_Factory(t) { return new (t || RouterLinkActiveDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(RouterLinkDirective, 8), ɵngcc0.ɵɵdirectiveInject(RouterLinkWithHrefDirective, 8)); };
RouterLinkActiveDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RouterLinkActiveDirective, selectors: [["", "bbRouterLinkActive", ""]], contentQueries: function RouterLinkActiveDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLinkDirective, 5);
        ɵngcc0.ɵɵcontentQuery(dirIndex, RouterLinkWithHrefDirective, 5);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linksWithHrefs = _t);
    } }, inputs: { bbRouterLinkActiveOptions: "bbRouterLinkActiveOptions", bbRouterLinkActive: "bbRouterLinkActive" }, exportAs: ["bbRouterLinkActive"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
RouterLinkActiveDirective.ctorParameters = () => [
    { type: Router },
    { type: ElementRef },
    { type: Renderer2 },
    { type: RouterLinkDirective, decorators: [{ type: Optional }] },
    { type: RouterLinkWithHrefDirective, decorators: [{ type: Optional }] }
];
RouterLinkActiveDirective.propDecorators = {
    links: [{ type: ContentChildren, args: [RouterLinkDirective, { descendants: true },] }],
    linksWithHrefs: [{ type: ContentChildren, args: [RouterLinkWithHrefDirective, { descendants: true },] }],
    bbRouterLinkActiveOptions: [{ type: Input }],
    bbRouterLinkActive: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterLinkActiveDirective, [{
        type: Directive,
        args: [{
                selector: '[bbRouterLinkActive]',
                exportAs: 'bbRouterLinkActive'
            }]
    }], function () { return [{ type: ɵngcc1.Router }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: RouterLinkDirective, decorators: [{
                type: Optional
            }] }, { type: RouterLinkWithHrefDirective, decorators: [{
                type: Optional
            }] }]; }, { bbRouterLinkActiveOptions: [{
            type: Input
        }], bbRouterLinkActive: [{
            type: Input
        }], links: [{
            type: ContentChildren,
            args: [RouterLinkDirective, { descendants: true }]
        }], linksWithHrefs: [{
            type: ContentChildren,
            args: [RouterLinkWithHrefDirective, { descendants: true }]
        }] }); })();

const OUTLET_IS_NOT_INITIALIZED_ERROR = 'Outlet is not instantiated';
/**
 * Includes the component associated with the current Route
 */
class RouterOutletDirective {
    constructor(childrenOutletContexts, componentFactoryResolver, vcRef, cdRef, router, bbRouter) {
        this.childrenOutletContexts = childrenOutletContexts;
        this.componentFactoryResolver = componentFactoryResolver;
        this.vcRef = vcRef;
        this.cdRef = cdRef;
        this.router = router;
        this.bbRouter = bbRouter;
        this.destroy$ = new Subject();
        /**
         * A router outlet will emit an activate event any time a new component
         * is being instantiated.
         */
        // eslint-disable-next-line  @angular-eslint/no-output-rename
        this.activateEvents = new EventEmitter();
        /**
         * A router outlet will emit a deactivate event when the route component
         * is being destroyed.
         */
        // eslint-disable-next-line  @angular-eslint/no-output-rename
        this.deactivateEvents = new EventEmitter();
    }
    get name() {
        return this.nameValue || PRIMARY_OUTLET;
    }
    get isActivated() {
        return this.outlet ? this.outlet.isActivated : false;
    }
    get component() {
        if (!this.outlet) {
            throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
        }
        return this.outlet.component;
    }
    get activatedRoute() {
        if (!this.outlet) {
            throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
        }
        return this.outlet.activatedRoute;
    }
    get activatedRouteData() {
        if (!this.outlet) {
            return {};
        }
        return this.outlet.activatedRouteData;
    }
    destroy() {
        if (this.nameValue) {
            return this.removeOutletFromUrl()
                .then(() => this.router.navigate(['/']))
                .then(() => this.destroyChild());
        }
        else {
            return Promise.resolve();
        }
    }
    destroyChild() {
        if (this.outlet) {
            this.outlet.ngOnDestroy();
        }
    }
    removeOutletFromUrl() {
        // @todo: It's not possible to remove an outlet from the navigation.
        // @see: https://github.com/angular/angular/issues/15338 (this workaround is from there)
        return this.nameValue ? this.router.navigate([{ outlets: { [this.nameValue]: null } }]) : Promise.resolve(true);
    }
    ngOnInit() {
        this.bbRouter.outletName.pipe(takeUntil(this.destroy$)).subscribe(outletName => {
            this.destroy().then(() => {
                this.nameValue = outletName;
                this.outlet = new RouterOutlet(this.childrenOutletContexts, this.vcRef, this.componentFactoryResolver, this.name, this.cdRef);
                this.outlet.activateEvents.subscribe((event) => {
                    this.activateEvents.next(event);
                });
                this.outlet.deactivateEvents.subscribe((event) => {
                    this.deactivateEvents.next(event);
                });
                // Doesn't implement the `RouterOutlet` interface due to private members
                this.childrenOutletContexts.onChildOutletCreated(this.name, this);
                this.outlet.ngOnInit();
            });
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
        this.destroyChild();
        this.childrenOutletContexts.onChildOutletDestroyed(this.name);
    }
    attach(ref, activatedRoute) {
        if (!this.outlet) {
            throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
        }
        return this.outlet.attach(ref, activatedRoute);
    }
    detach() {
        if (!this.outlet) {
            throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
        }
        return this.outlet.detach();
    }
    deactivate() {
        if (this.outlet) {
            this.outlet.deactivate();
        }
    }
    activateWith(activatedRoute, resolver) {
        if (!this.outlet) {
            throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
        }
        // Not sure how hacky this is - forcefully deactivating the outlet before reactivating it.
        this.outlet.deactivate();
        return this.outlet.activateWith(activatedRoute, resolver);
    }
}
RouterOutletDirective.ɵfac = function RouterOutletDirective_Factory(t) { return new (t || RouterOutletDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ChildrenOutletContexts), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Router), ɵngcc0.ɵɵdirectiveInject(RouterService)); };
RouterOutletDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: RouterOutletDirective, selectors: [["bb-router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["bbOutlet"] });
RouterOutletDirective.ctorParameters = () => [
    { type: ChildrenOutletContexts },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: ChangeDetectorRef },
    { type: Router },
    { type: RouterService }
];
RouterOutletDirective.propDecorators = {
    activateEvents: [{ type: Output, args: ['activate',] }],
    deactivateEvents: [{ type: Output, args: ['deactivate',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterOutletDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'bb-router-outlet',
                exportAs: 'bbOutlet'
            }]
    }], function () { return [{ type: ɵngcc1.ChildrenOutletContexts }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.Router }, { type: RouterService }]; }, { activateEvents: [{
            type: Output,
            args: ['activate']
        }], deactivateEvents: [{
            type: Output,
            args: ['deactivate']
        }] }); })();

const noop = undefined;
function createRouteConfigBootstrap(routerBootstrap) {
    return routerBootstrap.bootstrap.bind(routerBootstrap);
}
const notEmpty = (a) => a.length > 0;
const ɵ0$1 = notEmpty;
const itemToNavigate = (update) => {
    if (isInsert(update)) {
        // navigate to the first child of inserted item (if exists) or to the item itself
        return {
            name: update.item.name,
            nthChild: isContainer(update.item) && notEmpty(update.item.children) ? 0 : undefined,
        };
    }
    else if (isPropertyUpdate(update)) {
        // navigate to the updated item (@todo: if this item is currently active)
        return { name: update.name };
    }
    else if (isRemovalUpdate(update)) {
        // navigate to the nth child of the parent
        return { name: update.parentName, nthChild: update.index };
    }
    else {
        throw Error('not handled model update');
    }
};
const ɵ1$1 = itemToNavigate;
class RouterBootstrapService {
    constructor(routerConfig, router, rootModel, itemNavigation) {
        this.routerConfig = routerConfig;
        this.router = router;
        this.rootModel = rootModel;
        this.itemNavigation = itemNavigation;
        this.bootstrapRoutes = this.routerConfig.routes.pipe(take(1));
        this.updateRoutes = this.routerConfig.routes.pipe(skip(1), withLatestFrom(this.rootModel.modelUpdates.pipe(startWith(noop))));
    }
    bootstrap() {
        const initialRoutes = this.router.config;
        this.bootstrapRoutes.subscribe(routes => {
            this.router.resetConfig([...routes, ...initialRoutes]);
            this.router.initialNavigation();
        });
        let lastUpdate;
        this.updateRoutes.subscribe(([routes, update]) => {
            this.router.resetConfig([...routes, ...initialRoutes]);
            if (update && lastUpdate !== update) {
                lastUpdate = update;
                this.navigateOnUpdates(update);
            }
            else {
                this.router.navigateByUrl(this.router.url, { skipLocationChange: true });
            }
        });
    }
    navigateOnUpdates(update) {
        const itemNavigation = itemToNavigate(update);
        const navigation = itemNavigation.nthChild !== undefined
            ? this.itemNavigation.navigateToChild(itemNavigation.name, itemNavigation.nthChild, {})
            : this.itemNavigation.navigateToItem(itemNavigation.name, {});
        navigation.then((result) => {
            if (!result) {
                // If the navigation failed, it might be because the item
                // was not within a routable item, so it can't be navigated to.
                // In this case, we trigger a navigation to '/' to trigger
                // and new redirects (this use-case is when a "deck-container" is
                // dropped onto the root of the page, we need to trigger the
                // redirect to the first route).
                // @todo: is there a better way to trigger redirects?
                // @todo: is there a better way to know that the navigation
                //   failure was because it was to a non-routable item? maybe
                //   it should throw instead of resolve false?
                this.router.navigateByUrl('/');
            }
        });
    }
}
RouterBootstrapService.ɵfac = function RouterBootstrapService_Factory(t) { return new (t || RouterBootstrapService)(ɵngcc0.ɵɵinject(RouterConfigService), ɵngcc0.ɵɵinject(ɵngcc1.Router), ɵngcc0.ɵɵinject(ӨRootContainerService), ɵngcc0.ɵɵinject(ӨItemNavigationService)); };
RouterBootstrapService.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: RouterBootstrapService, factory: RouterBootstrapService.ɵfac });
RouterBootstrapService.ctorParameters = () => [
    { type: RouterConfigService },
    { type: Router },
    { type: ӨRootContainerService },
    { type: ӨItemNavigationService }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RouterBootstrapService, [{
        type: Injectable
    }], function () { return [{ type: RouterConfigService }, { type: ɵngcc1.Router }, { type: ӨRootContainerService }, { type: ӨItemNavigationService }]; }, null); })();

const DEPRECATED_WITH_CONFIG = new InjectionToken('Flags whether BackbaseCoreModule.withConfig was called with deprecated options');
const logDeprecatedConfig = (deprecationService, deprecatedConfigs) => {
    const deprecatedOptions = deprecatedConfigs.reduce((acc, deprecatedConfig) => [
        ...acc,
        ...Object.keys(deprecatedConfig).filter(key => deprecatedConfig[key] !== undefined),
    ], []);
    if (deprecatedOptions.length > 0) {
        deprecationService.logDeprecatedFeature(`Deprecated options (${deprecatedOptions.join(', ')}) ` +
            'being used with BackbaseCoreModule.withConfig. Use BackbaseCoreModule.forRoot instead.');
    }
};
const createLogDeprecatedConfig = (deprecationService, deprecatedConfig) => {
    return logDeprecatedConfig.bind(null, deprecationService, deprecatedConfig);
};

const TAG = 'memory';
/**
 * @deprecated Will be removed in v7.0.0
 * Memory Communication Transport
 *
 * Can be used to configure communication using Memory.
 *
 * @usageNotes
 *
 * Pass some data to widget-b via an in memory store
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": Memory.toProperty("myGroupName")
 *   }
 * },
 * {
 *   "name": "widget-b",
 *   "properties": {
 *     "input.myInput": Memory.toProperty("myGroupName")
 *   }
 * }
 * ```
 */
class Memory {
    /**
     * Generate a serialized communication configuration suitable for use as a Widget Input or Output property value.
     *
     * @param group The name of the communication group to which the Input/Output belongs
     */
    static toProperty(group) {
        return serializerDeserializer.toProperty(new CommunicationDefinition(TAG, group));
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Storage service to retain the values for each communication group that is using the Memory transport
 */
class MemoryStorageService {
    constructor() {
        this.storage = new Map();
    }
    getSubject(group) {
        if (!this.storage.has(group)) {
            this.storage.set(group, new ReplaySubject(1));
        } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.storage.get(group);
    }
    /**
     * Get an Observable of the values being communicated to the given group
     *
     * @param group The name of the communication group
     */
    get(group) {
        return this.getSubject(group)
            .asObservable()
            .pipe(map$1(item => {
            const localValue = item.value;
            if (typeof item.value === 'object' && item.value['_clearPayload'] === true) {
                item.value = undefined;
            }
            return localValue;
        }));
    }
    /**
     * Communicate some value to members of the given communication group
     *
     * @param group The name of the communication group
     * @param value The value to communicate
     */
    set(group, value) {
        this.getSubject(group).next({ value });
    }
}
MemoryStorageService.ɵfac = function MemoryStorageService_Factory(t) { return new (t || MemoryStorageService)(); };
MemoryStorageService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MemoryStorageService_Factory() { return new MemoryStorageService(); }, token: MemoryStorageService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MemoryStorageService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
const createMemory = (itemNavigation, rootModel, storage) => {
    return {
        source: (group) => () => storage.get(group),
        sink: (group) => (stdin) => {
            const commonAncestorItem = getItemFormCommunicationGroup(group, rootModel);
            return stdin
                .pipe(concatMap(data => commonAncestorItem.pipe(map$1(item => [data, item.name]))))
                .subscribe(([data, name]) => {
                asyncScheduler.schedule(() => {
                    storage.set(group, data);
                });
                itemNavigation.navigateToItem(name, {});
            });
        },
    };
};
/**
 * @deprecated Will be removed in v7.0.0
 */
const memoryProcessorConfig = createPipelineProcessorConfig(TAG, {
    provide: new InjectionToken('Memory pipeline handler'),
    useFactory: createMemory,
    deps: [ӨItemNavigationService, ӨRootContainerService, MemoryStorageService],
});
function getItemFormCommunicationGroup(group, rootModel) {
    const communicationDefinition = new CommunicationDefinition(TAG, group);
    const commonAncestorItem = rootModel.commonAncestor(communicationDefinition).pipe(first(), filter((item) => {
        if (item === undefined) {
            console.warn(`No Inputs configured to receive in memory value for communication group "${group}"`);
            return false;
        }
        return true;
    }));
    return commonAncestorItem;
}

const coreComponents = [
    RootComponent,
    AreaComponent,
    ChromeComponent,
    RouteComponent,
    OutletCollisionComponent,
    JourneyComponent,
];
const coreDirectives = [
    RouterLinkDirective,
    RouterLinkWithHrefDirective,
    RouterLinkActiveDirective,
    RouterOutletDirective,
];
const ɵ0 = createRouteConfigBootstrap, ɵ1 = createLogDeprecatedConfig, ɵ2 = createInputBootstrap, ɵ3 = createOutputBootstrap, ɵ5 = {
    RootComponent,
}, ɵ6 = [
    debugProcessorConfig,
    pluckProcessorConfig,
    routeParamsProcessorConfig,
    routeParamsMultiProcessorConfig,
    itemNavigateProcessorConfig,
    modelProcessorConfig,
    appConfigProcessorConfig,
    urlProcessorConfig,
    navigationProcessorConfig,
    memoryProcessorConfig,
    routerNavigateProcessorConfig,
], ɵ7 = {}, ɵ8 = [], ɵ9 = {}, ɵ10 = {};
class BackbaseCoreModule {
    /**
     * Creates a module that will populate entryComponents with Components passed as classMap
     *
     * @usageNotes
     *
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [
     *     BackbaseCoreModule.withConfig({
     *       classMap: {
     *         myClassId: MyComponent
     *       }
     *     })
     *   ]
     * })
     * class MyModule {}
     * ```
     */
    static withConfig(config) {
        return {
            ngModule: BackbaseCoreModule,
            providers: [
                {
                    provide: ANALYZE_FOR_ENTRY_COMPONENTS,
                    useValue: config.classMap || {},
                    multi: true,
                },
                {
                    provide: CONFIG_COMPONENT_CLASS_MAP,
                    useValue: config.classMap || {},
                    multi: true,
                },
                {
                    provide: CONFIG_ROUTE_GUARDS,
                    multi: true,
                    useValue: config.guards || {},
                },
                {
                    provide: CONFIG_PIPELINE_PROCESSORS,
                    useValue: config.pipelineProcessors || [],
                    multi: true,
                },
            ],
        };
    }
    /**
     * Creates a configured BackbaseCoreModule.
     *
     * This should be called only once per app.
     *
     * @usageNotes
     *
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [
     *     BackbaseCoreModule.forRoot({
     *       classMap: {
     *         myClassId: MyComponent,
     *         logDeprecations: true,
     *       }
     *     })
     *   ]
     * })
     * class AppModule {}
     * ```
     */
    static forRoot(config) {
        return {
            ngModule: BackbaseCoreModule,
            providers: [
                {
                    provide: ANALYZE_FOR_ENTRY_COMPONENTS,
                    useValue: config.classMap || {},
                    multi: true,
                },
                {
                    provide: CONFIG_COMPONENT_CLASS_MAP,
                    useValue: config.classMap || {},
                    multi: true,
                },
                {
                    provide: CONFIG_FLOWS,
                    multi: true,
                    useValue: config.flows || [],
                },
                {
                    provide: CONFIG_ROUTE_GUARDS,
                    multi: true,
                    useValue: config.guards || {},
                },
                {
                    provide: CONFIG_ASSETS,
                    multi: false,
                    useValue: config.assets || {
                        assetsStaticItemName: '',
                    },
                },
                {
                    provide: LOG_DEPRECATIONS_CONFIG,
                    multi: false,
                    useValue: !!config.logDeprecations,
                },
                {
                    provide: ENABLED_FEATURES_CONFIG,
                    multi: false,
                    useValue: config.features || {},
                },
                {
                    provide: CONFIG_PIPELINE_PROCESSORS,
                    useValue: config.pipelineProcessors || [],
                    multi: true,
                },
                {
                    provide: LAZY_MAP,
                    useValue: config.lazyModules || undefined,
                    multi: false,
                },
            ],
        };
    }
}
BackbaseCoreModule.ɵfac = function BackbaseCoreModule_Factory(t) { return new (t || BackbaseCoreModule)(); };
BackbaseCoreModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: BackbaseCoreModule });
BackbaseCoreModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        RootItemModelService,
        ItemRegistryService,
        BackbaseConnector,
        ӨItemNavigationService,
        ItemTransitionService,
        RouteGuardsRegistryService,
        RouterNavigationService,
        RouterService,
        DeprecationsService,
        OutputBrokerService,
        InputBrokerService,
        RouterBootstrapService,
        ItemInjectorService,
        FlowsService,
        AssetsService,
        ItemLoaderService,
        CombinedComponentFactoryResolver,
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useFactory: ɵ0,
            deps: [RouterBootstrapService],
            multi: true
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useFactory: ɵ1,
            deps: [DeprecationsService, DEPRECATED_WITH_CONFIG],
            multi: true
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useFactory: ɵ2,
            deps: [InputBrokerService],
            multi: true
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useFactory: ɵ3,
            deps: [OutputBrokerService],
            multi: true
        },
        {
            provide: CONFIG_COMPONENT_CLASS_MAP,
            useValue: ɵ5,
            multi: true
        },
        {
            provide: CONFIG_PIPELINE_PROCESSORS,
            useValue: ɵ6,
            multi: true
        },
        {
            provide: AbstractRouterConfigService,
            useExisting: RouterConfigService
        },
        // Defaults, overrided by forRoot and withConfig
        {
            provide: CONFIG_COMPONENT_CLASS_MAP,
            useValue: ɵ7,
            multi: true
        },
        {
            provide: CONFIG_FLOWS,
            multi: true,
            useValue: ɵ8
        },
        {
            provide: CONFIG_ROUTE_GUARDS,
            multi: true,
            useValue: ɵ9
        },
        {
            provide: DEPRECATED_WITH_CONFIG,
            useValue: ɵ10,
            multi: true
        },
    ], imports: [[CommonModule, RouterModule]] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BackbaseCoreModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, RouterModule],
                declarations: [...coreComponents, ...coreDirectives],
                exports: [...coreComponents, ...coreDirectives],
                entryComponents: coreComponents,
                providers: [
                    RootItemModelService,
                    ItemRegistryService,
                    BackbaseConnector,
                    ӨItemNavigationService,
                    ItemTransitionService,
                    RouteGuardsRegistryService,
                    RouterNavigationService,
                    RouterService,
                    DeprecationsService,
                    OutputBrokerService,
                    InputBrokerService,
                    RouterBootstrapService,
                    ItemInjectorService,
                    FlowsService,
                    AssetsService,
                    ItemLoaderService,
                    CombinedComponentFactoryResolver,
                    {
                        provide: APP_BOOTSTRAP_LISTENER,
                        useFactory: ɵ0,
                        deps: [RouterBootstrapService],
                        multi: true
                    },
                    {
                        provide: APP_BOOTSTRAP_LISTENER,
                        useFactory: ɵ1,
                        deps: [DeprecationsService, DEPRECATED_WITH_CONFIG],
                        multi: true
                    },
                    {
                        provide: APP_BOOTSTRAP_LISTENER,
                        useFactory: ɵ2,
                        deps: [InputBrokerService],
                        multi: true
                    },
                    {
                        provide: APP_BOOTSTRAP_LISTENER,
                        useFactory: ɵ3,
                        deps: [OutputBrokerService],
                        multi: true
                    },
                    {
                        provide: CONFIG_COMPONENT_CLASS_MAP,
                        useValue: ɵ5,
                        multi: true
                    },
                    {
                        provide: CONFIG_PIPELINE_PROCESSORS,
                        useValue: ɵ6,
                        multi: true
                    },
                    {
                        provide: AbstractRouterConfigService,
                        useExisting: RouterConfigService
                    },
                    // Defaults, overrided by forRoot and withConfig
                    {
                        provide: CONFIG_COMPONENT_CLASS_MAP,
                        useValue: ɵ7,
                        multi: true
                    },
                    {
                        provide: CONFIG_FLOWS,
                        multi: true,
                        useValue: ɵ8
                    },
                    {
                        provide: CONFIG_ROUTE_GUARDS,
                        multi: true,
                        useValue: ɵ9
                    },
                    {
                        provide: DEPRECATED_WITH_CONFIG,
                        useValue: ɵ10,
                        multi: true
                    },
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(BackbaseCoreModule, { declarations: function () { return [RootComponent, AreaComponent, ChromeComponent, RouteComponent, OutletCollisionComponent, JourneyComponent, RouterLinkDirective, RouterLinkWithHrefDirective, RouterLinkActiveDirective, RouterOutletDirective]; }, imports: function () { return [CommonModule, RouterModule]; }, exports: function () { return [RootComponent, AreaComponent, ChromeComponent, RouteComponent, OutletCollisionComponent, JourneyComponent, RouterLinkDirective, RouterLinkWithHrefDirective, RouterLinkActiveDirective, RouterOutletDirective]; } }); })();

/**
 *
 * @deprecated Will be removed in v7.0.0
 *
 * @description
 * Every custom template directive should extend this class.
 * See 'How to make widget customizable'
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * import { Component, Directive } from '@angular/core';
 * import { BbTemplate, ItemModel } from '@backbase/foundation-ang/core';
 *
 * @Component({
 *   selector: 'my-widget',
 *   template: `
 *   <li *ngFor="let item of pallete">
 *     My colors:
 *     <ng-container
 *       customItemTemplate
 *       [bbHostRef]="hostRef"
 *       [bbTemplateContext]="item"
 *     ></ng-container>
 *   </li>
 *
 *   <ng-template customItemTemplate let-hostRef let-item="context">
 *     Current name: {{ item.color }}
 *     Hex value: {{ hostRef.getHexColor(item.color) }}
 *   </ng-template>
 *   `,
 * })
 * export class MyWidgetComponent {
 *   readonly hostRef = this;
 *   readonly palette: Array<PaletteItem> = [{
 *     color: 'blue',
 *   }];
 *   readonly hexValues = {
 *     blue: '0000ff',
 *   };
 *
 *   constructor(private itemModel: ItemModel) {}
 *
 *   getHexColor(color: string): string | undefined {
 *     return this.hexValues[color];
 *   }
 * }
 *
 * type PaletteItem {
 *   color: string;
 * };
 *
 * @Directive({
 *   selector: '[customItemTemplate]',
 * })
 * export class customItemTemplate extends BbTemplate<MyWidgetComponent, PaletteItem> {}
 * ```
 */
/* eslint-disable @angular-eslint/directive-class-suffix */
class BbTemplate {
    constructor(viewContainerRef, registry, templateRef) {
        this.viewContainerRef = viewContainerRef;
        this.registry = registry;
        this.templateRef = templateRef;
    }
    /**
     * @internal
     */
    ngOnInit() {
        this.checkContainerHasHostRef();
        this.checkNgTemplateIsNotUsedtoDefineSlot();
        if (this.isContainer) {
            this.waitTemplate();
        }
        else {
            this.registry.set(this.templateId(), this.templateRef);
        }
    }
    templateId() {
        return this.constructor;
    }
    checkContainerHasHostRef() {
        if (this.isContainer && this.bbHostRef === undefined) {
            throw new Error(`${this.constructor.name}: Missing required input [bbHostRef]`);
        }
    }
    checkNgTemplateIsNotUsedtoDefineSlot() {
        if (!this.isContainer && this.bbHostRef) {
            throw new Error(`${this.constructor.name}: [bbHostRef] should not be used in conjunction with <ng-template>. Use <ng-container> instead.`);
        }
    }
    /**
     * @internal
     */
    ngOnChanges(changes) {
        if (!this.customTemplateContext) {
            return;
        }
        if ('bbTemplateContext' in changes) {
            this.customTemplateContext.context = changes.bbTemplateContext.currentValue;
        }
    }
    waitTemplate() {
        const templateSubject = this.registry.get(this.templateId());
        this.templateSubscription = templateSubject.subscribe((tempalateRef) => {
            this.viewContainerRef.clear();
            this.customTemplateContext = this.createContext();
            const view = tempalateRef.createEmbeddedView(this.customTemplateContext);
            this.viewContainerRef.insert(view);
        });
    }
    /**
     * @internal
     */
    ngOnDestroy() {
        if (this.templateSubscription) {
            this.templateSubscription.unsubscribe();
        }
    }
    createContext() {
        if (this.bbHostRef === undefined) {
            throw new Error(`${this.constructor.name}: Missing required input [bbHostRef]`);
        }
        return {
            $implicit: this.bbHostRef,
            context: this.bbTemplateContext,
        };
    }
    get isContainer() {
        return !this.templateRef;
    }
}
BbTemplate.ɵfac = function BbTemplate_Factory(t) { return new (t || BbTemplate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(TemplateRegistry), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
BbTemplate.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BbTemplate, inputs: { bbTemplateContext: "bbTemplateContext", bbHostRef: "bbHostRef" }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
BbTemplate.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRegistry },
    { type: TemplateRef, decorators: [{ type: Optional }] }
];
BbTemplate.propDecorators = {
    bbTemplateContext: [{ type: Input }],
    bbHostRef: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BbTemplate, [{
        type: Directive,
        args: [{}]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: TemplateRegistry }, { type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, { bbTemplateContext: [{
            type: Input
        }], bbHostRef: [{
            type: Input
        }] }); })();

/**
 * @deprecated Will be removed in v7.0.0
 */
class StepUpModule {
    static forRoot(config) {
        return {
            ngModule: StepUpModule,
            providers: [
                {
                    provide: ANALYZE_FOR_ENTRY_COMPONENTS,
                    useValue: [config.mediatorComponentClass],
                    multi: true,
                },
                {
                    provide: STEPUP_CONFIG,
                    useValue: config,
                },
                {
                    provide: HTTP_INTERCEPTORS,
                    useClass: StepUpInterceptor,
                    deps: [StepUpService, STEPUP_CONFIG, Injector],
                    multi: true,
                },
                {
                    provide: StepUpService,
                    useClass: StepUpService,
                    deps: [ComponentFactoryResolver, STEPUP_CONFIG],
                },
            ],
        };
    }
}
StepUpModule.ɵfac = function StepUpModule_Factory(t) { return new (t || StepUpModule)(); };
StepUpModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: StepUpModule });
StepUpModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StepUpModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();

class SessionTimeoutModule {
    /**
     * Creates a configured SessionTimeoutModule.
     *
     * This should be called only once per app.
     *
     * @usageNotes
     *
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [
     *     SessionTimeoutModule.forRoot({
     *       classMap: {
     *         sessionTimeoutComponentClass: MyCustomSessionTimeoutComponent,
     *         inactivityModalTime: 300,
     *       }
     *     })
     *   ]
     * })
     * class AppModule {}
     * ```
     */
    static forRoot(config) {
        return {
            ngModule: SessionTimeoutModule,
            providers: [
                {
                    provide: ANALYZE_FOR_ENTRY_COMPONENTS,
                    useValue: config.sessionTimeoutComponentClass,
                    multi: true,
                },
                {
                    provide: SESSION_TIMEOUT_CONFIG,
                    useValue: config,
                },
                {
                    provide: SessionTimeoutService,
                    useClass: SessionTimeoutService,
                    deps: [ComponentFactoryResolver, SESSION_TIMEOUT_CONFIG],
                },
            ],
        };
    }
}
SessionTimeoutModule.ɵfac = function SessionTimeoutModule_Factory(t) { return new (t || SessionTimeoutModule)(); };
SessionTimeoutModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: SessionTimeoutModule });
SessionTimeoutModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({});
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SessionTimeoutModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();

/**
 * Exposes Angular Single Page Application bootstrap method `window.BB.startSingleApp`
 * @param createNgModule Function that accepts StaticProviders and returns NgModuleRef
 * @usageNotes
 * ### Example
 *
 * ```
 * window.BB.startSingleApp = registerSingleApp(createNgModule);
 *
 * window.BB.startSingleApp(webSdkServices, staticProviders)
 *   .then((bbConnector: BackbaseConnector) => bbConector.bootstrap(item, itemLocation));
 * ```
 */
function registerSingleApp(createNgModule) {
    const startSingleApp = (externalServices = {}) => {
        const providers = [
            {
                provide: ɵEXTERNAL_SERVICES,
                useValue: externalServices,
            },
        ];
        return createNgModule(providers).then((moduleRef) => moduleRef.injector.get(BackbaseConnector));
    };
    window.BB = window.BB || {};
    Object.assign(window.BB, { startSingleApp });
    return startSingleApp;
}

/**
 * Generated bundle index. Do not edit.
 */

export { AppConfig, AssetsService, BackbaseConnector, BackbaseCoreModule, BbTemplate, CopyRoutes, ItemModel, ItemModelTree, LifecycleEventKind, Memory, RootItemModelService, RoutableContainer, RoutableWidget, RouteParam, RouterConfigService, RouterNavigateParamPlaceholder, RouterNavigateSink, RouterNavigateSource, RouterOutletDirective, RouterService, SessionTimeoutModule, StepUpInterceptor, StepUpModule, TemplateRegistry, createPipelineProcessorConfig, mapObservableArray, registerSingleApp, CONFIG_ASSETS as ɵa, ItemLifecycleService as ɵb, SessionTimeoutService as ɵba, LAZY_MAP as ɵbb, journeyItemModelFactory as ɵbc, storeNameFactory as ɵbd, AbstractRouterConfigService as ɵbe, RouterNavigationService as ɵbf, ItemInjectorService as ɵbg, InputBrokerService as ɵbh, createInputBootstrap as ɵbi, OutputBrokerService as ɵbj, createOutputBootstrap as ɵbk, ItemLoaderService as ɵbl, CombinedComponentFactoryResolver as ɵbm, AppConfigService as ɵbn, ItemTransitionService as ɵbo, createRouteConfigBootstrap as ɵbp, RouterBootstrapService as ɵbq, makeDebugPipe as ɵbr, debugProcessorConfig as ɵbs, pluckProcessorConfig as ɵbt, createRouteParamsMulti as ɵbu, routeParamsMultiProcessorConfig as ɵbv, createItemNavigate as ɵbw, itemNavigateProcessorConfig as ɵbx, createModelSource as ɵby, modelProcessorConfig as ɵbz, ObservableTree as ɵc, createUrlSink as ɵca, urlProcessorConfig as ɵcb, pipeName as ɵcc, navigationHandlerToken as ɵcd, createNavigationSink as ɵce, navigationProcessorConfig as ɵcf, CONFIG_ROUTE_GUARDS as ɵd, RouteGuardsRegistryService as ɵe, CONFIG_PIPELINE_PROCESSORS as ɵf, PipelineRegistry as ɵg, createAppConfigSource as ɵh, appConfigProcessorConfig as ɵi, createRouteParams as ɵj, routeParamsProcessorConfig as ɵk, MemoryStorageService as ɵl, createMemory as ɵm, memoryProcessorConfig as ɵn, serializeCommands as ɵo, createRouterNavigateStore as ɵp, routerNavigateProcessorConfig as ɵq, DEPRECATED_WITH_CONFIG as ɵr, createLogDeprecatedConfig as ɵs, CONFIG_COMPONENT_CLASS_MAP as ɵt, ItemRegistryService as ɵu, CONFIG_FLOWS as ɵv, FlowsService as ɵw, STEPUP_CONFIG as ɵx, StepUpService as ɵy, SESSION_TIMEOUT_CONFIG as ɵz, AreaComponent as ӨAreaComponent, ChromeComponent as ӨChromeComponent, ӨItemNavigationService, JourneyComponent as ӨJourneyComponent, OutletCollisionComponent as ӨOutletCollisionComponent, RootComponent as ӨRootComponent, ӨRootContainerService, RouteComponent as ӨRouteComponent, RouterLinkActiveDirective as ӨRouterLinkActiveDirective, RouterLinkDirective as ӨRouterLinkDirective, RouterLinkWithHrefDirective as ӨRouterLinkWithHrefDirective };

//# sourceMappingURL=backbase-foundation-ang-core.js.map