import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, Directive, TemplateRef, ViewContainerRef, ChangeDetectorRef, Input, NgModule } from '@angular/core';
import { of, forkJoin, Observable } from 'rxjs';
import { map, shareReplay, first } from 'rxjs/operators';
import * as i1 from '@angular/common/http';
import { HttpClient } from '@angular/common/http';
import { __awaiter } from 'tslib';
import * as i2 from '@angular/router';
import { Router } from '@angular/router';

const ENTITLEMENTS_CONFIG = new InjectionToken('web-sdk-entitlements-config');
/**
 * @deprecated Will be removed in v7.0.0
 */
const CONDITIONS = new InjectionToken('web-sdk-conditions');

var LogicalOperator;
(function (LogicalOperator) {
    LogicalOperator["AND"] = "AND";
    LogicalOperator["OR"] = "OR";
    LogicalOperator["NOT"] = "NOT";
})(LogicalOperator || (LogicalOperator = {}));
const SUMMARY_PERMISSIONS_PATH = '/accessgroups/users/permissions/summary';
const DATA_ITEMS_PERMISSIONS_PATH = '/accessgroups/users/data-item-permissions';
class ConditionsService {
    constructor(http, config) {
        var _a, _b, _c;
        this.http = http;
        this.config = config;
        this.createConditions = (stringDef) => {
            const splitBySpaces = stringDef
                .trim()
                .split(' ')
                .filter((spaced) => spaced !== '');
            return this.separateLogicalOperators(['AND'].concat(splitBySpaces));
        };
        const basePath = ((_a = this.config) === null || _a === void 0 ? void 0 : _a.accessControlBasePath) || '/access-control';
        const path = ((_b = this.config) === null || _b === void 0 ? void 0 : _b.accessControlPath) || `/client-api/v2${SUMMARY_PERMISSIONS_PATH}`;
        this.entitlements$ = this.http
            .get(`${basePath}${path}`)
            .pipe(map(EntitlementSummaryResponse => {
            if (EntitlementSummaryResponse.length && 'dataItem' in EntitlementSummaryResponse[0]) {
                return this.mapDataItemPermissions(EntitlementSummaryResponse);
            }
            else {
                return this.mapPermissionsSummary(EntitlementSummaryResponse);
            }
        }), shareReplay(1));
        this.forceResolved = ((_c = this.config) === null || _c === void 0 ? void 0 : _c.forceResolved) || false;
    }
    // map response of getUserPermissionsSummary to flat array of available entitlements
    mapPermissionsSummary(entitlementsData) {
        const entitlements = [];
        entitlementsData.forEach(entitlementData => {
            const availablePermissions = Object.entries(entitlementData.permissions).filter(([, value]) => value === true);
            availablePermissions.forEach(([privilege]) => {
                const entitlement = this.removeWhiteSpace({
                    resource: entitlementData.resource,
                    function: entitlementData.function,
                    privilege,
                });
                entitlements.push(entitlement);
            });
        });
        return entitlements;
    }
    // map response of getDataItemPermissionsContext to flat array of available entitlements
    // this endpoint can optionally be configured when needing data-item specific entitlements
    mapDataItemPermissions(entitlementsData) {
        const entitlements = [];
        entitlementsData.forEach(entitlementData => {
            entitlementData.permissions.forEach(permission => {
                permission.privileges.forEach(privilege => {
                    const entitlement = this.removeWhiteSpace({
                        dataItem: entitlementData.dataItem.id,
                        resource: permission.resource,
                        function: permission.businessFunction,
                        privilege,
                    });
                    entitlements.push(entitlement);
                });
            });
        });
        return entitlements;
    }
    resolveEntitlements(identifier) {
        if (this.forceResolved) {
            return Promise.resolve(true);
        }
        const conditions = this.createConditions(identifier);
        return this.resolveConditions(conditions).toPromise();
    }
    parseIdentifier(identifier) {
        const identifierArray = identifier.split('.').map((str) => str.trim());
        if (identifierArray.length < 3 || identifierArray.length > 4) {
            throw Error(`'${identifier}' is not valid entitlement identifier`);
        }
        if (identifierArray.length === 3) {
            return this.removeWhiteSpace({
                dataItem: undefined,
                resource: identifierArray[0],
                function: identifierArray[1],
                privilege: identifierArray[2],
            });
        }
        return this.removeWhiteSpace({
            dataItem: identifierArray[0],
            resource: identifierArray[1],
            function: identifierArray[2],
            privilege: identifierArray[3],
        });
    }
    resolveConditions(conditions) {
        if (conditions.length === 0) {
            return of(true);
        }
        const resolutions = conditions.map((condition) => this.resolveEntitlement(condition).pipe(map((value) => ({ value, logic: condition.logic }))));
        return forkJoin(resolutions).pipe(map(this.resolveResolutions));
    }
    resolveResolutions(resolutions) {
        return resolutions.reduce((final, resolution) => {
            if (resolution.logic === LogicalOperator.AND) {
                return final && resolution.value;
            }
            else if (resolution.logic === LogicalOperator.NOT) {
                return final && !resolution.value;
            }
            return final || resolution.value;
        }, true);
    }
    separateLogicalOperators(splitBySpaces) {
        const conditions = [];
        for (let i = 0; i < splitBySpaces.length; i += 2) {
            const logic = splitBySpaces[i];
            if (logic !== LogicalOperator.AND && logic !== LogicalOperator.OR) {
                throw Error(`'${logic}' is not valid logical operator`);
            }
            const identifier = splitBySpaces[i + 1];
            if (identifier.charAt(0) === '!') {
                conditions.push(Object.assign(Object.assign({}, this.parseIdentifier(identifier.substr(1))), { logic: LogicalOperator.NOT }));
            }
            else {
                conditions.push(Object.assign(Object.assign({}, this.parseIdentifier(identifier)), { logic }));
            }
        }
        return conditions;
    }
    removeWhiteSpace(item) {
        return Object.assign(Object.assign({}, item), { dataItem: item.dataItem ? item.dataItem.replace(/ /g, '') : undefined, resource: item.resource.replace(/ /g, ''), function: item.function.replace(/ /g, '') });
    }
    resolveEntitlement(entitlement) {
        return this.entitlements$.pipe(map(entitlements => entitlements.some(availableEntitlement => (entitlement.dataItem === undefined || availableEntitlement.dataItem === entitlement.dataItem) &&
            availableEntitlement.resource === entitlement.resource &&
            availableEntitlement.function === entitlement.function &&
            availableEntitlement.privilege === entitlement.privilege)));
    }
}
ConditionsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ConditionsService_Factory() { return new ConditionsService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(ENTITLEMENTS_CONFIG, 8)); }, token: ConditionsService, providedIn: "root" });
ConditionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ConditionsService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ENTITLEMENTS_CONFIG,] }] }
];

/**
 * @description
 * A structural directive that conditionally includes a template based on the value of
 * an expression coerced to Boolean based on a entitlements triplets validation.
 * When the expression evaluates to true, Angular renders the template
 * Angular renders the template provided in an optional `else` clause. The default
 * template for the `else` clause is blank.
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * <div *bbIfEntitlements="'ProductSummary.ProductSummary.edit'">Content to render when condition is true.</div>
 *
 * <div *bbIfEntitlements="'ProductSummary.ProductSummary.edit'; else alternative">Content to render when condition is true.</div>
 * <ng-template #alternative>
 *   <div>alternative content</div>
 * </ng-template>
 * ```
 */
class IfEntitlementsDirective {
    constructor(conditions, templateRef, viewContainerRef, cd) {
        this.conditions = conditions;
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.cd = cd;
    }
    /**
     * Entitlement to evaluate
     */
    set bbIfEntitlements(value) {
        const entitlements = value.trim();
        this.conditions.resolveEntitlements(entitlements).then(canAccess => {
            if (canAccess) {
                this.renderMainView();
            }
            else {
                this.renderAlternativeView();
            }
            this.cd.markForCheck();
        }, () => {
            console.error(`The element cannot be displayed because the identifier is invalid: "${value}"`);
            this.viewContainerRef.clear();
            this.cd.markForCheck();
        });
    }
    /**
     * Alternative template to show in the else clause
     */
    set bbIfEntitlementsElse(value) {
        this.elseTemplateRef = value;
    }
    renderMainView() {
        this.viewContainerRef.createEmbeddedView(this.templateRef);
    }
    renderAlternativeView() {
        this.viewContainerRef.clear();
        if (this.elseTemplateRef) {
            this.viewContainerRef.createEmbeddedView(this.elseTemplateRef);
        }
    }
}
IfEntitlementsDirective.decorators = [
    { type: Directive, args: [{
                selector: '[bbIfEntitlements]',
            },] }
];
IfEntitlementsDirective.ctorParameters = () => [
    { type: ConditionsService },
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: ChangeDetectorRef }
];
IfEntitlementsDirective.propDecorators = {
    bbIfEntitlements: [{ type: Input }],
    bbIfEntitlementsElse: [{ type: Input }]
};

class EntitlementsModule {
}
EntitlementsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IfEntitlementsDirective],
                providers: [{ provide: CONDITIONS, useExisting: ConditionsService }],
                exports: [IfEntitlementsDirective],
            },] }
];

class EntitlementsGuard {
    constructor(conditions, router) {
        this.conditions = conditions;
        this.router = router;
        this.userHasEntitlements = (entitlements) => __awaiter(this, void 0, void 0, function* () {
            try {
                if (!entitlements || (yield this.conditions.resolveEntitlements(entitlements))) {
                    return true;
                }
            }
            catch (err) {
                console.error(err);
            }
            return false;
        });
    }
    resolveEntitlements(entitlements, redirectTo, route, state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.userHasEntitlements(entitlements)) {
                return true;
            }
            if (typeof redirectTo === 'function') {
                redirectTo = yield this.getRedirection(redirectTo, route, state);
            }
            if (redirectTo) {
                return this.router.parseUrl(redirectTo);
            }
            return false;
        });
    }
    getRedirection(getRedirectTo, route, state) {
        if (!route || !state) {
            return undefined;
        }
        const redirectTo = getRedirectTo(this.userHasEntitlements, route, state);
        if (redirectTo instanceof Observable) {
            return redirectTo.pipe(first()).toPromise();
        }
        return redirectTo;
    }
    canActivateChild(childRoute, state) {
        const { entitlements, redirectTo } = childRoute.data;
        return this.resolveEntitlements(entitlements, redirectTo, childRoute, state);
    }
    canLoad(route, segments) {
        var _a, _b;
        const entitlements = (_a = route.data) === null || _a === void 0 ? void 0 : _a.entitlements;
        const redirectTo = (_b = route.data) === null || _b === void 0 ? void 0 : _b.redirectTo;
        return this.resolveEntitlements(entitlements, redirectTo, route, segments);
    }
    canActivate(route, state) {
        const { entitlements, redirectTo } = route.data;
        return this.resolveEntitlements(entitlements, redirectTo, route, state);
    }
}
EntitlementsGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function EntitlementsGuard_Factory() { return new EntitlementsGuard(i0.ɵɵinject(ConditionsService), i0.ɵɵinject(i2.Router)); }, token: EntitlementsGuard, providedIn: "root" });
EntitlementsGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
EntitlementsGuard.ctorParameters = () => [
    { type: ConditionsService },
    { type: Router }
];

/**
 * Generated bundle index. Do not edit.
 */

export { CONDITIONS, ConditionsService, DATA_ITEMS_PERMISSIONS_PATH, ENTITLEMENTS_CONFIG, EntitlementsGuard, EntitlementsModule, IfEntitlementsDirective, SUMMARY_PERMISSIONS_PATH };
//# sourceMappingURL=backbase-foundation-ang-entitlements.js.map
