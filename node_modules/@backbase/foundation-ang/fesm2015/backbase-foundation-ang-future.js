import * as i0 from '@angular/core';
import { InjectionToken, NgModule, Injectable, Optional, Inject } from '@angular/core';

import * as ɵngcc0 from '@angular/core';
const AVAILABLE_FEATURES_CONFIG = new InjectionToken('@backbase/foundation Available Feature Flags Configuration');
const ɵ0$1 = [];
/**
 * @deprecated Will be removed in v7.0.0
 */
class FutureFeaturesModule {
    static allowOptIn(features) {
        return {
            ngModule: FutureFeaturesModule,
            providers: [
                {
                    provide: AVAILABLE_FEATURES_CONFIG,
                    multi: true,
                    useValue: features,
                },
            ],
        };
    }
}
FutureFeaturesModule.ɵfac = function FutureFeaturesModule_Factory(t) { return new (t || FutureFeaturesModule)(); };
FutureFeaturesModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: FutureFeaturesModule });
FutureFeaturesModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [
        {
            provide: AVAILABLE_FEATURES_CONFIG,
            multi: true,
            useValue: ɵ0$1
        },
    ] });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FutureFeaturesModule, [{
        type: NgModule,
        args: [{
                providers: [
                    {
                        provide: AVAILABLE_FEATURES_CONFIG,
                        multi: true,
                        useValue: ɵ0$1
                    },
                ]
            }]
    }], null, null); })();

/**
 * @deprecated Will be removed in v7.0.0
 */
const LOG_DEPRECATIONS_CONFIG = new InjectionToken('@backbase/foundation Log Deprecation Warnings Configuration');
/**
 * @deprecated Will be removed in v7.0.0
 * Log deprecated features.
 *
 * Deprecations will only be logged when `logDeprecations` has been
 * configured to "true" in `BackbaseCoreConfiguration`.
 *
 * @usageNotes
 *
 * ### Example
 *
 * Log a deprecated property:
 *
 * ```
 * @Component({
 *   …
 * })
 * export class MyComponent {
 *   private myOldPropertyValue: string | undefined;
 *
 *   constructor(private deprecationsService: DeprecationsService) { }
 *
 *   @Input()
 *   set myOldProperty(prop: string | undefined) {
 *     this.deprecationsService.logDeprecatedFeature("The `myOldProperty` property of MyComponent has been deprecated");
 *     this.myOldPropertyValue = prop;
 *   }
 * }
 */
class DeprecationsService {
    constructor(logDeprecations) {
        this.logDeprecations = !!logDeprecations;
    }
    logDeprecatedFeature(warning) {
        if (!this.logDeprecations) {
            return;
        }
        console.warn('[DEPRECATED]', warning);
    }
}
DeprecationsService.ɵfac = function DeprecationsService_Factory(t) { return new (t || DeprecationsService)(ɵngcc0.ɵɵinject(LOG_DEPRECATIONS_CONFIG, 8)); };
DeprecationsService.ɵprov = i0.ɵɵdefineInjectable({ factory: function DeprecationsService_Factory() { return new DeprecationsService(i0.ɵɵinject(LOG_DEPRECATIONS_CONFIG, 8)); }, token: DeprecationsService, providedIn: "root" });
DeprecationsService.ctorParameters = () => [
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [LOG_DEPRECATIONS_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DeprecationsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LOG_DEPRECATIONS_CONFIG]
            }] }]; }, null); })();

// @todo: separate util package that can be shared across entry points?
const flatten = (arr) => arr.reduce((acc, a) => [...acc, ...a], []);
const ɵ0 = flatten;
/**
 * @deprecated Will be removed in v7.0.0
 */
const ENABLED_FEATURES_CONFIG = new InjectionToken('@backbase/foundation Enabled Feature Flags Configuration');
/**
 * @deprecated Will be removed in v7.0.0
 * @usageNotes
 *
 * ### Example
 *
 * Create a Feature Flag in the module that implements/uses it
 *
 * ```
 * export const FEATURE_EXAMPLE: AvailableFeature = {
 *  name: 'EXAMPLE',
 *  description: 'Describe the feature that will be enabled by this flag',
 * };
 * ```
 *
 * Check if the application has opted into the Feature Flag
 *
 * ```
 * if (featuresService.isEnabled(FEATURE_EXAMPLE)) {
 *   // Use new feature
 *   …
 * }
 * ```
 *
 * Make the feature flag available from the module that implements/uses it
 *
 * ```
 * @NgModule({
 *   imports: [
 *     FutureFeaturesModule.allowOptIn([FEATURE_EXAMPLE]),
 *     …
 *   ],
 *   …
 * })
 * export class MyModule {
 *   …
 * }
 * ```
 *
 * In the application, opt in to the new feature (and enable logging of configuration issues)
 *
 * ```
 * @NgModule({
 *   imports: [
 *     BackbaseCoreModule.forRoot({
 *       logDeprecations: true,
 *       features: {
 *          FEATURE_EXAMPLE: true,
 *       },
 *       …
 *     }),
 *     …
 *   ],
 *   …
 * })
 * export class AppModule {
 *   …
 * }
 * ```
 */
class FeaturesService {
    constructor(availableConfigs, enabledConfigOrNull, logDeprecations) {
        this.logDeprecations = !!logDeprecations;
        const availableConfig = flatten(availableConfigs || []);
        const available = new Set(availableConfig.map(feature => feature.name));
        const enabledConfig = enabledConfigOrNull || {};
        this.enabled = new Map(Array.from(available.values()).map(token => [token, false]));
        Object.entries(enabledConfig).forEach(([name, enabled]) => {
            if (available.has(name)) {
                this.enabled.set(name, enabled);
            }
        });
        if (this.logDeprecations) {
            this.logConfigurationErrors(availableConfig, enabledConfig);
        }
    }
    isEnabled(feature) {
        const enabled = this.enabled.get(feature.name);
        if (enabled !== undefined) {
            return enabled;
        }
        throw new Error(`[FEATURE] Using unknown feature: ${feature.name}: ${feature.description}\nYou probably need to add it to the modules provided features.`);
    }
    logConfigurationErrors(availableConfig, enabledConfig) {
        const unconfiguredFeatures = availableConfig.filter(feature => enabledConfig[feature.name] === undefined);
        if (unconfiguredFeatures.length) {
            const unconfiguredFeaturesList = unconfiguredFeatures
                .map(feature => `${feature.name}: ${feature.description}`)
                .join('\n - ');
            console.warn('[DEPRECATED]', `Unconfigured features available:
          \n - ${unconfiguredFeaturesList}
          \nYou should opt-in to them in the App module as they will likely become defaults in the next major release.`);
        }
    }
}
FeaturesService.ɵfac = function FeaturesService_Factory(t) { return new (t || FeaturesService)(ɵngcc0.ɵɵinject(AVAILABLE_FEATURES_CONFIG, 8), ɵngcc0.ɵɵinject(ENABLED_FEATURES_CONFIG, 8), ɵngcc0.ɵɵinject(LOG_DEPRECATIONS_CONFIG, 8)); };
FeaturesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FeaturesService_Factory() { return new FeaturesService(i0.ɵɵinject(AVAILABLE_FEATURES_CONFIG, 8), i0.ɵɵinject(ENABLED_FEATURES_CONFIG, 8), i0.ɵɵinject(LOG_DEPRECATIONS_CONFIG, 8)); }, token: FeaturesService, providedIn: FutureFeaturesModule });
FeaturesService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [AVAILABLE_FEATURES_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ENABLED_FEATURES_CONFIG,] }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [LOG_DEPRECATIONS_CONFIG,] }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FeaturesService, [{
        type: Injectable,
        args: [{
                providedIn: FutureFeaturesModule
            }]
    }], function () { return [{ type: Array, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [AVAILABLE_FEATURES_CONFIG]
            }] }, { type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [ENABLED_FEATURES_CONFIG]
            }] }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [LOG_DEPRECATIONS_CONFIG]
            }] }]; }, null); })();

// future

/**
 * Generated bundle index. Do not edit.
 */

export { DeprecationsService, ENABLED_FEATURES_CONFIG, FeaturesService, FutureFeaturesModule, LOG_DEPRECATIONS_CONFIG, AVAILABLE_FEATURES_CONFIG as ɵa };

//# sourceMappingURL=backbase-foundation-ang-future.js.map