import { ContentTypes, StructuredContentType, ContentType } from '@backbase/lib-bb-page-bootstrap-cdn';

/**
 * PortalContentMock class which functions as a mock content store
 *
 * @usageNotes
 * ```typescript
 * // Store content in mock content store and get contentRef back
 * const contentRef = PortalContentMock.addImageContent({ url: '/image.png' });
 *
 * // use PortalContentMock to get content from the mock content store
 * const portalContent = new PortalContentMock();
 * portalContent.getContent(contentRef);
 * ```
 */
class PortalContentMock {
    /**
     * Add image item to mock content store
     * @param content image item
     * @return content ref
     */
    static addImageContent(content, contentRef) {
        return PortalContentMock.addContentItem(ContentTypes.IMAGE, content, undefined, contentRef);
    }
    /**
     * Add document item to mock content store
     * @param content document item
     * @return content ref
     */
    static addDocumentContent(content, contentRef) {
        return PortalContentMock.addContentItem(ContentTypes.DOCUMENT, content, undefined, contentRef);
    }
    /**
     * Add structured content item to mock content store
     * @param typeDefinitionName type definition name of the strucutred content item
     * @param content structured content (JSON)
     * @return content ref
     */
    static addStructuredContent(typeDefinitionName, content, contentRef) {
        return PortalContentMock.addContentItem(ContentTypes.STRUCTURED_CONTENT, content, typeDefinitionName, contentRef);
    }
    /**
     * Add plain text content item to mock content store
     * @param content plain text
     * @return content ref
     */
    static addPlainTextContent(content, contentRef) {
        return PortalContentMock.addStructuredContent(StructuredContentType.PLAIN_TEXT, { content }, contentRef);
    }
    /**
     * Add rich text content item to mock content store
     * @param content rich text (HTML)
     * @return content ref
     */
    static addRichTextContent(content, contentRef) {
        return PortalContentMock.addStructuredContent(StructuredContentType.RICH_TEXT, { content }, contentRef);
    }
    static addContentItem(type, content, typeDefinitionName, contentRef = PortalContentMock.getContentRef()) {
        const contentItem = {
            type,
            content,
            properties: {},
        };
        if (typeDefinitionName) {
            contentItem.typeDefinitionName = typeDefinitionName;
        }
        PortalContentMock.contentMockMap[contentRef] = content;
        PortalContentMock.contentItemMockMap[contentRef] = contentItem;
        return contentRef;
    }
    static getContentRef() {
        PortalContentMock.id += 1;
        return `cs:mockRepository:${PortalContentMock.id}`;
    }
    get(contentRef) {
        const contentItem = PortalContentMock.contentItemMockMap[contentRef];
        if (!contentItem) {
            // Return empty text so deprecated content widget logic doesn't break
            return Promise.resolve({
                id: contentRef,
                type: ContentType.STRUCTURED_CONTENT,
                content: '',
            });
        }
        if (contentItem.type === ContentTypes.IMAGE) {
            const content = contentItem.content;
            const imageContentItem = {
                id: contentRef,
                type: ContentType.IMAGE,
                contentRef: content.url,
            };
            return Promise.resolve(imageContentItem);
        }
        if (contentItem.type === ContentTypes.STRUCTURED_CONTENT) {
            const content = contentItem.content;
            const structuredContentItem = {
                id: contentRef,
                type: ContentType.STRUCTURED_CONTENT,
                content: content.content,
            };
            return Promise.resolve(structuredContentItem);
        }
        return Promise.reject(`Couldn't map a content item of type ${contentItem.type}`);
    }
    getContent(contentRef) {
        return Promise.resolve(PortalContentMock.contentMockMap[contentRef]);
    }
    getContentItem(contentRef) {
        return Promise.resolve(PortalContentMock.contentItemMockMap[contentRef]);
    }
    subscribeContentUpdate() {
        return () => { };
    }
    subscribeContentItemUpdate() {
        return () => { };
    }
}
PortalContentMock.id = 0;
PortalContentMock.contentMockMap = {};
PortalContentMock.contentItemMockMap = {};

/**
 * Generated bundle index. Do not edit.
 */

export { PortalContentMock };
//# sourceMappingURL=backbase-foundation-ang-testing.js.map
