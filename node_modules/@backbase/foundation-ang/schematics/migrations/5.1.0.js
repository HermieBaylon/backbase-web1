"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const ts = require("typescript");
const changes_1 = require("../utils/changes");
const imports_1 = require("../utils/imports");
const ng_utils_1 = require("../utils/ng-utils");
const try_rule_1 = require("../utils/try-rule");
const typescript_1 = require("../utils/typescript");
const manualProcess = `
### Manual Process

- Replace StoreModule imported from @backbase/foundation-ang/store with BackbaseStoreModule
 for example:

    import { StoreModule } from '@backbase/foundation-ang/store'

  should be changed to:

    import { BackbaseStoreModule } from '@backbase/foundation-ang/store'

- Install ngrx required packages:

    npm install @ngrx/effects@8.1.0 @ngrx/store@8.1.0 --save-exact

- Add ngrx modules to your app module for example if you have app named my-app you should update
  /apps/my-app/src/app/app.module.ts file to include StoreModule.forRoot({}) and
  EffectsModule.forRoot([]) in angular imports like this:

    import { StoreModule } from '@ngrx/store';
    import { EffectsModule } from '@ngrx/effects';
    ...
      imports: [
       ...
        StoreModule.forRoot({}),
        EffectsModule.forRoot([])
      ],
     ...
    })
    export class AppModule { }
`;
function default_1() {
    return try_rule_1.tryRule((tree) => __awaiter(this, void 0, void 0, function* () {
        const OLD_MODULE_NAME = 'StoreModule';
        const TARGET_MODULE_NAME = 'BackbaseStoreModule';
        const program = typescript_1.createTsProgramForNgWorkSpace(tree);
        const languageService = typescript_1.createLanguageService(tree, program.getCompilerOptions(), [...program.getRootFileNames()]);
        for (const sourceFile of program.getSourceFiles()) {
            if (sourceFile.isDeclarationFile) {
                continue;
            }
            const [namedImports, nameSpaceImports] = imports_1.getImports(sourceFile, ['@backbase/foundation-ang/store']);
            const changes = [
                ...replaceNameImport(languageService, sourceFile, namedImports, OLD_MODULE_NAME, TARGET_MODULE_NAME),
                ...handleNameSpaceImports(nameSpaceImports, languageService, sourceFile, TARGET_MODULE_NAME),
            ];
            if (changes.length > 0) {
                changes_1.insert(tree, sourceFile.fileName, changes);
            }
        }
        ng_utils_1.addPackageJsonDependency(tree, {
            name: '@ngrx/store',
            version: '^8.0.0',
            type: ng_utils_1.NodeDependencyType.Default,
        });
        ng_utils_1.addPackageJsonDependency(tree, {
            name: '@ngrx/effects',
            version: '^8.0.0',
            type: ng_utils_1.NodeDependencyType.Default,
        });
        const workspace = yield ng_utils_1.getWorkspace(tree);
        addNGRXModules(tree, workspace);
    }), manualProcess);
}
exports.default = default_1;
function replaceNameImport(languageService, sourceFile, namedImports, oldName, newName) {
    const changes = [];
    for (const namedImport of namedImports) {
        for (const element of namedImport.elements) {
            const name = element.propertyName || element.name;
            if (oldName !== name.text) {
                continue;
            }
            changes.push(new ng_utils_1.ReplaceChange(sourceFile.fileName, name.getStart() - 1, name.text, newName));
            const refs = typescript_1.findReferences(languageService, sourceFile.fileName, name.getStart());
            for (const ref of refs) {
                const node = typescript_1.findTightestNode(sourceFile, ref.textSpan.start + 1);
                if (node && ts.isIdentifier(node) && node.text === oldName) {
                    changes.push(new ng_utils_1.ReplaceChange(sourceFile.fileName, node.getStart() - 1, name.text, newName));
                }
            }
        }
    }
    return changes;
}
function handleNameSpaceImports(nameSpaceImports, languageService, sourceFile, target) {
    const changes = [];
    for (const nameSpaceImport of nameSpaceImports) {
        const refs = typescript_1.findReferences(languageService, sourceFile.fileName, nameSpaceImport.name.getStart());
        for (const ref of refs) {
            const node = typescript_1.findTightestNode(sourceFile, ref.textSpan.start + 1);
            if (!node) {
                continue;
            }
            const replaceNode = getPropertyNodeFromAccessExpression(node.parent);
            if (!replaceNode) {
                continue;
            }
            changes.push(new ng_utils_1.ReplaceChange(sourceFile.fileName, replaceNode.getStart() - 1, replaceNode.text, target));
        }
    }
    return changes;
}
function addNGRXModules(tree, workspace) {
    for (const project of workspace.projects.values()) {
        const projectType = project.extensions.projectType;
        if (typeof projectType !== 'string' || projectType !== 'application') {
            continue;
        }
        const buildTarget = project.targets.get('build');
        if (!buildTarget || !buildTarget.options || typeof buildTarget.options.main !== 'string') {
            continue;
        }
        const modulePath = ng_utils_1.getAppModulePath(tree, buildTarget.options.main);
        const buffer = tree.read(modulePath);
        if (buffer === null) {
            throw new schematics_1.SchematicsException(`File '${modulePath}' does not exist.`);
        }
        const source = ts.createSourceFile(modulePath, buffer.toString('utf-8'), ts.ScriptTarget.Latest, true);
        const changes = [
            ...ng_utils_1.addImportToModule(source, modulePath, 'StoreModule.forRoot({})', '@ngrx/store'),
            ...ng_utils_1.addImportToModule(source, modulePath, 'EffectsModule.forRoot([])', '@ngrx/effects'),
        ];
        if (changes.length === 0) {
            continue;
        }
        const recorder = tree.beginUpdate(modulePath);
        for (const change of changes) {
            if (change instanceof ng_utils_1.InsertChange) {
                recorder.insertLeft(change.pos, change.toAdd);
            }
        }
        tree.commitUpdate(recorder);
    }
}
function getPropertyNodeFromAccessExpression(node) {
    if (ts.isPropertyAccessExpression(node)) {
        return node.name;
    }
    else if (ts.isElementAccessExpression(node) && ts.isStringLiteral(node.argumentExpression)) {
        return node.argumentExpression;
    }
    return;
}
//# sourceMappingURL=5.1.0.js.map