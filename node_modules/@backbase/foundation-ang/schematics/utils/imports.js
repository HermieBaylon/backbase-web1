"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateImportsSpecifier = exports.getImports = void 0;
const ts = require("typescript");
const typescript_1 = require("./typescript");
const ng_utils_1 = require("./ng-utils");
function getImports(sourceFile, importSpecifiers) {
    const namedImports = [];
    const nameSpaceImports = [];
    const visitor = (node) => {
        if (ts.isImportDeclaration(node) &&
            node.importClause &&
            node.importClause.namedBindings &&
            ts.isStringLiteral(node.moduleSpecifier) &&
            importSpecifiers.includes(node.moduleSpecifier.text)) {
            const namedBindings = node.importClause.namedBindings;
            if (ts.isNamedImports(namedBindings)) {
                namedImports.push(namedBindings);
            }
            else {
                nameSpaceImports.push(namedBindings);
            }
        }
        ts.forEachChild(node, visitor);
    };
    ts.forEachChild(sourceFile, visitor);
    return [namedImports, nameSpaceImports];
}
exports.getImports = getImports;
function updateImportsSpecifier(sourceFile, languageService, fromSpecifiers, toSpecifier, nameSpaceImportName, itemsToBeReplaced) {
    const [namedImports, nameSpaceImports] = getImports(sourceFile, fromSpecifiers);
    return [
        ...handleNamedImports(namedImports, sourceFile.fileName, toSpecifier, itemsToBeReplaced),
        ...handleNameSpaceImports(nameSpaceImports, languageService, sourceFile, toSpecifier, itemsToBeReplaced, nameSpaceImportName),
    ];
}
exports.updateImportsSpecifier = updateImportsSpecifier;
function handleNameSpaceImports(nameSpaceImports, languageService, sourceFile, toSpecifier, itemsToBeReplaced, nameSpaceImportName) {
    const changes = [];
    for (const item of nameSpaceImports) {
        const allRefs = typescript_1.findReferences(languageService, sourceFile.fileName, item.name.getStart()).filter(ref => {
            const node = typescript_1.findTightestNode(sourceFile, ref.textSpan.start + 1);
            if (!node || !node.parent || !node.parent.parent) {
                return false;
            }
            const typeNode = node.parent.parent;
            if (ts.isTypeReferenceNode(typeNode) && ts.isQualifiedName(typeNode.typeName)) {
                return itemsToBeReplaced.includes(typeNode.typeName.right.text);
            }
            else if (ts.isIndexedAccessTypeNode(typeNode) && ts.isLiteralTypeNode(typeNode.indexType)) {
                return itemsToBeReplaced.includes(typeNode.indexType.literal.getText());
            }
            return false;
        });
        changes.push(...allRefs.map(ref => new ng_utils_1.ReplaceChange(sourceFile.fileName, ref.textSpan.start - 1, item.name.text, nameSpaceImportName.text)), new ng_utils_1.InsertChange(sourceFile.fileName, item.parent.parent.getStart(), `import * as ${nameSpaceImportName.text} from "${toSpecifier}";\n`));
    }
    return changes;
}
function handleNamedImports(namedImports, fileName, toSpecifier, itemsToBeReplaced) {
    const changes = [];
    for (const nameImport of namedImports) {
        const elements = nameImport.elements.filter(element => {
            const nameIdentifier = element.propertyName || element.name;
            return itemsToBeReplaced.includes(nameIdentifier.text);
        });
        if (elements.length === 0) {
            continue;
        }
        if (elements.length === nameImport.elements.length) {
            changes.push(replaceImportSpecifier(nameImport, fileName, toSpecifier));
        }
        else {
            elements.forEach(element => {
                changes.push(...removeNamedImport(element, fileName));
            });
            changes.push(addNamedImportSpecifiersToFile(elements, fileName, toSpecifier, nameImport.parent.parent.getStart()));
        }
    }
    return changes;
}
function replaceImportSpecifier(nameImport, fileName, toSpecifier) {
    return new ng_utils_1.ReplaceChange(fileName, nameImport.parent.parent.moduleSpecifier.getStart(), nameImport.parent.parent.moduleSpecifier.text, toSpecifier);
}
function removeNamedImport(element, fileName) {
    const changes = [];
    const nameIdentifier = element.propertyName || element.name;
    changes.push(new ng_utils_1.RemoveChange(fileName, element.getStart() + 1, nameIdentifier.text));
    const syntaxList = element.parent.getChildren().find(child => child.kind === ts.SyntaxKind.SyntaxList);
    if (syntaxList) {
        const children = syntaxList.getChildren();
        const commaToken = children[children.indexOf(element) + 1];
        if (commaToken && commaToken.kind === ts.SyntaxKind.CommaToken) {
            changes.push(new ng_utils_1.RemoveChange(fileName, commaToken.getStart(), commaToken.getText()));
        }
    }
    return changes;
}
function addNamedImportSpecifiersToFile(elements, fileName, specifier, pos) {
    const newElements = elements.map(element => element.getText()).join(', ');
    return new ng_utils_1.InsertChange(fileName, pos, `import {${newElements}} from "${specifier}";\n`);
}
//# sourceMappingURL=imports.js.map