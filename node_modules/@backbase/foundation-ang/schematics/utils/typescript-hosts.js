"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseConfigFileHost = exports.SchematicsTreeLanguageServiceHost = exports.CompilerHost = void 0;
const core_1 = require("@angular-devkit/core");
const ts = require("typescript");
const tree_1 = require("./tree");
const fileExists = (tree, path) => tree.exists(path);
const readFile = (tree, path) => {
    const file = tree.read(path);
    return file ? file.toString('utf-8') : undefined;
};
class CompilerHost {
    constructor(fs, options = {}) {
        this.fs = fs;
        this.options = options;
    }
    getSourceFile(fileName, languageVersion) {
        const text = this.readFile(fileName);
        if (text !== undefined) {
            const sourceFile = ts.createSourceFile(fileName, text, languageVersion, true);
            return sourceFile;
        }
        return;
    }
    getDefaultLibFileName(options) {
        return core_1.join(core_1.normalize(this.getDefaultLibLocation()), core_1.normalize(ts.getDefaultLibFileName(options)));
    }
    getDefaultLibLocation() {
        return '/node_modules/typescript/lib/';
    }
    writeFile(fileName, data) {
        if (this.fs.exists(fileName)) {
            this.fs.overwrite(fileName, data);
        }
        else {
            this.fs.create(fileName, data);
        }
    }
    getCurrentDirectory() {
        return '/';
    }
    getCanonicalFileName(fileName) {
        return this.useCaseSensitiveFileNames() ? fileName : fileName.toLowerCase();
    }
    useCaseSensitiveFileNames() {
        return true;
    }
    getNewLine() {
        switch (this.options.newLine) {
            case ts.NewLineKind.CarriageReturnLineFeed:
                return '\r\n';
            case ts.NewLineKind.LineFeed:
                return '\n';
            default:
                return '\r\n';
        }
    }
    fileExists(fileName) {
        return this.fs.exists(fileName);
    }
    readFile(fileName) {
        return readFile(this.fs, fileName);
    }
}
exports.CompilerHost = CompilerHost;
class SchematicsTreeLanguageServiceHost extends CompilerHost {
    constructor(fs, options = {}, rootFiles, _getScriptVersion = () => '0') {
        super(fs, options);
        this.fs = fs;
        this.options = options;
        this.rootFiles = rootFiles;
        this._getScriptVersion = _getScriptVersion;
    }
    getCompilationSettings() {
        return this.options;
    }
    getScriptFileNames() {
        return this.rootFiles;
    }
    getScriptVersion(fileName) {
        return this._getScriptVersion(fileName);
    }
    getScriptSnapshot(fileName) {
        const sourceFile = super.getSourceFile(fileName, ts.ScriptTarget.Latest);
        const content = sourceFile ? sourceFile.getText() : undefined;
        if (content)
            return ts.ScriptSnapshot.fromString(content);
        return undefined;
    }
}
exports.SchematicsTreeLanguageServiceHost = SchematicsTreeLanguageServiceHost;
class ParseConfigFileHost {
    constructor(fs) {
        this.fs = fs;
        this.useCaseSensitiveFileNames = true;
    }
    getCurrentDirectory() {
        return '/';
    }
    readDirectory(rootDir, extensions, excludes) {
        if (rootDir !== this.getCurrentDirectory()) {
            throw Error('not implemented');
        }
        const result = [];
        tree_1.getAllFilesFromTree(this.fs, excludes).forEach(file => {
            if (extensions.some(ex => file.endsWith(ex))) {
                result.push(core_1.join(core_1.normalize(rootDir), file));
            }
        });
        return result;
    }
    fileExists(path) {
        return fileExists(this.fs, path);
    }
    readFile(path) {
        return readFile(this.fs, path);
    }
    onUnRecoverableConfigFileDiagnostic() { }
}
exports.ParseConfigFileHost = ParseConfigFileHost;
//# sourceMappingURL=typescript-hosts.js.map