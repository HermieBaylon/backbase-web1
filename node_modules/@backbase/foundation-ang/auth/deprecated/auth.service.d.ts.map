{"version":3,"file":"auth.service.d.ts","sources":["auth.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { LogoutService, ReauthenticateService, SessionService, ɵAuthEvents } from '@backbase/foundation-ang/web-sdk';\nimport { Observable } from 'rxjs';\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface AccessToken {\n    raw: string;\n    parsed: any;\n}\n/**\n * @internal\n */\nexport interface AuthSuccessPayload {\n    currentAccessToken: AccessToken;\n}\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface LoginOptions {\n    /**\n     * Url for redirecting to after login is done with the authorisation result.\n     */\n    redirectUri?: string;\n}\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface LogoutOptions {\n    /**\n     * Url for redirecting to after logout is done.\n     */\n    redirectUri?: string;\n}\nexport interface ReauthenticateOptions {\n    scope: string;\n    /**\n     * The acr (Authentication Context Class Reference) claim and associated acr_values request parameter\n     * are defined by the OpenID Connect Core 1.0 specification.\n     *\n     * The value provided here is used as the `acr_values` in the reauthentication request.\n     *\n     * For example, the acrValues may be returned by the server when challenging a request for a resource, such\n     * as requiring multifactor authentication.\n     */\n    acrValues: string;\n    /**\n     * Whether to redirect the user or perform a request.\n     */\n    redirect?: boolean;\n    /**\n     * Url to return to following reauthentication redirect.\n     */\n    redirectUri?: string;\n}\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport interface CountdownOptions {\n    /**\n     * Configures when the countdown will start.\n     *\n     * The countdown will `start` once the TTL equals (or is less than) the `duration`.\n     */\n    duration?: number;\n    /**\n     * Called once the countdown begins (when `TTL < duration`).\n     */\n    start: () => void;\n    /**\n     * Called once the session is reset (and `TTL > duration`)\n     */\n    reset: () => void;\n    /**\n     * Called once the session expires (TTL = 0)\n     */\n    end: () => void;\n    /**\n     * Called every second between `start` and `end`.\n     *\n     * The `remaining` param is the number of seconds remaining until TTL = 0.\n     */\n    tick?: (remaining: number) => void;\n}\n/**\n * @deprecated Will be removed in v7.0.0\n */\nexport declare abstract class AuthService {\n    abstract readonly accessToken: Observable<AccessToken | undefined>;\n    abstract readonly isAuthenticated: Observable<boolean>;\n    abstract login(loginOptions?: LoginOptions): void;\n    abstract logout(logoutOptions?: LogoutOptions): Promise<void>;\n    abstract reauthenticate(reauthenticateOptions: ReauthenticateOptions): Promise<void>;\n    abstract registerSessionCountdown(countdown: CountdownOptions): void;\n    abstract timeToLive(): number;\n    abstract refresh(): Promise<void>;\n    abstract isImpersonated(): boolean;\n}\nexport declare class AuthServiceImpl implements AuthService {\n    private readonly logoutService;\n    private readonly reauthenticateService;\n    private readonly sessionService;\n    private readonly authEvents;\n    private readonly accessTokenSubject;\n    private readonly isLoadingSubject;\n    /**\n     * The current access token for the session, or `undefined` if there is no session.\n     *\n     * The first token will be emitted after the session is initialised. So if the user is logged\n     * in already then the first emission will be an access token.\n     *\n     * This is a hot observable, so subscribing to it won't trigger anything.\n     *\n     * The latest value will be replayed to late subscribers.\n     */\n    readonly accessToken: Observable<AccessToken | undefined>;\n    /**\n     * Track whether the current user is authenticated.\n     *\n     * This is a hot observable, so subscribing to it won't trigger anything.\n     *\n     * The latest value will be replayed to late subscribers.\n     */\n    readonly isAuthenticated: Observable<boolean>;\n    constructor(logoutService?: LogoutService, reauthenticateService?: ReauthenticateService, sessionService?: SessionService, authEvents?: ɵAuthEvents);\n    /**\n     * Redirect the user to the login page.\n     *\n     * @param loginOptions\n     */\n    login(loginOptions?: LoginOptions): void;\n    /**\n     * Log out the current user.\n     *\n     * @param logoutOptions\n     */\n    logout(logoutOptions?: LogoutOptions): Promise<void>;\n    /**\n     * Register a set of callbacks that will be called as the user's session gets close to expiring.\n     *\n     * @param countdown\n     */\n    registerSessionCountdown(countdown: CountdownOptions): void;\n    /**\n     * Return the time to live (TTL) in seconds of the user's session.\n     *\n     * Returns -1 if the TTL can't be determined.\n     */\n    timeToLive(): number;\n    /**\n     * Returns whether the user is being impersonated.\n     * @returns true if the user is being impersonated.\n     */\n    isImpersonated(): boolean;\n    /**\n     * Reauthenticate the current user.\n     *\n     * This can be used when the backend responds with a 401 and the current user needs to\n     * reauthenticate.\n     *\n     * @usageNotes\n     *\n     * You can use this service to create an interceptor which will automatically redirect the\n     * user when the backend responds with a 401. Useful when the backend responds with a challenge\n     * (eg: for step-up multifactor authentication):\n     *\n     * ```\n     * import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpResponse } from '@angular/common/http';\n     * import { from, Observable } from 'rxjs';\n     * import { catchError, first, mapTo } from 'rxjs/operators';\n     * import { AuthService } from '@backbase/foundation-ang/auth';\n     *\n     * export class ReauthenticateInterceptor implements HttpInterceptor {\n     *   constructor(private readonly authService: AuthService) {}\n     *   intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n     *     return next.handle(request).pipe(\n     *       // When any HTTP request fails (you could check status & headers here to only catch some failures).\n     *       catchError(error => {\n     *         // Retreive the challenge from the server's response.\n     *         const challenge: { scope: string; acrValues: string } = (error.error.challenges || []).find(\n     *           c => c.scope !== undefined,\n     *         );\n     *         // Reauthenticate the user with the requested scope & acr values and redirect back to here.\n     *         return from(\n     *           this.authService.reauthenticate({\n     *             scope: challenge.scope,\n     *             acrValues: challenge.acrValues,\n     *             redirect: true,\n     *             redirectUri: location.href,\n     *           }),\n     *           // Retry the orignal request\n     *         ).pipe(first(), mapTo(new HttpResponse({ body: error.error.data })));\n     *       }),\n     *     );\n     *   }\n     * }\n     * ```\n     *\n     * @param reauthenticateOptions\n     */\n    reauthenticate(reauthenticateOptions: ReauthenticateOptions): Promise<void>;\n    /**\n     * Refreshes the session.\n     */\n    refresh(): Promise<void>;\n    private handleAuthEvents;\n}\n"]}