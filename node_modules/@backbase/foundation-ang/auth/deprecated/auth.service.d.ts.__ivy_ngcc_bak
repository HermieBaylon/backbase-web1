import { LogoutService, ReauthenticateService, SessionService, ɵAuthEvents } from '@backbase/foundation-ang/web-sdk';
import { Observable } from 'rxjs';
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface AccessToken {
    raw: string;
    parsed: any;
}
/**
 * @internal
 */
export interface AuthSuccessPayload {
    currentAccessToken: AccessToken;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface LoginOptions {
    /**
     * Url for redirecting to after login is done with the authorisation result.
     */
    redirectUri?: string;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface LogoutOptions {
    /**
     * Url for redirecting to after logout is done.
     */
    redirectUri?: string;
}
export interface ReauthenticateOptions {
    scope: string;
    /**
     * The acr (Authentication Context Class Reference) claim and associated acr_values request parameter
     * are defined by the OpenID Connect Core 1.0 specification.
     *
     * The value provided here is used as the `acr_values` in the reauthentication request.
     *
     * For example, the acrValues may be returned by the server when challenging a request for a resource, such
     * as requiring multifactor authentication.
     */
    acrValues: string;
    /**
     * Whether to redirect the user or perform a request.
     */
    redirect?: boolean;
    /**
     * Url to return to following reauthentication redirect.
     */
    redirectUri?: string;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface CountdownOptions {
    /**
     * Configures when the countdown will start.
     *
     * The countdown will `start` once the TTL equals (or is less than) the `duration`.
     */
    duration?: number;
    /**
     * Called once the countdown begins (when `TTL < duration`).
     */
    start: () => void;
    /**
     * Called once the session is reset (and `TTL > duration`)
     */
    reset: () => void;
    /**
     * Called once the session expires (TTL = 0)
     */
    end: () => void;
    /**
     * Called every second between `start` and `end`.
     *
     * The `remaining` param is the number of seconds remaining until TTL = 0.
     */
    tick?: (remaining: number) => void;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare abstract class AuthService {
    abstract readonly accessToken: Observable<AccessToken | undefined>;
    abstract readonly isAuthenticated: Observable<boolean>;
    abstract login(loginOptions?: LoginOptions): void;
    abstract logout(logoutOptions?: LogoutOptions): Promise<void>;
    abstract reauthenticate(reauthenticateOptions: ReauthenticateOptions): Promise<void>;
    abstract registerSessionCountdown(countdown: CountdownOptions): void;
    abstract timeToLive(): number;
    abstract refresh(): Promise<void>;
    abstract isImpersonated(): boolean;
}
export declare class AuthServiceImpl implements AuthService {
    private readonly logoutService;
    private readonly reauthenticateService;
    private readonly sessionService;
    private readonly authEvents;
    private readonly accessTokenSubject;
    private readonly isLoadingSubject;
    /**
     * The current access token for the session, or `undefined` if there is no session.
     *
     * The first token will be emitted after the session is initialised. So if the user is logged
     * in already then the first emission will be an access token.
     *
     * This is a hot observable, so subscribing to it won't trigger anything.
     *
     * The latest value will be replayed to late subscribers.
     */
    readonly accessToken: Observable<AccessToken | undefined>;
    /**
     * Track whether the current user is authenticated.
     *
     * This is a hot observable, so subscribing to it won't trigger anything.
     *
     * The latest value will be replayed to late subscribers.
     */
    readonly isAuthenticated: Observable<boolean>;
    constructor(logoutService?: LogoutService, reauthenticateService?: ReauthenticateService, sessionService?: SessionService, authEvents?: ɵAuthEvents);
    /**
     * Redirect the user to the login page.
     *
     * @param loginOptions
     */
    login(loginOptions?: LoginOptions): void;
    /**
     * Log out the current user.
     *
     * @param logoutOptions
     */
    logout(logoutOptions?: LogoutOptions): Promise<void>;
    /**
     * Register a set of callbacks that will be called as the user's session gets close to expiring.
     *
     * @param countdown
     */
    registerSessionCountdown(countdown: CountdownOptions): void;
    /**
     * Return the time to live (TTL) in seconds of the user's session.
     *
     * Returns -1 if the TTL can't be determined.
     */
    timeToLive(): number;
    /**
     * Returns whether the user is being impersonated.
     * @returns true if the user is being impersonated.
     */
    isImpersonated(): boolean;
    /**
     * Reauthenticate the current user.
     *
     * This can be used when the backend responds with a 401 and the current user needs to
     * reauthenticate.
     *
     * @usageNotes
     *
     * You can use this service to create an interceptor which will automatically redirect the
     * user when the backend responds with a 401. Useful when the backend responds with a challenge
     * (eg: for step-up multifactor authentication):
     *
     * ```
     * import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpResponse } from '@angular/common/http';
     * import { from, Observable } from 'rxjs';
     * import { catchError, first, mapTo } from 'rxjs/operators';
     * import { AuthService } from '@backbase/foundation-ang/auth';
     *
     * export class ReauthenticateInterceptor implements HttpInterceptor {
     *   constructor(private readonly authService: AuthService) {}
     *   intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
     *     return next.handle(request).pipe(
     *       // When any HTTP request fails (you could check status & headers here to only catch some failures).
     *       catchError(error => {
     *         // Retreive the challenge from the server's response.
     *         const challenge: { scope: string; acrValues: string } = (error.error.challenges || []).find(
     *           c => c.scope !== undefined,
     *         );
     *         // Reauthenticate the user with the requested scope & acr values and redirect back to here.
     *         return from(
     *           this.authService.reauthenticate({
     *             scope: challenge.scope,
     *             acrValues: challenge.acrValues,
     *             redirect: true,
     *             redirectUri: location.href,
     *           }),
     *           // Retry the orignal request
     *         ).pipe(first(), mapTo(new HttpResponse({ body: error.error.data })));
     *       }),
     *     );
     *   }
     * }
     * ```
     *
     * @param reauthenticateOptions
     */
    reauthenticate(reauthenticateOptions: ReauthenticateOptions): Promise<void>;
    /**
     * Refreshes the session.
     */
    refresh(): Promise<void>;
    private handleAuthEvents;
}
