(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),require('@angular/common'),require('@angular/common/http'),exports, require('@angular/core'), require('@backbase/foundation-ang/web-sdk'), require('rxjs'), require('rxjs/operators'), require('@angular/common'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@backbase/foundation-ang/auth', ['@angular/core','@angular/common','@angular/common/http','exports', '@angular/core', '@backbase/foundation-ang/web-sdk', 'rxjs', 'rxjs/operators', '@angular/common', '@angular/common/http'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ng.core,global.ng.common,global.ng.common.http,(global.backbase = global.backbase || {}, global.backbase["foundation-ang"] = global.backbase["foundation-ang"] || {}, global.backbase["foundation-ang"].auth = {}), global.ng.core, global.backbase["foundation-ang"]["web-sdk"], global.rxjs, global.rxjs.operators, global.ng.common, global.ng.common.http));
})(this, (function (ɵngcc0,ɵngcc1,ɵngcc2,exports, i0, i1, rxjs, operators, i2, http) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var AuthService = /** @class */ (function () {
        function AuthService() {
        }
AuthService.ɵfac = function AuthService_Factory(t) { return new (t || AuthService)(); };
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthService, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root',
                // eslint-disable-next-line  no-use-before-define, @typescript-eslint/no-use-before-define
                useClass: i0.forwardRef(function () { return AuthServiceImpl; })
            }]
    }], function () { return []; }, null); })();
        return AuthService;
    }());
    AuthService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthServiceImpl(i0__namespace.ɵɵinject(i1__namespace.LOGOUT, 8), i0__namespace.ɵɵinject(i1__namespace.REAUTHENTICATE, 8), i0__namespace.ɵɵinject(i1__namespace.SESSION, 8), i0__namespace.ɵɵinject(i1__namespace.ɵAUTH_EVENTS, 8)); }, token: AuthService, providedIn: "root" });
    var AuthServiceImpl = /** @class */ (function () {
        function AuthServiceImpl(logoutService, reauthenticateService, sessionService, authEvents) {
            var _this = this;
            this.accessTokenSubject = new rxjs.BehaviorSubject(undefined);
            this.isLoadingSubject = new rxjs.BehaviorSubject(true);
            /**
             * The current access token for the session, or `undefined` if there is no session.
             *
             * The first token will be emitted after the session is initialised. So if the user is logged
             * in already then the first emission will be an access token.
             *
             * This is a hot observable, so subscribing to it won't trigger anything.
             *
             * The latest value will be replayed to late subscribers.
             */
            this.accessToken = this.isLoadingSubject.pipe(operators.filter(function (loading) { return !loading; }), operators.distinctUntilChanged(), operators.switchMap(function () { return _this.accessTokenSubject; }));
            /**
             * Track whether the current user is authenticated.
             *
             * This is a hot observable, so subscribing to it won't trigger anything.
             *
             * The latest value will be replayed to late subscribers.
             */
            this.isAuthenticated = this.accessToken.pipe(operators.map(function (token) { return !!token; }));
            if (!logoutService || !reauthenticateService || !sessionService || !authEvents) {
                throw new Error('In order to use the @backbase/foundation-ang/auth, please include *either* the ' +
                    'WebSdkModule.forRoot(...) in your AppModule (for CDN deployment) or WebSdkApiModule ' +
                    '(for CX deployment)');
            }
            this.logoutService = logoutService;
            this.reauthenticateService = reauthenticateService;
            this.sessionService = sessionService;
            this.authEvents = authEvents;
            this.handleAuthEvents();
        }
        /**
         * Redirect the user to the login page.
         *
         * @param loginOptions
         */
        AuthServiceImpl.prototype.login = function (loginOptions) {
            this.logoutService.goToLoginPage(loginOptions === null || loginOptions === void 0 ? void 0 : loginOptions.redirectUri);
        };
        /**
         * Log out the current user.
         *
         * @param logoutOptions
         */
        AuthServiceImpl.prototype.logout = function (logoutOptions) {
            return this.logoutService.logout(logoutOptions === null || logoutOptions === void 0 ? void 0 : logoutOptions.redirectUri);
        };
        /**
         * Register a set of callbacks that will be called as the user's session gets close to expiring.
         *
         * @param countdown
         */
        AuthServiceImpl.prototype.registerSessionCountdown = function (countdown) {
            this.sessionService.registerCountdown(countdown);
        };
        /**
         * Return the time to live (TTL) in seconds of the user's session.
         *
         * Returns -1 if the TTL can't be determined.
         */
        AuthServiceImpl.prototype.timeToLive = function () {
            return this.sessionService.timeToLive();
        };
        /**
         * Returns whether the user is being impersonated.
         * @returns true if the user is being impersonated.
         */
        AuthServiceImpl.prototype.isImpersonated = function () {
            return this.sessionService.isImpersonated;
        };
        /**
         * Reauthenticate the current user.
         *
         * This can be used when the backend responds with a 401 and the current user needs to
         * reauthenticate.
         *
         * @usageNotes
         *
         * You can use this service to create an interceptor which will automatically redirect the
         * user when the backend responds with a 401. Useful when the backend responds with a challenge
         * (eg: for step-up multifactor authentication):
         *
         * ```
         * import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest, HttpResponse } from '@angular/common/http';
         * import { from, Observable } from 'rxjs';
         * import { catchError, first, mapTo } from 'rxjs/operators';
         * import { AuthService } from '@backbase/foundation-ang/auth';
         *
         * export class ReauthenticateInterceptor implements HttpInterceptor {
         *   constructor(private readonly authService: AuthService) {}
         *   intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
         *     return next.handle(request).pipe(
         *       // When any HTTP request fails (you could check status & headers here to only catch some failures).
         *       catchError(error => {
         *         // Retreive the challenge from the server's response.
         *         const challenge: { scope: string; acrValues: string } = (error.error.challenges || []).find(
         *           c => c.scope !== undefined,
         *         );
         *         // Reauthenticate the user with the requested scope & acr values and redirect back to here.
         *         return from(
         *           this.authService.reauthenticate({
         *             scope: challenge.scope,
         *             acrValues: challenge.acrValues,
         *             redirect: true,
         *             redirectUri: location.href,
         *           }),
         *           // Retry the orignal request
         *         ).pipe(first(), mapTo(new HttpResponse({ body: error.error.data })));
         *       }),
         *     );
         *   }
         * }
         * ```
         *
         * @param reauthenticateOptions
         */
        AuthServiceImpl.prototype.reauthenticate = function (reauthenticateOptions) {
            return this.reauthenticateService.reauthenticate(reauthenticateOptions.scope, reauthenticateOptions.acrValues, reauthenticateOptions);
        };
        /**
         * Refreshes the session.
         */
        AuthServiceImpl.prototype.refresh = function () {
            return this.sessionService.refresh();
        };
        AuthServiceImpl.prototype.handleAuthEvents = function () {
            var _this = this;
            rxjs.merge(this.authEvents.success.pipe(operators.pluck('currentAccessToken')), this.authEvents.init.pipe(operators.pluck('currentAccessToken')), this.authEvents.end.pipe(operators.mapTo(undefined)), this.authEvents.error.pipe(operators.mapTo(undefined)))
                .pipe(operators.distinctUntilChanged(function (t1, t2) { return (t1 === null || t1 === void 0 ? void 0 : t1.raw) === (t2 === null || t2 === void 0 ? void 0 : t2.raw); }))
                .subscribe(function (token) {
                _this.accessTokenSubject.next(token);
                _this.isLoadingSubject.next(false);
            });
        };
        return AuthServiceImpl;
    }());
    AuthServiceImpl.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.LOGOUT,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.REAUTHENTICATE,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1.SESSION,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [i1["ɵAUTH_EVENTS"],] }] }
    ]; };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var AuthGuard = /** @class */ (function () {
        function AuthGuard(auth, location, document) {
            this.auth = auth;
            this.location = location;
            this.document = document;
        }
        AuthGuard.prototype.canLoad = function () {
            return this.auth.isAuthenticated.pipe(operators.take(1));
        };
        AuthGuard.prototype.canActivate = function () {
            return this.redirectIfUnauthenticated();
        };
        AuthGuard.prototype.canActivateChild = function () {
            return this.redirectIfUnauthenticated();
        };
        AuthGuard.prototype.redirectIfUnauthenticated = function () {
            var _this = this;
            return this.auth.isAuthenticated.pipe(operators.tap(function (loggedIn) {
                if (!loggedIn) {
                    // Use an actual location path with hash instead of `RouterStateSnapshot.url`
                    // because `Keycloak` uses `history.replaceState` on initialization to remove
                    // auth data from the path.
                    var actualPath = _this.location.path(true);
                    _this.auth.login({
                        redirectUri: _this.document.location.origin + _this.location.prepareExternalUrl(actualPath),
                    });
                }
            }));
        };
AuthGuard.ɵfac = function AuthGuard_Factory(t) { return new (t || AuthGuard)(ɵngcc0.ɵɵinject(AuthService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(i2.DOCUMENT)); };
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthGuard, [{
        type: i0.Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AuthService }, { type: ɵngcc1.Location }, { type: undefined, decorators: [{
                type: i0.Inject,
                args: [i2.DOCUMENT]
            }] }]; }, null); })();
        return AuthGuard;
    }());
    AuthGuard.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0__namespace.ɵɵinject(AuthService), i0__namespace.ɵɵinject(i2__namespace.Location), i0__namespace.ɵɵinject(i2__namespace.DOCUMENT)); }, token: AuthGuard, providedIn: "root" });
    AuthGuard.ctorParameters = function () { return [
        { type: AuthService },
        { type: i2.Location },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }
    ]; };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var AuthInterceptor = /** @class */ (function () {
        function AuthInterceptor(authService) {
            this.authService = authService;
        }
        AuthInterceptor.prototype.intercept = function (req, next) {
            return this.authService.accessToken.pipe(operators.take(1), operators.switchMap(function (token) {
                if (!token) {
                    return next.handle(req);
                }
                var newReq = req.clone({
                    headers: req.headers.append('Authorization', "Bearer " + token.raw),
                });
                return next.handle(newReq);
            }));
        };
AuthInterceptor.ɵfac = function AuthInterceptor_Factory(t) { return new (t || AuthInterceptor)(ɵngcc0.ɵɵinject(AuthService)); };
AuthInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: AuthInterceptor, factory: function (t) { return AuthInterceptor.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthInterceptor, [{
        type: i0.Injectable
    }], function () { return [{ type: AuthService }]; }, null); })();
        return AuthInterceptor;
    }());
    AuthInterceptor.ctorParameters = function () { return [
        { type: AuthService }
    ]; };

    function createAutoRefresh(authService, httpClient) {
        var refresh$;
        var refreshFailed = false;
        function refreshAndRepeat(req) {
            if (!refresh$) {
                refresh$ = rxjs.from(authService.refresh()).pipe(operators.tap(
                // after successful refresh remove reference as access token can expire again in the future
                function () { return (refresh$ = undefined); }, 
                // flag refresh failure so we will not try auto refresh again
                function () { return (refreshFailed = true); }));
            }
            return refresh$.pipe(operators.switchMap(function () {
                // repeat request (presume that access token is updated after refresh)
                return httpClient.request(req.clone());
            }));
        }
        return {
            failed: refreshFailed,
            refreshAndRepeat: refreshAndRepeat,
        };
    }

    var UNKNOWN_SCHEME = 'unknown';
    /**
     * See https://datatracker.ietf.org/doc/html/rfc6750#section-3
     * See https://www.rfc-editor.org/rfc/rfc7235.html#section-4.1
     * See https://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html
     * See https://datatracker.ietf.org/doc/html/rfc2617#section-3.2.1
     */
    function getWwwAuthenticate(headers) {
        var _a;
        var currentScheme = UNKNOWN_SCHEME;
        var schemes = (_a = {}, _a[currentScheme] = {}, _a);
        var headerName = headers.keys().find(function (key) { return key.toLowerCase() === 'www-authenticate'; });
        if (!headerName) {
            return schemes;
        }
        var value = headers.get(headerName).toLowerCase().trim();
        if (!value) {
            return schemes;
        }
        var matches = value.match(/(?:[^\s,"]+|"[^"]*")+/g);
        if (!matches) {
            schemes[currentScheme] = value;
            return schemes;
        }
        return matches.reduce(function (acc, match) {
            var nameVal = match.split('=').map(function (v) { return v.trim(); });
            if (nameVal.length === 1) {
                currentScheme = nameVal[0];
                acc[currentScheme] = {};
            }
            else if (nameVal.length === 2) {
                acc[currentScheme][nameVal[0]] = nameVal[1].replace(/"/g, '');
            }
            return acc;
        }, schemes);
    }
    /**
     * The 401 (Unauthorized) status code indicates that the request has not
     * been applied because it lacks valid authentication credentials for
     * the target resource.  The server generating a 401 response MUST send
     * a WWW-Authenticate header field (Section 4.1) containing at least one
     * challenge applicable to the target resource.
     */
    function is401AndNotReauth(error) {
        if (error.status !== 401) {
            return false;
        }
        var bearer = getWwwAuthenticate(error.headers).bearer;
        if (!bearer) {
            return false;
        }
        if (bearer.challenge_types && bearer.challenge_types !== 'reauth') {
            return false;
        }
        return bearer.error === 'invalid_token';
    }

    var INVALID_TOKEN_CONFIG = new i0.InjectionToken('invalid-token-config');
    var InvalidTokenInterceptor = /** @class */ (function () {
        function InvalidTokenInterceptor(authService, httpClient, injectedConfig, document) {
            this.authService = authService;
            this.httpClient = httpClient;
            this.injectedConfig = injectedConfig;
            this.document = document;
            this.config = {
                enableAutoRefresh: false,
                redirectToLoginPage: true,
            };
            this.autoRefresh = createAutoRefresh(this.authService, this.httpClient);
            this.config = Object.assign(Object.assign({}, this.config), (this.injectedConfig || {}));
        }
        InvalidTokenInterceptor.prototype.checkRedirect = function () {
            if (this.config.redirectToLoginPage) {
                this.authService.logout({ redirectUri: this.document.location.href });
            }
        };
        InvalidTokenInterceptor.prototype.tryRefresh = function (req, err) {
            var _this = this;
            return this.autoRefresh.refreshAndRepeat(req).pipe(operators.catchError(function () {
                _this.checkRedirect();
                return rxjs.throwError(err);
            }));
        };
        InvalidTokenInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            return next.handle(req).pipe(operators.catchError(function (err) {
                if (is401AndNotReauth(err)) {
                    if (_this.config.enableAutoRefresh && !_this.autoRefresh.failed) {
                        return _this.tryRefresh(req, err);
                    }
                    _this.checkRedirect();
                }
                return rxjs.throwError(err);
            }));
        };
InvalidTokenInterceptor.ɵfac = function InvalidTokenInterceptor_Factory(t) { return new (t || InvalidTokenInterceptor)(ɵngcc0.ɵɵinject(AuthService), ɵngcc0.ɵɵinject(ɵngcc2.HttpClient), ɵngcc0.ɵɵinject(INVALID_TOKEN_CONFIG, 8), ɵngcc0.ɵɵinject(i2.DOCUMENT)); };
InvalidTokenInterceptor.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: InvalidTokenInterceptor, factory: function (t) { return InvalidTokenInterceptor.ɵfac(t); } });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(InvalidTokenInterceptor, [{
        type: i0.Injectable
    }], function () { return [{ type: AuthService }, { type: ɵngcc2.HttpClient }, { type: undefined, decorators: [{
                type: i0.Optional
            }, {
                type: i0.Inject,
                args: [INVALID_TOKEN_CONFIG]
            }] }, { type: undefined, decorators: [{
                type: i0.Inject,
                args: [i2.DOCUMENT]
            }] }]; }, null); })();
        return InvalidTokenInterceptor;
    }());
    InvalidTokenInterceptor.ctorParameters = function () { return [
        { type: AuthService },
        { type: http.HttpClient },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [INVALID_TOKEN_CONFIG,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [i2.DOCUMENT,] }] }
    ]; };

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AuthGuard = AuthGuard;
    exports.AuthInterceptor = AuthInterceptor;
    exports.AuthService = AuthService;
    exports.INVALID_TOKEN_CONFIG = INVALID_TOKEN_CONFIG;
    exports.InvalidTokenInterceptor = InvalidTokenInterceptor;
    exports. ɵa   = AuthServiceImpl;

    Object.defineProperty(exports, '__esModule', { value: true });

}));

//# sourceMappingURL=backbase-foundation-ang-auth.umd.js.map