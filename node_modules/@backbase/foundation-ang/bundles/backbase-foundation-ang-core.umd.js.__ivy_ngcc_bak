(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/router'), require('rxjs'), require('@backbase/foundation-ang/web-sdk'), require('rxjs/operators'), require('@backbase/communication-property'), require('@backbase/foundation-ang/future'), require('@backbase/foundation-ang/store'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@backbase/foundation-ang/core', ['exports', '@angular/common', '@angular/core', '@angular/router', 'rxjs', '@backbase/foundation-ang/web-sdk', 'rxjs/operators', '@backbase/communication-property', '@backbase/foundation-ang/future', '@backbase/foundation-ang/store', '@angular/common/http'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.backbase = global.backbase || {}, global.backbase["foundation-ang"] = global.backbase["foundation-ang"] || {}, global.backbase["foundation-ang"].core = {}), global.ng.common, global.ng.core, global.ng.router, global.rxjs, global.backbase["foundation-ang"]["web-sdk"], global.rxjs.operators, global.communicationProperty, global.backbase["foundation-ang"].future, global.backbase["foundation-ang"].store, global.ng.common.http));
})(this, (function (exports, common, i0, router, rxjs, webSdk, operators, communicationProperty, future, store, http) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var CONFIG_ASSETS = new i0.InjectionToken('@backbase/foundation Assets Service Configuration');
    var DEFAULT_STATIC_ROOT = '/';
    var DEFAULT_STATIC_ITEM_NAME = '';
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var AssetsService = /** @class */ (function () {
        function AssetsService(pageConfig, assetsConfig) {
            this.pageConfig = pageConfig;
            this.assetsConfig = assetsConfig;
            if (!pageConfig && i0.isDevMode()) {
                console.warn("pageConfig is not provided which may impact the path that is resolving assets\n         please include *either* the 'WebSdkModule.forRoot(...)' in your AppModule (for CDN deployment) or WebSdkApiModule\n          (for CX deployment)");
            }
        }
        AssetsService.prototype.createAssetsResolver = function (config) {
            var widgetName = config.widgetName;
            var assetsIdResolver = config.getURIFromAssetID;
            var staticRoot = this.pageConfig ? this.pageConfig.staticResourcesRoot : DEFAULT_STATIC_ROOT;
            var staticItemName = this.assetsConfig ? this.assetsConfig.assetsStaticItemName : DEFAULT_STATIC_ITEM_NAME;
            return function (assetId) {
                if (!assetId.length) {
                    return rxjs.of('');
                }
                return rxjs.of([staticRoot, staticItemName, 'assets', widgetName, assetsIdResolver(assetId)]
                    .filter(Boolean)
                    .map(function (str) { return str.replace(/\/$/, ''); })
                    .join('/'));
            };
        };
        return AssetsService;
    }());
    AssetsService.decorators = [
        { type: i0.Injectable }
    ];
    AssetsService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [webSdk.PAGE_CONFIG,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [CONFIG_ASSETS,] }] }
    ]; };

    function equal(a, b) {
        if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        return a === b;
    }
    /**
     * Allow the processing of Properties as an array of pairs.
     *
     * @param process The processing to apply to the property pairs; mapping, filtering, etc.
     * @param properties
     */
    var propertiesAsPairs = function (process, properties) {
        var pairs = process(Object.entries(properties));
        return pairs.reduce(function (acc, _a) {
            var _b;
            var _c = __read(_a, 2), name = _c[0], value = _c[1];
            return (Object.assign(Object.assign({}, acc), (_b = {}, _b[name] = value, _b)));
        }, {});
    };
    /**
     * Returns a subset of the properties that start
     * with a given prefix, and also removes the prefix from the name
     * of the property.
     *
     * @param prefix
     * @param properties
     */
    var propertiesByPrefix = function (prefix, properties) { return propertiesAsPairs(function (pairs) { return pairs
        .filter(function (_a) {
        var _b = __read(_a, 1), name = _b[0];
        return name.startsWith(prefix);
    })
        .map(function (_a) {
        var _b = __read(_a, 2), name = _b[0], value = _b[1];
        return [name.substring(prefix.length), value];
    }); }, properties); };

    var AppConfigService = /** @class */ (function () {
        function AppConfigService() {
            this.config = new rxjs.BehaviorSubject({});
            this.propertyPrefix = 'AppConfig.';
        }
        Object.defineProperty(AppConfigService.prototype, "prefix", {
            get: function () {
                return this.propertyPrefix;
            },
            enumerable: false,
            configurable: true
        });
        AppConfigService.prototype.getConfig = function () {
            return this.config.asObservable();
        };
        AppConfigService.prototype.setConfig = function (config) {
            this.config.next(config);
        };
        return AppConfigService;
    }());
    AppConfigService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function AppConfigService_Factory() { return new AppConfigService(); }, token: AppConfigService, providedIn: "root" });
    AppConfigService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var map = function (callbackfn, arr) { return arr.map(callbackfn); };
    var flatten = function (arr) { return arr.reduce(function (acc, a) { return __spreadArray(__spreadArray([], __read(acc)), __read(a)); }, []); };
    var flatMap = function (callbackfn, arr) { return flatten(map(callbackfn, arr)); };
    var uniq = function (array) { return Array.from(new Set(array)); };
    var hasDuplicates = function (array) { return array.length !== uniq(array).length; };
    /**
     * Creates a new list out of the two supplied by pairing up equally-positioned
     * items from both lists. The returned list is the length of the longer of two
     * lists. If one of the lists is shorter, the values will be set to "undefined".
     *
     * @param left
     * @param right
     */
    var pairs = function (left, right) {
        var max = Math.max(left.length, right.length);
        var idx = 0;
        var returnZip = [];
        while (idx < max) {
            returnZip[idx] = [left[idx], right[idx]];
            idx++;
        }
        return returnZip;
    };
    /**
     * This helper checks if the value is array of strings.
     * @param value a value to be evaluated
     * @returns true for array of strings and false for any other values
     */
    var isArrayOfStrings = function (value) { return Array.isArray(value) && value.every(function (item) { return typeof item === 'string'; }); };

    /**
     * This helper determines container objects from any other ones.
     * @param item an item to be evaluated
     * @returns true for containers and false for widgets and any other objects
     */
    var isContainer = function (item) { return 'name' in item && 'properties' in item && 'children' in item; };
    /**
     * Returns the elements of a tree with the children that meet the condition specified in a predicate function.
     * @param item an item whose children need to be filtered
     * @param predicate the filter method called for each child. It should return boolean
     */
    var filterChildren = function (item, predicate) {
        return isContainer(item)
            ? Object.assign(Object.assign({}, item), { children: item.children.map(function (child) { return filterChildren(child, predicate); }).filter(predicate) }) : item;
    };

    var treeValue = function (t) { return t.value; };
    var ɵ0$f = treeValue;
    /**
     * Abstract tree representation.
     */
    var Tree = /** @class */ (function () {
        function Tree(
        /**
         * The value of this node
         */
        value, 
        /**
         * The children of this node
         */
        children) {
            this.value = value;
            this.children = children;
        }
        Tree.prototype.map = function (callbackfn) {
            var newChildren = this.children.map(function (childTree) { return childTree.map(callbackfn); });
            return new Tree(callbackfn(this.value, this.children.map(treeValue), newChildren.map(treeValue)), newChildren);
        };
        /**
         * Flattens the tree into a flat array of tree nodes.
         *
         * The tree is flattened by in order of depth-first-preorder-traversal.
         */
        Tree.prototype.flatten = function () {
            return __spreadArray([this], __read(flatMap(function (child) { return child.flatten(); }, this.children)));
        };
        Tree.prototype.pathTo = function (value) {
            var e_1, _a;
            if (this.value === value) {
                return [this.value];
            }
            else {
                try {
                    for (var _b = __values(this.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        var childPath = child.pathTo(value);
                        if (childPath.length !== 0) {
                            return __spreadArray([this.value], __read(childPath));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return [];
            }
        };
        Tree.prototype.lowestCommonAncestor = function (left, right) {
            var leftPath = new Set(this.pathTo(left));
            return this.pathTo(right)
                .reverse()
                .find(function (candidate) { return leftPath.has(candidate); });
        };
        return Tree;
    }());
    /**
     * @description
     * This is an operator that can be used with an Observable's `pipe`.
     *
     * The piped observable should be an observable of an array.
     *
     * The source array is mapped over with the provided callback function, and the
     * callback function should take an item (T) from the source array, and return an
     * *observable* of a new item (R).
     *
     * The result is a new observable of an array the same length as the source array
     * but with the Ts mapped to Rs.
     *
     * This is useful for mapping over the observable children of node in the model tree.
     *
     * @usageNotes
     *
     * ### Example
     * ```
     * const children: ObservableTree<ItemModel> = this.model.children;
     * const titleProperties: Observable<Array<string>> = this.model.children.pipe(
     *   mapObservableArray(item => item.value.property<string>('title', 'Default Title'))
     * );
     * ```
     * @param callback Function that produces an *observable* element of the new Array
     */
    var mapObservableArray = function (callback) {
        return function (source) {
            return source.pipe(operators.switchMap(function (tArray) { return rxjs.combineLatest(tArray.map(callback)); }));
        };
    };
    /**
     * An tree where each node's children are observable.
     */
    var ObservableTree = /** @class */ (function () {
        function ObservableTree(
        /**
         * The value of this node
         */
        value, initialChildren, insertions, removals) {
            this.value = value;
            this.insertions = insertions;
            this.removals = removals;
            // Reducers to update children state
            this.initialChildren = rxjs.of(function (acc) { return acc; }); // identity reducer for initial value
            this.insertUpdates = this.insertions.pipe(operators.map(function (_a) {
                var item = _a.item, index = _a.index;
                return function (children) { return __spreadArray(__spreadArray(__spreadArray([], __read(children.slice(0, index))), [item]), __read(children.slice(index))); };
            }));
            this.removalUpdates = this.removals.pipe(operators.map(function (index) { return function (children) {
                var newChildren = __spreadArray([], __read(children));
                newChildren.splice(index, 1);
                return newChildren;
            }; }));
            // Combine reducers to a single stream
            this.reducers = rxjs.merge(this.initialChildren, this.insertUpdates, this.removalUpdates);
            this.children = this.reducers.pipe(operators.scan(function (currentChildren, updateFn) { return updateFn(currentChildren); }, initialChildren), operators.shareReplay(1));
        }
        /**
         * Find a node in the tree. Returns the result as an observable.
         *
         * If the element is found it is emitted, otherwise, the result emits undefined.
         *
         * The result observable will only emit again if the found node changes (ie: if
         * it is added or removed, or if it finds a different node).
         *
         * @param predicate predicate is called once for each node of the tree, until a
         * node is found. The predicate will be called again every time the tree changes
         * (ie: a node in the tree is added or removed). The predicate is called in order
         * of depth-first-preorder-traversal.
         */
        ObservableTree.prototype.find = function (predicate) {
            return this.flatten().pipe(operators.map(function (nodes) { return nodes.find(function (node) { return predicate(node.value); }); }), operators.distinctUntilChanged());
        };
        ObservableTree.prototype.pathTo = function (value) {
            return this.toTree().pipe(operators.map(function (tree) { return tree.pathTo(value); }), operators.distinctUntilChanged());
        };
        ObservableTree.prototype.lowestCommonAncestor = function (left, right) {
            return this.toTree().pipe(operators.map(function (tree) { return tree.lowestCommonAncestor(left, right); }), operators.distinctUntilChanged());
        };
        ObservableTree.prototype.filter = function (predicate) {
            return this.flatten().pipe(operators.map(function (nodes) { return nodes.filter(function (node) { return predicate(node.value); }); }), operators.distinctUntilChanged());
        };
        /**
         * Flattens a tree into a single array of nodes. The result nodes are still trees.
         *
         * The tree is flattened in order of depth-first-preorder-traversal.
         *
         * The result is returned as an observable and re-emits every time a node is added
         * or removed from the tree.
         */
        ObservableTree.prototype.flatten = function () {
            var _this = this;
            return this.children.pipe(operators.switchMap(function (children) { return (children.length === 0 ? rxjs.of([]) : rxjs.combineLatest(children.map(function (child) { return child.flatten(); }))); }), operators.map(flatten), operators.map(function (flat) { return __spreadArray([_this], __read(flat)); }));
        };
        /**
         * Takes a snapshot of the tree.
         */
        ObservableTree.prototype.toTree = function () {
            var _this = this;
            return this.children.pipe(operators.switchMap(function (children) {
                var mappedChildren$ = children.length === 0 ? rxjs.of([]) : rxjs.combineLatest(children.map(function (child) { return child.toTree(); }));
                return mappedChildren$.pipe(operators.map(function (mappedChildren) { return new Tree(_this.value, mappedChildren); }));
            }));
        };
        return ObservableTree;
    }());
    /**
     * Like combineLatest in rxjs, but for a tree of observables, instead of
     * an array of observables.
     */
    function combineTree(tree) {
        // Convert children from Array<Tree<Observable<T>>> to Observable<Array<Tree<T>>>
        var children$ = tree.children.length === 0 ? rxjs.of([]) : rxjs.combineLatest(tree.children.map(combineTree));
        return rxjs.combineLatest([tree.value, children$]).pipe(operators.map(function (_a) {
            var _b = __read(_a, 2), value = _b[0], children = _b[1];
            return new Tree(value, children);
        }));
    }
    /**
     * Extracts a branch from a tree that starts at the root, and ends at the leaf
     * node, as determined by the predicate (returns a linked list).
     *
     * If the element is not found, the result is undefined.
     *
     * @param predicate predicate is called once for each node of the tree, until a
     * node is found. The predicate is called in order of depth-first-preorder-traversal.
     */
    var treeBranch = function (tree, predicate) {
        var walkTree = function (treeInner, index, parentTree) {
            if (predicate(treeInner, index, parentTree)) {
                return {
                    value: treeInner,
                };
            }
            if (!treeInner.children) {
                return undefined;
            }
            for (var i = 0; i < treeInner.children.length; i++) {
                var foundInChild = walkTree(treeInner.children[i], i, treeInner);
                if (foundInChild) {
                    return {
                        value: treeInner,
                        next: foundInChild,
                    };
                }
            }
            return undefined;
        };
        return walkTree(tree);
    };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var ItemModel = /** @class */ (function () {
        function ItemModel(name, initialProperties, propertyUpdates) {
            this.name = name;
            var applyPropertyUpdate = function (currentProperties, update) {
                return Object.assign(Object.assign({}, currentProperties), update);
            };
            this.properties = propertyUpdates.pipe(operators.startWith(initialProperties), operators.scan(applyPropertyUpdate), operators.shareReplay(1));
            if (initialProperties.classId === undefined) {
                throw new Error("Missing classId property for " + name);
            }
            this.ɵclassId = initialProperties.classId;
            this.ɵoutputProperties = this.outputProperties(initialProperties);
            this.ɵinputProperties = this.inputProperties(initialProperties);
            this.ɵproperties = this.nonIOProperties(initialProperties);
        }
        ItemModel.prototype.property = function (propertyName, defaultValue) {
            return this.properties.pipe(operators.pluck(propertyName), operators.map(function (propertyValue) { return (propertyValue === undefined || propertyValue === null ? defaultValue : propertyValue); }), operators.distinctUntilChanged(function (a, b) {
                if (a === undefined && b === undefined) {
                    return true;
                }
                if (a === undefined) {
                    return false;
                }
                if (b === undefined) {
                    return false;
                }
                return equal(a, b);
            }));
        };
        ItemModel.prototype.outputProperties = function (properties) {
            return propertiesByPrefix('output.', properties);
        };
        ItemModel.prototype.inputProperties = function (properties) {
            return propertiesByPrefix('input.', properties);
        };
        ItemModel.prototype.nonIOProperties = function (properties) {
            return propertiesAsPairs(function (pairs) { return pairs.filter(function (_a) {
                var _b = __read(_a, 1), name = _b[0];
                return !name.startsWith('input.') && !name.startsWith('output.');
            }); }, properties);
        };
        return ItemModel;
    }());
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var ItemModelTree = /** @class */ (function (_super) {
        __extends(ItemModelTree, _super);
        function ItemModelTree() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ItemModelTree;
    }(ObservableTree));

    var ROOT_COMPONENT_CLASS_ID = 'RootComponent';
    var DEFAULT_ROOT_NAME = 'bb-root-empty';
    var isInsert = function (update) { return !!(update.item && update.itemLocation); };
    var isPropertyUpdate = function (update) { return !!(update.name && update.properties); };
    var isRemovalUpdate = function (update) { return !!(update && 'parentName' in update && 'index' in update); };
    var CommunicationInputs = /** @class */ (function () {
        function CommunicationInputs(properties) {
            this.properties = properties;
        }
        CommunicationInputs.fromProperties = function (properties) {
            return new CommunicationInputs(new Map(Object.entries(properties)
                .filter(function (property) { return typeof property[1] === 'string'; })
                .map(function (_a) {
                var _b = __read(_a, 2), propertyName = _b[0], propertyValue = _b[1];
                return [propertyName, communicationProperty.serializerDeserializer.fromProperty(propertyValue)];
            })
                .filter(function (property) { return property[1] !== undefined; })));
        };
        CommunicationInputs.prototype.hasInputFor = function (communicationDefinition) {
            return (Array.from(this.properties.values()).find(function (candidate) { return communicationDefinition.equals(candidate); }) !== undefined);
        };
        return CommunicationInputs;
    }());
    /**
     * The root container is basically the page model, but we don't assume that the
     * angular app is the entire page. It could just be a subset of the page model,
     * hence we call it "root container"
     *
     * @internal
     */
    var ӨRootContainerService = /** @class */ (function () {
        function ӨRootContainerService() {
            var _this = this;
            // The websdk commands mapped to observables.
            this.propertyUpdates = new rxjs.Subject();
            this.inserts = new rxjs.Subject();
            this.removals = new rxjs.Subject();
            this.modelUpdates = rxjs.merge(this.propertyUpdates, this.inserts, this.removals);
            this.defaultValue = {
                name: DEFAULT_ROOT_NAME,
                properties: { classId: ROOT_COMPONENT_CLASS_ID },
                children: [],
            };
            this.rootContainerItem = new rxjs.BehaviorSubject(this.defaultValue);
            this.model = this.rootContainerItem.pipe(operators.filter(function (container) { return !_this.isDefaultContainer(container.name); }), // skip the empty state
            operators.map(function (c) { return _this.createInitialModelState(c); }), operators.shareReplay(1));
        }
        ӨRootContainerService.prototype.createInitialModelState = function (_a) {
            var name = _a.name, properties = _a.properties, children = _a.children;
            var initialRootContainerProperties = Object.assign(Object.assign({}, properties), { classId: ROOT_COMPONENT_CLASS_ID });
            return this.createModelStateNode({
                name: name,
                properties: initialRootContainerProperties,
                children: children,
            });
        };
        ӨRootContainerService.prototype.createModelStateNode = function (item) {
            var _this = this;
            // Filter property updates to just the updates for this item.
            var propertyUpdates = this.propertyUpdates.pipe(operators.filter(function (update) { return update.name === item.name; }), operators.pluck('properties'));
            // Recursively create the children.
            var childNodes = isContainer(item)
                ? item.children.map(this.createModelStateNode.bind(this))
                : [];
            var insertions;
            var removals;
            if (isContainer(item)) {
                // Filter container updates for this item (inserts and removes)
                insertions = this.inserts.pipe(operators.filter(function (insert) { return !!insert.itemLocation && insert.itemLocation.parentName === item.name; }), operators.map(function (insert) { return ({
                    item: _this.createModelStateNode(insert.item),
                    index: insert.itemLocation ? insert.itemLocation.index : 0,
                }); }));
                removals = this.removals.pipe(operators.filter(function (removal) { return !!removal && removal.parentName === item.name; }), operators.pluck('index'));
            }
            else {
                insertions = rxjs.of();
                removals = rxjs.of();
            }
            // Create the node itself.
            return new ObservableTree(new ItemModel(item.name, item.properties, propertyUpdates), childNodes, insertions, removals);
        };
        Object.defineProperty(ӨRootContainerService.prototype, "rootName", {
            get: function () {
                return this.rootContainerItem.getValue().name;
            },
            enumerable: false,
            configurable: true
        });
        ӨRootContainerService.prototype.isDefaultContainer = function (name) {
            return name === DEFAULT_ROOT_NAME;
        };
        ӨRootContainerService.prototype.isBootstrapped = function () {
            return !this.isDefaultContainer(this.rootName);
        };
        ӨRootContainerService.prototype.updateItem = function (name, properties) {
            this.propertyUpdates.next({ name: name, properties: properties });
        };
        ӨRootContainerService.prototype.insertItem = function (item, itemLocation) {
            if (!this.isBootstrapped()) {
                this.rootContainerItem.next(item);
            }
            else {
                this.inserts.next({ item: item, itemLocation: itemLocation });
            }
        };
        ӨRootContainerService.prototype.removeItem = function (itemName, itemLocation) {
            if (this.rootName === itemName) {
                this.rootContainerItem.next(this.defaultValue);
            }
            else {
                this.removals.next(itemLocation);
            }
        };
        ӨRootContainerService.prototype.filter = function (predicate) {
            return this.model.pipe(operators.switchMap(function (model) { return model.filter(predicate); }));
        };
        ӨRootContainerService.prototype.getCommunicationGroupItems = function (groupDefinition) {
            return this.filter(function (item) { return CommunicationInputs.fromProperties(item.ɵinputProperties).hasInputFor(groupDefinition); }).pipe(operators.map(function (nodes) { return nodes.map(function (node) { return node.value; }); }));
        };
        // The only case where there will not be a common ancestor (i.e. return `undefined`) is if there are
        // no items with inputs in the communication group.
        ӨRootContainerService.prototype.commonAncestor = function (groupDefinition) {
            return rxjs.combineLatest([
                this.model.pipe(operators.switchMap(function (model) { return model.toTree(); })),
                this.getCommunicationGroupItems(groupDefinition),
            ]).pipe(operators.map(function (_a) {
                var e_1, _b;
                var _c = __read(_a, 2), tree = _c[0], _d = __read(_c[1]), first = _d[0], items = _d.slice(1);
                var lowest = first;
                try {
                    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        var newLowest = tree.lowestCommonAncestor(lowest, item);
                        if (newLowest === undefined) {
                            return undefined;
                        }
                        else {
                            lowest = newLowest;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_b = items_1.return)) _b.call(items_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return lowest;
            }));
        };
        return ӨRootContainerService;
    }());
    ӨRootContainerService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ӨRootContainerService_Factory() { return new ӨRootContainerService(); }, token: ӨRootContainerService, providedIn: "root" });
    ӨRootContainerService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    exports.LifecycleEventKind = void 0;
    (function (LifecycleEventKind) {
        LifecycleEventKind["Create"] = "create";
        LifecycleEventKind["Remove"] = "remove";
    })(exports.LifecycleEventKind || (exports.LifecycleEventKind = {}));
    var ItemLifecycleService = /** @class */ (function () {
        function ItemLifecycleService() {
            this.lifecycleEvents = new rxjs.Subject();
        }
        ItemLifecycleService.prototype.onCreate = function (itemModel, component) {
            this.lifecycleEvents.next({
                kind: exports.LifecycleEventKind.Create,
                itemModel: itemModel,
                component: component,
            });
        };
        ItemLifecycleService.prototype.onRemove = function (itemModel, component) {
            this.lifecycleEvents.next({
                kind: exports.LifecycleEventKind.Remove,
                itemModel: itemModel,
                component: component,
            });
        };
        ItemLifecycleService.prototype.fromItem = function (name) {
            return this.lifecycleEvents.pipe(operators.filter(function (lcEvent) { return name === lcEvent.itemModel.value.name; }));
        };
        ItemLifecycleService.prototype.whenCreate = function (name) {
            var nameFilter = name ? function (currentName) { return currentName === name; } : function () { return true; };
            return this.lifecycleEvents.pipe(operators.filter(function (lcEvent) { return exports.LifecycleEventKind.Create === lcEvent.kind && nameFilter(lcEvent.itemModel.value.name); }));
        };
        ItemLifecycleService.prototype.whenRemove = function (name) {
            var nameFilter = name ? function (currentName) { return currentName === name; } : function () { return true; };
            return this.lifecycleEvents.pipe(operators.filter(function (lcEvent) { return exports.LifecycleEventKind.Remove === lcEvent.kind && nameFilter(lcEvent.itemModel.value.name); }));
        };
        return ItemLifecycleService;
    }());
    ItemLifecycleService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ItemLifecycleService_Factory() { return new ItemLifecycleService(); }, token: ItemLifecycleService, providedIn: "root" });
    ItemLifecycleService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var isRootContainerItem = function (item) { return !item.properties || !item.properties.classId; };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var BackbaseConnector = /** @class */ (function () {
        /**
         * BackbaseConnectorService constructor
         * @param zone NgZone to be used for manipulations with an item
         * @param componentInjectors Backbase core components injector service to handle the model
         */
        function BackbaseConnector(zone, appConfig, rootContainer, lifeCycle) {
            this.zone = zone;
            this.appConfig = appConfig;
            this.rootContainer = rootContainer;
            this.lifeCycle = lifeCycle;
        }
        BackbaseConnector.prototype.filterItem = function (item) {
            var features = propertiesByPrefix(this.appConfig.prefix, item.properties);
            this.appConfig.setConfig(features);
            return filterChildren(item, function (child) {
                var itemFeatures = child.properties.features;
                return (!itemFeatures ||
                    !isArrayOfStrings(itemFeatures) ||
                    itemFeatures.some(function (requiredFeature) { return features[requiredFeature] !== false; }));
            });
        };
        /**
         * Bootstrap function to be called on page model initialization,
         * and when new item added to the model (dropped on the page).
         * @param item Item to bootstrap
         * @param itemLocation Location of the item
         */
        BackbaseConnector.prototype.bootstrap = function (item, itemLocation) {
            var _this = this;
            return this.zone.run(function () {
                var event;
                if (isRootContainerItem(item)) {
                    event = _this.lifeCycle.whenCreate(undefined).pipe(operators.publishReplay(1));
                }
                else {
                    event = _this.lifeCycle.fromItem(item.name).pipe(operators.publishReplay(1));
                }
                event.connect();
                var itemToInsert = _this.rootContainer.isBootstrapped() ? item : _this.filterItem(item);
                _this.rootContainer.insertItem(itemToInsert, itemLocation);
                return event.pipe(operators.take(1), operators.mapTo(true)).toPromise();
            });
        };
        /**
         * Update function will be called when properties are changed for
         * one of the existing items on a page.
         * @param item Updated item
         * @param itemLocation Location of the item
         * @param changes Object which contains only changed properties and their values
         */
        BackbaseConnector.prototype.update = function (item, _, itemProperties) {
            var _this = this;
            return this.zone.run(function () {
                _this.rootContainer.updateItem(item.name, itemProperties);
                return _this.lifeCycle.fromItem(item.name).pipe(operators.take(1), operators.mapTo(undefined)).toPromise();
            });
        };
        /**
         * Remove function will be called when existing item is removed from the page.
         * @param item Item to remove
         * @param itemLocation Location of the item
         */
        BackbaseConnector.prototype.remove = function (item, itemLocation) {
            var _this = this;
            return this.zone.run(function () {
                _this.rootContainer.removeItem(item.name, itemLocation);
                return _this.lifeCycle.whenRemove().pipe(operators.debounceTime(20), operators.take(1), operators.mapTo(undefined)).toPromise();
            });
        };
        return BackbaseConnector;
    }());
    BackbaseConnector.decorators = [
        { type: i0.Injectable }
    ];
    BackbaseConnector.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: AppConfigService },
        { type: ӨRootContainerService },
        { type: ItemLifecycleService }
    ]; };

    var LAZY_MAP = new i0.InjectionToken('Lazy load map');

    /**
     * ComponentRegistry configuration injection token
     */
    var CONFIG_COMPONENT_CLASS_MAP = new i0.InjectionToken('@backbase/foundation Components Registry');
    /**
     * ItemRegistryService stores a hashMap
     * of the components included into the app and
     * avaliable for usage. It's meant to be an extension
     * point which is used by a developer.
     */
    var ItemRegistryService = /** @class */ (function () {
        /**
         * ItemRegistryService constructor which allows to define components
         * included into application
         * @param ComponentRegistry a hashMap of the component classes to be added
         */
        function ItemRegistryService(classMaps, lazyConfig) {
            this.itemRegistry = new rxjs.BehaviorSubject(new Map(classMaps
                ? classMaps.reduce(function (acc, classMap) { return __spreadArray(__spreadArray([], __read(acc)), __read(Object.entries(classMap))); }, [])
                : undefined));
            this.lazyModuleConfig = (lazyConfig || []).filter(isLazyModuleConfig);
        }
        ItemRegistryService.prototype.entries = function () {
            return Array.from(this.itemRegistry.value.entries());
        };
        ItemRegistryService.prototype.add = function (classId, componentClass) {
            this.itemRegistry.next(new Map(__spreadArray(__spreadArray([], __read(this.entries())), [[classId, componentClass]])));
        };
        ItemRegistryService.prototype.has = function (classId) {
            return this.itemRegistry.value.has(classId);
        };
        /**
         * This method allows to retrieve Component by it's classId
         * @param classId classId key to get a component class
         * @returns componentType to be used by a ComponentFactoryResolver
         */
        ItemRegistryService.prototype.getComponentValue = function (classId) {
            return this.itemRegistry.value.get(classId);
        };
        ItemRegistryService.prototype.getComponent = function (classId) {
            return this.itemRegistry
                .pipe(operators.map(function (registry) { return registry.get(classId); }), operators.filter(function (componentClass) { return componentClass !== undefined; }), operators.take(1))
                .toPromise();
        };
        ItemRegistryService.prototype.getModuleLoader = function (classId) {
            var lazyModuleConfigItem = this.lazyModuleConfig.find(function (config) { return config.module === classId; });
            return lazyModuleConfigItem && lazyModuleConfigItem.loadChildren;
        };
        return ItemRegistryService;
    }());
    ItemRegistryService.decorators = [
        { type: i0.Injectable }
    ];
    ItemRegistryService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [CONFIG_COMPONENT_CLASS_MAP,] }, { type: i0.Optional }] },
        { type: Array, decorators: [{ type: i0.Inject, args: [LAZY_MAP,] }, { type: i0.Optional }] }
    ]; };
    function isLazyModuleConfig(config) {
        return !!config.module;
    }

    var RouteComponent = /** @class */ (function () {
        function RouteComponent(route, tree, itemRegistry) {
            var _this = this;
            this.route = route;
            this.tree = tree;
            this.itemRegistry = itemRegistry;
            this.item = this.route.data.pipe(operators.pluck('renderChild'), operators.switchMap(function (renderChild) { return _this.tree.find(function (item) { return item.name === renderChild; }); }), operators.filter(function (a) { return a !== undefined; }));
        }
        RouteComponent.isItemInRoute = function (itemName, route) {
            if (!route.data || !route.data.renderChild) {
                throw new Error("@backbase/foundation Invalid route for RouteComponent. Missing data renderChild: " + route);
            }
            return route.data.renderChild === itemName;
        };
        /**
         * @internal
         */
        RouteComponent.prototype.isModule = function (model) {
            return !!this.itemRegistry.getModuleLoader(model.ɵclassId);
        };
        return RouteComponent;
    }());
    RouteComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'bb-route',
                    template: "\n    <ng-container *ngIf=\"item | async as item\">\n      <router-outlet *ngIf=\"isModule(item.value); else renderModel\"></router-outlet>\n      <ng-template #renderModel><bb-chrome [item]=\"item\"></bb-chrome></ng-template>\n    </ng-container>\n  "
                },] }
    ];
    RouteComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute },
        { type: ItemModelTree },
        { type: ItemRegistryService }
    ]; };

    var DefaultContainerStrategy = /** @class */ (function () {
        function DefaultContainerStrategy() {
        }
        DefaultContainerStrategy.prototype.itemRoutePath = function (route, index) {
            if (route) {
                return route;
            }
            return (index + 1).toString();
        };
        // routes is guaranteed to have 1 item, but I don't know how to type that
        DefaultContainerStrategy.prototype.defaultRoute = function (routes) {
            var defaultRoute = routes[0];
            // Default behaviour, redirect to the first tab (primary route).
            return {
                path: '',
                redirectTo: defaultRoute.path,
                pathMatch: 'full',
            };
        };
        DefaultContainerStrategy.prototype.itemRoute = function (child, childrenRoutes, index) {
            return {
                path: this.itemRoutePath(child.route, index),
                component: RouteComponent,
                canActivate: child.canActivate,
                data: {
                    renderChild: child.name,
                    custom: child.routeData,
                },
                children: childrenRoutes,
            };
        };
        DefaultContainerStrategy.prototype.findChildrenRoutes = function (childrenItemRoutes, item) {
            var itemRoutes = childrenItemRoutes.find(function (child) { return child.item === item.name; });
            return itemRoutes ? itemRoutes.routes : [];
        };
        DefaultContainerStrategy.prototype.childrenRoutes = function (children, childrenItemRoutes) {
            var _this = this;
            return children.map(function (child, index) { return _this.itemRoute(child, _this.findChildrenRoutes(childrenItemRoutes, child), index); });
        };
        DefaultContainerStrategy.prototype.getRoutes = function (item, children, childrenRoutes) {
            var childRoutes = this.childrenRoutes(children, childrenRoutes);
            var defaultRoutes = childRoutes.length && item.hasDefault ? [this.defaultRoute(childRoutes)] : [];
            var routes = __spreadArray(__spreadArray([], __read(childRoutes)), __read(defaultRoutes));
            if (item.canActivateChild.length) {
                return [
                    {
                        path: '',
                        canActivateChild: item.canActivateChild,
                        children: routes,
                    },
                ];
            }
            else {
                return routes;
            }
        };
        return DefaultContainerStrategy;
    }());

    var StaticRoutesStrategy = /** @class */ (function () {
        function StaticRoutesStrategy(routes) {
            if (routes === void 0) { routes = []; }
            this.routes = routes;
        }
        StaticRoutesStrategy.prototype.getRoutes = function () {
            return this.routes;
        };
        return StaticRoutesStrategy;
    }());

    /**
     * Symbol used to keep internal Backbase routing information
     * in an Angular component class
     */
    var routingStrategyField = Symbol('ΩRoutingStrategy');
    /**
     * RoutingStrategyToken enum with routing strategy tokens
     */
    var RoutingStrategyToken;
    (function (RoutingStrategyToken) {
        RoutingStrategyToken["STATIC"] = "StaticRoutesStrategy";
        RoutingStrategyToken["CONTAINERS"] = "DefaultContainerStrategy";
    })(RoutingStrategyToken || (RoutingStrategyToken = {}));
    /**
     * RoutableContainer decorator is used to mark an item as
     * routable. It makes the routing config service to use default
     * strategy for containers.
     */
    function RoutableContainer() {
        return function (constructor) {
            constructor[routingStrategyField] = {
                token: RoutingStrategyToken.CONTAINERS,
            };
            return constructor;
        };
    }
    /**
     * RoutableWidget decorator is used to define widget's internal routes.
     *
     * @usageNotes
     *
     * ### Example
     * ```
     * @Component({
     *   selector: 'bb-todo-widget',
     *   template: `
     *     <bb-router-outlet></bb-router-outlet>
     *   `,
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   providers: [RouterService, TodoNavigationService],
     * })
     * @RoutableWidget({
     *   routes: [
     *     { path: '', component: TodoListContainerComponent },
     *     { path: ':id', component: TodoDetailContainerComponent },
     *     { path: 'edit/:id', component: TodoFormContainerComponent },
     *   ],
     * })
     * export class TodoWidgetComponent {}
     * ```
     *
     * @param config Configuration object of the RoutableWidget decorator
     */
    function RoutableWidget(config) {
        return function (constructor) {
            constructor[routingStrategyField] = {
                token: RoutingStrategyToken.STATIC,
                routes: config.routes,
            };
            return constructor;
        };
    }
    var createRouteComponentStrategy = function (component) {
        var isItemInRoute = component === RouteComponent ? component.isItemInRoute : function () { return false; };
        return {
            isItemInRoute: isItemInRoute,
        };
    };
    var createRoutingStrategy = function (componentClass) {
        var strategy = componentClass[routingStrategyField];
        if (strategy === undefined) {
            return undefined;
        }
        switch (strategy.token) {
            case RoutingStrategyToken.CONTAINERS:
                return new DefaultContainerStrategy();
            case RoutingStrategyToken.STATIC:
                return new StaticRoutesStrategy(strategy.routes);
            default:
                return undefined;
        }
    };
    var isRoutableItem = function (componentClass) {
        var strategy = componentClass[routingStrategyField];
        return (!!strategy &&
            strategy.token &&
            (strategy.token === RoutingStrategyToken.CONTAINERS || strategy.token === RoutingStrategyToken.STATIC));
    };
    /**
     * CopyRoutes decorator is used to re-use the internal routing configuration from an existing widget.
     *
     * @usageNotes
     *
     * ### Example
     * ```
     * @Component({
     *   selector: 'my-todo-widget',
     *   template: `
     *     <h1>My Custom Todo Widget</h1>
     *     <bb-router-outlet></bb-router-outlet>
     *   `,
     * })
     * @CopyRoutes(TodoWidgetComponent)
     * export class MyTodoWidgetComponent {}
     * ```
     *
     * @param from The Widget Component class from which to copy the routing configuration
     */
    // Note: `from` should be `{ [routingStrategyField]: RoutingStrategyDefinition }` but the type checker
    // can't resolve properties dynamically added by decorators.
    function CopyRoutes(componentClass, customize) {
        if (customize === void 0) { customize = function (routes) { return routes; }; }
        return function (constructor) {
            var definition = componentClass[routingStrategyField];
            if (definition === undefined || definition.token !== RoutingStrategyToken.STATIC) {
                return constructor;
            }
            constructor[routingStrategyField] = {
                token: RoutingStrategyToken.STATIC,
                routes: customize(definition.routes),
            };
            return constructor;
        };
    }

    /**
     * Special type to flag an outlet as having a collision. This
     * enables us to create the outlet tree, and name the outlet, but
     * also flag the item as having a collision with another item.
     */
    var OutletCollision = /** @class */ (function () {
        function OutletCollision(outletName, itemName, collisionWith) {
            this.outletName = outletName;
            this.itemName = itemName;
            this.collisionWith = collisionWith;
        }
        return OutletCollision;
    }());
    var isValidOutlet = function (outlet) { return outlet !== undefined && outlet !== ''; };
    var ɵ0$e = isValidOutlet;
    var outletCollision = function (outletItem, collisionWith) {
        return {
            item: outletItem.item,
            outlet: new OutletCollision("\u0275" + outletItem.item, outletItem.item, collisionWith.item),
        };
    };
    var ɵ1$a = outletCollision;
    var flattenOutletTreeNode = function (node) {
        var flattenedChildren = flatMap(flattenOutletTreeNode, node.children);
        if (node.value.outlet !== undefined) {
            // not routable
            // Don't flatten this node (just it's children)
            return [new Tree({ item: node.value.name, outlet: node.value.outlet }, flattenedChildren)];
        }
        else {
            // Flatten this node
            return flattenedChildren.reduce(function (acc, nextChild) {
                var collisionWith = acc.find(function (child) { return child.value.outlet === nextChild.value.outlet; });
                var newChild = collisionWith
                    ? new Tree(outletCollision(nextChild.value, collisionWith.value), nextChild.children)
                    : nextChild;
                return __spreadArray(__spreadArray([], __read(acc)), [newChild]);
            }, []);
        }
    };
    var ɵ2$6 = flattenOutletTreeNode;
    /**
     * Special case for flattening the root node. If it can't be flattened into a tree with a single
     * root node, we create a special root node, so there is only ever a single tree.
     */
    var flattenOutletTree = function (outletTree) {
        return {
            rootItem: outletTree.value.name,
            children: flattenOutletTreeNode(outletTree),
        };
    };
    var ɵ3$6 = flattenOutletTree;
    var mapItemToOutlet = function (item) {
        if (!item.routingStrategy) {
            return {
                name: item.name,
                outlet: undefined,
            };
        }
        return {
            name: item.name,
            outlet: isValidOutlet(item.outlet) ? item.outlet : router.PRIMARY_OUTLET,
        };
    };
    var ɵ4$3 = mapItemToOutlet;
    var outletTreeToMap = function (outletTree) {
        var entries = flatMap(function (tree) { return tree.flatten(); }, outletTree.children) // flatten and merge the root outlet trees
            .map(function (node) { return [node.value.item, node.value.outlet]; });
        return new Map(entries);
    };
    var ɵ5$1 = outletTreeToMap;
    var outletMap = function (itemTree) {
        return outletTreeToMap(flattenOutletTree(itemTree.map(mapItemToOutlet)));
    };

    var CONFIG_ROUTE_GUARDS = new i0.InjectionToken('@backbase/foundation Route Guards');
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var RouteGuardsRegistryService = /** @class */ (function () {
        function RouteGuardsRegistryService(configs) {
            var _this = this;
            this.canActivate = new Map();
            this.canActivateChild = new Map();
            configs.forEach(function (handlerMap) {
                Object.entries(handlerMap.canActivate || {})
                    .filter(function (entry) { return 'canActivate' in entry[1].prototype; })
                    .forEach(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], guard = _b[1];
                    _this.canActivate.set(key, guard);
                });
                Object.entries(handlerMap.canActivateChild || {}).forEach(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], guard = _b[1];
                    _this.canActivateChild.set(key, guard);
                });
            });
        }
        return RouteGuardsRegistryService;
    }());
    RouteGuardsRegistryService.decorators = [
        { type: i0.Injectable }
    ];
    RouteGuardsRegistryService.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: i0.Inject, args: [CONFIG_ROUTE_GUARDS,] }] }
    ]; };

    var TemplateRegistry = /** @class */ (function () {
        function TemplateRegistry() {
            this.registry = new Map();
        }
        TemplateRegistry.prototype.set = function (id, entry) {
            var entry$ = this.registry.get(id) || this.initEntry(id);
            entry$.next(entry);
        };
        TemplateRegistry.prototype.get = function (id) {
            var entry$ = this.registry.get(id) || this.initEntry(id);
            return entry$.pipe(operators.first());
        };
        TemplateRegistry.prototype.initEntry = function (id) {
            var entry = new rxjs.ReplaySubject();
            this.registry.set(id, entry);
            return entry;
        };
        return TemplateRegistry;
    }());
    TemplateRegistry.decorators = [
        { type: i0.Injectable }
    ];

    function journeyItemModelFactory(route) {
        return route.snapshot.data.item;
    }
    function storeNameFactory(route) {
        return route.snapshot.data.item.name;
    }
    var JourneyComponent = /** @class */ (function () {
        function JourneyComponent() {
        }
        return JourneyComponent;
    }());
    JourneyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'bb-journey',
                    template: " <router-outlet></router-outlet> ",
                    providers: [
                        {
                            provide: ItemModel,
                            useFactory: journeyItemModelFactory,
                            deps: [router.ActivatedRoute],
                        },
                        TemplateRegistry,
                        {
                            provide: store["ɵSTORE_BRANCH"],
                            useFactory: storeNameFactory,
                            deps: [router.ActivatedRoute],
                        },
                        {
                            provide: store["ɵSTORE_DISPATCH_CHANNEL"],
                            useFactory: storeNameFactory,
                            deps: [router.ActivatedRoute],
                        },
                        {
                            provide: store.StoreFactory,
                            useClass: store.StoreFactory,
                            deps: [store["ɵStoreBroker"], store["ɵSTORE_BRANCH"], store["ɵSTORE_DISPATCH_CHANNEL"], future.FeaturesService],
                        },
                    ]
                },] }
    ];

    var CUSTOM_DATA_PREFIX = 'route.data.custom.';
    var RouteModelProperty;
    (function (RouteModelProperty) {
        /**
         * Each child of a RoutableContainer may have a property for "route",
         * else the route will be the index of the child plus 1.
         */
        RouteModelProperty["ROUTE"] = "route";
        /**
         * RoutableContainers and RoutableWidget can have an optional "outletName"
         * property to dynamically set the outlet name for the bb-router-outlet.
         */
        RouteModelProperty["OUTLET"] = "outletName";
        /**
         * `CanActivate` route guards can be added to generated child routes by including a
         * `route.canActivate` property in the child's model. These guards must be registered with the
         * `RouteGuardsRegistryService` via the `guards` option passed to `BackbaseCore.withConfig`.
         */
        RouteModelProperty["CAN_ACTIVATE"] = "route.canActivate";
        /**
         * `CanActivateChild` route guards can be added to generated routes by including a
         * `route.canActivateChild` property in the item's model. These guards must be registered with the
         * `RouteGuardsRegistryService` via the `guards` option passed to `BackbaseCore.withConfig`.
         */
        RouteModelProperty["CAN_ACTIVATE_CHILD"] = "route.canActivateChild";
        /**
         * RoutableContainer's can have a "disableDefault" property which will disable the
         * default behaviour of containers where an empty path route will be created to
         * redirect to the first child's route.
         */
        RouteModelProperty["DISABLE_DEFAULT"] = "disableDefault";
    })(RouteModelProperty || (RouteModelProperty = {}));
    var getRoutingStrategy = function (itemRegistry, item) {
        var loadModuleFunction = itemRegistry.getModuleLoader(item.ɵclassId);
        if (loadModuleFunction) {
            return rxjs.of(createJourneyStrategy(item, loadModuleFunction));
        }
        var component = itemRegistry.getComponentValue(item.ɵclassId);
        if (component) {
            return rxjs.of(createRoutingStrategy(component));
        }
        return rxjs.from(itemRegistry.getComponent(item.ɵclassId)).pipe(operators.map(createRoutingStrategy), operators.startWith(undefined));
    };
    var ɵ0$d = getRoutingStrategy;
    var getCanActivateRouteGuards = function (guardRegistry, guards) { return guards
        .map(function (guardName) { return guardRegistry.canActivate.get(guardName); })
        .filter(function (guard) { return guard !== undefined; }); };
    var ɵ1$9 = getCanActivateRouteGuards;
    var getCanActivateChildRouteGuards = function (guardRegistry, guards) { return guards
        .map(function (guardName) { return guardRegistry.canActivateChild.get(guardName); })
        .filter(function (guard) { return guard !== undefined; }); };
    var ɵ2$5 = getCanActivateChildRouteGuards;
    var toRoutableItem = function (item, routeGuards, routeProperties, routingStrategy) {
        return {
            name: item.name,
            routingStrategy: routingStrategy,
            route: routeProperties[RouteModelProperty.ROUTE],
            outlet: routeProperties[RouteModelProperty.OUTLET],
            canActivate: getCanActivateRouteGuards(routeGuards, (routeProperties[RouteModelProperty.CAN_ACTIVATE] || [])),
            canActivateChild: getCanActivateChildRouteGuards(routeGuards, (routeProperties[RouteModelProperty.CAN_ACTIVATE_CHILD] || [])),
            hasDefault: routingStrategy ? true !== routeProperties[RouteModelProperty.DISABLE_DEFAULT] : undefined,
            routeData: propertiesByPrefix(CUSTOM_DATA_PREFIX, routeProperties),
        };
    };
    var ɵ3$5 = toRoutableItem;
    // @fixme: don't re-emit unless properties we care about change
    var routableItem = function (itemRegistry, routeGuards) { return function (item) { return rxjs.combineLatest([item.properties, getRoutingStrategy(itemRegistry, item)]).pipe(operators.map(function (_a) {
        var _b = __read(_a, 2), routeProperties = _b[0], routingStrategy = _b[1];
        return toRoutableItem(item, routeGuards, routeProperties, routingStrategy);
    })); }; };
    var ɵ4$2 = routableItem;
    function createJourneyStrategy(item, loadChildren) {
        return {
            getRoutes: function () {
                return [
                    {
                        path: '',
                        component: JourneyComponent,
                        data: { item: item },
                        loadChildren: loadChildren,
                    },
                ];
            },
        };
    }
    var routableItemTree = function (itemRegistry, routeGuards, modelTree) { return combineTree(modelTree.map(routableItem(itemRegistry, routeGuards))); };

    var OutletCollisionComponent = /** @class */ (function () {
        function OutletCollisionComponent(route) {
            this.route = route;
            this.me = this.route.data.pipe(operators.pluck('item'));
            this.collisionWith = this.route.data.pipe(operators.pluck('collisionWith'));
        }
        return OutletCollisionComponent;
    }());
    OutletCollisionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'bb-outlet-collision',
                    template: "\n    <p>You have dropped a routable item next to another routable item.</p>\n    <p>\n      You need to give this item ({{ me | async }}) a unique \"outletName\" from\n      <strong>{{ collisionWith | async }}</strong> to ensure the routes don't conflict.\n    </p>\n  "
                },] }
    ];
    OutletCollisionComponent.ctorParameters = function () { return [
        { type: router.ActivatedRoute }
    ]; };

    var isRoutable = function (itemRoutes) { return itemRoutes.outletName !== undefined; };
    var isAbsolute = function (routePath) { return routePath.startsWith('/'); };
    var ɵ0$c = isAbsolute;
    var isMatchingRedirect = function (redirectTo) { return function (route) { return route.path !== undefined && route.path === redirectTo; }; };
    var ɵ1$8 = isMatchingRedirect;
    /**
     * Applies an outlet name to a route
     * @param outlet
     * @param route
     * @param oldRoutes
     */
    var namedOutletRoute = function (outlet, route, oldRoutes) {
        // Add outlet name
        var newRoute = route.component ? Object.assign(Object.assign({}, route), { outlet: outlet }) : route;
        // Convert redirects to duplicated routes (can't redirect to a named outlet easily).
        if (newRoute.redirectTo !== undefined && !isAbsolute(newRoute.redirectTo)) {
            // If it's not absolute, we try and make it a default route instead (no path)
            var routeTo = oldRoutes.find(isMatchingRedirect(newRoute.redirectTo));
            if (!routeTo) {
                // Coudn't find a route that they're redirecting too, so we remove the route, as it won't work.
                throw new Error("Couldn't redirect to " + newRoute.redirectTo);
            }
            newRoute = Object.assign(Object.assign({}, routeTo), {
                outlet: outlet,
                path: ''
            });
        }
        return newRoute;
    };
    var ɵ2$4 = namedOutletRoute;
    var applyOutletName = function (item, outlet, routes) {
        if (outlet === router.PRIMARY_OUTLET) {
            return routes;
        }
        else if (outlet instanceof OutletCollision) {
            return [
                {
                    path: '',
                    component: OutletCollisionComponent,
                    outlet: outlet.outletName,
                    data: {
                        item: item.name,
                        collisionWith: outlet.collisionWith,
                    },
                },
            ];
        }
        return routes.map(function (route, _, oldRoutes) { return namedOutletRoute("" + outlet, route, oldRoutes); });
    };
    var ɵ3$4 = applyOutletName;
    var mapItemToRoutes = function (outlets) { return function (item, children, childRoutes) {
        var outletName = outlets.get(item.name);
        var routes = item.routingStrategy ? item.routingStrategy.getRoutes(item, children, childRoutes) : undefined;
        if (outletName === undefined || routes === undefined) {
            // Flatten non-routable items
            return {
                item: item.name,
                outletName: undefined,
                routes: flatMap(function (childRoute) { return childRoute.routes; }, childRoutes),
            };
        }
        return {
            item: item.name,
            routes: applyOutletName(item, outletName, routes),
            outletName: outletName,
        };
    }; };
    var ɵ4$1 = mapItemToRoutes;
    /**
     * Create a tree of the components with routes. This is a direct map of the
     * component tree. Each node in the tree holds all routes for the nodes beneath
     * it. So the root node in the returned tree will hold all the routes for the
     * entire component tree.
     */
    var routingTree = function (tree, outlets) { return tree.map(mapItemToRoutes(outlets)); };

    var AbstractRouterConfigService = /** @class */ (function () {
        function AbstractRouterConfigService() {
        }
        return AbstractRouterConfigService;
    }());

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var RouterConfigService = /** @class */ (function (_super) {
        __extends(RouterConfigService, _super);
        function RouterConfigService(itemRegistry, routeGuardsRegistry, rootContainer) {
            var _this = _super.call(this) || this;
            _this.itemRegistry = itemRegistry;
            _this.routeGuardsRegistry = routeGuardsRegistry;
            _this.rootContainer = rootContainer;
            _this.routableItemTree = _this.rootContainer.model.pipe(operators.switchMap(function (model) { return model.toTree(); }), operators.switchMap(function (model) { return routableItemTree(_this.itemRegistry, _this.routeGuardsRegistry, model); }), operators.shareReplay(1));
            _this.outlets = _this.routableItemTree.pipe(operators.map(outletMap), operators.shareReplay(1));
            /**
             * Convert the component tree to a routing tree
             *
             * @internal
             */
            _this.ɵrouteTree = _this.outlets.pipe(operators.withLatestFrom(_this.routableItemTree), operators.map(function (_a) {
                var _b = __read(_a, 2), outlets = _b[0], tree = _b[1];
                return routingTree(tree, outlets);
            }), operators.shareReplay(1));
            /**
             * The dynamically generated Angular routes for the SPA, based on the model of the app.
             */
            _this.routes = _this.ɵrouteTree.pipe(operators.map(function (routeTrees) { return routeTrees.value.routes; }), operators.shareReplay(1));
            return _this;
        }
        /**
         * Get the router-outlet name for the given item in the model tree.
         *
         * @internal
         */
        RouterConfigService.prototype.ɵitemOutletName = function (item) {
            return this.outlets.pipe(operators.map(function (outlets) { return outlets.get(item.name); }), operators.map(function (outlet) { return (outlet instanceof OutletCollision ? outlet.outletName : outlet); }), operators.distinctUntilChanged());
        };
        return RouterConfigService;
    }(AbstractRouterConfigService));
    RouterConfigService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function RouterConfigService_Factory() { return new RouterConfigService(i0__namespace.ɵɵinject(ItemRegistryService), i0__namespace.ɵɵinject(RouteGuardsRegistryService), i0__namespace.ɵɵinject(ӨRootContainerService)); }, token: RouterConfigService, providedIn: "root" });
    RouterConfigService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    RouterConfigService.ctorParameters = function () { return [
        { type: ItemRegistryService },
        { type: RouteGuardsRegistryService },
        { type: ӨRootContainerService }
    ]; };

    /**
     * Creates a new LinkedList with the results of calling a provided function on
     * every element in the provided LinkedList.
     *
     * @param list
     * @param fn
     */
    var mapLinkedList = function (list, fn) { return ({
        value: fn(list.value),
        next: list.next === undefined ? undefined : mapLinkedList(list.next, fn),
    }); };
    /**
     * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
     * to TAIL, where the new HEAD is determined by the first "true" result of calling the predicate
     * on each node in the list.
     *
     * The search is done by iterating over each element in the linked list
     * in the order from HEAD to TAIL.
     *
     * If not found, returns undefined.
     *
     * @param list
     * @param predicate
     */
    var linkedListFind = function (list, predicate) {
        if (predicate(list.value)) {
            return list;
        }
        return list.next ? linkedListFind(list.next, predicate) : undefined;
    };
    /**
     * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
     * to TAIL, where the new HEAD is determined by the first "true" result of calling the predicate
     * on each node in the list.
     *
     * The search is done by iterating over each element in the linked list
     * in the order from TAIL to HEAD.
     *
     * If not found, returns undefined.
     *
     * @param list
     * @param predicate
     */
    var linkedListFindLast = function (list, predicate) {
        var foundChild = list.next ? linkedListFindLast(list.next, predicate) : undefined;
        if (foundChild) {
            return foundChild;
        }
        return predicate(list.value) ? list : undefined;
    };
    /**
     * Returns a shallow copy of a portion of a linked list into a new linked list,
     * selected from HEAD (inclusive) to the first element to return true (exclusive).
     * So the new TAIL will be the parent of the first element to return true.
     *
     * The search is done by iterating over each element in the linked list in the
     * order from HEAD to TAIL.
     *
     * If not found, returns undefined.
     *
     * @param list
     * @param predicate
     */
    var linkedListSliceTail = function (list, predicate) {
        if (predicate(list.value)) {
            return undefined;
        }
        return {
            value: list.value,
            next: list.next ? linkedListSliceTail(list.next, predicate) : undefined,
        };
    };
    var ɵ0$b = linkedListSliceTail;
    /**
     * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
     * to TAIL, where the new HEAD is determined by the first "true" result of calling the "begin"
     * predicate and the new TAIL is determined by the first "true" result of calling the "end"
     * predicate.
     *
     * If no "begin" predicate is sent, the HEAD will be the current HEAD.
     *
     * If no "end" predicate is sent, the TAIL will be the current TAIL.
     *
     * The search is done by iterating over each element in the linked list
     * in the order from HEAD to TAIL until both predicates return true.
     *
     * If not both found, returns undefined.
     *
     * @param list
     * @param predicate
     */
    var linkedListSlice = function (list, begin, end) {
        var head = begin ? linkedListFind(list, begin) : list;
        if (!head) {
            return undefined;
        }
        return end ? linkedListSliceTail(head, end) : head;
    };
    var linkedListToArray = function (list) { return __spreadArray([
        list.value
    ], __read((list.next ? linkedListToArray(list.next) : []))); };
    var linkedListFromArray = function (arr) { return arr.reduceRight(function (next, value) { return ({ value: value, next: next }); }, undefined); };
    var linkedListLast = function (list) { return (list.next ? linkedListLast(list.next) : list); };

    var hasNamedOutlet = function (node) { return node.outlet !== router.PRIMARY_OUTLET; };
    var ɵ0$a = hasNamedOutlet;
    var routeSegmentToUrlSegment = function (node) { return new router.UrlSegment(node.path, node.params || {}); };
    var ɵ1$7 = routeSegmentToUrlSegment;
    var RouterNavigationService = /** @class */ (function () {
        function RouterNavigationService(router) {
            this.router = router;
        }
        /**
         * Set (merge) the params on a given `ActivatedRoute`, preserving the active children's states.
         *
         * This allows updating the params in an arbitrary route in the active route
         * tree without needing to know the state of every child route.
         *
         * @param params The route params that should be set on the given route
         * @param from The route to set the params on
         * @returns The new URLTree
         */
        RouterNavigationService.prototype.setParams = function (params, from) {
            var snapshot = from instanceof router.ActivatedRoute ? from.snapshot : from;
            var navigationRoute = linkedListFromArray(flatMap(function (route) { return route.url.map(function (url) { return ({
                path: url.path,
                outlet: route.outlet,
                params: url.parameters,
            }); }); }, snapshot.pathFromRoot));
            if (!navigationRoute) {
                throw new Error('No route to set params on');
            }
            var last = linkedListLast(navigationRoute);
            last.value.params = last.value.params ? Object.assign(Object.assign({}, last.value.params), params) : params;
            return this.createUrlTree(navigationRoute);
        };
        RouterNavigationService.prototype.createUrlTree = function (routeBranch) {
            var tree = this.router.parseUrl('/'); // @todo: is there no better way to make a tree?
            var rootRouteSegment = routeBranch.value;
            tree.root.children[rootRouteSegment.outlet] = this.urlSegmentGroupForRoute(routeBranch);
            return tree;
        };
        /*
         * A segment group is a node in the UrlTree. The node itself is an array
         * of segments, which are all considered on the "primary" outlet.
         * The children of this node are the paths on the "non-primary" outlets.
         * There will only be a single "child" for the NavigationRoute (as it
         * represents a single branch through a UrlTree).
         */
        RouterNavigationService.prototype.urlSegmentGroupForRoute = function (routeBranch) {
            var _a;
            // Find all paths up to the first non-primary outlet - these will be the segments.
            var routeSegments = {
                value: routeBranch.value,
                next: routeBranch.next ? linkedListSlice(routeBranch.next, undefined, hasNamedOutlet) : undefined,
            };
            var segments = linkedListToArray(routeSegments).map(routeSegmentToUrlSegment);
            // Find the first non-primary outlet - this will be the child.
            var nextOutlet = routeBranch.next && linkedListFind(routeBranch.next, hasNamedOutlet);
            var segmentGroupChildren = nextOutlet
                ? (_a = {}, _a[nextOutlet.value.outlet] = this.urlSegmentGroupForRoute(nextOutlet), _a) : {};
            return new router.UrlSegmentGroup(segments, segmentGroupChildren);
        };
        /**
         * Merge a new `UrlTree` into the current active `UrlTree`.
         *
         * @param newTree
         */
        RouterNavigationService.prototype.navigate = function (newTree) {
            var activeTree = this.router.parseUrl(this.router.url);
            var mergedTree = this.router.parseUrl('/');
            mergedTree.root.children = this.mergeUrlSegmentGroupChildren(activeTree.root.children, newTree.root.children);
            return this.router.navigateByUrl(mergedTree);
        };
        /**
         * Merge new children of a `UrlSegmentGroup` children into the children of the
         * current active `UrlSegmentGroup`.
         *
         * @param activeChildren
         * @param newChildren
         */
        RouterNavigationService.prototype.mergeUrlSegmentGroupChildren = function (activeChildren, newChildren) {
            var _this = this;
            var mergedChildren = Object.keys(newChildren).reduce(function (acc, outletName) {
                var _a;
                if (!activeChildren[outletName]) {
                    return acc;
                }
                return Object.assign(Object.assign({}, acc), (_a = {}, _a[outletName] = _this.mergeUrlTreeSegmentGroup(activeChildren[outletName], newChildren[outletName]), _a));
            }, newChildren);
            /**
             * Sibling routes can be preserved, or not.
             *
             * Because the current active route is a tree (for example, when you have multiple named
             * outlets and they are active) when you navigate to a new route it is possible to preserve
             * active routes that are siblings to the route you're navigating to.
             *
             * For example, when navigating from URL `/a/(b//x:c)` to `/a/c`, should the `x:c` or `b`
             * be preserved. The URL can be visualised as a tree (where a double slash `//` shows siblings
             * in the tree):
             *
             * ```
             *  -a
             *   `- b
             *   `- x:c
             * ```
             *
             * When set to true, all sibling will be preserved. For example, when navigating to `/a/d`
             * the `x:c` branch will be preserved and the new URL will be `/a/(d//x:c)`. Similarly,
             * when navigating to `/a/(x:e)`, the `b` branch will be preserved and the new URL will
             * be `/a/(b//x:e)`.
             *
             * Merging is disabled by default, but can be enabled with a feature flag.
             */
            return Object.assign(Object.assign({}, activeChildren), mergedChildren);
        };
        /**
         * Merge a new `UrlSegmentGroup` into the current active `UrlSegmentGroup`.
         *
         * @param activeSegmentGroup
         * @param newSegmentGroup
         */
        RouterNavigationService.prototype.mergeUrlTreeSegmentGroup = function (activeSegmentGroup, newSegmentGroup) {
            return new router.UrlSegmentGroup(this.mergeUrlSegments(activeSegmentGroup.segments, newSegmentGroup.segments), this.mergeUrlSegmentGroupChildren(activeSegmentGroup.children, newSegmentGroup.children));
        };
        /**
         * Merge an array of new `UrlSegment` into the current active `UrlSegment` array.
         *
         * @param activeSegments
         * @param newSegments
         */
        RouterNavigationService.prototype.mergeUrlSegments = function (activeSegments, newSegments) {
            var _this = this;
            // Determine if any params are being set.
            var preserveActiveTailSegments = !!newSegments.find(function (segment) { return Object.keys(segment.parameters).length > 0; });
            // When the new segments change path from the active segment, then they
            // should no longer be preserved, so they get set to undefined.
            var removeActiveSegments = function () {
                var matches = true;
                return function (_a) {
                    var _b = __read(_a, 2), activeSegment = _b[0], newSegment = _b[1];
                    if (matches && activeSegment && newSegment) {
                        matches = activeSegment.path === newSegment.path;
                    }
                    return [matches ? activeSegment : undefined, newSegment];
                };
            };
            // pair the segments into a single array
            return pairs(activeSegments, newSegments)
                .map(removeActiveSegments())
                .map(function (_a) {
                var _b = __read(_a, 2), activeSegment = _b[0], newSegment = _b[1];
                return _this.mergeUrlSegment(activeSegment, newSegment, preserveActiveTailSegments);
            })
                .filter(function (a) { return a !== undefined; });
        };
        /**
         * Merge a new `UrlSegment` into the current active `UrlSegment`.
         *
         * If there is both an active and new segment it is assumed that the path
         * is the same already.
         *
         * @param activeSegment
         * @param newSegment
         * @param isSettingParams
         */
        RouterNavigationService.prototype.mergeUrlSegment = function (activeSegment, newSegment, preserveActiveTailSegments) {
            /**
             * There are 3 different strategies for how to preserve any "tail" segments in
             * the route: 'never' | 'on-param-set' | 'always'.
             *
             * This is only relevant when any route branch you're navigating to is a subset
             * of a current active route. For example, when navigating from URL `/a/b` to
             * `/a`, should `b` be preserved?
             *
             * When set to 'never' the children will be discarded, and the new URL will simply
             * be `/a`.
             *
             * When set to 'always' the children will always be preserved (this means it would
             * be impossible to navigate to a parent route).
             *
             * When set to 'on-param-set' the children will only be preserved if params are being
             * set on the route. For example, when navigating from `/a/b` to
             * `/a;data=foo` then the new URL will be `/a:data=foo/b`.
             *
             * This is implemented using the 'never' OR 'on-param-set' strategy depending on the
             * `preserveActiveTailSegments` flag.
             */
            if (activeSegment && !newSegment && preserveActiveTailSegments) {
                return new router.UrlSegment(activeSegment.path, activeSegment.parameters);
            }
            else if (newSegment) {
                var activeSegmentParams = (activeSegment && activeSegment.parameters) || {};
                return new router.UrlSegment(newSegment.path, this.mergeUrlSegmentParams(activeSegmentParams, newSegment.parameters));
            }
            return undefined;
        };
        RouterNavigationService.prototype.mergeUrlSegmentParams = function (activeSegmentParams, newSegmentParams) {
            /**
             * There 3 different strategies for how to preserve any route-parameters in the
             * route: 'never' | 'overwrite' | 'merge'.
             *
             * For example, when navigating from URL `/a;data=foo/b` to `/a;x=y/c`, should the
             * 'data' param be preserved.
             *
             * When `never` the params will be discarded, and the new URL will simply be `/a;x=y/c`.
             *
             * When `merge`, then the params will be preserved, and the new URL will be
             * `/a;data=foo;x=y/c`.
             *
             * When 'overwrite', then the params will be only be preserved if there are no *other*
             * params being set on that segment. For example, when navigating instead to:
             * `/a/c;foo=bar`, the new URL will be `/a;data=foo/c;foo=bar`.
             *
             * This is implemented using the "overwrite" strategy.
             */
            return Object.keys(newSegmentParams).length === 0 ? activeSegmentParams : newSegmentParams;
        };
        return RouterNavigationService;
    }());
    RouterNavigationService.decorators = [
        { type: i0.Injectable }
    ];
    RouterNavigationService.ctorParameters = function () { return [
        { type: router.Router }
    ]; };

    /**
     * Extracts a tree branch from the component route tree up to the given item and
     * unwraps the value.
     *
     * It unwraps it so we don't end up with a `LinkedList<Tree>`, where each node
     * would have value`.value`.
     *
     * @param itemRouteTree
     * @param itemName
     */
    var itemRoutesBranch = function (findRoute, itemRouteTree) {
        var branch = treeBranch(itemRouteTree, findRoute);
        if (branch === undefined) {
            return undefined;
        }
        return mapLinkedList(branch, function (tree) { return tree.value; });
    };
    var ɵ0$9 = itemRoutesBranch;
    /**
     * Maps a LinkedList<Route> to a NavigationRoute, to ensure each route is a
     * part of a URL segment.
     */
    var mapToNavigationRoute = function (routeBranch) { return mapLinkedList(routeBranch, function (route) {
        if (route.path === undefined) {
            throw new Error("Can't find route to item as route has no path");
        }
        return {
            path: route.path,
            outlet: route.outlet || router.PRIMARY_OUTLET,
        };
    }); };
    var ɵ1$6 = mapToNavigationRoute;
    /**
     * @internal
     */
    var ӨItemNavigationService = /** @class */ (function () {
        function ӨItemNavigationService(routerConfig, navigationService) {
            this.routerConfig = routerConfig;
            this.navigationService = navigationService;
        }
        ӨItemNavigationService.prototype.navigateToItem = function (itemName, params) {
            return __awaiter(this, void 0, void 0, function () {
                var isItemByName;
                return __generator(this, function (_a) {
                    isItemByName = function (tree) { return tree.value.item === itemName; };
                    return [2 /*return*/, this.navigateToRoute(isItemByName, params)];
                });
            });
        };
        ӨItemNavigationService.prototype.isItemChild = function (navigateToParent, childIndex) {
            return function (tree, index, parent) {
                if (parent) {
                    var isChild = parent.value.item === navigateToParent;
                    var isNthChild = index === childIndex;
                    if (isChild && isNthChild) {
                        return true;
                    }
                    var isLastChild = index === parent.children.length - 1;
                    var isIndexOutOfRange = childIndex > parent.children.length - 1;
                    if (isChild && isLastChild && isIndexOutOfRange) {
                        return true;
                    }
                }
                var noChildren = tree.children.length === 0;
                var isParent = tree.value.item === navigateToParent;
                if (isParent && noChildren) {
                    return true;
                }
                return false;
            };
        };
        ӨItemNavigationService.prototype.navigateToChild = function (navigateToParent, childIndex, params) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.navigateToRoute(this.isItemChild(navigateToParent, childIndex), params)];
                });
            });
        };
        ӨItemNavigationService.prototype.navigateToRoute = function (findRoute, params) {
            return __awaiter(this, void 0, void 0, function () {
                var route, navigationRoute;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.routeToItem(findRoute)];
                        case 1:
                            route = _a.sent();
                            if (!route) {
                                // If there is no route, then this item should already be visible, as it means
                                // it's somewhere in the component tree above any routable item.
                                if (Object.keys(params).length) {
                                    // If trying to pass params, this can't work, so throw
                                    return [2 /*return*/, Promise.reject("Can't pass params to an item that isn't within a routable item")];
                                }
                                // Otherwise, there is no need to navigate, navigation has failed
                                return [2 /*return*/, Promise.resolve(false)];
                            }
                            navigationRoute = mapToNavigationRoute(route);
                            // Set the params on the last path in the route.
                            linkedListLast(navigationRoute).value.params = params;
                            return [2 /*return*/, this.navigationService.navigate(this.navigationService.createUrlTree(navigationRoute))];
                    }
                });
            });
        };
        /**
         * Search the component tree for a given item, and return the route to that item.
         *
         * @param itemName The CXP instance name of the item to route to.
         */
        ӨItemNavigationService.prototype.routeToItem = function (findRoute) {
            var _this = this;
            // Take a snapshot of the current state of the route tree.
            return this.routerConfig.ɵrouteTree
                .pipe(operators.take(1))
                .toPromise()
                .then(function (routeTree) { return _this.findItemRoute(findRoute, routeTree); });
        };
        /**
         * Breadth-first-search of routes, to find a route to a given item.
         *
         * 1. Find the branch to this item in the component route tree.
         * 2. Once found, find the closest routable parent.
         * 3. Take the child of the routable parent.
         * 4. For each route in the parent, use the "RouteComponentStrategy" to determine
         *      which route the route-child is rendered in.
         * 5. Once the route is found, flatten the routes of the componentRouteTree up to that route.
         *
         * @param itemName
         * @param routes
         */
        ӨItemNavigationService.prototype.findItemRoute = function (findRoute, componentRouteTree) {
            var e_1, _a;
            var _this = this;
            // 1. Find the branch containing the item.
            var branch = itemRoutesBranch(findRoute, componentRouteTree);
            if (!branch) {
                // item not in tree
                throw new Error("No matching route found in model.");
            }
            var foundNode = linkedListLast(branch);
            // 2. Find the closest *routable* parent (depth-first search, so it searches from TAIL to HEAD)
            var isParent = function (node) { return node.item !== foundNode.value.item; };
            var isRoutableParent = function (node) { return isRoutable(node) && isParent(node); };
            var routableNode = linkedListFindLast(branch, isRoutableParent);
            if (!routableNode) {
                return undefined;
            }
            // 3. Take the child of the routable node.
            var routableNodeChild = routableNode.next;
            // 4. Determine which route the child is rendered in.
            var foundItemInRoute = routableNodeChild &&
                routableNode.value.routes.find(function (route) { return _this.isItemInRoute(routableNodeChild.value.item, route); });
            try {
                // 5. Find the branch in the route tree up to that route (similar to step 1).
                // Except that "Routes" is really like an array of trees, so we loop through them.
                for (var _b = __values(componentRouteTree.value.routes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var rootRoute = _c.value;
                    var routeBranch = treeBranch(rootRoute, function (route) { return route === foundItemInRoute; });
                    if (routeBranch) {
                        return routeBranch;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return undefined;
        };
        ӨItemNavigationService.prototype.isItemInRoute = function (itemName, route) {
            if (!route.component) {
                return false;
            }
            return createRouteComponentStrategy(route.component).isItemInRoute(itemName, route);
        };
        return ӨItemNavigationService;
    }());
    ӨItemNavigationService.decorators = [
        { type: i0.Injectable }
    ];
    ӨItemNavigationService.ctorParameters = function () { return [
        { type: RouterConfigService },
        { type: RouterNavigationService }
    ]; };

    var createComponentPipe = function () { return ({
        source: function (ref, outputName) { return function () { return ref.instance[outputName]; }; },
        sink: function (ref, inputName) { return function (stdin) {
            stdin.subscribe(function (value) {
                ref.instance[inputName] = value;
                ref.changeDetectorRef.markForCheck();
            });
        }; },
    }); };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var CONFIG_PIPELINE_PROCESSORS = new i0.InjectionToken('@backbase/foundation Pipeline Handlers');
    /**
     * @deprecated Will be removed in v7.0.0
     * Helper service wrapping around CONFIG_PIPELINE_PROCESSORS
     */
    var PipelineRegistry = /** @class */ (function () {
        function PipelineRegistry(processorsNested) {
            var allProcessors = flatten(processorsNested);
            this.registeredHandlers = new Map(allProcessors.map(function (_a) {
                var name = _a.name, provider = _a.provider;
                return [name, provider];
            }));
        }
        PipelineRegistry.prototype.getProcessorProvider = function (name) {
            var provider = this.registeredHandlers.get(name);
            if (provider === undefined) {
                throw new Error("No provider to pipeline handler " + name);
            }
            return Object.assign({ deps: [] }, provider);
        };
        PipelineRegistry.prototype.getProcessorProviderToken = function (name) {
            return this.getProcessorProvider(name).provide;
        };
        return PipelineRegistry;
    }());
    PipelineRegistry.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function PipelineRegistry_Factory() { return new PipelineRegistry(i0__namespace.ɵɵinject(CONFIG_PIPELINE_PROCESSORS)); }, token: PipelineRegistry, providedIn: "root" });
    PipelineRegistry.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    PipelineRegistry.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: i0.Inject, args: [CONFIG_PIPELINE_PROCESSORS,] }] }
    ]; };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    function createPipelineProcessorConfig(name, provider) {
        return {
            name: name,
            provider: provider,
        };
    }

    var noop$2 = function () { };
    var ɵ0$8 = noop$2;
    // @see https://github.com/ReactiveX/rxjs/blob/5b82dcc601ed6eae955409ed0995cad61744f102/src/internal/util/pipe.ts
    function pipeFromArray(fns) {
        if (!fns) {
            return noop$2;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }

    var noop$1 = function () { };
    var ɵ0$7 = noop$1;
    var noopSink = function (stdin) {
        stdin.subscribe(noop$1);
    };
    var ɵ1$5 = noopSink;
    var isSourceDefinition = function (definition) { return definition && 'source' in definition; };
    var ɵ2$3 = isSourceDefinition;
    var isPipeDefinition = function (definition) { return definition && 'pipe' in definition; };
    var ɵ3$3 = isPipeDefinition;
    var isSinkDefinition = function (definition) { return definition && 'sink' in definition; };
    var ɵ4 = isSinkDefinition;
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var PipelineService = /** @class */ (function () {
        function PipelineService(broker, injector) {
            this.broker = broker;
            this.injector = injector;
        }
        PipelineService.prototype.createSource = function (name, args) {
            var instance = this.getInstance(name);
            if (!isSourceDefinition(instance)) {
                throw new Error(name + " is not a valid source");
            }
            return instance.source.apply(instance, __spreadArray([], __read(args)));
        };
        PipelineService.prototype.createPipe = function (name, args) {
            var instance = this.getInstance(name);
            if (!isPipeDefinition(instance)) {
                throw new Error(name + " is not a valid pipe");
            }
            return instance.pipe.apply(instance, __spreadArray([], __read(args)));
        };
        PipelineService.prototype.createSink = function (name, args) {
            var instance = this.getInstance(name);
            if (isSinkDefinition(instance)) {
                return instance.sink.apply(instance, __spreadArray([], __read(args)));
            }
            else if (isPipeDefinition(instance)) {
                return this.chainSink([instance.pipe.apply(instance, __spreadArray([], __read(args)))], noopSink);
            }
            throw new Error(name + " is not a valid sink");
        };
        PipelineService.prototype.getInstance = function (name) {
            var provide = this.broker.getProcessorProviderToken(name);
            return this.injector.get(provide);
        };
        PipelineService.prototype.chainSink = function (pipes, sink) {
            return function (stdin) {
                sink(stdin.pipe(pipeFromArray(pipes)));
            };
        };
        PipelineService.prototype.runPipeline = function (pipeline, gc) {
            return pipeline.sink(pipeline.source().pipe(operators.takeUntil(gc)));
        };
        return PipelineService;
    }());
    PipelineService.decorators = [
        { type: i0.Injectable }
    ];
    PipelineService.ctorParameters = function () { return [
        { type: PipelineRegistry },
        { type: i0.Injector }
    ]; };

    var parsePipe = function (pipeString) {
        var communicationDefinition = communicationProperty.serializerDeserializer.fromProperty(pipeString);
        if (communicationDefinition !== undefined) {
            return {
                processorName: communicationDefinition.transport,
                args: [communicationDefinition.param],
            };
        }
        else {
            var parts = pipeString.split(' ');
            var processorName = parts.shift();
            return {
                processorName: processorName,
                args: parts,
            };
        }
    };
    var ɵ0$6 = parsePipe;
    var LEGACY_HANDLERS = ['debug', 'navigation', 'navigation-url', 'route-param', 'model-property'];
    var isPipelineConfig = function (propertyValue) {
        var handlerName = propertyValue.split(':')[0];
        return !LEGACY_HANDLERS.includes(handlerName);
    };
    var ɵ1$4 = isPipelineConfig;
    var upgradeToPipelineConfig = function (propertyName, propertyValue) {
        var colonIndex = propertyValue.indexOf(':');
        var hasArg = colonIndex !== -1;
        var handlerName = hasArg ? propertyValue.substr(0, colonIndex) : propertyValue;
        var handlerArg = hasArg ? propertyValue.substr(colonIndex + 1) : '';
        var handlerToPipeMapping = {
            'navigation-url': function () { return "url " + handlerArg + " " + propertyName; },
            navigation: function () { return "navigation " + propertyName + " " + handlerArg; },
            'model-property': function () { return "model " + handlerArg; },
        };
        return (handlerToPipeMapping[handlerName] || (function () { return handlerName + " " + handlerArg; }))().trim();
    };
    var ɵ2$2 = upgradeToPipelineConfig;
    var normalizePropertyValue = function (propertyName, value) {
        if (!isPipelineConfig(value)) {
            return upgradeToPipelineConfig(propertyName, value);
        }
        return value;
    };
    var ɵ3$2 = normalizePropertyValue;
    var parseInputOutputPropertyValue = function (propertyName, propertyValue) {
        var normalPropertyValue = normalizePropertyValue(propertyName, propertyValue);
        var streamHandlers = normalPropertyValue.trim();
        return parsePipe(streamHandlers);
    };
    var inputOutputProperties = function (properties) { return Object.entries(properties).map(function (_a) {
        var _b = __read(_a, 2), propertyName = _b[0], value = _b[1];
        return ({
            propertyName: propertyName,
            pipeline: parseInputOutputPropertyValue(propertyName, "" + value),
        });
    }); };

    function parseProperties(properties) {
        return inputOutputProperties(properties).filter(function (prop) { return !!prop.pipeline && !!prop.pipeline.processorName; });
    }
    function getProcessorNames(properties) {
        return parseProperties(properties).map(function (propertyConfig) { return propertyConfig.pipeline.processorName; });
    }

    /**
     * The input broker service creates a communication pipeline
     * using the component input as a sink. The source of the pipeline
     * is determined by the item model.
     */
    var InputBrokerService = /** @class */ (function () {
        function InputBrokerService(itemLifecycle, pipelineRegistry, componentFactoryResolver, lazyConfig) {
            this.itemLifecycle = itemLifecycle;
            this.pipelineRegistry = pipelineRegistry;
            this.componentFactoryResolver = componentFactoryResolver;
            this.lazyConfig = lazyConfig;
        }
        InputBrokerService.prototype.bootstrap = function () {
            var _this = this;
            // Model properties cannot be linked to the Inputs of lazy loaded items
            var lazyLoadedComponents = (this.lazyConfig
                ? this.lazyConfig.filter(function (config) { return !!config.components; })
                : []).reduce(function (acc, config) { return __spreadArray(__spreadArray([], __read(acc)), __read(config.components)); }, []);
            this.itemLifecycle.whenCreate().subscribe(function (_a) {
                var itemModel = _a.itemModel, component = _a.component;
                var gc$ = _this.itemLifecycle.whenRemove(itemModel.value.name).pipe(operators.take(1));
                _this.runInputPipelines(itemModel, component, gc$);
                if (!lazyLoadedComponents.includes(itemModel.value.ɵclassId)) {
                    _this.runModelInputs(itemModel, component, gc$);
                }
            });
        };
        InputBrokerService.prototype.runModelInputs = function (itemModel, ref, gc$) {
            var _this = this;
            this.componentFactoryResolver.resolveComponentFactory(ref.componentType).inputs.forEach(function (input) {
                // Abort if there is already an "input." property with the same name
                if (itemModel.value.ɵinputProperties[input.templateName] !== undefined)
                    return;
                var modelValue = itemModel.value.ɵproperties[input.templateName];
                if (modelValue === undefined)
                    return;
                var source = itemModel.value.property(input.templateName, modelValue);
                var sink = _this.inputSink(ref, input.propName);
                return sink(source.pipe(operators.takeUntil(gc$)));
            });
        };
        InputBrokerService.prototype.runInputPipelines = function (itemModel, ref, gc$) {
            var _this = this;
            var pipelineService = ref.injector.get(PipelineService);
            parseProperties(itemModel.value.ɵinputProperties).forEach(function (inputPipesConfig) {
                var sourceCommand = inputPipesConfig.pipeline;
                var sourceFn = pipelineService.createSource(sourceCommand.processorName, sourceCommand.args);
                var pipeline = {
                    source: sourceFn,
                    sink: _this.inputSink(ref, inputPipesConfig.propertyName),
                };
                pipelineService.runPipeline(pipeline, gc$);
            });
        };
        InputBrokerService.prototype.inputSink = function (ref, inputName) {
            return createComponentPipe().sink(ref, inputName);
        };
        InputBrokerService.prototype.getItemProviders = function (item) {
            var _this = this;
            return getProcessorNames(item.ɵinputProperties).map(function (processorName) {
                try {
                    return _this.pipelineRegistry.getProcessorProvider(processorName);
                }
                catch (message) {
                    throw new Error("Input '" + processorName + "' on " + item.name + " is misconfigured. " + message);
                }
            });
        };
        return InputBrokerService;
    }());
    InputBrokerService.decorators = [
        { type: i0.Injectable }
    ];
    InputBrokerService.ctorParameters = function () { return [
        { type: ItemLifecycleService },
        { type: PipelineRegistry },
        { type: i0.ComponentFactoryResolver },
        { type: undefined, decorators: [{ type: i0.Inject, args: [LAZY_MAP,] }, { type: i0.Optional }] }
    ]; };
    function createInputBootstrap(Broker) {
        return Broker.bootstrap.bind(Broker);
    }

    /**
     * The output broker service creates a communication pipeline
     * using the component output as a source. The sink of the pipeline
     * is determined by the item model.
     */
    var OutputBrokerService = /** @class */ (function () {
        function OutputBrokerService(itemLifecycle, pipelineRegistry) {
            this.itemLifecycle = itemLifecycle;
            this.pipelineRegistry = pipelineRegistry;
        }
        OutputBrokerService.prototype.bootstrap = function () {
            var _this = this;
            this.itemLifecycle.whenCreate().subscribe(function (_a) {
                var itemModel = _a.itemModel, component = _a.component;
                var gc$ = _this.itemLifecycle.whenRemove(itemModel.value.name).pipe(operators.take(1));
                _this.runOutputPipelines(itemModel, component, gc$);
            });
        };
        OutputBrokerService.prototype.runOutputPipelines = function (itemModel, ref, gc$) {
            var _this = this;
            var pipelineService = ref.injector.get(PipelineService);
            parseProperties(itemModel.value.ɵoutputProperties).forEach(function (outputPipesConfig) {
                var sinkCommand = outputPipesConfig.pipeline;
                var sinkFn = pipelineService.createSink(sinkCommand.processorName, sinkCommand.args);
                var pipeline = {
                    source: _this.outputSource(ref, outputPipesConfig.propertyName),
                    sink: sinkFn,
                };
                if (!pipeline.source()) {
                    throw new Error(ref.componentType.name + " does not have an output named '" + outputPipesConfig.propertyName + "'");
                }
                pipelineService.runPipeline(pipeline, gc$);
            });
        };
        OutputBrokerService.prototype.outputSource = function (ref, outputName) {
            return createComponentPipe().source(ref, outputName);
        };
        OutputBrokerService.prototype.getItemProviders = function (item) {
            var _this = this;
            return getProcessorNames(item.ɵoutputProperties).map(function (processorName) {
                try {
                    return _this.pipelineRegistry.getProcessorProvider(processorName);
                }
                catch (message) {
                    throw new Error("Output '" + processorName + "' on " + item.name + " is misconfigured. " + message);
                }
            });
        };
        return OutputBrokerService;
    }());
    OutputBrokerService.decorators = [
        { type: i0.Injectable }
    ];
    OutputBrokerService.ctorParameters = function () { return [
        { type: ItemLifecycleService },
        { type: PipelineRegistry }
    ]; };
    function createOutputBootstrap(outputBroker) {
        return outputBroker.bootstrap.bind(outputBroker);
    }

    var makeDebugPipe = function () { return ({
        pipe: function (debugPrefix) {
            if (debugPrefix === void 0) { debugPrefix = 'DEBUG'; }
            return function (stdin) { return stdin.pipe(operators.tap(function (value) {
                // eslint-disable-next-line  no-console
                console.log("DEBUG ITEM OUTPUT " + debugPrefix + ":", value);
            })); };
        },
    }); };
    /**
     * Configure the `DebugPipe`.
     *
     * Use the string 'debug' to configure this handler.
     *
     * @usageNotes
     *
     * ```json
     * {
     *   "output.myOutput1": "debug test", // use as sink
     *   "output.myOutput2": "debug > route-param" // use a pipe
     * }
     * ```
     */
    var debugProcessorConfig = {
        name: 'debug',
        provider: {
            provide: new i0.InjectionToken('Debug handler'),
            useFactory: makeDebugPipe,
        },
    };

    var pluckPipe = { pipe: operators.pluck };
    var ɵ0$5 = pluckPipe;
    /**
     * Configure the `PluckPipe`.
     *
     * Use the string 'pluck' to configure this handler.
     *
     * @usageNotes
     *
     * ```json
     * {
     *   "output.myObject": "pluck id > debug", // transform an output
     *   "input.myInput": "pluck id < some-object-source" // transform an input
     * }
     * ```
     */
    var pluckProcessorConfig = {
        name: 'pluck',
        provider: {
            provide: new i0.InjectionToken('Pluck pipeline handler'),
            useValue: ɵ0$5,
        },
    };

    /**
     * @deprecated Will be removed in v7.0.0
     * Pipeable operator for normalizing value to `RouteParams`.
     *
     * @param paramNameArg
     */
    var routeParams = function (paramNameArg) { return function (stdin) { return stdin.pipe(operators.map(function (payload) {
        var _a;
        return (paramNameArg ? (_a = {}, _a[paramNameArg] = "" + payload, _a) : {});
    })); }; };
    var TAG$3 = 'route-param';
    /**
     * @deprecated Will be removed in v7.0.0
     * RouteParam Communication Transport
     *
     * Can be used to configure communication using RouteParam.
     *
     * @usageNotes
     *
     * Store some 2-way bound state to the router as "paramName"
     *
     * ```json
     * {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": RouteParam.toProperty("paramName"),
     *     "input.myInput": RouteParam.toProperty("paramName")
     *   }
     * }
     * ```
     *
     * Navigate to widget-b and pass data via route-param
     *
     * ```json
     * {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": RouteParam.toProperty("inputName")
     *   }
     * },
     * {
     *   "name": "widget-b",
     *   "properties": {
     *     "input.myInput": RouteParam.toProperty("inputName")
     *   }
     * }
     * ```
     */
    var RouteParam = /** @class */ (function () {
        function RouteParam() {
        }
        /**
         * Generate a serialized communication configuration suitable for use as a Widget Input or Output property value.
         *
         * @param group The name of the communication group to which the Input/Output belongs
         */
        RouteParam.toProperty = function (group) {
            return communicationProperty.serializerDeserializer.toProperty(new communicationProperty.CommunicationDefinition(TAG$3, group));
        };
        return RouteParam;
    }());
    var getActivatedRouteParam = function (paramName) { return function (activatedRoute) { return activatedRoute.paramMap.pipe(operators.filter(Boolean), operators.map(function (params) { return params.get(paramName); }), operators.map(function (param) { return (param === null ? undefined : param); })); }; };
    var ɵ0$4 = getActivatedRouteParam;
    var walkRoutePath = function (activatedRoute) {
        if (!activatedRoute.parent) {
            return [activatedRoute];
        }
        return __spreadArray([activatedRoute], __read(walkRoutePath(activatedRoute.parent)));
    };
    var ɵ1$3 = walkRoutePath;
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var getRouteParam = function (activatedRoute, group) {
        var activatedRoutes = walkRoutePath(activatedRoute);
        var allParams$ = activatedRoutes.map(getActivatedRouteParam(group));
        return rxjs.combineLatest(allParams$).pipe(operators.map(function (allParams) { return allParams.find(function (v) { return v !== undefined; }); }));
    };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var createRouteParams = function (activatedRoute, itemNavigation, rootModel) { return ({
        source: function (group) { return function () { return getRouteParam(activatedRoute, group).pipe(operators.map(deserialize)); }; },
        sink: function (group) {
            return function (stdin) {
                stdin.pipe(operators.map(serialize), routeParams(group)).subscribe(function (params) {
                    rootModel
                        .commonAncestor(new communicationProperty.CommunicationDefinition(TAG$3, group))
                        .pipe(operators.first())
                        .subscribe(function (commonAncestor) {
                        if (commonAncestor === undefined) {
                            return console.warn('No Inputs configured to receive route param');
                        }
                        itemNavigation.navigateToItem(commonAncestor.name, params);
                    });
                });
            };
        },
    }); };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var routeParamsProcessorConfig = createPipelineProcessorConfig(TAG$3, {
        provide: new i0.InjectionToken('Route param pipeline handler'),
        useFactory: createRouteParams,
        deps: [router.ActivatedRoute, ӨItemNavigationService, ӨRootContainerService],
    });
    function serialize(outputValue) {
        return typeof outputValue === 'string' ? outputValue : "\"" + JSON.stringify(outputValue) + "\"";
    }
    function deserialize(payload) {
        if (payload === undefined) {
            return undefined;
        }
        // not serialized
        if (!(payload.startsWith('"') && payload.endsWith('"'))) {
            return payload;
        }
        // actually attempt to deserialize
        try {
            return JSON.parse(payload.substr(1, payload.length - 2));
        }
        catch (_) {
            return payload;
        }
    }

    var createRouteParamsMulti = function (activatedRoute, routerService, itemNavigation) { return ({
        sink: function (targetName) { return function (stdin) {
            stdin.subscribe(function (params) {
                if (!targetName) {
                    routerService.navigate(routerService.setParams(params, activatedRoute));
                }
                else {
                    itemNavigation.navigateToItem(targetName, params);
                }
            });
        }; },
    }); };
    /**
     * Configure the `RouteParamsMultiSink`.
     *
     * Use the string 'route-param-multi' to configure this handler.
     *
     * @usageNotes
     *
     * Store some 2-way bound states to the router as "paramName"
     *
     * ```json
     * {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": "route-param-multi",
     *     "input.myInput": "route-param input1", // assuming input1 is set via myOutput
     *     "input.myInput2": "route-param input2" // assuming input2 is set via myOutput
     *   }
     * }
     * ```
     *
     * Navigate to widget-b and pass data via route-param
     *
     * ```json
     * {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": "route-param-multi widget-b"
     *   }
     * },
     * {
     *   "name": "widget-b",
     *   "properties": {
     *     "input.myInput": "route-param input1",
     *     "input.myInput2": "route-param input2"
     *   }
     * }
     * ```
     *
     * See `RouteParamsMultiSink` for more options.
     *
     * Also see:
     *  - `routeParamsProcessorConfig`
     *  -
     */
    var routeParamsMultiProcessorConfig = {
        name: 'route-param-multi',
        provider: {
            provide: new i0.InjectionToken('Route param multi pipeline handler'),
            useFactory: createRouteParamsMulti,
            deps: [router.ActivatedRoute, RouterNavigationService, ӨItemNavigationService],
        },
    };

    var createItemNavigate = function (itemNavigation) { return ({
        sink: function (targetName) { return function (stdin) {
            stdin.subscribe(function () {
                itemNavigation.navigateToItem(targetName, {});
            });
        }; },
    }); };
    /**
     * Configure the `ItemNavigateSink`.
     *
     * Use the string 'item-navigate' to configure this handler.
     *
     * Note: to pass route params you must use `RouteParamsStore` instead.
     *
     * @usageNotes
     *
     * Navigate between widgets
     *
     *
     * ```json
     * {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": "item-navigate widget-b"
     *   }
     * },
     * {
     *   "name": "widget-b"
     * }
     * ```
     *
     * See `RouteParamsStore` for more options.
     */
    var itemNavigateProcessorConfig = {
        name: 'item-navigate',
        provider: {
            provide: new i0.InjectionToken('Item navigation pipeline handler'),
            useFactory: createItemNavigate,
            deps: [ӨItemNavigationService],
        },
    };

    var createModelSource = function (itemModel) { return ({
        source: function (propertyName) { return function () { return itemModel.property(propertyName); }; },
    }); };
    /**
     * Configure the `ModelSource`.
     *
     * Use the string 'model' to configure this handler.
     *
     * @usageNotes
     *
     * ```json
     * {
     *   "modelProperty": "foobar",
     *   "input.myInput": "model modelProperty", // read the value of modelProperty
     * }
     * ```
     */
    var modelProcessorConfig = {
        name: 'model',
        provider: {
            provide: new i0.InjectionToken('Model pipeline handler'),
            useFactory: createModelSource,
            deps: [ItemModel],
        },
    };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var createAppConfigSource = function (appConfig) { return ({
        source: function (configName) { return function () { return appConfig.getConfig().pipe(operators.pluck(configName)); }; },
    }); };
    var TAG$2 = 'app-config';
    /**
     * @deprecated Will be removed in v7.0.0
     * AppConfig Communication Transport
     *
     * Can be used in standalone development to configure communication using AppConfig
     */
    var AppConfig = /** @class */ (function () {
        function AppConfig() {
        }
        /**
         * Generate a serialized communication configuration suitable for use as a Widget Input property value.
         *
         * @param group The name of the communication group to which the Input belongs
         */
        AppConfig.toProperty = function (group) {
            return communicationProperty.serializerDeserializer.toProperty(new communicationProperty.CommunicationDefinition(TAG$2, group));
        };
        return AppConfig;
    }());
    /**
     * @deprecated Will be removed in v7.0.0
     * Configure the `AppConfigSource`.
     *
     * Use the `AppConfig.toProperty` helper to configure this handler.
     *
     * @usageNotes
     *
     * ```json
     * {
     *   "input.myInput": "AppConfig.toProperty(configPropertyName)", // read the value of application configuration
     * }
     * ```
     */
    var appConfigProcessorConfig = createPipelineProcessorConfig(TAG$2, {
        provide: new i0.InjectionToken('Application configuration pipeline handler'),
        useFactory: createAppConfigSource,
        deps: [AppConfigService],
    });

    var UrlSinkNavigator = /** @class */ (function () {
        function UrlSinkNavigator() {
        }
        UrlSinkNavigator.prototype.go = function (url) {
            window.location.href = url;
        };
        return UrlSinkNavigator;
    }());
    var createUrlSink = function (navigator) {
        if (navigator === void 0) { navigator = new UrlSinkNavigator(); }
        return ({
            sink: function (url, paramName) { return function (stdin) {
                stdin.subscribe(function (payload) {
                    navigator.go(navigationUrlWithParam(url, paramName, payload));
                });
            }; },
        });
    };
    function navigationUrlWithParam(navigationUrl, paramName, param) {
        if (!paramName || !param) {
            return navigationUrl;
        }
        var paramSeparator = navigationUrl.indexOf('?') === -1 ? '?' : '&';
        return "" + navigationUrl + paramSeparator + paramName + "=" + param;
    }
    /**
     * Configure the `UrlSink`.
     *
     * Use the string 'url' to configure this handler.
     *
     * @usageNotes
     *
     * ```json
     * {
     *   "output.myOutput1": "url http://www.google.com/", // navigate without param
     *   "output.myOutput2": "url http://www.google.com/ query" // navigate with param
     * }
     * ```
     */
    var urlProcessorConfig = {
        name: 'url',
        provider: {
            provide: new i0.InjectionToken('Url pipeline handler'),
            useFactory: createUrlSink,
            deps: [],
        },
    };

    var TAG$1 = 'router.navigate';
    var isDefined = function (param) { return param !== undefined; };
    var ɵ0$3 = isDefined;
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var PARAM_PLACEHOLDER_BUILDER = Symbol('Param Placeholder Builder');
    /**
     * @deprecated Will be removed in v7.0.0
     * Placeholder to use for a named optional matrix param in `RouterNavigate`.
     *
     * This class is private. Use `RouterNavigateSink.param` to create a placeholder.
     */
    var RouterNavigateParamPlaceholder = /** @class */ (function () {
        function RouterNavigateParamPlaceholder(paramName) {
            this.paramName = paramName;
        }
        /**
         * @internal
         */
        RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER] = function (name) {
            return new RouterNavigateParamPlaceholder(name);
        };
        return RouterNavigateParamPlaceholder;
    }());
    /**
     * @deprecated Will be removed in v7.0.0
     * Serialize the command generated with TS to pipeline source argument strings for the model.
     *
     * - Path commands are serialized as the path string.
     * - Single named optional params are serialzed as {paramName}
     * @param commands
     */
    var serializeCommands = function (commands) {
        // Validate that there is only max one placeholder
        if (commands.filter(function (command) { return command instanceof RouterNavigateParamPlaceholder; }).length > 1) {
            throw new Error('RouterNavigate: Only a single placeholder can be configured');
        }
        return commands.map(function (command) {
            if (command instanceof RouterNavigateParamPlaceholder) {
                return "{" + command.paramName + "}";
            }
            else {
                return command;
            }
        });
    };
    /**
     * Deserialize the pipeline string arguments to commands for Router.navigate.
     * @param commands
     */
    var deserializeCommands = function (commands) { return commands.map(function (command) {
        var paramNameMatches = command.match(/^{([^}]+)}$/);
        if (!paramNameMatches) {
            return command;
        }
        return RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER](paramNameMatches[1]);
    }); };
    var ɵ1$2 = deserializeCommands;
    /**
     * @deprecated Will be removed in v7.0.0
     * Helper to configure output properties to write to the `RouterNavigateStore`
     *
     * @usageNotes
     *
     * To navigate like:
     *
     * ```ts
     * myOutput.subscribe(() => Router.navigate(['items']);)
     * ```
     *
     * Configure your model like:
     *
     * ```json
     *  {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": RouterNavigateSink.navigate(['items']),
     *   }
     * }
     * ```
     *
     * To navigate to nested paths like:
     *
     * ```ts
     * myOutput.subscribe(() => Router.navigate(['dashboard', 'transactions']);)
     * ```
     *
     * Configure your model like:
     *
     * ```json
     *  {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": RouterNavigateSink.navigate(['dashboard', 'transactions']),
     *   }
     * }
     * ```
     *
     * To navigate passing [optional route
     * params](https://angular.io/guide/router-tutorial-toh#heroes-list-optionally-selecting-a-hero),
     * eg in Angular it would be:
     *
     * ```ts
     * heroId.subscribe((heroId) => Router.navigate(['heroes', { id: heroId }]));
     * ```
     *
     * Configure your model like:
     *
     * ```json
     * {
     *   "output.heroId": RouterNavigateSink.navigate(['heroes', RouterNavigateSink.param('id')]),
     * }
     * ```
     *
     * To read a param you can connect an input to the `RouterNavigateSource`.
     */
    var RouterNavigateSink = /** @class */ (function () {
        function RouterNavigateSink() {
        }
        /**
         * Generate a serialized `PipelineSink` configuration suitable for use as a Widget Output property value.
         *
         * @param commands The commands to use for navigation.
         */
        RouterNavigateSink.navigate = function (commands) {
            return TAG$1 + " " + serializeCommands(commands).join(' ');
        };
        /**
         * Create a param placeholder to use in a `RouterNavigateSink`.
         *
         * @param paramName
         */
        RouterNavigateSink.param = function (paramName) {
            if (!paramName) {
                throw new Error('RouterNavigateSink.param: paramName must be set');
            }
            return RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER](paramName);
        };
        return RouterNavigateSink;
    }());
    /**
     * @deprecated Will be removed in v7.0.0
     * Helper to configure input properties to read from the `RouterNavigateStore`
     *
     * @usageNotes
     *
     *
     * To read a param into an input property:
     *
     * ```json
     * {
     *   "input.heroId": RouterNavigateSource.param('id')
     * }
     * ```
     */
    var RouterNavigateSource = /** @class */ (function () {
        function RouterNavigateSource() {
        }
        /**
         * Generate a serialized `PipelineSource` configuration suitable for use as a Widget Input property value.
         *
         * @param paramName The name of the param to read from the URL.
         */
        RouterNavigateSource.param = function (paramName) {
            return TAG$1 + " " + paramName;
        };
        return RouterNavigateSource;
    }());
    var matrixParam = function (param, paramValue) {
        var _a;
        return isDefined(paramValue) ? (_a = {}, _a[param.paramName] = "" + paramValue, _a) : paramValue;
    };
    var ɵ2$1 = matrixParam;
    // Convert configured navigate commands to actual angular Router.navigate commands
    var navigateCommands = function (commands, paramValue) { return commands
        .map(function (command) { return (command instanceof RouterNavigateParamPlaceholder ? matrixParam(command, paramValue) : command); })
        .filter(isDefined); };
    var ɵ3$1 = navigateCommands;
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var createRouterNavigateStore = function (router, activatedRoute) { return ({
        sink: function () {
            var serializedCommands = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                serializedCommands[_i] = arguments[_i];
            }
            var commands = deserializeCommands(serializedCommands);
            return function (stdin) {
                stdin.subscribe(function (paramValue) {
                    router.navigate(navigateCommands(commands, paramValue));
                });
            };
        },
        source: function (paramName) { return function () { return getRouteParam(activatedRoute, paramName); }; },
    }); };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var routerNavigateProcessorConfig = createPipelineProcessorConfig(TAG$1, {
        provide: new i0.InjectionToken('Router.Navigate pipeline handler'),
        useFactory: createRouterNavigateStore,
        deps: [router.Router, router.ActivatedRoute],
    });

    /**
     * @deprecated
     */
    var Graph = /** @class */ (function () {
        function Graph() {
            this.vertexes = new Set();
            this.edges = new Map();
        }
        Graph.prototype.add = function (vertex) {
            this.vertexes.add(vertex);
        };
        Graph.prototype.connect = function (from, to, value) {
            this.add(from);
            this.add(to);
            var vertexEdges = this.edges.get(from);
            if (vertexEdges === undefined) {
                vertexEdges = new Map();
                this.edges.set(from, vertexEdges);
            }
            vertexEdges.set(to, { value: value });
        };
        Graph.prototype.getEdge = function (from, to) {
            var edges = this.edges.get(from);
            var edge = edges === undefined ? undefined : edges.get(to);
            return edge === undefined ? undefined : edge.value;
        };
        return Graph;
    }());

    var CONFIG_FLOWS = new i0.InjectionToken('@backbase/foundation Communcation Flow Configuration');
    var FlowsService = /** @class */ (function () {
        function FlowsService(flowsConfig) {
            var _this = this;
            this.transitions = new Graph();
            if (flowsConfig !== null) {
                flowsConfig.forEach(function (flows) {
                    flows.forEach(function (flow) {
                        _this.addFlow(flow);
                    });
                });
            }
        }
        FlowsService.prototype.addFlow = function (config) {
            var currentEdge = this.transitions.getEdge(config.output.classId, config.input.classId);
            var flow = {
                output: config.output.outputName,
                input: config.input.inputName,
                map: config.mapPayload,
            };
            var edge = currentEdge ? __spreadArray(__spreadArray([], __read(currentEdge)), [flow]) : [flow];
            this.transitions.connect(config.output.classId, config.input.classId, edge);
        };
        FlowsService.prototype.getFlows = function (from, fromOutput, to, toInput) {
            var _this = this;
            var flows = to.reduce(function (acc, classId) { return __spreadArray(__spreadArray([], __read(acc)), __read((_this.transitions.getEdge(from, classId) || []))); }, []);
            return flows.filter(function (flow) { return flow.output === fromOutput && (toInput === undefined || flow.input === undefined || toInput === flow.input); });
        };
        return FlowsService;
    }());
    FlowsService.decorators = [
        { type: i0.Injectable }
    ];
    FlowsService.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [CONFIG_FLOWS,] }] }
    ]; };

    var ItemTransitionService = /** @class */ (function () {
        function ItemTransitionService(flows, navigationService) {
            this.flows = flows;
            this.navigationService = navigationService;
        }
        ItemTransitionService.prototype.transition = function (fromItem, fromOutput, toItem, toInput, ancestors, payload) {
            // Deprecated
            var flows = this.flows.getFlows(fromItem.ɵclassId, fromOutput, __spreadArray([], __read(ancestors.map(function (item) { return item.ɵclassId; }))), toInput);
            if (flows.length === 0) {
                flows.push({ output: fromOutput, input: toInput });
            }
            var params = this.mapFlows(flows, toInput, payload);
            return this.navigationService.navigateToItem(toItem.name, params);
        };
        ItemTransitionService.prototype.mapFlows = function (flows, toInput, payload) {
            return flows.reduce(function (acc, flow) {
                var _a;
                var inputName = toInput || flow.input || flow.output;
                var value = flow.map ? flow.map(payload) : payload;
                if (value === undefined) {
                    return acc; // @todo: should it be possible to "clear" a param with undefined?
                }
                // Note: if 2 flows map to the same input, the 2nd will overwrite
                return Object.assign(Object.assign({}, acc), (_a = {}, _a[inputName] = value, _a));
            }, {});
        };
        return ItemTransitionService;
    }());
    ItemTransitionService.decorators = [
        { type: i0.Injectable }
    ];
    ItemTransitionService.ctorParameters = function () { return [
        { type: FlowsService },
        { type: ӨItemNavigationService }
    ]; };

    var pipeName = 'navigation';
    var navigationHandlerToken = new i0.InjectionToken('Navigation handler');
    var createNavigationSink = function (rootContainer, itemTransition, itemModel) {
        return {
            sink: function (outputName, config) { return function (stdin) {
                if (outputName === undefined || config === undefined) {
                    return;
                }
                var _a = __read(config.split('.'), 2), targetName = _a[0], targetInput = _a[1];
                var target$ = rootContainer.model.pipe(operators.mergeMap(function (tree) { return tree.find(function (item) { return item.name === targetName; }); }), operators.filter(function (a) { return a !== undefined; }));
                var targetAnscestors = target$.pipe(operators.mergeMap(function (tree) { return tree.flatten(); }), operators.map(function (flatNodes) { return flatNodes.map(function (node) { return node.value; }); }));
                rxjs.combineLatest([target$, targetAnscestors, stdin]).subscribe(function (_a) {
                    var _b = __read(_a, 3), target = _b[0], anscestors = _b[1], payload = _b[2];
                    return itemTransition.transition(itemModel, outputName, target.value, targetInput, anscestors, payload);
                });
            }; },
        };
    };
    var navigationProcessorConfig = {
        name: pipeName,
        provider: {
            provide: navigationHandlerToken,
            useFactory: createNavigationSink,
            deps: [ӨRootContainerService, ItemTransitionService, ItemModel],
        },
    };

    /**
     * The model of the item at the root of the SPA (ie: the app container).
     */
    var RootItemModelService = /** @class */ (function () {
        function RootItemModelService(rootModel) {
            this.rootModel = rootModel;
        }
        /**
         * Find an item by searching the tree of the SPA.
         *
         * Note: Because the model of the SPA can change, this method returns an observable.
         *
         * @param name The instance name of the item to find.
         */
        RootItemModelService.prototype.findByName = function (name) {
            return this.find(function (model) { return model.name === name; });
        };
        RootItemModelService.prototype.find = function (predicate) {
            return this.rootModel.model.pipe(operators.switchMap(function (model) { return model.find(predicate); }));
        };
        return RootItemModelService;
    }());
    RootItemModelService.decorators = [
        { type: i0.Injectable }
    ];
    RootItemModelService.ctorParameters = function () { return [
        { type: ӨRootContainerService }
    ]; };

    /**
     * AreaComponent is a wrapper for ChromeComponent,
     * which defines the area for dynamic components rendering
     */
    var AreaComponent = /** @class */ (function () {
        function AreaComponent(itemRegistry) {
            this.itemRegistry = itemRegistry;
            /**
             * name attribute of the area,
             * represented also as a "data-area"
             * attribute in the corresponding node
             */
            this.name = '0';
            this.children = [];
        }
        /**
         * @internal
         */
        AreaComponent.prototype.isModule = function (model) {
            return !!this.itemRegistry.getModuleLoader(model.ɵclassId);
        };
        return AreaComponent;
    }());
    AreaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'bb-area',
                    template: "\n    <ng-container *ngFor=\"let item of children\">\n      <router-outlet *ngIf=\"isModule(item.value); else renderModel\"></router-outlet>\n      <ng-template #renderModel><bb-chrome [item]=\"item\"></bb-chrome></ng-template>\n      <ng-container> </ng-container\n    ></ng-container>\n  ",
                    styles: [':host { display: block; }']
                },] }
    ];
    AreaComponent.ctorParameters = function () { return [
        { type: ItemRegistryService }
    ]; };
    AreaComponent.propDecorators = {
        name: [{ type: i0.HostBinding, args: ['attr.data-area',] }, { type: i0.Input }],
        children: [{ type: i0.Input }]
    };

    var RouterService = /** @class */ (function () {
        /**
         * Backbase Angular Router abstraction.
         * See https://angular.io/api/router/Router
         *
         * The purpose for Backbase abstracting around the default Angular Router is
         * when linking a to a bb-router-outlet. The outlet name for a bb-router-outlet
         * is dynamically generated by a property on the model, so you can use the
         * Backbase Router service to automatically apply the outletName to the navigation
         * commands.
         *
         * @param router Angular Router
         * @param route Angular ActivatedRoute
         * @param itemModel Model of the Backbase Widget or Container
         */
        function RouterService(router, route, itemModel, routerConfig) {
            this.router = router;
            this.route = route;
            this.itemModel = itemModel;
            this.routerConfig = routerConfig;
            this.outletName = this.routerConfig.ɵitemOutletName(this.itemModel);
        }
        /**
         * Navigate based on the provided array of commands and a starting point.
         * If no starting route is provided, the navigation is absolute.
         * See Angular Router.navigate
         */
        RouterService.prototype.navigate = function (commands, extras) {
            var _this = this;
            if (extras === void 0) { extras = {}; }
            return this.createUrlTree(commands, extras).then(function (urlTree) { return _this.router.navigateByUrl(_this.router.serializeUrl(urlTree), extras); });
        };
        /**
         * Applies an array of commands to the current url tree and creates a new url tree.
         * See Angular Router.createUrlTree
         */
        RouterService.prototype.createUrlTree = function (commands, extras) {
            var _this = this;
            if (extras === void 0) { extras = {}; }
            return this.outletName
                .pipe(operators.take(1))
                .toPromise()
                .then(function (outletName) { return _this.outletCommands(outletName, commands); })
                .then(function (cmnds) { return _this.router.createUrlTree(cmnds, Object.assign({ relativeTo: _this.route }, extras)); });
        };
        RouterService.prototype.outletCommands = function (outletName, commands) {
            var _a;
            if (outletName == null || outletName === router.PRIMARY_OUTLET) {
                return commands;
            }
            else {
                return [{ outlets: (_a = {}, _a[outletName] = commands, _a) }];
            }
        };
        return RouterService;
    }());
    RouterService.decorators = [
        { type: i0.Injectable }
    ];
    RouterService.ctorParameters = function () { return [
        { type: router.Router },
        { type: router.ActivatedRoute },
        { type: ItemModel },
        { type: AbstractRouterConfigService }
    ]; };

    var ItemInjectorService = /** @class */ (function () {
        function ItemInjectorService(inputBroker, outputBroker) {
            this.inputBroker = inputBroker;
            this.outputBroker = outputBroker;
        }
        ItemInjectorService.prototype.createInjector = function (parent, item) {
            var widgetProvider = {
                provide: ItemModel,
                useValue: item.value,
            };
            var containerProvider = {
                provide: ItemModelTree,
                useValue: item,
            };
            var routerServiceProvider = {
                provide: RouterService,
                deps: [router.Router, router.ActivatedRoute, ItemModel, AbstractRouterConfigService],
            };
            /**
             * @todo: consider putting *all* configured handlers on the
             * injector, instead of only handlers used based on the model.
             *
             * This would make it possible to create higher-order handlers
             */
            var communicationPipelineProviders = uniq(__spreadArray(__spreadArray([], __read(this.inputBroker.getItemProviders(item.value))), __read(this.outputBroker.getItemProviders(item.value))));
            var pipelineService = {
                provide: PipelineService,
                deps: [PipelineRegistry, i0.Injector],
            };
            return i0.Injector.create({
                providers: __spreadArray(__spreadArray([
                    widgetProvider,
                    containerProvider,
                    routerServiceProvider
                ], __read(communicationPipelineProviders)), [
                    pipelineService,
                    {
                        provide: store["ɵSTORE_BRANCH"],
                        useValue: item.value.name,
                    },
                    {
                        provide: store["ɵSTORE_DISPATCH_CHANNEL"],
                        useValue: item.value.name,
                    },
                    {
                        provide: store.StoreFactory,
                        useClass: store.StoreFactory,
                        deps: [store["ɵStoreBroker"], store["ɵSTORE_BRANCH"], store["ɵSTORE_DISPATCH_CHANNEL"], future.FeaturesService],
                    },
                    {
                        provide: TemplateRegistry,
                        useClass: TemplateRegistry,
                        deps: [],
                    },
                ]),
                parent: parent,
            });
        };
        return ItemInjectorService;
    }());
    ItemInjectorService.decorators = [
        { type: i0.Injectable }
    ];
    ItemInjectorService.ctorParameters = function () { return [
        { type: InputBrokerService },
        { type: OutputBrokerService }
    ]; };

    var CombinedComponentFactoryResolver = /** @class */ (function () {
        function CombinedComponentFactoryResolver(itemRegistry, rootResolver) {
            this.itemRegistry = itemRegistry;
            this.rootResolver = rootResolver;
            this.childResolvers = new Map();
        }
        CombinedComponentFactoryResolver.prototype.registerChildResolver = function (classId, resolver) {
            this.childResolvers.set(classId, resolver);
        };
        CombinedComponentFactoryResolver.prototype.resolveComponentFactory = function (classId) {
            var type = this.itemRegistry.getComponentValue(classId);
            if (!type) {
                throw new Error("@backbase/foundation No component registered for " + classId + ". Did you add it to the classMap?");
            }
            var resolver = this.childResolvers.get(classId) || this.rootResolver;
            return resolver.resolveComponentFactory(type);
        };
        return CombinedComponentFactoryResolver;
    }());
    CombinedComponentFactoryResolver.decorators = [
        { type: i0.Injectable }
    ];
    CombinedComponentFactoryResolver.ctorParameters = function () { return [
        { type: ItemRegistryService },
        { type: i0.ComponentFactoryResolver }
    ]; };

    var ItemLoaderService = /** @class */ (function () {
        function ItemLoaderService(compiler, parentInjector, itemRegistry, componentFactoryResolver, 
        // @fixme: generate lazy map from the page model?
        lazyConfig) {
            this.compiler = compiler;
            this.parentInjector = parentInjector;
            this.itemRegistry = itemRegistry;
            this.componentFactoryResolver = componentFactoryResolver;
            this.lazyComponentsConfig = lazyConfig
                ? lazyConfig.filter(function (config) { return !!config.components; })
                : [];
            if (hasDuplicates(this.lazyComponentsConfig.reduce(function (acc, config) { return __spreadArray(__spreadArray([], __read(acc)), __read(config.components)); }, []))) {
                throw new Error('[LazyConfig] You have added one or more components inside multiple lazy loading bundles. ' +
                    "This will make an impact on your app's performance. " +
                    'Update your config to have one component included in only one bundle.');
            }
        }
        /**
         * Loads the module this class is in, and adds
         * it to the global item registry, and global component
         * resolver.
         *
         * @param classId
         */
        ItemLoaderService.prototype.loadComponent = function (classId) {
            if (this.itemRegistry.has(classId) || this.lazyComponentsConfig.length === 0) {
                return Promise.resolve();
            }
            var foundBundle = this.lazyComponentsConfig.find(function (item) { return item.components.indexOf(classId) !== -1; });
            var callback = foundBundle ? foundBundle.loadChildren : undefined;
            if (!callback) {
                return Promise.resolve();
            }
            return callback()
                .then(this.toModuleFactory.bind(this))
                .then(this.loadModule.bind(this))
                .then(this.registerModule.bind(this, classId));
        };
        ItemLoaderService.prototype.toModuleFactory = function (loadedItem) {
            // Depending on compiler, callback can return either module factory or the module itself.
            return loadedItem instanceof i0.NgModuleFactory ? loadedItem : this.compiler.compileModuleSync(loadedItem);
        };
        ItemLoaderService.prototype.loadModule = function (moduleFactory) {
            return moduleFactory.create(this.parentInjector);
        };
        ItemLoaderService.prototype.registerModule = function (classId, ngModule) {
            this.registerComponentClass(classId, ngModule);
            this.registerComponentFactoryResolver(classId, ngModule);
        };
        ItemLoaderService.prototype.registerComponentClass = function (classId, ngModule) {
            var childRegistry = ngModule.injector.get(ItemRegistryService);
            var componentClass = childRegistry.getComponentValue(classId);
            if (!componentClass) {
                throw new Error("@backbase/foundation No component registered for " + classId + ". Did you add it to the classMap?");
            }
            this.itemRegistry.add(classId, componentClass);
        };
        ItemLoaderService.prototype.registerComponentFactoryResolver = function (classId, ngModule) {
            this.componentFactoryResolver.registerChildResolver(classId, ngModule.componentFactoryResolver);
        };
        return ItemLoaderService;
    }());
    ItemLoaderService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function ItemLoaderService_Factory() { return new ItemLoaderService(i0__namespace.ɵɵinject(i0__namespace.Compiler), i0__namespace.ɵɵinject(i0__namespace.INJECTOR), i0__namespace.ɵɵinject(ItemRegistryService), i0__namespace.ɵɵinject(CombinedComponentFactoryResolver), i0__namespace.ɵɵinject(LAZY_MAP, 8)); }, token: ItemLoaderService, providedIn: "root" });
    ItemLoaderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ItemLoaderService.ctorParameters = function () { return [
        { type: i0.Compiler },
        { type: i0.Injector },
        { type: ItemRegistryService },
        { type: CombinedComponentFactoryResolver },
        { type: undefined, decorators: [{ type: i0.Inject, args: [LAZY_MAP,] }, { type: i0.Optional }] }
    ]; };

    /**
     * ChromeComponent represents "chrome element" and
     * implements dynamic components rendering
     */
    var ChromeComponent = /** @class */ (function () {
        /**
         * ChromeComponent constructor
         * @param componentFactoryResolver Factory which allows chrome component to resolve items
         * @param injectors Injectors map
         * @param components Components Registry Service
         */
        function ChromeComponent(itemLifecycle, itemInjector, itemLoader, componentFactoryLoader) {
            var _this = this;
            this.itemLifecycle = itemLifecycle;
            this.itemInjector = itemInjector;
            this.itemLoader = itemLoader;
            this.componentFactoryLoader = componentFactoryLoader;
            this.gc$ = new rxjs.Subject();
            this.itemValue = new rxjs.ReplaySubject(1);
            this.component$ = this.itemValue.pipe(operators.switchMap(function (item) { return _this.createComponent(item); }), operators.shareReplay(1));
            this.componentItemModelTuple = this.component$.pipe(operators.withLatestFrom(this.itemValue), operators.map(function (_a) {
                var _b = __read(_a, 2), ref = _b[0], item = _b[1];
                return ref === undefined ? [undefined, undefined] : [ref, item];
            }), operators.startWith([undefined, undefined]));
        }
        Object.defineProperty(ChromeComponent.prototype, "item", {
            /**
             * Setter (Input) for an item to be bootstrapped
             * @param item Actual item to be bootstrapped
             */
            set: function (item) {
                this.name = item.value.name;
                this.itemValue.next(item);
            },
            enumerable: false,
            configurable: true
        });
        ChromeComponent.prototype.ngOnInit = function () {
            var _this = this;
            // Insert component on create
            this.componentItemModelTuple
                .pipe(operators.pairwise(), operators.takeUntil(this.gc$))
                .subscribe(function (_a) {
                var _b = __read(_a, 2), _c = __read(_b[0], 2), oldComponent = _c[0], oldItemValue = _c[1], _d = __read(_b[1], 2), component = _d[0], item = _d[1];
                if (!_this.vcRef || !component || !item) {
                    return;
                }
                if (oldComponent && oldItemValue) {
                    _this.itemLifecycle.onRemove(oldItemValue, oldComponent);
                }
                _this.vcRef.clear();
                _this.vcRef.insert(component.hostView);
                _this.itemLifecycle.onCreate(item, component);
                component.changeDetectorRef.markForCheck();
            });
        };
        ChromeComponent.prototype.ngOnDestroy = function () {
            var _this = this;
            // Cleanup on destroy
            this.componentItemModelTuple.pipe(operators.takeUntil(this.gc$), operators.last()).subscribe(function (_a) {
                var _b = __read(_a, 2), component = _b[0], item = _b[1];
                if (item && component) {
                    _this.itemLifecycle.onRemove(item, component);
                }
            });
            this.gc$.next();
            this.gc$.complete();
        };
        /**
         * inner helper function which creates components
         * @param item item to be created
         */
        ChromeComponent.prototype.createComponent = function (item) {
            var _this = this;
            return this.itemLoader
                .loadComponent(item.value.ɵclassId)
                .then(function () { return _this.componentFactoryLoader.resolveComponentFactory(item.value.ɵclassId); })
                .then(function (componentFactory) {
                // FIXME: @deprecated parentInjector (no replacement)
                var injector = _this.itemInjector.createInjector(_this.vcRef && _this.vcRef.parentInjector, item);
                // Create the component
                return componentFactory.create(injector);
            });
        };
        return ChromeComponent;
    }());
    ChromeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'bb-chrome',
                    template: " <ng-container #vc></ng-container> "
                },] }
    ];
    ChromeComponent.ctorParameters = function () { return [
        { type: ItemLifecycleService },
        { type: ItemInjectorService },
        { type: ItemLoaderService },
        { type: CombinedComponentFactoryResolver }
    ]; };
    ChromeComponent.propDecorators = {
        vcRef: [{ type: i0.ViewChild, args: ['vc', { read: i0.ViewContainerRef, static: true },] }],
        name: [{ type: i0.HostBinding, args: ['attr.data-chrome',] }],
        item: [{ type: i0.Input }]
    };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var createInterceptCallback = function (interceptConfig) { return function (responseError) {
        return (responseError.status === interceptConfig.statusCode &&
            responseError.headers.get(interceptConfig.headerAttribute) !== null);
    }; };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var isInterceptCallback = function (interceptConfig) { return typeof interceptConfig === 'function'; };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var DEFAULT_STEPUP_CONFIG = {
        retryRequests: {
            headerAttribute: 'X-MFA',
        },
        interceptResponses: {
            statusCode: 401,
            headerAttribute: 'WWW-Authenticate',
        },
    };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var StepUpInterceptor = /** @class */ (function () {
        function StepUpInterceptor(stepupService, config, injector) {
            this.stepupService = stepupService;
            this.config = config;
            this.injector = injector;
        }
        StepUpInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            var shouldIntercept = isInterceptCallback(this.config.interceptResponses)
                ? this.config.interceptResponses
                : createInterceptCallback(this.config.interceptResponses);
            return next.handle(req).pipe(operators.catchError(function (error) {
                var _a;
                if (!shouldIntercept(error)) {
                    // if it's an error which shouldn't be intercepted propagate the error
                    // to as if it wasn't intercepted at all.
                    return rxjs.throwError(error);
                }
                _this.mediatorComponent = (_a = _this.mediatorComponent) !== null && _a !== void 0 ? _a : _this.stepupService.stepupComponent;
                // Errors which are to be intercepted should be "paused" and the stream will be handled according
                // to the event coming from a mediator component. On complete event we are going to retry the request
                // while if any other event was fired by the mediator component, we proceed with the error as usual
                var handleMediatorComponentEvent = function (_b) {
                    var _c;
                    var _d = __read(_b, 2), event = _d[0], token = _d[1];
                    if (event === 'complete' && token) {
                        // The HttpClient cannot be injected because it is a circular dependency, so we must lazily get it only when required.
                        var http$1 = _this.injector.get(http.HttpClient);
                        return http$1.request(req.clone({ setHeaders: (_c = {}, _c[_this.config.retryRequests.headerAttribute] = token, _c) }));
                    }
                    else {
                        return rxjs.throwError(error);
                    }
                };
                // we listen to an event from mediator component in order to be able to amend
                // requests "chain", so we can repeat the request or just propagate the error
                var mediatorComponentResponse = rxjs.race(_this.mediatorComponent.instance.complete.pipe(operators.map(function (value) { return ['complete', value]; })), _this.mediatorComponent.instance.cancel.pipe(operators.map(function () { return ['cancel', undefined]; }))).pipe(operators.take(1), operators.switchMap(handleMediatorComponentEvent));
                // and we trigger the component to open
                _this.mediatorComponent.instance.open(error);
                return mediatorComponentResponse;
            }));
        };
        return StepUpInterceptor;
    }());

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var STEPUP_CONFIG = new i0.InjectionToken('Custom step-up configuration injection token');
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var StepUpService = /** @class */ (function () {
        function StepUpService(resolver, stepupConfigParam) {
            this.resolver = resolver;
            this.stepupConfig = Object.assign(Object.assign({}, DEFAULT_STEPUP_CONFIG), stepupConfigParam);
        }
        Object.defineProperty(StepUpService.prototype, "stepupComponent", {
            get: function () {
                if (this.stepupComponentRef) {
                    return this.stepupComponentRef;
                }
                throw new Error('No stepupComponent defined');
            },
            enumerable: false,
            configurable: true
        });
        StepUpService.prototype.createStepUpComponent = function (stepupContainer) {
            stepupContainer.clear();
            var factory = this.resolver.resolveComponentFactory(this.stepupConfig.mediatorComponentClass);
            this.stepupComponentRef = stepupContainer.createComponent(factory);
        };
        return StepUpService;
    }());
    StepUpService.decorators = [
        { type: i0.Injectable }
    ];
    StepUpService.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: undefined, decorators: [{ type: i0.Inject, args: [STEPUP_CONFIG,] }] }
    ]; };

    var SESSION_TIMEOUT_CONFIG = new i0.InjectionToken('Custom session timeout configuration injection token');
    /**
     * The session timeout service creates a session timeout component instance within the root.
     */
    var SessionTimeoutService = /** @class */ (function () {
        function SessionTimeoutService(resolver, sessionTimeoutConfig) {
            this.resolver = resolver;
            this.sessionTimeoutConfig = sessionTimeoutConfig;
        }
        Object.defineProperty(SessionTimeoutService.prototype, "sessionTimeoutComponent", {
            get: function () {
                if (this.sessionTimeoutComponentRef) {
                    return this.sessionTimeoutComponentRef;
                }
                throw new Error('No sessionTimeoutComponent defined');
            },
            enumerable: false,
            configurable: true
        });
        SessionTimeoutService.prototype.createSessionTimeoutComponent = function (sessionTimeoutContainer) {
            sessionTimeoutContainer.clear();
            var factory = this.resolver.resolveComponentFactory(this.sessionTimeoutConfig.sessionTimeoutComponentClass);
            this.sessionTimeoutComponentRef = sessionTimeoutContainer.createComponent(factory);
            this.sessionTimeoutComponentRef.instance.inactivityModalTime = this.sessionTimeoutConfig.inactivityModalTime;
        };
        return SessionTimeoutService;
    }());
    SessionTimeoutService.decorators = [
        { type: i0.Injectable }
    ];
    SessionTimeoutService.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: undefined, decorators: [{ type: i0.Inject, args: [SESSION_TIMEOUT_CONFIG,] }] }
    ]; };

    var RootComponent = /** @class */ (function () {
        function RootComponent(rootContainer, zone, itemNavigation, events, stepupService, sessionTimeoutService) {
            var _this = this;
            this.rootContainer = rootContainer;
            this.zone = zone;
            this.itemNavigation = itemNavigation;
            this.events = events;
            this.stepupService = stepupService;
            this.sessionTimeoutService = sessionTimeoutService;
            this.children = this.rootContainer.model.pipe(operators.flatMap(function (state) { return state.children; }));
            this.eventListener = function (_a) {
                var name = _a.name;
                // [FIXME] This zone should almost certainly be handled in the EventBus, but can't be currently
                // because we only provide an interface not a wrapper
                _this.zone.run(function () {
                    _this.itemNavigation.navigateToItem(name, {});
                });
            };
        }
        RootComponent.prototype.ngOnInit = function () {
            if (this.events) {
                this.events.subscribe('navigation.viewItem', this.eventListener);
            }
            if (this.stepupService && this.stepupContainer) {
                this.stepupService.createStepUpComponent(this.stepupContainer);
            }
            if (this.sessionTimeoutService && this.sessionTimeoutContainer) {
                this.sessionTimeoutService.createSessionTimeoutComponent(this.sessionTimeoutContainer);
            }
        };
        RootComponent.prototype.ngOnDestroy = function () {
            if (this.events) {
                this.events.unsubscribe('navigation.viewItem', this.eventListener);
            }
        };
        return RootComponent;
    }());
    RootComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'bb-root',
                    template: "\n    <bb-area [children]=\"children | async\"></bb-area>\n    <template #stepupContainer></template>\n    <template #sessionTimeoutContainer></template>\n  ",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    RootComponent.ctorParameters = function () { return [
        { type: ӨRootContainerService },
        { type: i0.NgZone },
        { type: ӨItemNavigationService },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [webSdk.PUBSUB,] }] },
        { type: StepUpService, decorators: [{ type: i0.Optional }] },
        { type: SessionTimeoutService, decorators: [{ type: i0.Optional }] }
    ]; };
    RootComponent.propDecorators = {
        stepupContainer: [{ type: i0.ViewChild, args: ['stepupContainer', { read: i0.ViewContainerRef, static: true },] }],
        sessionTimeoutContainer: [{ type: i0.ViewChild, args: ['sessionTimeoutContainer', { read: i0.ViewContainerRef, static: true },] }]
    };

    var toCommandsArray = function (commands) {
        if (commands != null) {
            return Array.isArray(commands) ? commands : [commands];
        }
        else {
            return [];
        }
    };
    var ɵ0$2 = toCommandsArray;
    var RouterLinkWithHrefDirective = /** @class */ (function () {
        function RouterLinkWithHrefDirective(router$1, bbRouter, locationStrategy, el, renderer) {
            var _this = this;
            this.router = router$1;
            this.bbRouter = bbRouter;
            this.locationStrategy = locationStrategy;
            this.el = el;
            this.renderer = renderer;
            this.commands = [];
            this.subscriptions = [
                router$1.events.subscribe(function (s) {
                    if (s instanceof router.NavigationEnd) {
                        _this.updateTargetUrlAndHref();
                    }
                }),
            ];
        }
        Object.defineProperty(RouterLinkWithHrefDirective.prototype, "bbRouterLink", {
            set: function (commands) {
                this.commands = toCommandsArray(commands);
            },
            enumerable: false,
            configurable: true
        });
        RouterLinkWithHrefDirective.prototype.ngOnChanges = function () {
            this.updateTargetUrlAndHref();
        };
        RouterLinkWithHrefDirective.prototype.ngOnDestroy = function () {
            this.subscriptions.forEach(function (s) { return s.unsubscribe(); });
        };
        RouterLinkWithHrefDirective.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {
            var _this = this;
            if (button !== 0 || ctrlKey || metaKey || shiftKey) {
                return true;
            }
            if (typeof this.target === 'string' && this.target !== '_self') {
                return true;
            }
            var extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
            };
            this.urlTree.then(function (urlTree) {
                _this.router.navigateByUrl(_this.router.serializeUrl(urlTree), extras);
            });
            return false;
        };
        RouterLinkWithHrefDirective.prototype.updateTargetUrlAndHref = function () {
            var _this = this;
            this.urlTree.then(function (urlTree) {
                _this.renderer.setAttribute(_this.el.nativeElement, 'href', _this.locationStrategy.prepareExternalUrl(_this.router.serializeUrl(urlTree)));
            });
        };
        Object.defineProperty(RouterLinkWithHrefDirective.prototype, "urlTree", {
            get: function () {
                return this.bbRouter.createUrlTree(this.commands, Object.assign(Object.assign({ queryParams: this.queryParams, fragment: this.fragment }, (attrBoolValue(this.preserve) ? { queryParamsHandling: 'preserve' } : {})), { queryParamsHandling: this.queryParamsHandling, preserveFragment: attrBoolValue(this.preserveFragment) }));
            },
            enumerable: false,
            configurable: true
        });
        return RouterLinkWithHrefDirective;
    }());
    RouterLinkWithHrefDirective.decorators = [
        { type: i0.Directive, args: [{ selector: 'a[bbRouterLink]' },] }
    ];
    RouterLinkWithHrefDirective.ctorParameters = function () { return [
        { type: router.Router },
        { type: RouterService },
        { type: common.LocationStrategy },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    RouterLinkWithHrefDirective.propDecorators = {
        target: [{ type: i0.HostBinding, args: ['attr.target',] }, { type: i0.Input }],
        queryParams: [{ type: i0.Input }],
        fragment: [{ type: i0.Input }],
        queryParamsHandling: [{ type: i0.Input }],
        preserveFragment: [{ type: i0.Input }],
        skipLocationChange: [{ type: i0.Input }],
        replaceUrl: [{ type: i0.Input }],
        bbRouterLink: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ['click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey'],] }]
    };
    var RouterLinkDirective = /** @class */ (function () {
        function RouterLinkDirective(router, route, tabIndex, renderer, el, bbRouter) {
            this.router = router;
            this.route = route;
            this.bbRouter = bbRouter;
            this.commands = [];
            if (tabIndex == null) {
                renderer.setAttribute(el.nativeElement, 'tabindex', '0');
            }
        }
        Object.defineProperty(RouterLinkDirective.prototype, "bbRouterLink", {
            set: function (commands) {
                this.commands = toCommandsArray(commands);
            },
            enumerable: false,
            configurable: true
        });
        RouterLinkDirective.prototype.onClick = function () {
            var _this = this;
            var extras = {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
            };
            this.urlTree.then(function (urlTree) {
                _this.router.navigateByUrl(_this.router.serializeUrl(urlTree), extras);
            });
            return true;
        };
        Object.defineProperty(RouterLinkDirective.prototype, "urlTree", {
            get: function () {
                return this.bbRouter.createUrlTree(this.commands, Object.assign(Object.assign({ relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment }, (attrBoolValue(this.preserve) ? { queryParamsHandling: 'preserve' } : {})), { queryParamsHandling: this.queryParamsHandling, preserveFragment: attrBoolValue(this.preserveFragment) }));
            },
            enumerable: false,
            configurable: true
        });
        return RouterLinkDirective;
    }());
    RouterLinkDirective.decorators = [
        { type: i0.Directive, args: [{ selector: ':not(a)[bbRouterLink]' },] }
    ];
    RouterLinkDirective.ctorParameters = function () { return [
        { type: router.Router },
        { type: router.ActivatedRoute },
        { type: String, decorators: [{ type: i0.Attribute, args: ['tabindex',] }] },
        { type: i0.Renderer2 },
        { type: i0.ElementRef },
        { type: RouterService }
    ]; };
    RouterLinkDirective.propDecorators = {
        queryParams: [{ type: i0.Input }],
        fragment: [{ type: i0.Input }],
        queryParamsHandling: [{ type: i0.Input }],
        preserveFragment: [{ type: i0.Input }],
        skipLocationChange: [{ type: i0.Input }],
        replaceUrl: [{ type: i0.Input }],
        bbRouterLink: [{ type: i0.Input }],
        onClick: [{ type: i0.HostListener, args: ['click',] }]
    };
    function attrBoolValue(s) {
        return s === '' || !!s;
    }

    /**
     *
     * @description
     *
     * Lets you add a CSS class and `aria-current` attribute to an element when the link's route becomes active.
     *
     * This directive lets you add a CSS class and `aria-current` attribute to an element when the link's route
     * becomes active.
     *
     * Consider the following example:
     *
     * ```
     * <a bbRouterLink="/user/bob" bbRouterLinkActive="active-link">Bob</a>
     * ```
     *
     * When the url is either '/user' or '/user/bob', the active-link class will
     * be added to the `a` tag. If the url changes, the class Will be removed.
     *
     * You can set more than one class, as follows:
     *
     * ```
     * <a bbRouterLink="/user/bob" bbRouterLinkActive="class1 class2">Bob</a>
     * <a bbRouterLink="/user/bob" [bbRouterLinkActive]="['class1', 'class2']">Bob</a>
     * ```
     *
     * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
     * only when the url matches the link exactly.
     *
     * ```
     * <a bbRouterLink="/user/bob" bbRouterLinkActive="active-link" [bbRouterLinkActiveOptions]="{exact:
     * true}">Bob</a>
     * ```
     *
     * You can configure RouterLinkActive to set `aria-current` attribute for all links. If option is defined,
     * value will be added to the active link and `aria-current="false"` to the other links.
     *
     * ```
     * <a bbRouterLink="/user/bob" bbRouterLinkActive="active-link" [bbRouterLinkActiveOptions]="{ariaCurrent: 'page'}">
     *  Bob
     * </a>
     * ```
     *
     * You can assign the RouterLinkActive instance to a template variable and directly check
     * the `isActive` status.
     * ```
     * <a bbRouterLink="/user/bob" bbRouterLinkActive #rla="bbRouterLinkActive">
     *   Bob {{ rla.isActive ? '(already open)' : ''}}
     * </a>
     * ```
     *
     * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
     *
     * ```
     * <div bbRouterLinkActive="active-link" [bbRouterLinkActiveOptions]="{exact: true}">
     *   <a bbRouterLink="/user/jim">Jim</a>
     *   <a bbRouterLink="/user/bob">Bob</a>
     * </div>
     * ```
     *
     * This will set the active-link class on the div tag if the url is either '/user/jim' or
     * '/user/bob'.
     *
     * @ngModule RouterModule
     *
     */
    var RouterLinkActiveDirective = /** @class */ (function () {
        function RouterLinkActiveDirective(router$1, element, renderer, link, linkWithHref) {
            var _this = this;
            this.router = router$1;
            this.element = element;
            this.renderer = renderer;
            this.link = link;
            this.linkWithHref = linkWithHref;
            this.classes = [];
            this.isActive = false;
            this.bbRouterLinkActiveOptions = {};
            this.subscription = router$1.events.subscribe(function (s) {
                if (s instanceof router.NavigationEnd) {
                    _this.update();
                }
            });
        }
        RouterLinkActiveDirective.prototype.ngAfterContentInit = function () {
            var _this = this;
            if (!this.links || !this.linksWithHrefs)
                return;
            this.links.changes.subscribe(function (_) { return _this.update(); });
            this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
            this.update();
        };
        Object.defineProperty(RouterLinkActiveDirective.prototype, "bbRouterLinkActive", {
            set: function (data) {
                var classes = Array.isArray(data) ? data : data.split(' ');
                this.classes = classes.filter(function (c) { return !!c; });
            },
            enumerable: false,
            configurable: true
        });
        RouterLinkActiveDirective.prototype.ngOnChanges = function () {
            this.update();
        };
        RouterLinkActiveDirective.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        RouterLinkActiveDirective.prototype.updateClasses = function (hasActiveLinks) {
            var _this = this;
            this.classes.forEach(function (c) {
                if (hasActiveLinks) {
                    _this.renderer.addClass(_this.element.nativeElement, c);
                }
                else {
                    _this.renderer.removeClass(_this.element.nativeElement, c);
                }
            });
        };
        RouterLinkActiveDirective.prototype.updateAria = function (hasActiveLinks) {
            var ariaAttr = 'aria-current';
            if (this.bbRouterLinkActiveOptions.ariaCurrent) {
                this.renderer.setAttribute(this.element.nativeElement, ariaAttr, hasActiveLinks ? this.bbRouterLinkActiveOptions.ariaCurrent : 'false');
            }
            else {
                this.renderer.removeAttribute(this.element.nativeElement, ariaAttr);
            }
        };
        RouterLinkActiveDirective.prototype.update = function () {
            var _this = this;
            if (!this.links || !this.linksWithHrefs || !this.router.navigated)
                return;
            this.hasActiveLinks().then(function (hasActiveLinks) {
                if (_this.isActive !== hasActiveLinks) {
                    _this.isActive = hasActiveLinks;
                    _this.updateAria(hasActiveLinks);
                    _this.updateClasses(hasActiveLinks);
                }
            });
        };
        RouterLinkActiveDirective.prototype.isLinkActive = function (router) {
            var _this = this;
            return function (link) { return link.urlTree.then(function (urlTree) { return router.isActive(urlTree, !!_this.bbRouterLinkActiveOptions.exact); }); };
        };
        RouterLinkActiveDirective.prototype.hasActiveLinks = function () {
            if (!this.links || !this.linksWithHrefs)
                return Promise.resolve(false);
            return Promise.all(__spreadArray(__spreadArray([
                this.link ? this.isLinkActive(this.router)(this.link) : Promise.resolve(false),
                this.linkWithHref ? this.isLinkActive(this.router)(this.linkWithHref) : Promise.resolve(false)
            ], __read(this.links.map(this.isLinkActive(this.router)))), __read(this.linksWithHrefs.map(this.isLinkActive(this.router))))).then(function (liveActives) { return liveActives.some(function (a) { return a; }); });
        };
        return RouterLinkActiveDirective;
    }());
    RouterLinkActiveDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[bbRouterLinkActive]',
                    exportAs: 'bbRouterLinkActive',
                },] }
    ];
    RouterLinkActiveDirective.ctorParameters = function () { return [
        { type: router.Router },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: RouterLinkDirective, decorators: [{ type: i0.Optional }] },
        { type: RouterLinkWithHrefDirective, decorators: [{ type: i0.Optional }] }
    ]; };
    RouterLinkActiveDirective.propDecorators = {
        links: [{ type: i0.ContentChildren, args: [RouterLinkDirective, { descendants: true },] }],
        linksWithHrefs: [{ type: i0.ContentChildren, args: [RouterLinkWithHrefDirective, { descendants: true },] }],
        bbRouterLinkActiveOptions: [{ type: i0.Input }],
        bbRouterLinkActive: [{ type: i0.Input }]
    };

    var OUTLET_IS_NOT_INITIALIZED_ERROR = 'Outlet is not instantiated';
    /**
     * Includes the component associated with the current Route
     */
    var RouterOutletDirective = /** @class */ (function () {
        function RouterOutletDirective(childrenOutletContexts, componentFactoryResolver, vcRef, cdRef, router, bbRouter) {
            this.childrenOutletContexts = childrenOutletContexts;
            this.componentFactoryResolver = componentFactoryResolver;
            this.vcRef = vcRef;
            this.cdRef = cdRef;
            this.router = router;
            this.bbRouter = bbRouter;
            this.destroy$ = new rxjs.Subject();
            /**
             * A router outlet will emit an activate event any time a new component
             * is being instantiated.
             */
            // eslint-disable-next-line  @angular-eslint/no-output-rename
            this.activateEvents = new i0.EventEmitter();
            /**
             * A router outlet will emit a deactivate event when the route component
             * is being destroyed.
             */
            // eslint-disable-next-line  @angular-eslint/no-output-rename
            this.deactivateEvents = new i0.EventEmitter();
        }
        Object.defineProperty(RouterOutletDirective.prototype, "name", {
            get: function () {
                return this.nameValue || router.PRIMARY_OUTLET;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RouterOutletDirective.prototype, "isActivated", {
            get: function () {
                return this.outlet ? this.outlet.isActivated : false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RouterOutletDirective.prototype, "component", {
            get: function () {
                if (!this.outlet) {
                    throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
                }
                return this.outlet.component;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RouterOutletDirective.prototype, "activatedRoute", {
            get: function () {
                if (!this.outlet) {
                    throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
                }
                return this.outlet.activatedRoute;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RouterOutletDirective.prototype, "activatedRouteData", {
            get: function () {
                if (!this.outlet) {
                    return {};
                }
                return this.outlet.activatedRouteData;
            },
            enumerable: false,
            configurable: true
        });
        RouterOutletDirective.prototype.destroy = function () {
            var _this = this;
            if (this.nameValue) {
                return this.removeOutletFromUrl()
                    .then(function () { return _this.router.navigate(['/']); })
                    .then(function () { return _this.destroyChild(); });
            }
            else {
                return Promise.resolve();
            }
        };
        RouterOutletDirective.prototype.destroyChild = function () {
            if (this.outlet) {
                this.outlet.ngOnDestroy();
            }
        };
        RouterOutletDirective.prototype.removeOutletFromUrl = function () {
            var _a;
            // @todo: It's not possible to remove an outlet from the navigation.
            // @see: https://github.com/angular/angular/issues/15338 (this workaround is from there)
            return this.nameValue ? this.router.navigate([{ outlets: (_a = {}, _a[this.nameValue] = null, _a) }]) : Promise.resolve(true);
        };
        RouterOutletDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.bbRouter.outletName.pipe(operators.takeUntil(this.destroy$)).subscribe(function (outletName) {
                _this.destroy().then(function () {
                    _this.nameValue = outletName;
                    _this.outlet = new router.RouterOutlet(_this.childrenOutletContexts, _this.vcRef, _this.componentFactoryResolver, _this.name, _this.cdRef);
                    _this.outlet.activateEvents.subscribe(function (event) {
                        _this.activateEvents.next(event);
                    });
                    _this.outlet.deactivateEvents.subscribe(function (event) {
                        _this.deactivateEvents.next(event);
                    });
                    // Doesn't implement the `RouterOutlet` interface due to private members
                    _this.childrenOutletContexts.onChildOutletCreated(_this.name, _this);
                    _this.outlet.ngOnInit();
                });
            });
        };
        RouterOutletDirective.prototype.ngOnDestroy = function () {
            this.destroy$.next();
            this.destroy$.complete();
            this.destroyChild();
            this.childrenOutletContexts.onChildOutletDestroyed(this.name);
        };
        RouterOutletDirective.prototype.attach = function (ref, activatedRoute) {
            if (!this.outlet) {
                throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
            }
            return this.outlet.attach(ref, activatedRoute);
        };
        RouterOutletDirective.prototype.detach = function () {
            if (!this.outlet) {
                throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
            }
            return this.outlet.detach();
        };
        RouterOutletDirective.prototype.deactivate = function () {
            if (this.outlet) {
                this.outlet.deactivate();
            }
        };
        RouterOutletDirective.prototype.activateWith = function (activatedRoute, resolver) {
            if (!this.outlet) {
                throw new Error(OUTLET_IS_NOT_INITIALIZED_ERROR);
            }
            // Not sure how hacky this is - forcefully deactivating the outlet before reactivating it.
            this.outlet.deactivate();
            return this.outlet.activateWith(activatedRoute, resolver);
        };
        return RouterOutletDirective;
    }());
    RouterOutletDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'bb-router-outlet',
                    exportAs: 'bbOutlet',
                },] }
    ];
    RouterOutletDirective.ctorParameters = function () { return [
        { type: router.ChildrenOutletContexts },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ViewContainerRef },
        { type: i0.ChangeDetectorRef },
        { type: router.Router },
        { type: RouterService }
    ]; };
    RouterOutletDirective.propDecorators = {
        activateEvents: [{ type: i0.Output, args: ['activate',] }],
        deactivateEvents: [{ type: i0.Output, args: ['deactivate',] }]
    };

    var noop = undefined;
    function createRouteConfigBootstrap(routerBootstrap) {
        return routerBootstrap.bootstrap.bind(routerBootstrap);
    }
    var notEmpty = function (a) { return a.length > 0; };
    var ɵ0$1 = notEmpty;
    var itemToNavigate = function (update) {
        if (isInsert(update)) {
            // navigate to the first child of inserted item (if exists) or to the item itself
            return {
                name: update.item.name,
                nthChild: isContainer(update.item) && notEmpty(update.item.children) ? 0 : undefined,
            };
        }
        else if (isPropertyUpdate(update)) {
            // navigate to the updated item (@todo: if this item is currently active)
            return { name: update.name };
        }
        else if (isRemovalUpdate(update)) {
            // navigate to the nth child of the parent
            return { name: update.parentName, nthChild: update.index };
        }
        else {
            throw Error('not handled model update');
        }
    };
    var ɵ1$1 = itemToNavigate;
    var RouterBootstrapService = /** @class */ (function () {
        function RouterBootstrapService(routerConfig, router, rootModel, itemNavigation) {
            this.routerConfig = routerConfig;
            this.router = router;
            this.rootModel = rootModel;
            this.itemNavigation = itemNavigation;
            this.bootstrapRoutes = this.routerConfig.routes.pipe(operators.take(1));
            this.updateRoutes = this.routerConfig.routes.pipe(operators.skip(1), operators.withLatestFrom(this.rootModel.modelUpdates.pipe(operators.startWith(noop))));
        }
        RouterBootstrapService.prototype.bootstrap = function () {
            var _this = this;
            var initialRoutes = this.router.config;
            this.bootstrapRoutes.subscribe(function (routes) {
                _this.router.resetConfig(__spreadArray(__spreadArray([], __read(routes)), __read(initialRoutes)));
                _this.router.initialNavigation();
            });
            var lastUpdate;
            this.updateRoutes.subscribe(function (_a) {
                var _b = __read(_a, 2), routes = _b[0], update = _b[1];
                _this.router.resetConfig(__spreadArray(__spreadArray([], __read(routes)), __read(initialRoutes)));
                if (update && lastUpdate !== update) {
                    lastUpdate = update;
                    _this.navigateOnUpdates(update);
                }
                else {
                    _this.router.navigateByUrl(_this.router.url, { skipLocationChange: true });
                }
            });
        };
        RouterBootstrapService.prototype.navigateOnUpdates = function (update) {
            var _this = this;
            var itemNavigation = itemToNavigate(update);
            var navigation = itemNavigation.nthChild !== undefined
                ? this.itemNavigation.navigateToChild(itemNavigation.name, itemNavigation.nthChild, {})
                : this.itemNavigation.navigateToItem(itemNavigation.name, {});
            navigation.then(function (result) {
                if (!result) {
                    // If the navigation failed, it might be because the item
                    // was not within a routable item, so it can't be navigated to.
                    // In this case, we trigger a navigation to '/' to trigger
                    // and new redirects (this use-case is when a "deck-container" is
                    // dropped onto the root of the page, we need to trigger the
                    // redirect to the first route).
                    // @todo: is there a better way to trigger redirects?
                    // @todo: is there a better way to know that the navigation
                    //   failure was because it was to a non-routable item? maybe
                    //   it should throw instead of resolve false?
                    _this.router.navigateByUrl('/');
                }
            });
        };
        return RouterBootstrapService;
    }());
    RouterBootstrapService.decorators = [
        { type: i0.Injectable }
    ];
    RouterBootstrapService.ctorParameters = function () { return [
        { type: RouterConfigService },
        { type: router.Router },
        { type: ӨRootContainerService },
        { type: ӨItemNavigationService }
    ]; };

    var DEPRECATED_WITH_CONFIG = new i0.InjectionToken('Flags whether BackbaseCoreModule.withConfig was called with deprecated options');
    var logDeprecatedConfig = function (deprecationService, deprecatedConfigs) {
        var deprecatedOptions = deprecatedConfigs.reduce(function (acc, deprecatedConfig) { return __spreadArray(__spreadArray([], __read(acc)), __read(Object.keys(deprecatedConfig).filter(function (key) { return deprecatedConfig[key] !== undefined; }))); }, []);
        if (deprecatedOptions.length > 0) {
            deprecationService.logDeprecatedFeature("Deprecated options (" + deprecatedOptions.join(', ') + ") " +
                'being used with BackbaseCoreModule.withConfig. Use BackbaseCoreModule.forRoot instead.');
        }
    };
    var createLogDeprecatedConfig = function (deprecationService, deprecatedConfig) {
        return logDeprecatedConfig.bind(null, deprecationService, deprecatedConfig);
    };

    var TAG = 'memory';
    /**
     * @deprecated Will be removed in v7.0.0
     * Memory Communication Transport
     *
     * Can be used to configure communication using Memory.
     *
     * @usageNotes
     *
     * Pass some data to widget-b via an in memory store
     *
     * ```json
     * {
     *   "name": "widget-a",
     *   "properties": {
     *     "output.myOutput": Memory.toProperty("myGroupName")
     *   }
     * },
     * {
     *   "name": "widget-b",
     *   "properties": {
     *     "input.myInput": Memory.toProperty("myGroupName")
     *   }
     * }
     * ```
     */
    var Memory = /** @class */ (function () {
        function Memory() {
        }
        /**
         * Generate a serialized communication configuration suitable for use as a Widget Input or Output property value.
         *
         * @param group The name of the communication group to which the Input/Output belongs
         */
        Memory.toProperty = function (group) {
            return communicationProperty.serializerDeserializer.toProperty(new communicationProperty.CommunicationDefinition(TAG, group));
        };
        return Memory;
    }());
    /**
     * @deprecated Will be removed in v7.0.0
     * Storage service to retain the values for each communication group that is using the Memory transport
     */
    var MemoryStorageService = /** @class */ (function () {
        function MemoryStorageService() {
            this.storage = new Map();
        }
        MemoryStorageService.prototype.getSubject = function (group) {
            if (!this.storage.has(group)) {
                this.storage.set(group, new rxjs.ReplaySubject(1));
            } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.storage.get(group);
        };
        /**
         * Get an Observable of the values being communicated to the given group
         *
         * @param group The name of the communication group
         */
        MemoryStorageService.prototype.get = function (group) {
            return this.getSubject(group)
                .asObservable()
                .pipe(operators.map(function (item) {
                var localValue = item.value;
                if (typeof item.value === 'object' && item.value['_clearPayload'] === true) {
                    item.value = undefined;
                }
                return localValue;
            }));
        };
        /**
         * Communicate some value to members of the given communication group
         *
         * @param group The name of the communication group
         * @param value The value to communicate
         */
        MemoryStorageService.prototype.set = function (group, value) {
            this.getSubject(group).next({ value: value });
        };
        return MemoryStorageService;
    }());
    MemoryStorageService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function MemoryStorageService_Factory() { return new MemoryStorageService(); }, token: MemoryStorageService, providedIn: "root" });
    MemoryStorageService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    var createMemory = function (itemNavigation, rootModel, storage) {
        return {
            source: function (group) { return function () { return storage.get(group); }; },
            sink: function (group) { return function (stdin) {
                var commonAncestorItem = getItemFormCommunicationGroup(group, rootModel);
                return stdin
                    .pipe(operators.concatMap(function (data) { return commonAncestorItem.pipe(operators.map(function (item) { return [data, item.name]; })); }))
                    .subscribe(function (_a) {
                    var _b = __read(_a, 2), data = _b[0], name = _b[1];
                    rxjs.asyncScheduler.schedule(function () {
                        storage.set(group, data);
                    });
                    itemNavigation.navigateToItem(name, {});
                });
            }; },
        };
    };
    /**
     * @deprecated Will be removed in v7.0.0
     */
    var memoryProcessorConfig = createPipelineProcessorConfig(TAG, {
        provide: new i0.InjectionToken('Memory pipeline handler'),
        useFactory: createMemory,
        deps: [ӨItemNavigationService, ӨRootContainerService, MemoryStorageService],
    });
    function getItemFormCommunicationGroup(group, rootModel) {
        var communicationDefinition = new communicationProperty.CommunicationDefinition(TAG, group);
        var commonAncestorItem = rootModel.commonAncestor(communicationDefinition).pipe(operators.first(), operators.filter(function (item) {
            if (item === undefined) {
                console.warn("No Inputs configured to receive in memory value for communication group \"" + group + "\"");
                return false;
            }
            return true;
        }));
        return commonAncestorItem;
    }

    var coreComponents = [
        RootComponent,
        AreaComponent,
        ChromeComponent,
        RouteComponent,
        OutletCollisionComponent,
        JourneyComponent,
    ];
    var coreDirectives = [
        RouterLinkDirective,
        RouterLinkWithHrefDirective,
        RouterLinkActiveDirective,
        RouterOutletDirective,
    ];
    var ɵ0 = createRouteConfigBootstrap, ɵ1 = createLogDeprecatedConfig, ɵ2 = createInputBootstrap, ɵ3 = createOutputBootstrap, ɵ5 = {
        RootComponent: RootComponent,
    }, ɵ6 = [
        debugProcessorConfig,
        pluckProcessorConfig,
        routeParamsProcessorConfig,
        routeParamsMultiProcessorConfig,
        itemNavigateProcessorConfig,
        modelProcessorConfig,
        appConfigProcessorConfig,
        urlProcessorConfig,
        navigationProcessorConfig,
        memoryProcessorConfig,
        routerNavigateProcessorConfig,
    ], ɵ7 = {}, ɵ8 = [], ɵ9 = {}, ɵ10 = {};
    var BackbaseCoreModule = /** @class */ (function () {
        function BackbaseCoreModule() {
        }
        /**
         * Creates a module that will populate entryComponents with Components passed as classMap
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * @NgModule({
         *   imports: [
         *     BackbaseCoreModule.withConfig({
         *       classMap: {
         *         myClassId: MyComponent
         *       }
         *     })
         *   ]
         * })
         * class MyModule {}
         * ```
         */
        BackbaseCoreModule.withConfig = function (config) {
            return {
                ngModule: BackbaseCoreModule,
                providers: [
                    {
                        provide: i0.ANALYZE_FOR_ENTRY_COMPONENTS,
                        useValue: config.classMap || {},
                        multi: true,
                    },
                    {
                        provide: CONFIG_COMPONENT_CLASS_MAP,
                        useValue: config.classMap || {},
                        multi: true,
                    },
                    {
                        provide: CONFIG_ROUTE_GUARDS,
                        multi: true,
                        useValue: config.guards || {},
                    },
                    {
                        provide: CONFIG_PIPELINE_PROCESSORS,
                        useValue: config.pipelineProcessors || [],
                        multi: true,
                    },
                ],
            };
        };
        /**
         * Creates a configured BackbaseCoreModule.
         *
         * This should be called only once per app.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * @NgModule({
         *   imports: [
         *     BackbaseCoreModule.forRoot({
         *       classMap: {
         *         myClassId: MyComponent,
         *         logDeprecations: true,
         *       }
         *     })
         *   ]
         * })
         * class AppModule {}
         * ```
         */
        BackbaseCoreModule.forRoot = function (config) {
            return {
                ngModule: BackbaseCoreModule,
                providers: [
                    {
                        provide: i0.ANALYZE_FOR_ENTRY_COMPONENTS,
                        useValue: config.classMap || {},
                        multi: true,
                    },
                    {
                        provide: CONFIG_COMPONENT_CLASS_MAP,
                        useValue: config.classMap || {},
                        multi: true,
                    },
                    {
                        provide: CONFIG_FLOWS,
                        multi: true,
                        useValue: config.flows || [],
                    },
                    {
                        provide: CONFIG_ROUTE_GUARDS,
                        multi: true,
                        useValue: config.guards || {},
                    },
                    {
                        provide: CONFIG_ASSETS,
                        multi: false,
                        useValue: config.assets || {
                            assetsStaticItemName: '',
                        },
                    },
                    {
                        provide: future.LOG_DEPRECATIONS_CONFIG,
                        multi: false,
                        useValue: !!config.logDeprecations,
                    },
                    {
                        provide: future.ENABLED_FEATURES_CONFIG,
                        multi: false,
                        useValue: config.features || {},
                    },
                    {
                        provide: CONFIG_PIPELINE_PROCESSORS,
                        useValue: config.pipelineProcessors || [],
                        multi: true,
                    },
                    {
                        provide: LAZY_MAP,
                        useValue: config.lazyModules || undefined,
                        multi: false,
                    },
                ],
            };
        };
        return BackbaseCoreModule;
    }());
    BackbaseCoreModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, router.RouterModule],
                    declarations: __spreadArray(__spreadArray([], __read(coreComponents)), __read(coreDirectives)),
                    exports: __spreadArray(__spreadArray([], __read(coreComponents)), __read(coreDirectives)),
                    entryComponents: coreComponents,
                    providers: [
                        RootItemModelService,
                        ItemRegistryService,
                        BackbaseConnector,
                        ӨItemNavigationService,
                        ItemTransitionService,
                        RouteGuardsRegistryService,
                        RouterNavigationService,
                        RouterService,
                        future.DeprecationsService,
                        OutputBrokerService,
                        InputBrokerService,
                        RouterBootstrapService,
                        ItemInjectorService,
                        FlowsService,
                        AssetsService,
                        ItemLoaderService,
                        CombinedComponentFactoryResolver,
                        {
                            provide: i0.APP_BOOTSTRAP_LISTENER,
                            useFactory: ɵ0,
                            deps: [RouterBootstrapService],
                            multi: true,
                        },
                        {
                            provide: i0.APP_BOOTSTRAP_LISTENER,
                            useFactory: ɵ1,
                            deps: [future.DeprecationsService, DEPRECATED_WITH_CONFIG],
                            multi: true,
                        },
                        {
                            provide: i0.APP_BOOTSTRAP_LISTENER,
                            useFactory: ɵ2,
                            deps: [InputBrokerService],
                            multi: true,
                        },
                        {
                            provide: i0.APP_BOOTSTRAP_LISTENER,
                            useFactory: ɵ3,
                            deps: [OutputBrokerService],
                            multi: true,
                        },
                        {
                            provide: CONFIG_COMPONENT_CLASS_MAP,
                            useValue: ɵ5,
                            multi: true,
                        },
                        {
                            provide: CONFIG_PIPELINE_PROCESSORS,
                            useValue: ɵ6,
                            multi: true,
                        },
                        {
                            provide: AbstractRouterConfigService,
                            useExisting: RouterConfigService,
                        },
                        // Defaults, overrided by forRoot and withConfig
                        {
                            provide: CONFIG_COMPONENT_CLASS_MAP,
                            useValue: ɵ7,
                            multi: true,
                        },
                        {
                            provide: CONFIG_FLOWS,
                            multi: true,
                            useValue: ɵ8,
                        },
                        {
                            provide: CONFIG_ROUTE_GUARDS,
                            multi: true,
                            useValue: ɵ9,
                        },
                        {
                            provide: DEPRECATED_WITH_CONFIG,
                            useValue: ɵ10,
                            multi: true,
                        },
                    ],
                },] }
    ];

    /**
     *
     * @deprecated Will be removed in v7.0.0
     *
     * @description
     * Every custom template directive should extend this class.
     * See 'How to make widget customizable'
     *
     * @usageNotes
     *
     * ### Example
     * ```
     * import { Component, Directive } from '@angular/core';
     * import { BbTemplate, ItemModel } from '@backbase/foundation-ang/core';
     *
     * @Component({
     *   selector: 'my-widget',
     *   template: `
     *   <li *ngFor="let item of pallete">
     *     My colors:
     *     <ng-container
     *       customItemTemplate
     *       [bbHostRef]="hostRef"
     *       [bbTemplateContext]="item"
     *     ></ng-container>
     *   </li>
     *
     *   <ng-template customItemTemplate let-hostRef let-item="context">
     *     Current name: {{ item.color }}
     *     Hex value: {{ hostRef.getHexColor(item.color) }}
     *   </ng-template>
     *   `,
     * })
     * export class MyWidgetComponent {
     *   readonly hostRef = this;
     *   readonly palette: Array<PaletteItem> = [{
     *     color: 'blue',
     *   }];
     *   readonly hexValues = {
     *     blue: '0000ff',
     *   };
     *
     *   constructor(private itemModel: ItemModel) {}
     *
     *   getHexColor(color: string): string | undefined {
     *     return this.hexValues[color];
     *   }
     * }
     *
     * type PaletteItem {
     *   color: string;
     * };
     *
     * @Directive({
     *   selector: '[customItemTemplate]',
     * })
     * export class customItemTemplate extends BbTemplate<MyWidgetComponent, PaletteItem> {}
     * ```
     */
    /* eslint-disable @angular-eslint/directive-class-suffix */
    var BbTemplate = /** @class */ (function () {
        function BbTemplate(viewContainerRef, registry, templateRef) {
            this.viewContainerRef = viewContainerRef;
            this.registry = registry;
            this.templateRef = templateRef;
        }
        /**
         * @internal
         */
        BbTemplate.prototype.ngOnInit = function () {
            this.checkContainerHasHostRef();
            this.checkNgTemplateIsNotUsedtoDefineSlot();
            if (this.isContainer) {
                this.waitTemplate();
            }
            else {
                this.registry.set(this.templateId(), this.templateRef);
            }
        };
        BbTemplate.prototype.templateId = function () {
            return this.constructor;
        };
        BbTemplate.prototype.checkContainerHasHostRef = function () {
            if (this.isContainer && this.bbHostRef === undefined) {
                throw new Error(this.constructor.name + ": Missing required input [bbHostRef]");
            }
        };
        BbTemplate.prototype.checkNgTemplateIsNotUsedtoDefineSlot = function () {
            if (!this.isContainer && this.bbHostRef) {
                throw new Error(this.constructor.name + ": [bbHostRef] should not be used in conjunction with <ng-template>. Use <ng-container> instead.");
            }
        };
        /**
         * @internal
         */
        BbTemplate.prototype.ngOnChanges = function (changes) {
            if (!this.customTemplateContext) {
                return;
            }
            if ('bbTemplateContext' in changes) {
                this.customTemplateContext.context = changes.bbTemplateContext.currentValue;
            }
        };
        BbTemplate.prototype.waitTemplate = function () {
            var _this = this;
            var templateSubject = this.registry.get(this.templateId());
            this.templateSubscription = templateSubject.subscribe(function (tempalateRef) {
                _this.viewContainerRef.clear();
                _this.customTemplateContext = _this.createContext();
                var view = tempalateRef.createEmbeddedView(_this.customTemplateContext);
                _this.viewContainerRef.insert(view);
            });
        };
        /**
         * @internal
         */
        BbTemplate.prototype.ngOnDestroy = function () {
            if (this.templateSubscription) {
                this.templateSubscription.unsubscribe();
            }
        };
        BbTemplate.prototype.createContext = function () {
            if (this.bbHostRef === undefined) {
                throw new Error(this.constructor.name + ": Missing required input [bbHostRef]");
            }
            return {
                $implicit: this.bbHostRef,
                context: this.bbTemplateContext,
            };
        };
        Object.defineProperty(BbTemplate.prototype, "isContainer", {
            get: function () {
                return !this.templateRef;
            },
            enumerable: false,
            configurable: true
        });
        return BbTemplate;
    }());
    BbTemplate.decorators = [
        { type: i0.Directive, args: [{},] }
    ];
    BbTemplate.ctorParameters = function () { return [
        { type: i0.ViewContainerRef },
        { type: TemplateRegistry },
        { type: i0.TemplateRef, decorators: [{ type: i0.Optional }] }
    ]; };
    BbTemplate.propDecorators = {
        bbTemplateContext: [{ type: i0.Input }],
        bbHostRef: [{ type: i0.Input }]
    };

    /**
     * @deprecated Will be removed in v7.0.0
     */
    var StepUpModule = /** @class */ (function () {
        function StepUpModule() {
        }
        StepUpModule.forRoot = function (config) {
            return {
                ngModule: StepUpModule,
                providers: [
                    {
                        provide: i0.ANALYZE_FOR_ENTRY_COMPONENTS,
                        useValue: [config.mediatorComponentClass],
                        multi: true,
                    },
                    {
                        provide: STEPUP_CONFIG,
                        useValue: config,
                    },
                    {
                        provide: http.HTTP_INTERCEPTORS,
                        useClass: StepUpInterceptor,
                        deps: [StepUpService, STEPUP_CONFIG, i0.Injector],
                        multi: true,
                    },
                    {
                        provide: StepUpService,
                        useClass: StepUpService,
                        deps: [i0.ComponentFactoryResolver, STEPUP_CONFIG],
                    },
                ],
            };
        };
        return StepUpModule;
    }());
    StepUpModule.decorators = [
        { type: i0.NgModule, args: [{},] }
    ];

    var SessionTimeoutModule = /** @class */ (function () {
        function SessionTimeoutModule() {
        }
        /**
         * Creates a configured SessionTimeoutModule.
         *
         * This should be called only once per app.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * @NgModule({
         *   imports: [
         *     SessionTimeoutModule.forRoot({
         *       classMap: {
         *         sessionTimeoutComponentClass: MyCustomSessionTimeoutComponent,
         *         inactivityModalTime: 300,
         *       }
         *     })
         *   ]
         * })
         * class AppModule {}
         * ```
         */
        SessionTimeoutModule.forRoot = function (config) {
            return {
                ngModule: SessionTimeoutModule,
                providers: [
                    {
                        provide: i0.ANALYZE_FOR_ENTRY_COMPONENTS,
                        useValue: config.sessionTimeoutComponentClass,
                        multi: true,
                    },
                    {
                        provide: SESSION_TIMEOUT_CONFIG,
                        useValue: config,
                    },
                    {
                        provide: SessionTimeoutService,
                        useClass: SessionTimeoutService,
                        deps: [i0.ComponentFactoryResolver, SESSION_TIMEOUT_CONFIG],
                    },
                ],
            };
        };
        return SessionTimeoutModule;
    }());
    SessionTimeoutModule.decorators = [
        { type: i0.NgModule, args: [{},] }
    ];

    /**
     * Exposes Angular Single Page Application bootstrap method `window.BB.startSingleApp`
     * @param createNgModule Function that accepts StaticProviders and returns NgModuleRef
     * @usageNotes
     * ### Example
     *
     * ```
     * window.BB.startSingleApp = registerSingleApp(createNgModule);
     *
     * window.BB.startSingleApp(webSdkServices, staticProviders)
     *   .then((bbConnector: BackbaseConnector) => bbConector.bootstrap(item, itemLocation));
     * ```
     */
    function registerSingleApp(createNgModule) {
        var startSingleApp = function (externalServices) {
            if (externalServices === void 0) { externalServices = {}; }
            var providers = [
                {
                    provide: webSdk["ɵEXTERNAL_SERVICES"],
                    useValue: externalServices,
                },
            ];
            return createNgModule(providers).then(function (moduleRef) { return moduleRef.injector.get(BackbaseConnector); });
        };
        window.BB = window.BB || {};
        Object.assign(window.BB, { startSingleApp: startSingleApp });
        return startSingleApp;
    }

    /**
     * Generated bundle index. Do not edit.
     */

    Object.defineProperty(exports, 'DeprecationsService', {
        enumerable: true,
        get: function () { return future.DeprecationsService; }
    });
    Object.defineProperty(exports, 'FeaturesService', {
        enumerable: true,
        get: function () { return future.FeaturesService; }
    });
    Object.defineProperty(exports, 'FutureFeaturesModule', {
        enumerable: true,
        get: function () { return future.FutureFeaturesModule; }
    });
    exports.AppConfig = AppConfig;
    exports.AssetsService = AssetsService;
    exports.BackbaseConnector = BackbaseConnector;
    exports.BackbaseCoreModule = BackbaseCoreModule;
    exports.BbTemplate = BbTemplate;
    exports.CopyRoutes = CopyRoutes;
    exports.ItemModel = ItemModel;
    exports.ItemModelTree = ItemModelTree;
    exports.Memory = Memory;
    exports.RootItemModelService = RootItemModelService;
    exports.RoutableContainer = RoutableContainer;
    exports.RoutableWidget = RoutableWidget;
    exports.RouteParam = RouteParam;
    exports.RouterConfigService = RouterConfigService;
    exports.RouterNavigateParamPlaceholder = RouterNavigateParamPlaceholder;
    exports.RouterNavigateSink = RouterNavigateSink;
    exports.RouterNavigateSource = RouterNavigateSource;
    exports.RouterOutletDirective = RouterOutletDirective;
    exports.RouterService = RouterService;
    exports.SessionTimeoutModule = SessionTimeoutModule;
    exports.StepUpInterceptor = StepUpInterceptor;
    exports.StepUpModule = StepUpModule;
    exports.TemplateRegistry = TemplateRegistry;
    exports.createPipelineProcessorConfig = createPipelineProcessorConfig;
    exports.mapObservableArray = mapObservableArray;
    exports.registerSingleApp = registerSingleApp;
    exports["ɵa"] = CONFIG_ASSETS;
    exports["ɵb"] = ItemLifecycleService;
    exports["ɵba"] = SessionTimeoutService;
    exports["ɵbb"] = LAZY_MAP;
    exports["ɵbc"] = journeyItemModelFactory;
    exports["ɵbd"] = storeNameFactory;
    exports["ɵbe"] = AbstractRouterConfigService;
    exports["ɵbf"] = RouterNavigationService;
    exports["ɵbg"] = ItemInjectorService;
    exports["ɵbh"] = InputBrokerService;
    exports["ɵbi"] = createInputBootstrap;
    exports["ɵbj"] = OutputBrokerService;
    exports["ɵbk"] = createOutputBootstrap;
    exports["ɵbl"] = ItemLoaderService;
    exports["ɵbm"] = CombinedComponentFactoryResolver;
    exports["ɵbn"] = AppConfigService;
    exports["ɵbo"] = ItemTransitionService;
    exports["ɵbp"] = createRouteConfigBootstrap;
    exports["ɵbq"] = RouterBootstrapService;
    exports["ɵbr"] = makeDebugPipe;
    exports["ɵbs"] = debugProcessorConfig;
    exports["ɵbt"] = pluckProcessorConfig;
    exports["ɵbu"] = createRouteParamsMulti;
    exports["ɵbv"] = routeParamsMultiProcessorConfig;
    exports["ɵbw"] = createItemNavigate;
    exports["ɵbx"] = itemNavigateProcessorConfig;
    exports["ɵby"] = createModelSource;
    exports["ɵbz"] = modelProcessorConfig;
    exports["ɵc"] = ObservableTree;
    exports["ɵca"] = createUrlSink;
    exports["ɵcb"] = urlProcessorConfig;
    exports["ɵcc"] = pipeName;
    exports["ɵcd"] = navigationHandlerToken;
    exports["ɵce"] = createNavigationSink;
    exports["ɵcf"] = navigationProcessorConfig;
    exports["ɵd"] = CONFIG_ROUTE_GUARDS;
    exports["ɵe"] = RouteGuardsRegistryService;
    exports["ɵf"] = CONFIG_PIPELINE_PROCESSORS;
    exports["ɵg"] = PipelineRegistry;
    exports["ɵh"] = createAppConfigSource;
    exports["ɵi"] = appConfigProcessorConfig;
    exports["ɵj"] = createRouteParams;
    exports["ɵk"] = routeParamsProcessorConfig;
    exports["ɵl"] = MemoryStorageService;
    exports["ɵm"] = createMemory;
    exports["ɵn"] = memoryProcessorConfig;
    exports["ɵo"] = serializeCommands;
    exports["ɵp"] = createRouterNavigateStore;
    exports["ɵq"] = routerNavigateProcessorConfig;
    exports["ɵr"] = DEPRECATED_WITH_CONFIG;
    exports["ɵs"] = createLogDeprecatedConfig;
    exports["ɵt"] = CONFIG_COMPONENT_CLASS_MAP;
    exports["ɵu"] = ItemRegistryService;
    exports["ɵv"] = CONFIG_FLOWS;
    exports["ɵw"] = FlowsService;
    exports["ɵx"] = STEPUP_CONFIG;
    exports["ɵy"] = StepUpService;
    exports["ɵz"] = SESSION_TIMEOUT_CONFIG;
    exports["ӨAreaComponent"] = AreaComponent;
    exports["ӨChromeComponent"] = ChromeComponent;
    exports["ӨItemNavigationService"] = ӨItemNavigationService;
    exports["ӨJourneyComponent"] = JourneyComponent;
    exports["ӨOutletCollisionComponent"] = OutletCollisionComponent;
    exports["ӨRootComponent"] = RootComponent;
    exports["ӨRootContainerService"] = ӨRootContainerService;
    exports["ӨRouteComponent"] = RouteComponent;
    exports["ӨRouterLinkActiveDirective"] = RouterLinkActiveDirective;
    exports["ӨRouterLinkDirective"] = RouterLinkDirective;
    exports["ӨRouterLinkWithHrefDirective"] = RouterLinkWithHrefDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=backbase-foundation-ang-core.umd.js.map
