import { Inject, Injectable, InjectionToken, Injector, Optional } from '@angular/core';
import { fromExamples, MOCKS_EXAMPLES } from './mocks';
import { joinUrl } from './url';
import * as i0 from "@angular/core";
import * as i1 from "./mocks";
const DEFAULT_CONFIG_TOKEN = new InjectionToken(`@backbase/foundation default config token`);
export class DataModulesManager {
    constructor(injector, mockData) {
        this.injector = injector;
        this._mocks = [];
        this.modulesConfig = new Map();
        this.addMockExamples(mockData || []);
    }
    setModuleConfig(token, config) {
        if (this.modulesConfig.has(token)) {
            const current = this.modulesConfig.get(token);
            this.modulesConfig.set(token, Object.assign(Object.assign({}, current), { config }));
        }
        else {
            this.modulesConfig.set(token, {
                config,
            });
        }
        this.updateMocks();
    }
    getMocks() {
        return this._mocks;
    }
    addMockExamples(mockData) {
        var _a, _b, _c;
        for (const { token, examples } of mockData) {
            const configToken = token || DEFAULT_CONFIG_TOKEN;
            const config = (_a = this.injector.get(configToken, null)) !== null && _a !== void 0 ? _a : undefined;
            const allExamples = configToken === DEFAULT_CONFIG_TOKEN
                ? examples.concat((_c = (_b = this.modulesConfig.get(configToken)) === null || _b === void 0 ? void 0 : _b.examples) !== null && _c !== void 0 ? _c : [])
                : examples;
            this.modulesConfig.set(configToken, {
                examples: allExamples,
                config,
            });
        }
        this.updateMocks();
    }
    updateMocks() {
        const mockExamples = [];
        for (const { config, examples } of this.modulesConfig.values()) {
            mockExamples.push(...(examples || []).map(example => this.createURL(example, config)));
        }
        this._mocks = fromExamples(mockExamples);
    }
    createURL(example, serviceConfig) {
        return serviceConfig
            ? Object.assign(Object.assign({}, example), { urlPattern: joinUrl(serviceConfig.apiRoot, serviceConfig.servicePath, example.urlPattern) }) : example;
    }
}
DataModulesManager.ɵprov = i0.ɵɵdefineInjectable({ factory: function DataModulesManager_Factory() { return new DataModulesManager(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.MOCKS_EXAMPLES, 8)); }, token: DataModulesManager, providedIn: "root" });
DataModulesManager.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
DataModulesManager.ctorParameters = () => [
    { type: Injector },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [MOCKS_EXAMPLES,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1tb2R1bGUtbWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2RhdGEtaHR0cC9zcmMvZGF0YS1tb2R1bGUtbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV2RixPQUFPLEVBQUUsWUFBWSxFQUFvQyxjQUFjLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFDekYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE9BQU8sQ0FBQzs7O0FBRWhDLE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxjQUFjLENBQWtCLDJDQUEyQyxDQUFDLENBQUM7QUFHOUcsTUFBTSxPQUFPLGtCQUFrQjtJQVc3QixZQUNVLFFBQWtCLEVBRzFCLFFBQTBCO1FBSGxCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFYcEIsV0FBTSxHQUFxQixFQUFFLENBQUM7UUFFOUIsa0JBQWEsR0FBRyxJQUFJLEdBQUcsRUFNNUIsQ0FBQztRQVFGLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxlQUFlLENBQUMsS0FBNEMsRUFBRSxNQUE2QjtRQUN6RixJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzlDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLEtBQUssa0NBQU8sT0FBTyxLQUFFLE1BQU0sSUFBRyxDQUFDO1NBQ3ZEO2FBQU07WUFDTCxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUU7Z0JBQzVCLE1BQU07YUFDUCxDQUFDLENBQUM7U0FDSjtRQUNELElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBRU8sZUFBZSxDQUFDLFFBQXlCOztRQUMvQyxLQUFLLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLElBQUksUUFBUSxFQUFFO1lBQzFDLE1BQU0sV0FBVyxHQUFHLEtBQUssSUFBSSxvQkFBb0IsQ0FBQztZQUNsRCxNQUFNLE1BQU0sR0FBRyxNQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUErQixXQUFXLEVBQUUsSUFBSSxDQUFDLG1DQUFJLFNBQVMsQ0FBQztZQUUvRixNQUFNLFdBQVcsR0FDZixXQUFXLEtBQUssb0JBQW9CO2dCQUNsQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxNQUFBLE1BQUEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLDBDQUFFLFFBQVEsbUNBQUksRUFBRSxDQUFDO2dCQUN0RSxDQUFDLENBQUMsUUFBUSxDQUFDO1lBRWYsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFO2dCQUNsQyxRQUFRLEVBQUUsV0FBVztnQkFDckIsTUFBTTthQUNQLENBQUMsQ0FBQztTQUNKO1FBRUQsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFTyxXQUFXO1FBQ2pCLE1BQU0sWUFBWSxHQUF1QixFQUFFLENBQUM7UUFDNUMsS0FBSyxNQUFNLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLEVBQUU7WUFDOUQsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN4RjtRQUNELElBQUksQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTyxTQUFTLENBQUMsT0FBb0IsRUFBRSxhQUFxQztRQUMzRSxPQUFPLGFBQWE7WUFDbEIsQ0FBQyxpQ0FDTSxPQUFPLEdBQ1AsRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFFcEcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUNkLENBQUM7Ozs7WUF2RUYsVUFBVSxTQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7O1lBUFcsUUFBUTtZQXVCdEMsS0FBSyx1QkFGZixRQUFRLFlBQ1IsTUFBTSxTQUFDLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlcnZpY2VEYXRhSHR0cENvbmZpZyB9IGZyb20gJy4vZGF0YS1odHRwLWNvbmZpZyc7XG5pbXBvcnQgeyBmcm9tRXhhbXBsZXMsIE1vY2tEYXRhLCBNb2NrRXhhbXBsZSwgTW9ja3NJdGVtLCBNT0NLU19FWEFNUExFUyB9IGZyb20gJy4vbW9ja3MnO1xuaW1wb3J0IHsgam9pblVybCB9IGZyb20gJy4vdXJsJztcblxuY29uc3QgREVGQVVMVF9DT05GSUdfVE9LRU4gPSBuZXcgSW5qZWN0aW9uVG9rZW48QXJyYXk8TW9ja0RhdGE+PihgQGJhY2tiYXNlL2ZvdW5kYXRpb24gZGVmYXVsdCBjb25maWcgdG9rZW5gKTtcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhTW9kdWxlc01hbmFnZXIge1xuICBwcml2YXRlIF9tb2NrczogQXJyYXk8TW9ja3NJdGVtPiA9IFtdO1xuXG4gIHByaXZhdGUgbW9kdWxlc0NvbmZpZyA9IG5ldyBNYXA8XG4gICAgSW5qZWN0aW9uVG9rZW48U2VydmljZURhdGFIdHRwQ29uZmlnPixcbiAgICBQYXJ0aWFsPHtcbiAgICAgIGV4YW1wbGVzOiBBcnJheTxNb2NrRXhhbXBsZT47XG4gICAgICBjb25maWc6IFNlcnZpY2VEYXRhSHR0cENvbmZpZztcbiAgICB9PlxuICA+KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KE1PQ0tTX0VYQU1QTEVTKVxuICAgIG1vY2tEYXRhPzogQXJyYXk8TW9ja0RhdGE+LFxuICApIHtcbiAgICB0aGlzLmFkZE1vY2tFeGFtcGxlcyhtb2NrRGF0YSB8fCBbXSk7XG4gIH1cblxuICBzZXRNb2R1bGVDb25maWcodG9rZW46IEluamVjdGlvblRva2VuPFNlcnZpY2VEYXRhSHR0cENvbmZpZz4sIGNvbmZpZzogU2VydmljZURhdGFIdHRwQ29uZmlnKSB7XG4gICAgaWYgKHRoaXMubW9kdWxlc0NvbmZpZy5oYXModG9rZW4pKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5tb2R1bGVzQ29uZmlnLmdldCh0b2tlbik7XG4gICAgICB0aGlzLm1vZHVsZXNDb25maWcuc2V0KHRva2VuLCB7IC4uLmN1cnJlbnQsIGNvbmZpZyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb2R1bGVzQ29uZmlnLnNldCh0b2tlbiwge1xuICAgICAgICBjb25maWcsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2NrcygpO1xuICB9XG5cbiAgZ2V0TW9ja3MoKTogUmVhZG9ubHlBcnJheTxNb2Nrc0l0ZW0+IHtcbiAgICByZXR1cm4gdGhpcy5fbW9ja3M7XG4gIH1cblxuICBwcml2YXRlIGFkZE1vY2tFeGFtcGxlcyhtb2NrRGF0YTogQXJyYXk8TW9ja0RhdGE+KSB7XG4gICAgZm9yIChjb25zdCB7IHRva2VuLCBleGFtcGxlcyB9IG9mIG1vY2tEYXRhKSB7XG4gICAgICBjb25zdCBjb25maWdUb2tlbiA9IHRva2VuIHx8IERFRkFVTFRfQ09ORklHX1RPS0VOO1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5pbmplY3Rvci5nZXQ8U2VydmljZURhdGFIdHRwQ29uZmlnIHwgbnVsbD4oY29uZmlnVG9rZW4sIG51bGwpID8/IHVuZGVmaW5lZDtcblxuICAgICAgY29uc3QgYWxsRXhhbXBsZXMgPVxuICAgICAgICBjb25maWdUb2tlbiA9PT0gREVGQVVMVF9DT05GSUdfVE9LRU5cbiAgICAgICAgICA/IGV4YW1wbGVzLmNvbmNhdCh0aGlzLm1vZHVsZXNDb25maWcuZ2V0KGNvbmZpZ1Rva2VuKT8uZXhhbXBsZXMgPz8gW10pXG4gICAgICAgICAgOiBleGFtcGxlcztcblxuICAgICAgdGhpcy5tb2R1bGVzQ29uZmlnLnNldChjb25maWdUb2tlbiwge1xuICAgICAgICBleGFtcGxlczogYWxsRXhhbXBsZXMsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlTW9ja3MoKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlTW9ja3MoKSB7XG4gICAgY29uc3QgbW9ja0V4YW1wbGVzOiBBcnJheTxNb2NrRXhhbXBsZT4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsgY29uZmlnLCBleGFtcGxlcyB9IG9mIHRoaXMubW9kdWxlc0NvbmZpZy52YWx1ZXMoKSkge1xuICAgICAgbW9ja0V4YW1wbGVzLnB1c2goLi4uKGV4YW1wbGVzIHx8IFtdKS5tYXAoZXhhbXBsZSA9PiB0aGlzLmNyZWF0ZVVSTChleGFtcGxlLCBjb25maWcpKSk7XG4gICAgfVxuICAgIHRoaXMuX21vY2tzID0gZnJvbUV4YW1wbGVzKG1vY2tFeGFtcGxlcyk7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZVVSTChleGFtcGxlOiBNb2NrRXhhbXBsZSwgc2VydmljZUNvbmZpZz86IFNlcnZpY2VEYXRhSHR0cENvbmZpZyk6IE1vY2tFeGFtcGxlIHtcbiAgICByZXR1cm4gc2VydmljZUNvbmZpZ1xuICAgICAgPyB7XG4gICAgICAgICAgLi4uZXhhbXBsZSxcbiAgICAgICAgICAuLi57IHVybFBhdHRlcm46IGpvaW5Vcmwoc2VydmljZUNvbmZpZy5hcGlSb290LCBzZXJ2aWNlQ29uZmlnLnNlcnZpY2VQYXRoLCBleGFtcGxlLnVybFBhdHRlcm4pIH0sXG4gICAgICAgIH1cbiAgICAgIDogZXhhbXBsZTtcbiAgfVxufVxuIl19