import { HttpErrorResponse, HttpResponse, HTTP_INTERCEPTORS, } from '@angular/common/http';
import { APP_BOOTSTRAP_LISTENER, Injectable, isDevMode } from '@angular/core';
import { of as observableOf, throwError } from 'rxjs';
import { delay, dematerialize, materialize, tap } from 'rxjs/operators';
import { DataModulesManager } from './data-module-manager';
import { isSuccessStatus, MOCKS_EXAMPLES } from './mocks';
import * as i0 from "@angular/core";
import * as i1 from "./data-module-manager";
const DEFAULT_OPTIONS = {
    responseDelay: 300,
    enableMocksStorageKey: 'enableMocks',
};
export class MocksInterceptor {
    /*
     * this class is constructed in createMocksInterceptor
     function so make sure to updated it too if you have changes in the dependancy list
     */
    constructor(dataModuleManager) {
        this.dataModuleManager = dataModuleManager;
        this.options = DEFAULT_OPTIONS;
    }
    urlMatchesPattern(url, pattern) {
        const regexp = new RegExp(pattern
            .replace(/[.*+?^${}()|[\]\\]/g, '\\$&') // escape regex characters in URL pattern
            .replace(/\\{[^\}]*\}/g, '[^/]*') // convert template {placeholders} to regex
            .concat('$'));
        // fixes bug with older versions of data modules, where they could have ended up
        // with double slashes in the request URL, depending on the environment
        // by replacing multiple slashes with a single slash (except after ":" - e.g. in "http://")
        const normalUrl = url.replace(/([^:]\/)\/+/g, '$1');
        return regexp.test(normalUrl);
    }
    findRequestMock(request) {
        const urlAndMethodMatch = (item) => {
            return request.method === item.method && this.urlMatchesPattern(request.url, item.urlPattern);
        };
        return this.dataModuleManager.getMocks().find(urlAndMethodMatch);
    }
    toResponseObject(mockItem) {
        const response = mockItem.responses.find(resp => resp.status === mockItem.statusToReturn);
        if (!response) {
            return throwError(new HttpErrorResponse({
                status: 500,
                statusText: 'No Mock Defined',
            }));
        }
        if (isSuccessStatus(response.status)) {
            return observableOf(new HttpResponse(response));
        }
        else {
            return throwError(new HttpErrorResponse(response));
        }
    }
    getMockItemFromStorage(urlPattern) {
        try {
            return JSON.parse(localStorage.getItem(urlPattern) || '{}');
        }
        catch (_a) {
            console.warn(`[MOCK] Invalid json for the "${urlPattern}" local storage item`);
            return {};
        }
    }
    processRequest(request, next) {
        const mock = this.findRequestMock(request);
        if (mock) {
            return this.toResponseObject(Object.assign(Object.assign({}, mock), this.getMockItemFromStorage(mock.urlPattern)));
        }
        return next.handle(request);
    }
    intercept(request, next) {
        if (localStorage.getItem(this.options.enableMocksStorageKey) !== 'true') {
            return next.handle(request);
        }
        return this.processRequest(request, next).pipe(materialize(), delay(this.options.responseDelay), dematerialize(), tap(response => {
            // eslint-disable-next-line  no-console
            console.log('[MOCK]', request, response);
        }));
    }
}
MocksInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function MocksInterceptor_Factory() { return new MocksInterceptor(i0.ɵɵinject(i1.DataModulesManager)); }, token: MocksInterceptor, providedIn: "root" });
MocksInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
MocksInterceptor.ctorParameters = () => [
    { type: DataModulesManager }
];
/**
 * Create a HTTP_INTERCEPTOR to return mock responses for data modules.
 */
export function createMocksInterceptor() {
    return [
        {
            provide: HTTP_INTERCEPTORS,
            useClass: MocksInterceptor,
            deps: [DataModulesManager],
            multi: true,
        },
        {
            provide: APP_BOOTSTRAP_LISTENER,
            useValue: bootstrapMocksInterceptor,
            multi: true,
        },
    ];
}
export function bootstrapMocksInterceptor() {
    if (!isDevMode()) {
        console.warn('Mocks should not be enabled in a production environment.');
    }
}
/**
 * @internal
 * @deprecated
 */
export function createMockInterceptor(examples) {
    return createMocks(examples);
}
/**
 * Create mocks
 *
 * @param examples
 * @param serviceConfigToken
 */
export function createMocks(examples, serviceConfigToken) {
    return {
        provide: MOCKS_EXAMPLES,
        useValue: { examples, token: serviceConfigToken },
        multi: true,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ja3MuaW50ZXJjZXB0b3Iuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2RhdGEtaHR0cC9zcmMvbW9ja3MuaW50ZXJjZXB0b3Iuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBS2pCLFlBQVksRUFDWixpQkFBaUIsR0FDbEIsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsVUFBVSxFQUFrQixTQUFTLEVBQVksTUFBTSxlQUFlLENBQUM7QUFDeEcsT0FBTyxFQUFjLEVBQUUsSUFBSSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4RSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsZUFBZSxFQUEwQixjQUFjLEVBQUUsTUFBTSxTQUFTLENBQUM7OztBQUVsRixNQUFNLGVBQWUsR0FBRztJQUN0QixhQUFhLEVBQUUsR0FBRztJQUNsQixxQkFBcUIsRUFBRSxhQUFhO0NBQ3JDLENBQUM7QUFLRixNQUFNLE9BQU8sZ0JBQWdCO0lBMkMzQjs7O09BR0c7SUFDSCxZQUE2QixpQkFBcUM7UUFBckMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFvQjtRQTlDakQsWUFBTyxHQUFrQyxlQUFlLENBQUM7SUE4Q0wsQ0FBQztJQTVDOUQsaUJBQWlCLENBQUMsR0FBVyxFQUFFLE9BQWU7UUFDcEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQ3ZCLE9BQU87YUFDSixPQUFPLENBQUMscUJBQXFCLEVBQUUsTUFBTSxDQUFDLENBQUMseUNBQXlDO2FBQ2hGLE9BQU8sQ0FB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QUN2QyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7Ozs7WUFuRkYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUFWUSxrQkFBa0I7O0FBbUczQjs7R0FFRztBQUNILE1BQU0sVUFBVSxzQkFBc0I7SUFDcEMsT0FBTztRQUNMO1lBQ0UsT0FBTyxFQUFFLGlCQUFpQjtZQUMxQixRQUFRLEVBQUUsZ0JBQWdCO1lBQzFCLElBQUksRUFBRSxDQUFDLGtCQUFrQixDQUFDO1lBQzFCLEtBQUssRUFBRSxJQUFJO1NBQ1o7UUFDRDtZQUNFLE9BQU8sRUFBRSxzQkFBc0I7WUFDL0IsUUFBUSxFQUFFLHlCQUF5QjtZQUNuQyxLQUFLLEVBQUUsSUFBSTtTQUNaO0tBQ0YsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUseUJBQXlCO0lBQ3ZDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLDBEQUEwRCxDQUFDLENBQUM7S0FDMUU7QUFDSCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUFDLFFBQTRCO0lBQ2hFLE9BQU8sV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQy9CLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3pCLFFBQTRCLEVBQzVCLGtCQUEwRDtJQUUxRCxPQUFPO1FBQ0wsT0FBTyxFQUFFLGNBQWM7UUFDdkIsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxrQkFBa0IsRUFBRTtRQUNqRCxLQUFLLEVBQUUsSUFBSTtLQUNaLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSHR0cEVycm9yUmVzcG9uc2UsXG4gIEh0dHBFdmVudCxcbiAgSHR0cEhhbmRsZXIsXG4gIEh0dHBJbnRlcmNlcHRvcixcbiAgSHR0cFJlcXVlc3QsXG4gIEh0dHBSZXNwb25zZSxcbiAgSFRUUF9JTlRFUkNFUFRPUlMsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IEFQUF9CT09UU1RSQVBfTElTVEVORVIsIEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBpc0Rldk1vZGUsIFByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBvZiBhcyBvYnNlcnZhYmxlT2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlbGF5LCBkZW1hdGVyaWFsaXplLCBtYXRlcmlhbGl6ZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU2VydmljZURhdGFIdHRwQ29uZmlnIH0gZnJvbSAnLi9kYXRhLWh0dHAtY29uZmlnJztcbmltcG9ydCB7IERhdGFNb2R1bGVzTWFuYWdlciB9IGZyb20gJy4vZGF0YS1tb2R1bGUtbWFuYWdlcic7XG5pbXBvcnQgeyBpc1N1Y2Nlc3NTdGF0dXMsIE1vY2tFeGFtcGxlLCBNb2Nrc0l0ZW0sIE1PQ0tTX0VYQU1QTEVTIH0gZnJvbSAnLi9tb2Nrcyc7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcmVzcG9uc2VEZWxheTogMzAwLCAvLyBtc1xuICBlbmFibGVNb2Nrc1N0b3JhZ2VLZXk6ICdlbmFibGVNb2NrcycsXG59O1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgTW9ja3NJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogTW9ja3NJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb24gPSBERUZBVUxUX09QVElPTlM7XG5cbiAgcHJpdmF0ZSB1cmxNYXRjaGVzUGF0dGVybih1cmw6IHN0cmluZywgcGF0dGVybjogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVnZXhwID0gbmV3IFJlZ0V4cChcbiAgICAgIHBhdHRlcm5cbiAgICAgICAgLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykgLy8gZXNjYXBlIHJlZ2V4IGNoYXJhY3RlcnMgaW4gVVJMIHBhdHRlcm5cbiAgICAgICAgLnJlcGxhY2UoL1xcXFx7W15cXH1dKlxcfS9nLCAnW14vXSonKSAvLyBjb252ZXJ0IHRlbXBsYXRlIHtwbGFjZWhvbGRlcnN9IHRvIHJlZ2V4XG4gICAgICAgIC5jb25jYXQoJyQnKSwgLy8gYW5jaG9yIHRvIGVuZCBvZiB1cmxcbiAgICApO1xuICAgIC8vIGZpeGVzIGJ1ZyB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGRhdGEgbW9kdWxlcywgd2hlcmUgdGhleSBjb3VsZCBoYXZlIGVuZGVkIHVwXG4gICAgLy8gd2l0aCBkb3VibGUgc2xhc2hlcyBpbiB0aGUgcmVxdWVzdCBVUkwsIGRlcGVuZGluZyBvbiB0aGUgZW52aXJvbm1lbnRcbiAgICAvLyBieSByZXBsYWNpbmcgbXVsdGlwbGUgc2xhc2hlcyB3aXRoIGEgc2luZ2xlIHNsYXNoIChleGNlcHQgYWZ0ZXIgXCI6XCIgLSBlLmcuIGluIFwiaHR0cDovL1wiKVxuICAgIGNvbnN0IG5vcm1hbFVybCA9IHVybC5yZXBsYWNlKC8oW146XVxcLylcXC8rL2csICckMScpO1xuICAgIHJldHVybiByZWdleHAudGVzdChub3JtYWxVcmwpO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kUmVxdWVzdE1vY2s8Uj4ocmVxdWVzdDogSHR0cFJlcXVlc3Q8Uj4pOiBNb2Nrc0l0ZW0gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHVybEFuZE1ldGhvZE1hdGNoID0gKGl0ZW06IE1vY2tzSXRlbSkgPT4ge1xuICAgICAgcmV0dXJuIHJlcXVlc3QubWV0aG9kID09PSBpdGVtLm1ldGhvZCAmJiB0aGlzLnVybE1hdGNoZXNQYXR0ZXJuKHJlcXVlc3QudXJsLCBpdGVtLnVybFBhdHRlcm4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhTW9kdWxlTWFuYWdlci5nZXRNb2NrcygpLmZpbmQodXJsQW5kTWV0aG9kTWF0Y2gpO1xuICB9XG5cbiAgcHJpdmF0ZSB0b1Jlc3BvbnNlT2JqZWN0PFQ+KG1vY2tJdGVtOiBNb2Nrc0l0ZW0pOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxUPj4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gbW9ja0l0ZW0ucmVzcG9uc2VzLmZpbmQocmVzcCA9PiByZXNwLnN0YXR1cyA9PT0gbW9ja0l0ZW0uc3RhdHVzVG9SZXR1cm4pO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiB0aHJvd0Vycm9yKFxuICAgICAgICBuZXcgSHR0cEVycm9yUmVzcG9uc2Uoe1xuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgIHN0YXR1c1RleHQ6ICdObyBNb2NrIERlZmluZWQnLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGlzU3VjY2Vzc1N0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEh0dHBFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogdGhpcyBjbGFzcyBpcyBjb25zdHJ1Y3RlZCBpbiBjcmVhdGVNb2Nrc0ludGVyY2VwdG9yIFxuICAgZnVuY3Rpb24gc28gbWFrZSBzdXJlIHRvIHVwZGF0ZWQgaXQgdG9vIGlmIHlvdSBoYXZlIGNoYW5nZXMgaW4gdGhlIGRlcGVuZGFuY3kgbGlzdFxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBkYXRhTW9kdWxlTWFuYWdlcjogRGF0YU1vZHVsZXNNYW5hZ2VyKSB7fVxuXG4gIHByaXZhdGUgZ2V0TW9ja0l0ZW1Gcm9tU3RvcmFnZSh1cmxQYXR0ZXJuOiBzdHJpbmcpOiBQYXJ0aWFsPE1vY2tzSXRlbT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh1cmxQYXR0ZXJuKSB8fCAne30nKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGNvbnNvbGUud2FybihgW01PQ0tdIEludmFsaWQganNvbiBmb3IgdGhlIFwiJHt1cmxQYXR0ZXJufVwiIGxvY2FsIHN0b3JhZ2UgaXRlbWApO1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc1JlcXVlc3Q8UiwgVD4ocmVxdWVzdDogSHR0cFJlcXVlc3Q8Uj4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8VD4+IHtcbiAgICBjb25zdCBtb2NrID0gdGhpcy5maW5kUmVxdWVzdE1vY2socmVxdWVzdCk7XG4gICAgaWYgKG1vY2spIHtcbiAgICAgIHJldHVybiB0aGlzLnRvUmVzcG9uc2VPYmplY3Q8VD4oeyAuLi5tb2NrLCAuLi50aGlzLmdldE1vY2tJdGVtRnJvbVN0b3JhZ2UobW9jay51cmxQYXR0ZXJuKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcXVlc3QpO1xuICB9XG5cbiAgaW50ZXJjZXB0PFIsIFQ+KHJlcXVlc3Q6IEh0dHBSZXF1ZXN0PFI+LCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PFQ+PiB7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMub3B0aW9ucy5lbmFibGVNb2Nrc1N0b3JhZ2VLZXkpICE9PSAndHJ1ZScpIHtcbiAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXF1ZXN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzUmVxdWVzdDxSLCBUPihyZXF1ZXN0LCBuZXh0KS5waXBlKFxuICAgICAgbWF0ZXJpYWxpemUoKSxcbiAgICAgIGRlbGF5KHRoaXMub3B0aW9ucy5yZXNwb25zZURlbGF5KSxcbiAgICAgIGRlbWF0ZXJpYWxpemUoKSxcbiAgICAgIHRhcChyZXNwb25zZSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSAgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZygnW01PQ0tdJywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgfSksXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1vY2tzSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uIHtcbiAgcmVzcG9uc2VEZWxheTogbnVtYmVyO1xuICBlbmFibGVNb2Nrc1N0b3JhZ2VLZXk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBIVFRQX0lOVEVSQ0VQVE9SIHRvIHJldHVybiBtb2NrIHJlc3BvbnNlcyBmb3IgZGF0YSBtb2R1bGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9ja3NJbnRlcmNlcHRvcigpOiBQcm92aWRlciB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcHJvdmlkZTogSFRUUF9JTlRFUkNFUFRPUlMsXG4gICAgICB1c2VDbGFzczogTW9ja3NJbnRlcmNlcHRvcixcbiAgICAgIGRlcHM6IFtEYXRhTW9kdWxlc01hbmFnZXJdLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBBUFBfQk9PVFNUUkFQX0xJU1RFTkVSLFxuICAgICAgdXNlVmFsdWU6IGJvb3RzdHJhcE1vY2tzSW50ZXJjZXB0b3IsXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vdHN0cmFwTW9ja3NJbnRlcmNlcHRvcigpIHtcbiAgaWYgKCFpc0Rldk1vZGUoKSkge1xuICAgIGNvbnNvbGUud2FybignTW9ja3Mgc2hvdWxkIG5vdCBiZSBlbmFibGVkIGluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudC4nKTtcbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1vY2tJbnRlcmNlcHRvcihleGFtcGxlczogQXJyYXk8TW9ja0V4YW1wbGU+KTogUHJvdmlkZXIge1xuICByZXR1cm4gY3JlYXRlTW9ja3MoZXhhbXBsZXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBtb2Nrc1xuICpcbiAqIEBwYXJhbSBleGFtcGxlc1xuICogQHBhcmFtIHNlcnZpY2VDb25maWdUb2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9ja3MoXG4gIGV4YW1wbGVzOiBBcnJheTxNb2NrRXhhbXBsZT4sXG4gIHNlcnZpY2VDb25maWdUb2tlbj86IEluamVjdGlvblRva2VuPFNlcnZpY2VEYXRhSHR0cENvbmZpZz4sXG4pOiBQcm92aWRlciB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZTogTU9DS1NfRVhBTVBMRVMsXG4gICAgdXNlVmFsdWU6IHsgZXhhbXBsZXMsIHRva2VuOiBzZXJ2aWNlQ29uZmlnVG9rZW4gfSxcbiAgICBtdWx0aTogdHJ1ZSxcbiAgfTtcbn1cbiJdfQ==