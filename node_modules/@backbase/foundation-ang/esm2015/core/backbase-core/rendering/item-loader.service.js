import { Compiler, Injector, Injectable, Inject, Optional, NgModuleFactory } from '@angular/core';
import { hasDuplicates } from '../models/array';
import { ItemRegistryService } from './item-registry.service';
import { CombinedComponentFactoryResolver } from './combined-component-factory-resolver';
import { LAZY_MAP } from './lazy-config';
import * as i0 from "@angular/core";
import * as i1 from "./item-registry.service";
import * as i2 from "./combined-component-factory-resolver";
import * as i3 from "./lazy-config";
export class ItemLoaderService {
    constructor(compiler, parentInjector, itemRegistry, componentFactoryResolver, 
    // @fixme: generate lazy map from the page model?
    lazyConfig) {
        this.compiler = compiler;
        this.parentInjector = parentInjector;
        this.itemRegistry = itemRegistry;
        this.componentFactoryResolver = componentFactoryResolver;
        this.lazyComponentsConfig = lazyConfig
            ? lazyConfig.filter((config) => !!config.components)
            : [];
        if (hasDuplicates(this.lazyComponentsConfig.reduce((acc, config) => [...acc, ...config.components], []))) {
            throw new Error('[LazyConfig] You have added one or more components inside multiple lazy loading bundles. ' +
                "This will make an impact on your app's performance. " +
                'Update your config to have one component included in only one bundle.');
        }
    }
    /**
     * Loads the module this class is in, and adds
     * it to the global item registry, and global component
     * resolver.
     *
     * @param classId
     */
    loadComponent(classId) {
        if (this.itemRegistry.has(classId) || this.lazyComponentsConfig.length === 0) {
            return Promise.resolve();
        }
        const foundBundle = this.lazyComponentsConfig.find(item => item.components.indexOf(classId) !== -1);
        const callback = foundBundle ? foundBundle.loadChildren : undefined;
        if (!callback) {
            return Promise.resolve();
        }
        return callback()
            .then(this.toModuleFactory.bind(this))
            .then(this.loadModule.bind(this))
            .then(this.registerModule.bind(this, classId));
    }
    toModuleFactory(loadedItem) {
        // Depending on compiler, callback can return either module factory or the module itself.
        return loadedItem instanceof NgModuleFactory ? loadedItem : this.compiler.compileModuleSync(loadedItem);
    }
    loadModule(moduleFactory) {
        return moduleFactory.create(this.parentInjector);
    }
    registerModule(classId, ngModule) {
        this.registerComponentClass(classId, ngModule);
        this.registerComponentFactoryResolver(classId, ngModule);
    }
    registerComponentClass(classId, ngModule) {
        const childRegistry = ngModule.injector.get(ItemRegistryService);
        const componentClass = childRegistry.getComponentValue(classId);
        if (!componentClass) {
            throw new Error(`@backbase/foundation No component registered for ${classId}. Did you add it to the classMap?`);
        }
        this.itemRegistry.add(classId, componentClass);
    }
    registerComponentFactoryResolver(classId, ngModule) {
        this.componentFactoryResolver.registerChildResolver(classId, ngModule.componentFactoryResolver);
    }
}
ItemLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ItemLoaderService_Factory() { return new ItemLoaderService(i0.ɵɵinject(i0.Compiler), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.ItemRegistryService), i0.ɵɵinject(i2.CombinedComponentFactoryResolver), i0.ɵɵinject(i3.LAZY_MAP, 8)); }, token: ItemLoaderService, providedIn: "root" });
ItemLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
ItemLoaderService.ctorParameters = () => [
    { type: Compiler },
    { type: Injector },
    { type: ItemRegistryService },
    { type: CombinedComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [LAZY_MAP,] }, { type: Optional }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXRlbS1sb2FkZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2NvcmUvc3JjL2JhY2tiYXNlLWNvcmUvcmVuZGVyaW5nL2l0ZW0tbG9hZGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQWUsVUFBVSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFRLE1BQU0sZUFBZSxDQUFDO0FBQ3JILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUN6RixPQUFPLEVBQW9DLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7QUFLM0UsTUFBTSxPQUFPLGlCQUFpQjtJQUU1QixZQUNtQixRQUFrQixFQUNsQixjQUF3QixFQUN4QixZQUFpQyxFQUNqQyx3QkFBMEQ7SUFDM0UsaURBQWlEO0lBR2pELFVBQTZCO1FBUFosYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNsQixtQkFBYyxHQUFkLGNBQWMsQ0FBVTtRQUN4QixpQkFBWSxHQUFaLFlBQVksQ0FBcUI7UUFDakMsNkJBQXdCLEdBQXhCLHdCQUF3QixDQUFrQztRQU0zRSxJQUFJLENBQUMsb0JBQW9CLEdBQUcsVUFBVTtZQUNwQyxDQUFDLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBa0MsRUFBRSxDQUFDLENBQUMsQ0FBRSxNQUErQixDQUFDLFVBQVUsQ0FBQztZQUM5RyxDQUFDLENBQUMsRUFBRSxDQUFDO1FBRVAsSUFDRSxhQUFhLENBQ1gsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFD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Q0FjcEMsTUFBTSxTQUFDLFFBQVEsY0FDZixRQUFRIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcGlsZXIsIEluamVjdG9yLCBOZ01vZHVsZVJlZiwgSW5qZWN0YWJsZSwgSW5qZWN0LCBPcHRpb25hbCwgTmdNb2R1bGVGYWN0b3J5LCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBoYXNEdXBsaWNhdGVzIH0gZnJvbSAnLi4vbW9kZWxzL2FycmF5JztcbmltcG9ydCB7IEl0ZW1SZWdpc3RyeVNlcnZpY2UgfSBmcm9tICcuL2l0ZW0tcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgeyBDb21iaW5lZENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB9IGZyb20gJy4vY29tYmluZWQtY29tcG9uZW50LWZhY3RvcnktcmVzb2x2ZXInO1xuaW1wb3J0IHsgTGF6eUNvbXBvbmVudHNDb25maWcsIExhenlDb25maWcsIExBWllfTUFQIH0gZnJvbSAnLi9sYXp5LWNvbmZpZyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBJdGVtTG9hZGVyU2VydmljZSB7XG4gIHByaXZhdGUgcmVhZG9ubHkgbGF6eUNvbXBvbmVudHNDb25maWc6IEFycmF5PExhenlDb21wb25lbnRzQ29uZmlnPjtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb21waWxlcjogQ29tcGlsZXIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwYXJlbnRJbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBpdGVtUmVnaXN0cnk6IEl0ZW1SZWdpc3RyeVNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbWJpbmVkQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIC8vIEBmaXhtZTogZ2VuZXJhdGUgbGF6eSBtYXAgZnJvbSB0aGUgcGFnZSBtb2RlbD9cbiAgICBASW5qZWN0KExBWllfTUFQKVxuICAgIEBPcHRpb25hbCgpXG4gICAgbGF6eUNvbmZpZzogTGF6eUNvbmZpZyB8IG51bGwsXG4gICkge1xuICAgIHRoaXMubGF6eUNvbXBvbmVudHNDb25maWcgPSBsYXp5Q29uZmlnXG4gICAgICA/IGxhenlDb25maWcuZmlsdGVyKChjb25maWcpOiBjb25maWcgaXMgTGF6eUNvbXBvbmVudHNDb25maWcgPT4gISEoY29uZmlnIGFzIExhenlDb21wb25lbnRzQ29uZmlnKS5jb21wb25lbnRzKVxuICAgICAgOiBbXTtcblxuICAgIGlmIChcbiAgICAgIGhhc0R1cGxpY2F0ZXMoXG4gICAgICAgIHRoaXMubGF6eUNvbXBvbmVudHNDb25maWcucmVkdWNlKChhY2MsIGNvbmZpZykgPT4gWy4uLmFjYywgLi4uY29uZmlnLmNvbXBvbmVudHNdLCBbXSBhcyBBcnJheTxzdHJpbmc+KSxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1tMYXp5Q29uZmlnXSBZb3UgaGF2ZSBhZGRlZCBvbmUgb3IgbW9yZSBjb21wb25lbnRzIGluc2lkZSBtdWx0aXBsZSBsYXp5IGxvYWRpbmcgYnVuZGxlcy4gJyArXG4gICAgICAgICAgXCJUaGlzIHdpbGwgbWFrZSBhbiBpbXBhY3Qgb24geW91ciBhcHAncyBwZXJmb3JtYW5jZS4gXCIgK1xuICAgICAgICAgICdVcGRhdGUgeW91ciBjb25maWcgdG8gaGF2ZSBvbmUgY29tcG9uZW50IGluY2x1ZGVkIGluIG9ubHkgb25lIGJ1bmRsZS4nLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgdGhlIG1vZHVsZSB0aGlzIGNsYXNzIGlzIGluLCBhbmQgYWRkc1xuICAgKiBpdCB0byB0aGUgZ2xvYmFsIGl0ZW0gcmVnaXN0cnksIGFuZCBnbG9iYWwgY29tcG9uZW50XG4gICAqIHJlc29sdmVyLlxuICAgKlxuICAgKiBAcGFyYW0gY2xhc3NJZFxuICAgKi9cbiAgbG9hZENvbXBvbmVudChjbGFzc0lkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pdGVtUmVnaXN0cnkuaGFzKGNsYXNzSWQpIHx8IHRoaXMubGF6eUNvbXBvbmVudHNDb25maWcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZm91bmRCdW5kbGUgPSB0aGlzLmxhenlDb21wb25lbnRzQ29uZmlnLmZpbmQoaXRlbSA9PiBpdGVtLmNvbXBvbmVudHMuaW5kZXhPZihjbGFzc0lkKSAhPT0gLTEpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZm91bmRCdW5kbGUgPyBmb3VuZEJ1bmRsZS5sb2FkQ2hpbGRyZW4gOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgIC50aGVuKHRoaXMudG9Nb2R1bGVGYWN0b3J5LmJpbmQodGhpcykpXG4gICAgICAudGhlbih0aGlzLmxvYWRNb2R1bGUuYmluZCh0aGlzKSlcbiAgICAgIC50aGVuKHRoaXMucmVnaXN0ZXJNb2R1bGUuYmluZCh0aGlzLCBjbGFzc0lkKSk7XG4gIH1cblxuICBwcml2YXRlIHRvTW9kdWxlRmFjdG9yeShsb2FkZWRJdGVtOiBOZ01vZHVsZUZhY3Rvcnk8dW5rbm93bj4gfCBUeXBlPHVua25vd24+KTogTmdNb2R1bGVGYWN0b3J5PHVua25vd24+IHtcbiAgICAvLyBEZXBlbmRpbmcgb24gY29tcGlsZXIsIGNhbGxiYWNrIGNhbiByZXR1cm4gZWl0aGVyIG1vZHVsZSBmYWN0b3J5IG9yIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAgIHJldHVybiBsb2FkZWRJdGVtIGluc3RhbmNlb2YgTmdNb2R1bGVGYWN0b3J5ID8gbG9hZGVkSXRlbSA6IHRoaXMuY29tcGlsZXIuY29tcGlsZU1vZHVsZVN5bmMobG9hZGVkSXRlbSk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRNb2R1bGUobW9kdWxlRmFjdG9yeTogTmdNb2R1bGVGYWN0b3J5PHVua25vd24+KTogTmdNb2R1bGVSZWY8dW5rbm93bj4ge1xuICAgIHJldHVybiBtb2R1bGVGYWN0b3J5LmNyZWF0ZSh0aGlzLnBhcmVudEluamVjdG9yKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJNb2R1bGUoY2xhc3NJZDogc3RyaW5nLCBuZ01vZHVsZTogTmdNb2R1bGVSZWY8dW5rbm93bj4pIHtcbiAgICB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50Q2xhc3MoY2xhc3NJZCwgbmdNb2R1bGUpO1xuICAgIHRoaXMucmVnaXN0ZXJDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIoY2xhc3NJZCwgbmdNb2R1bGUpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckNvbXBvbmVudENsYXNzKGNsYXNzSWQ6IHN0cmluZywgbmdNb2R1bGU6IE5nTW9kdWxlUmVmPHVua25vd24+KSB7XG4gICAgY29uc3QgY2hpbGRSZWdpc3RyeSA9IG5nTW9kdWxlLmluamVjdG9yLmdldDxJdGVtUmVnaXN0cnlTZXJ2aWNlPihJdGVtUmVnaXN0cnlTZXJ2aWNlKTtcbiAgICBjb25zdCBjb21wb25lbnRDbGFzcyA9IGNoaWxkUmVnaXN0cnkuZ2V0Q29tcG9uZW50VmFsdWUoY2xhc3NJZCk7XG4gICAgaWYgKCFjb21wb25lbnRDbGFzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBAYmFja2Jhc2UvZm91bmRhdGlvbiBObyBjb21wb25lbnQgcmVnaXN0ZXJlZCBmb3IgJHtjbGFzc0lkfS4gRGlkIHlvdSBhZGQgaXQgdG8gdGhlIGNsYXNzTWFwP2ApO1xuICAgIH1cbiAgICB0aGlzLml0ZW1SZWdpc3RyeS5hZGQoY2xhc3NJZCwgY29tcG9uZW50Q2xhc3MpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcihjbGFzc0lkOiBzdHJpbmcsIG5nTW9kdWxlOiBOZ01vZHVsZVJlZjx1bmtub3duPikge1xuICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlZ2lzdGVyQ2hpbGRSZXNvbHZlcihjbGFzc0lkLCBuZ01vZHVsZS5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICB9XG59XG4iXX0=