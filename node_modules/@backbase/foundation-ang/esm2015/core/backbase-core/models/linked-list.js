/**
 * Creates a new LinkedList with the results of calling a provided function on
 * every element in the provided LinkedList.
 *
 * @param list
 * @param fn
 */
export const mapLinkedList = (list, fn) => ({
    value: fn(list.value),
    next: list.next === undefined ? undefined : mapLinkedList(list.next, fn),
});
/**
 * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
 * to TAIL, where the new HEAD is determined by the first "true" result of calling the predicate
 * on each node in the list.
 *
 * The search is done by iterating over each element in the linked list
 * in the order from HEAD to TAIL.
 *
 * If not found, returns undefined.
 *
 * @param list
 * @param predicate
 */
export const linkedListFind = (list, predicate) => {
    if (predicate(list.value)) {
        return list;
    }
    return list.next ? linkedListFind(list.next, predicate) : undefined;
};
/**
 * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
 * to TAIL, where the new HEAD is determined by the first "true" result of calling the predicate
 * on each node in the list.
 *
 * The search is done by iterating over each element in the linked list
 * in the order from TAIL to HEAD.
 *
 * If not found, returns undefined.
 *
 * @param list
 * @param predicate
 */
export const linkedListFindLast = (list, predicate) => {
    const foundChild = list.next ? linkedListFindLast(list.next, predicate) : undefined;
    if (foundChild) {
        return foundChild;
    }
    return predicate(list.value) ? list : undefined;
};
/**
 * Returns a shallow copy of a portion of a linked list into a new linked list,
 * selected from HEAD (inclusive) to the first element to return true (exclusive).
 * So the new TAIL will be the parent of the first element to return true.
 *
 * The search is done by iterating over each element in the linked list in the
 * order from HEAD to TAIL.
 *
 * If not found, returns undefined.
 *
 * @param list
 * @param predicate
 */
const linkedListSliceTail = (list, predicate) => {
    if (predicate(list.value)) {
        return undefined;
    }
    return {
        value: list.value,
        next: list.next ? linkedListSliceTail(list.next, predicate) : undefined,
    };
};
const ɵ0 = linkedListSliceTail;
/**
 * Returns a shallow copy of a portion of a linked list into a linked list, selected from HEAD
 * to TAIL, where the new HEAD is determined by the first "true" result of calling the "begin"
 * predicate and the new TAIL is determined by the first "true" result of calling the "end"
 * predicate.
 *
 * If no "begin" predicate is sent, the HEAD will be the current HEAD.
 *
 * If no "end" predicate is sent, the TAIL will be the current TAIL.
 *
 * The search is done by iterating over each element in the linked list
 * in the order from HEAD to TAIL until both predicates return true.
 *
 * If not both found, returns undefined.
 *
 * @param list
 * @param predicate
 */
export const linkedListSlice = (list, begin, end) => {
    const head = begin ? linkedListFind(list, begin) : list;
    if (!head) {
        return undefined;
    }
    return end ? linkedListSliceTail(head, end) : head;
};
export const linkedListToArray = (list) => [
    list.value,
    ...(list.next ? linkedListToArray(list.next) : []),
];
export const linkedListFromArray = (arr) => arr.reduceRight((next, value) => ({ value, next }), undefined);
export const linkedListLast = (list) => (list.next ? linkedListLast(list.next) : list);
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlua2VkLWxpc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL21vZGVscy9saW5rZWQtbGlzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFLQTs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsQ0FBTyxJQUFtQixFQUFFLEVBQW1CLEVBQWlCLEVBQUUsQ0FBQyxDQUFDO0lBQy9GLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNyQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDO0NBQ3pFLENBQUMsQ0FBQztBQUVIOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxDQUFJLElBQW1CLEVBQUUsU0FBZ0MsRUFBNkIsRUFBRTtJQUNwSCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDekIsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUN0RSxDQUFDLENBQUM7QUFFRjs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBRyxDQUNoQyxJQUFtQixFQUNuQixTQUFnQyxFQUNMLEVBQUU7SUFDN0IsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ3BGLElBQUksVUFBVSxFQUFFO1FBQ2QsT0FBTyxVQUFVLENBQUM7S0FDbkI7SUFDRCxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ2xELENBQUMsQ0FBQztBQUVGOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sbUJBQW1CLEdBQUcsQ0FBSSxJQUFtQixFQUFFLFNBQWdDLEVBQTZCLEVBQUU7SUFDbEgsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3pCLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsT0FBTztRQUNMLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztRQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUztLQUN4RSxDQUFDO0FBQ0osQ0FBQyxDQUFDOztBQUVGOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUNILE1BQU0sQ0FBQyxNQUFNLGVBQWUsR0FBRyxDQUM3QixJQUFtQixFQUNuQixLQUE2QixFQUM3QixHQUEyQixFQUNBLEVBQUU7SUFDN0IsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDeEQsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3JELENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLGlCQUFpQixHQUFHLENBQUksSUFBbUIsRUFBWSxFQUFFLENBQUM7SUFDckUsSUFBSSxDQUFDLEtBQUs7SUFDVixHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7Q0FDbkQsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLG1CQUFtQixHQUFHLENBQUksR0FBYSxFQUE2QixFQUFFLENBQ2pGLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUErQixFQUFFLEtBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBRS9GLE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBRyxDQUFJLElBQW1CLEVBQWlCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGludGVyZmFjZSBMaW5rZWRMaXN0PFQ+IHtcbiAgdmFsdWU6IFQ7XG4gIG5leHQ/OiBMaW5rZWRMaXN0PFQ+O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlua2VkTGlzdCB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvblxuICogZXZlcnkgZWxlbWVudCBpbiB0aGUgcHJvdmlkZWQgTGlua2VkTGlzdC5cbiAqXG4gKiBAcGFyYW0gbGlzdFxuICogQHBhcmFtIGZuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXBMaW5rZWRMaXN0ID0gPFQsIFI+KGxpc3Q6IExpbmtlZExpc3Q8VD4sIGZuOiAodmFsdWU6IFQpID0+IFIpOiBMaW5rZWRMaXN0PFI+ID0+ICh7XG4gIHZhbHVlOiBmbihsaXN0LnZhbHVlKSxcbiAgbmV4dDogbGlzdC5uZXh0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBtYXBMaW5rZWRMaXN0KGxpc3QubmV4dCwgZm4pLFxufSk7XG5cbi8qKlxuICogUmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgYSBsaW5rZWQgbGlzdCBpbnRvIGEgbGlua2VkIGxpc3QsIHNlbGVjdGVkIGZyb20gSEVBRFxuICogdG8gVEFJTCwgd2hlcmUgdGhlIG5ldyBIRUFEIGlzIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IFwidHJ1ZVwiIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBwcmVkaWNhdGVcbiAqIG9uIGVhY2ggbm9kZSBpbiB0aGUgbGlzdC5cbiAqXG4gKiBUaGUgc2VhcmNoIGlzIGRvbmUgYnkgaXRlcmF0aW5nIG92ZXIgZWFjaCBlbGVtZW50IGluIHRoZSBsaW5rZWQgbGlzdFxuICogaW4gdGhlIG9yZGVyIGZyb20gSEVBRCB0byBUQUlMLlxuICpcbiAqIElmIG5vdCBmb3VuZCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIGxpc3RcbiAqIEBwYXJhbSBwcmVkaWNhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGxpbmtlZExpc3RGaW5kID0gPFQ+KGxpc3Q6IExpbmtlZExpc3Q8VD4sIHByZWRpY2F0ZTogKHZhbHVlOiBUKSA9PiBib29sZWFuKTogTGlua2VkTGlzdDxUPiB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmIChwcmVkaWNhdGUobGlzdC52YWx1ZSkpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICByZXR1cm4gbGlzdC5uZXh0ID8gbGlua2VkTGlzdEZpbmQobGlzdC5uZXh0LCBwcmVkaWNhdGUpIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhIGxpbmtlZCBsaXN0IGludG8gYSBsaW5rZWQgbGlzdCwgc2VsZWN0ZWQgZnJvbSBIRUFEXG4gKiB0byBUQUlMLCB3aGVyZSB0aGUgbmV3IEhFQUQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgXCJ0cnVlXCIgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIHByZWRpY2F0ZVxuICogb24gZWFjaCBub2RlIGluIHRoZSBsaXN0LlxuICpcbiAqIFRoZSBzZWFyY2ggaXMgZG9uZSBieSBpdGVyYXRpbmcgb3ZlciBlYWNoIGVsZW1lbnQgaW4gdGhlIGxpbmtlZCBsaXN0XG4gKiBpbiB0aGUgb3JkZXIgZnJvbSBUQUlMIHRvIEhFQUQuXG4gKlxuICogSWYgbm90IGZvdW5kLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gbGlzdFxuICogQHBhcmFtIHByZWRpY2F0ZVxuICovXG5leHBvcnQgY29uc3QgbGlua2VkTGlzdEZpbmRMYXN0ID0gPFQ+KFxuICBsaXN0OiBMaW5rZWRMaXN0PFQ+LFxuICBwcmVkaWNhdGU6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbixcbik6IExpbmtlZExpc3Q8VD4gfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBmb3VuZENoaWxkID0gbGlzdC5uZXh0ID8gbGlua2VkTGlzdEZpbmRMYXN0KGxpc3QubmV4dCwgcHJlZGljYXRlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGZvdW5kQ2hpbGQpIHtcbiAgICByZXR1cm4gZm91bmRDaGlsZDtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKGxpc3QudmFsdWUpID8gbGlzdCA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNoYWxsb3cgY29weSBvZiBhIHBvcnRpb24gb2YgYSBsaW5rZWQgbGlzdCBpbnRvIGEgbmV3IGxpbmtlZCBsaXN0LFxuICogc2VsZWN0ZWQgZnJvbSBIRUFEIChpbmNsdXNpdmUpIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRvIHJldHVybiB0cnVlIChleGNsdXNpdmUpLlxuICogU28gdGhlIG5ldyBUQUlMIHdpbGwgYmUgdGhlIHBhcmVudCBvZiB0aGUgZmlyc3QgZWxlbWVudCB0byByZXR1cm4gdHJ1ZS5cbiAqXG4gKiBUaGUgc2VhcmNoIGlzIGRvbmUgYnkgaXRlcmF0aW5nIG92ZXIgZWFjaCBlbGVtZW50IGluIHRoZSBsaW5rZWQgbGlzdCBpbiB0aGVcbiAqIG9yZGVyIGZyb20gSEVBRCB0byBUQUlMLlxuICpcbiAqIElmIG5vdCBmb3VuZCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIGxpc3RcbiAqIEBwYXJhbSBwcmVkaWNhdGVcbiAqL1xuY29uc3QgbGlua2VkTGlzdFNsaWNlVGFpbCA9IDxUPihsaXN0OiBMaW5rZWRMaXN0PFQ+LCBwcmVkaWNhdGU6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbik6IExpbmtlZExpc3Q8VD4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAocHJlZGljYXRlKGxpc3QudmFsdWUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBsaXN0LnZhbHVlLFxuICAgIG5leHQ6IGxpc3QubmV4dCA/IGxpbmtlZExpc3RTbGljZVRhaWwobGlzdC5uZXh0LCBwcmVkaWNhdGUpIDogdW5kZWZpbmVkLFxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc2hhbGxvdyBjb3B5IG9mIGEgcG9ydGlvbiBvZiBhIGxpbmtlZCBsaXN0IGludG8gYSBsaW5rZWQgbGlzdCwgc2VsZWN0ZWQgZnJvbSBIRUFEXG4gKiB0byBUQUlMLCB3aGVyZSB0aGUgbmV3IEhFQUQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgXCJ0cnVlXCIgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFwiYmVnaW5cIlxuICogcHJlZGljYXRlIGFuZCB0aGUgbmV3IFRBSUwgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgXCJ0cnVlXCIgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFwiZW5kXCJcbiAqIHByZWRpY2F0ZS5cbiAqXG4gKiBJZiBubyBcImJlZ2luXCIgcHJlZGljYXRlIGlzIHNlbnQsIHRoZSBIRUFEIHdpbGwgYmUgdGhlIGN1cnJlbnQgSEVBRC5cbiAqXG4gKiBJZiBubyBcImVuZFwiIHByZWRpY2F0ZSBpcyBzZW50LCB0aGUgVEFJTCB3aWxsIGJlIHRoZSBjdXJyZW50IFRBSUwuXG4gKlxuICogVGhlIHNlYXJjaCBpcyBkb25lIGJ5IGl0ZXJhdGluZyBvdmVyIGVhY2ggZWxlbWVudCBpbiB0aGUgbGlua2VkIGxpc3RcbiAqIGluIHRoZSBvcmRlciBmcm9tIEhFQUQgdG8gVEFJTCB1bnRpbCBib3RoIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUuXG4gKlxuICogSWYgbm90IGJvdGggZm91bmQsIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSBsaXN0XG4gKiBAcGFyYW0gcHJlZGljYXRlXG4gKi9cbmV4cG9ydCBjb25zdCBsaW5rZWRMaXN0U2xpY2UgPSA8VD4oXG4gIGxpc3Q6IExpbmtlZExpc3Q8VD4sXG4gIGJlZ2luPzogKHZhbHVlOiBUKSA9PiBib29sZWFuLFxuICBlbmQ/OiAodmFsdWU6IFQpID0+IGJvb2xlYW4sXG4pOiBMaW5rZWRMaXN0PFQ+IHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgaGVhZCA9IGJlZ2luID8gbGlua2VkTGlzdEZpbmQobGlzdCwgYmVnaW4pIDogbGlzdDtcbiAgaWYgKCFoZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZW5kID8gbGlua2VkTGlzdFNsaWNlVGFpbChoZWFkLCBlbmQpIDogaGVhZDtcbn07XG5cbmV4cG9ydCBjb25zdCBsaW5rZWRMaXN0VG9BcnJheSA9IDxUPihsaXN0OiBMaW5rZWRMaXN0PFQ+KTogQXJyYXk8VD4gPT4gW1xuICBsaXN0LnZhbHVlLFxuICAuLi4obGlzdC5uZXh0ID8gbGlua2VkTGlzdFRvQXJyYXkobGlzdC5uZXh0KSA6IFtdKSxcbl07XG5cbmV4cG9ydCBjb25zdCBsaW5rZWRMaXN0RnJvbUFycmF5ID0gPFQ+KGFycjogQXJyYXk8VD4pOiBMaW5rZWRMaXN0PFQ+IHwgdW5kZWZpbmVkID0+XG4gIGFyci5yZWR1Y2VSaWdodCgobmV4dDogTGlua2VkTGlzdDxUPiB8IHVuZGVmaW5lZCwgdmFsdWU6IFQpID0+ICh7IHZhbHVlLCBuZXh0IH0pLCB1bmRlZmluZWQpO1xuXG5leHBvcnQgY29uc3QgbGlua2VkTGlzdExhc3QgPSA8VD4obGlzdDogTGlua2VkTGlzdDxUPik6IExpbmtlZExpc3Q8VD4gPT4gKGxpc3QubmV4dCA/IGxpbmtlZExpc3RMYXN0KGxpc3QubmV4dCkgOiBsaXN0KTtcbiJdfQ==