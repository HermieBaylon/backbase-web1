import { flatMap, flatten } from './array';
import { merge, of, combineLatest } from 'rxjs';
import { map, scan, shareReplay, distinctUntilChanged, switchMap } from 'rxjs/operators';
const treeValue = (t) => t.value;
const ɵ0 = treeValue;
/**
 * Abstract tree representation.
 */
export class Tree {
    constructor(
    /**
     * The value of this node
     */
    value, 
    /**
     * The children of this node
     */
    children) {
        this.value = value;
        this.children = children;
    }
    map(callbackfn) {
        const newChildren = this.children.map(childTree => childTree.map(callbackfn));
        return new Tree(callbackfn(this.value, this.children.map(treeValue), newChildren.map(treeValue)), newChildren);
    }
    /**
     * Flattens the tree into a flat array of tree nodes.
     *
     * The tree is flattened by in order of depth-first-preorder-traversal.
     */
    flatten() {
        return [this, ...flatMap(child => child.flatten(), this.children)];
    }
    pathTo(value) {
        if (this.value === value) {
            return [this.value];
        }
        else {
            for (const child of this.children) {
                const childPath = child.pathTo(value);
                if (childPath.length !== 0) {
                    return [this.value, ...childPath];
                }
            }
            return [];
        }
    }
    lowestCommonAncestor(left, right) {
        const leftPath = new Set(this.pathTo(left));
        return this.pathTo(right)
            .reverse()
            .find(candidate => leftPath.has(candidate));
    }
}
/**
 * @description
 * This is an operator that can be used with an Observable's `pipe`.
 *
 * The piped observable should be an observable of an array.
 *
 * The source array is mapped over with the provided callback function, and the
 * callback function should take an item (T) from the source array, and return an
 * *observable* of a new item (R).
 *
 * The result is a new observable of an array the same length as the source array
 * but with the Ts mapped to Rs.
 *
 * This is useful for mapping over the observable children of node in the model tree.
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * const children: ObservableTree<ItemModel> = this.model.children;
 * const titleProperties: Observable<Array<string>> = this.model.children.pipe(
 *   mapObservableArray(item => item.value.property<string>('title', 'Default Title'))
 * );
 * ```
 * @param callback Function that produces an *observable* element of the new Array
 */
export const mapObservableArray = function (callback) {
    return (source) => {
        return source.pipe(switchMap((tArray) => combineLatest(tArray.map(callback))));
    };
};
/**
 * An tree where each node's children are observable.
 */
export class ObservableTree {
    constructor(
    /**
     * The value of this node
     */
    value, initialChildren, insertions, removals) {
        this.value = value;
        this.insertions = insertions;
        this.removals = removals;
        // Reducers to update children state
        this.initialChildren = of((acc) => acc); // identity reducer for initial value
        this.insertUpdates = this.insertions.pipe(map(({ item, index }) => (children) => [...children.slice(0, index), item, ...children.slice(index)]));
        this.removalUpdates = this.removals.pipe(map((index) => (children) => {
            const newChildren = [...children];
            newChildren.splice(index, 1);
            return newChildren;
        }));
        // Combine reducers to a single stream
        this.reducers = merge(this.initialChildren, this.insertUpdates, this.removalUpdates);
        this.children = this.reducers.pipe(scan((currentChildren, updateFn) => updateFn(currentChildren), initialChildren), shareReplay(1));
    }
    /**
     * Find a node in the tree. Returns the result as an observable.
     *
     * If the element is found it is emitted, otherwise, the result emits undefined.
     *
     * The result observable will only emit again if the found node changes (ie: if
     * it is added or removed, or if it finds a different node).
     *
     * @param predicate predicate is called once for each node of the tree, until a
     * node is found. The predicate will be called again every time the tree changes
     * (ie: a node in the tree is added or removed). The predicate is called in order
     * of depth-first-preorder-traversal.
     */
    find(predicate) {
        return this.flatten().pipe(map(nodes => nodes.find(node => predicate(node.value))), distinctUntilChanged());
    }
    pathTo(value) {
        return this.toTree().pipe(map((tree) => tree.pathTo(value)), distinctUntilChanged());
    }
    lowestCommonAncestor(left, right) {
        return this.toTree().pipe(map((tree) => tree.lowestCommonAncestor(left, right)), distinctUntilChanged());
    }
    filter(predicate) {
        return this.flatten().pipe(map(nodes => nodes.filter(node => predicate(node.value))), distinctUntilChanged());
    }
    /**
     * Flattens a tree into a single array of nodes. The result nodes are still trees.
     *
     * The tree is flattened in order of depth-first-preorder-traversal.
     *
     * The result is returned as an observable and re-emits every time a node is added
     * or removed from the tree.
     */
    flatten() {
        return this.children.pipe(switchMap(children => (children.length === 0 ? of([]) : combineLatest(children.map(child => child.flatten())))), map(flatten), map(flat => [this, ...flat]));
    }
    /**
     * Takes a snapshot of the tree.
     */
    toTree() {
        return this.children.pipe(switchMap(children => {
            const mappedChildren$ = children.length === 0 ? of([]) : combineLatest(children.map(child => child.toTree()));
            return mappedChildren$.pipe(map((mappedChildren) => new Tree(this.value, mappedChildren)));
        }));
    }
}
/**
 * Like combineLatest in rxjs, but for a tree of observables, instead of
 * an array of observables.
 */
export function combineTree(tree) {
    // Convert children from Array<Tree<Observable<T>>> to Observable<Array<Tree<T>>>
    const children$ = tree.children.length === 0 ? of([]) : combineLatest(tree.children.map(combineTree));
    return combineLatest([tree.value, children$]).pipe(map(([value, children]) => new Tree(value, children)));
}
/**
 * Extracts a branch from a tree that starts at the root, and ends at the leaf
 * node, as determined by the predicate (returns a linked list).
 *
 * If the element is not found, the result is undefined.
 *
 * @param predicate predicate is called once for each node of the tree, until a
 * node is found. The predicate is called in order of depth-first-preorder-traversal.
 */
export const treeBranch = (tree, predicate) => {
    const walkTree = (treeInner, index, parentTree) => {
        if (predicate(treeInner, index, parentTree)) {
            return {
                value: treeInner,
            };
        }
        if (!treeInner.children) {
            return undefined;
        }
        for (let i = 0; i < treeInner.children.length; i++) {
            const foundInChild = walkTree(treeInner.children[i], i, treeInner);
            if (foundInChild) {
                return {
                    value: treeInner,
                    next: foundInChild,
                };
            }
        }
        return undefined;
    };
    return walkTree(tree);
};
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2NvcmUvc3JjL2JhY2tiYXNlLWNvcmUvbW9kZWxzL3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxTQUFTLENBQUM7QUFFM0MsT0FBTyxFQUFjLEtBQUssRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzVELE9BQU8sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxvQkFBb0IsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUl6RixNQUFNLFNBQVMsR0FBRyxDQUFJLENBQVUsRUFBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQzs7QUFFaEQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sSUFBSTtJQUNmO0lBQ0U7O09BRUc7SUFDSSxLQUFRO0lBQ2Y7O09BRUc7SUFDSSxRQUF3QjtRQUp4QixVQUFLLEdBQUwsS0FBSyxDQUFHO1FBSVIsYUFBUSxHQUFSLFFBQVEsQ0FBZ0I7SUFDOUIsQ0FBQztJQUVKLEdBQUcsQ0FBSSxVQUF5RTtRQUM5RSxNQUFNLFdBQVcsR0FBbUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDOUYsT0FBTyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxXQUFXLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDakgsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxPQUFPO1FBQ0wsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQVE7UUFDYixJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxFQUFFO1lBQ3hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDckI7YUFBTTtZQUNMLEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDakMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdEMsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDMUIsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxTQUFTLENBQUMsQ0FBQztpQkFDbkM7YUFDRjtZQUNELE9BQU8sRUFBRSxDQUFDO1NBQ1g7SUFDSCxDQUFDO0lBRUQsb0JBQW9CLENBQUMsSUFBTyxFQUFFLEtBQVE7UUFDcEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDdEIsT0FBTyxFQUFFO2FBQ1QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7Q0FDRjtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBeUJHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsVUFBZ0IsUUFBaUM7SUFDakYsT0FBTyxDQUFDLE1BQTRCLEVBQXdCLEVBQUU7UUFDNUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQWdCLEVBQUUsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNGLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGNBQWM7SUE4QnpCO0lBQ0U7O09BRUc7SUFDSSxLQUFRLEVBQ2YsZUFBeUMsRUFDeEIsVUFBa0UsRUFDbEUsUUFBNEI7UUFIdEMsVUFBSyxHQUFMLEtBQUssQ0FBRztRQUVFLGVBQVUsR0FBVixVQUFVLENBQXdEO1FBQ2xFLGFBQVEsR0FBUixRQUFRLENBQW9CO1FBcEMvQyxvQ0FBb0M7UUFDbkIsb0JBQWUsR0FBb0MsRUFBRSxDQUFDLENBQUMsR0FBNkIsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxxQ0FBcUM7UUFDcEksa0JBQWEsR0FBb0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQ3BGLEdBQUcsQ0FBQyxDQUNGLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUNmLEVBQUUsQ0FBQyxDQUFDLFFBQWtDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FDNUcsQ0FBQztRQUNlLG1CQUFjLEdBQW9DLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUNuRixHQUFHLENBQUMsQ0FDRixLQUFLLEVBQ0wsRUFBRSxDQUFDLENBQUMsUUFBa0MsRUFBRSxFQUFFO1lBQzFDLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztZQUNsQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM3QixPQUFPLFdBQVcsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FDSCxDQUFDO1FBRUYsc0NBQXNDO1FBQ3JCLGFBQVEsR0FBb0MsS0FBSyxDQUNoRSxJQUFJLENBQUMsZUFBZSxFQUNwQixJQUFJLENBQUMsYUFBYSxFQUNsQixJQUFJLENBQUMsY0FBYyxDQUNwQixDQUFDO1FBZ0JBLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ2hDLElBQUksQ0FDRixDQUFDLGVBQXlDLEVBQUUsUUFBNkIsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxFQUN2RyxlQUFlLENBQ2hCLEVBQ0QsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUNmLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHO0lBQ0gsSUFBSSxDQUFDLFNBQWdDO1FBQ25DLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FDeEIsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUN2RCxvQkFBb0IsRUFBRSxDQUN2QixDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxLQUFRO1FBQ2IsT0FBTyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUN2QixHQUFHLENBQUMsQ0FBQyxJQUFhLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFDMUMsb0JBQW9CLEVBQUUsQ0FDdkIsQ0FBQztJQUNKLENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxJQUFPLEVBQUUsS0FBUTtRQUNwQyxPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLENBQ3ZCLEdBQUcsQ0FBQyxDQUFDLElBQWEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxFQUM5RCxvQkFBb0IsRUFBRSxDQUN2QixDQUFDO0lBQ0osQ0FBQztJQUVELE1BQU0sQ0FBQyxTQUFnQztRQUNyQyxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQ3hCLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFDekQsb0JBQW9CLEVBQUUsQ0FDdkIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0gsT0FBTztRQUNMLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ3ZCLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFDL0csR0FBRyxDQUE0RCxPQUFPLENBQUMsRUFDdkUsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUM3QixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTTtRQUNKLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ3ZCLFNBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNuQixNQUFNLGVBQWUsR0FBRyxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDOUcsT0FBTyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLGNBQThCLEVBQUUsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdHLENBQUMsQ0FBQyxDQUNILENBQUM7SUFDSixDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUFJLElBQXlCO0lBQ3RELGlGQUFpRjtJQUNqRixNQUFNLFNBQVMsR0FDYixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7SUFDdEYsT0FBTyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUNoRCxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQXNCLEVBQUUsRUFBRSxDQUFDLElBQUksSUFBSSxDQUFJLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUM5RSxDQUFDO0FBQ0osQ0FBQztBQW1CRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sQ0FBQyxNQUFNLFVBQVUsR0FBRyxDQUN4QixJQUFvQixFQUNwQixTQUE0RCxFQUNqQyxFQUFFO0lBQzdCLE1BQU0sUUFBUSxHQUFHLENBQ2YsU0FBeUIsRUFDekIsS0FBYyxFQUNkLFVBQTJCLEVBQ0EsRUFBRTtRQUM3QixJQUFJLFNBQVMsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLFVBQVUsQ0FBQyxFQUFFO1lBQzNDLE9BQU87Z0JBQ0wsS0FBSyxFQUFFLFNBQVM7YUFDakIsQ0FBQztTQUNIO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUU7WUFDdkIsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFFRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDbEQsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ25FLElBQUksWUFBWSxFQUFFO2dCQUNoQixPQUFPO29CQUNMLEtBQUssRUFBRSxTQUFTO29CQUNoQixJQUFJLEVBQUUsWUFBWTtpQkFDbkIsQ0FBQzthQUNIO1NBQ0Y7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDLENBQUM7SUFFRixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmbGF0TWFwLCBmbGF0dGVuIH0gZnJvbSAnLi9hcnJheSc7XG5pbXBvcnQgeyBMaW5rZWRMaXN0IH0gZnJvbSAnLi9saW5rZWQtbGlzdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBtZXJnZSwgb2YsIGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCwgc2Nhbiwgc2hhcmVSZXBsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCB0eXBlIENoaWxkcmVuVXBkYXRlRm48VD4gPSAoYWNjOiBBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4pID0+IEFycmF5PE9ic2VydmFibGVUcmVlPFQ+PjtcblxuY29uc3QgdHJlZVZhbHVlID0gPFQ+KHQ6IFRyZWU8VD4pOiBUID0+IHQudmFsdWU7XG5cbi8qKlxuICogQWJzdHJhY3QgdHJlZSByZXByZXNlbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyZWU8VD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBub2RlXG4gICAgICovXG4gICAgcHVibGljIHZhbHVlOiBULFxuICAgIC8qKlxuICAgICAqIFRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGVcbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpbGRyZW46IEFycmF5PFRyZWU8VD4+LFxuICApIHt9XG5cbiAgbWFwPFI+KGNhbGxiYWNrZm46ICh2YWx1ZTogVCwgb2xkQ2hpbGRyZW46IEFycmF5PFQ+LCBuZXdDaGlsZHJlbjogQXJyYXk8Uj4pID0+IFIpOiBUcmVlPFI+IHtcbiAgICBjb25zdCBuZXdDaGlsZHJlbjogQXJyYXk8VHJlZTxSPj4gPSB0aGlzLmNoaWxkcmVuLm1hcChjaGlsZFRyZWUgPT4gY2hpbGRUcmVlLm1hcChjYWxsYmFja2ZuKSk7XG4gICAgcmV0dXJuIG5ldyBUcmVlKGNhbGxiYWNrZm4odGhpcy52YWx1ZSwgdGhpcy5jaGlsZHJlbi5tYXAodHJlZVZhbHVlKSwgbmV3Q2hpbGRyZW4ubWFwKHRyZWVWYWx1ZSkpLCBuZXdDaGlsZHJlbik7XG4gIH1cblxuICAvKipcbiAgICogRmxhdHRlbnMgdGhlIHRyZWUgaW50byBhIGZsYXQgYXJyYXkgb2YgdHJlZSBub2Rlcy5cbiAgICpcbiAgICogVGhlIHRyZWUgaXMgZmxhdHRlbmVkIGJ5IGluIG9yZGVyIG9mIGRlcHRoLWZpcnN0LXByZW9yZGVyLXRyYXZlcnNhbC5cbiAgICovXG4gIGZsYXR0ZW4oKTogQXJyYXk8VHJlZTxUPj4ge1xuICAgIHJldHVybiBbdGhpcywgLi4uZmxhdE1hcChjaGlsZCA9PiBjaGlsZC5mbGF0dGVuKCksIHRoaXMuY2hpbGRyZW4pXTtcbiAgfVxuXG4gIHBhdGhUbyh2YWx1ZTogVCk6IEFycmF5PFQ+IHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBbdGhpcy52YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBjaGlsZC5wYXRoVG8odmFsdWUpO1xuICAgICAgICBpZiAoY2hpbGRQYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgLi4uY2hpbGRQYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIGxvd2VzdENvbW1vbkFuY2VzdG9yKGxlZnQ6IFQsIHJpZ2h0OiBUKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgbGVmdFBhdGggPSBuZXcgU2V0KHRoaXMucGF0aFRvKGxlZnQpKTtcbiAgICByZXR1cm4gdGhpcy5wYXRoVG8ocmlnaHQpXG4gICAgICAucmV2ZXJzZSgpXG4gICAgICAuZmluZChjYW5kaWRhdGUgPT4gbGVmdFBhdGguaGFzKGNhbmRpZGF0ZSkpO1xuICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIGlzIGFuIG9wZXJhdG9yIHRoYXQgY2FuIGJlIHVzZWQgd2l0aCBhbiBPYnNlcnZhYmxlJ3MgYHBpcGVgLlxuICpcbiAqIFRoZSBwaXBlZCBvYnNlcnZhYmxlIHNob3VsZCBiZSBhbiBvYnNlcnZhYmxlIG9mIGFuIGFycmF5LlxuICpcbiAqIFRoZSBzb3VyY2UgYXJyYXkgaXMgbWFwcGVkIG92ZXIgd2l0aCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24sIGFuZCB0aGVcbiAqIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCB0YWtlIGFuIGl0ZW0gKFQpIGZyb20gdGhlIHNvdXJjZSBhcnJheSwgYW5kIHJldHVybiBhblxuICogKm9ic2VydmFibGUqIG9mIGEgbmV3IGl0ZW0gKFIpLlxuICpcbiAqIFRoZSByZXN1bHQgaXMgYSBuZXcgb2JzZXJ2YWJsZSBvZiBhbiBhcnJheSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlIHNvdXJjZSBhcnJheVxuICogYnV0IHdpdGggdGhlIFRzIG1hcHBlZCB0byBScy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFwcGluZyBvdmVyIHRoZSBvYnNlcnZhYmxlIGNoaWxkcmVuIG9mIG5vZGUgaW4gdGhlIG1vZGVsIHRyZWUuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBjaGlsZHJlbjogT2JzZXJ2YWJsZVRyZWU8SXRlbU1vZGVsPiA9IHRoaXMubW9kZWwuY2hpbGRyZW47XG4gKiBjb25zdCB0aXRsZVByb3BlcnRpZXM6IE9ic2VydmFibGU8QXJyYXk8c3RyaW5nPj4gPSB0aGlzLm1vZGVsLmNoaWxkcmVuLnBpcGUoXG4gKiAgIG1hcE9ic2VydmFibGVBcnJheShpdGVtID0+IGl0ZW0udmFsdWUucHJvcGVydHk8c3RyaW5nPigndGl0bGUnLCAnRGVmYXVsdCBUaXRsZScpKVxuICogKTtcbiAqIGBgYFxuICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gKm9ic2VydmFibGUqIGVsZW1lbnQgb2YgdGhlIG5ldyBBcnJheVxuICovXG5leHBvcnQgY29uc3QgbWFwT2JzZXJ2YWJsZUFycmF5ID0gZnVuY3Rpb24gPFQsIFI+KGNhbGxiYWNrOiAoYTogVCkgPT4gT2JzZXJ2YWJsZTxSPikge1xuICByZXR1cm4gKHNvdXJjZTogT2JzZXJ2YWJsZTxBcnJheTxUPj4pOiBPYnNlcnZhYmxlPEFycmF5PFI+PiA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKHN3aXRjaE1hcCgodEFycmF5OiBBcnJheTxUPikgPT4gY29tYmluZUxhdGVzdCh0QXJyYXkubWFwKGNhbGxiYWNrKSkpKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQW4gdHJlZSB3aGVyZSBlYWNoIG5vZGUncyBjaGlsZHJlbiBhcmUgb2JzZXJ2YWJsZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmFibGVUcmVlPFQ+IHtcbiAgLy8gUmVkdWNlcnMgdG8gdXBkYXRlIGNoaWxkcmVuIHN0YXRlXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5pdGlhbENoaWxkcmVuOiBPYnNlcnZhYmxlPENoaWxkcmVuVXBkYXRlRm48VD4+ID0gb2YoKGFjYzogQXJyYXk8T2JzZXJ2YWJsZVRyZWU8VD4+KSA9PiBhY2MpOyAvLyBpZGVudGl0eSByZWR1Y2VyIGZvciBpbml0aWFsIHZhbHVlXG4gIHByaXZhdGUgcmVhZG9ubHkgaW5zZXJ0VXBkYXRlczogT2JzZXJ2YWJsZTxDaGlsZHJlblVwZGF0ZUZuPFQ+PiA9IHRoaXMuaW5zZXJ0aW9ucy5waXBlKFxuICAgIG1hcCgoXG4gICAgICB7IGl0ZW0sIGluZGV4IH0sIC8vIG1hcCBpbnNlcnRzIHRvIHJlZHVjZXIgZnVuY3Rpb25zXG4gICAgKSA9PiAoY2hpbGRyZW46IEFycmF5PE9ic2VydmFibGVUcmVlPFQ+PikgPT4gWy4uLmNoaWxkcmVuLnNsaWNlKDAsIGluZGV4KSwgaXRlbSwgLi4uY2hpbGRyZW4uc2xpY2UoaW5kZXgpXSksXG4gICk7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVtb3ZhbFVwZGF0ZXM6IE9ic2VydmFibGU8Q2hpbGRyZW5VcGRhdGVGbjxUPj4gPSB0aGlzLnJlbW92YWxzLnBpcGUoXG4gICAgbWFwKChcbiAgICAgIGluZGV4LCAvLyBtYXAgcmVtb3ZhbHMgdG8gcmVkdWNlciBmdW50aW9uc1xuICAgICkgPT4gKGNoaWxkcmVuOiBBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4pID0+IHtcbiAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gWy4uLmNoaWxkcmVuXTtcbiAgICAgIG5ld0NoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gbmV3Q2hpbGRyZW47XG4gICAgfSksXG4gICk7XG5cbiAgLy8gQ29tYmluZSByZWR1Y2VycyB0byBhIHNpbmdsZSBzdHJlYW1cbiAgcHJpdmF0ZSByZWFkb25seSByZWR1Y2VyczogT2JzZXJ2YWJsZTxDaGlsZHJlblVwZGF0ZUZuPFQ+PiA9IG1lcmdlKFxuICAgIHRoaXMuaW5pdGlhbENoaWxkcmVuLFxuICAgIHRoaXMuaW5zZXJ0VXBkYXRlcyxcbiAgICB0aGlzLnJlbW92YWxVcGRhdGVzLFxuICApO1xuXG4gIC8qKlxuICAgKiBUaGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlXG4gICAqL1xuICByZWFkb25seSBjaGlsZHJlbjogT2JzZXJ2YWJsZTxBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGlzIG5vZGVcbiAgICAgKi9cbiAgICBwdWJsaWMgdmFsdWU6IFQsXG4gICAgaW5pdGlhbENoaWxkcmVuOiBBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4sXG4gICAgcHJpdmF0ZSByZWFkb25seSBpbnNlcnRpb25zOiBPYnNlcnZhYmxlPHsgaXRlbTogT2JzZXJ2YWJsZVRyZWU8VD47IGluZGV4OiBudW1iZXIgfT4sXG4gICAgcHJpdmF0ZSByZWFkb25seSByZW1vdmFsczogT2JzZXJ2YWJsZTxudW1iZXI+LFxuICApIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5yZWR1Y2Vycy5waXBlKFxuICAgICAgc2NhbjxDaGlsZHJlblVwZGF0ZUZuPFQ+LCBBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4+KFxuICAgICAgICAoY3VycmVudENoaWxkcmVuOiBBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4sIHVwZGF0ZUZuOiBDaGlsZHJlblVwZGF0ZUZuPFQ+KSA9PiB1cGRhdGVGbihjdXJyZW50Q2hpbGRyZW4pLFxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICApLFxuICAgICAgc2hhcmVSZXBsYXkoMSksXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgbm9kZSBpbiB0aGUgdHJlZS4gUmV0dXJucyB0aGUgcmVzdWx0IGFzIGFuIG9ic2VydmFibGUuXG4gICAqXG4gICAqIElmIHRoZSBlbGVtZW50IGlzIGZvdW5kIGl0IGlzIGVtaXR0ZWQsIG90aGVyd2lzZSwgdGhlIHJlc3VsdCBlbWl0cyB1bmRlZmluZWQuXG4gICAqXG4gICAqIFRoZSByZXN1bHQgb2JzZXJ2YWJsZSB3aWxsIG9ubHkgZW1pdCBhZ2FpbiBpZiB0aGUgZm91bmQgbm9kZSBjaGFuZ2VzIChpZTogaWZcbiAgICogaXQgaXMgYWRkZWQgb3IgcmVtb3ZlZCwgb3IgaWYgaXQgZmluZHMgYSBkaWZmZXJlbnQgbm9kZSkuXG4gICAqXG4gICAqIEBwYXJhbSBwcmVkaWNhdGUgcHJlZGljYXRlIGlzIGNhbGxlZCBvbmNlIGZvciBlYWNoIG5vZGUgb2YgdGhlIHRyZWUsIHVudGlsIGFcbiAgICogbm9kZSBpcyBmb3VuZC4gVGhlIHByZWRpY2F0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiBldmVyeSB0aW1lIHRoZSB0cmVlIGNoYW5nZXNcbiAgICogKGllOiBhIG5vZGUgaW4gdGhlIHRyZWUgaXMgYWRkZWQgb3IgcmVtb3ZlZCkuIFRoZSBwcmVkaWNhdGUgaXMgY2FsbGVkIGluIG9yZGVyXG4gICAqIG9mIGRlcHRoLWZpcnN0LXByZW9yZGVyLXRyYXZlcnNhbC5cbiAgICovXG4gIGZpbmQocHJlZGljYXRlOiAodmFsdWU6IFQpID0+IGJvb2xlYW4pOiBPYnNlcnZhYmxlPE9ic2VydmFibGVUcmVlPFQ+IHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpLnBpcGUoXG4gICAgICBtYXAobm9kZXMgPT4gbm9kZXMuZmluZChub2RlID0+IHByZWRpY2F0ZShub2RlLnZhbHVlKSkpLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICApO1xuICB9XG5cbiAgcGF0aFRvKHZhbHVlOiBUKTogT2JzZXJ2YWJsZTxBcnJheTxUPj4ge1xuICAgIHJldHVybiB0aGlzLnRvVHJlZSgpLnBpcGUoXG4gICAgICBtYXAoKHRyZWU6IFRyZWU8VD4pID0+IHRyZWUucGF0aFRvKHZhbHVlKSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICk7XG4gIH1cblxuICBsb3dlc3RDb21tb25BbmNlc3RvcihsZWZ0OiBULCByaWdodDogVCk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLnRvVHJlZSgpLnBpcGUoXG4gICAgICBtYXAoKHRyZWU6IFRyZWU8VD4pID0+IHRyZWUubG93ZXN0Q29tbW9uQW5jZXN0b3IobGVmdCwgcmlnaHQpKSxcbiAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXG4gICAgKTtcbiAgfVxuXG4gIGZpbHRlcihwcmVkaWNhdGU6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbik6IE9ic2VydmFibGU8QXJyYXk8T2JzZXJ2YWJsZVRyZWU8VD4+PiB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpLnBpcGUoXG4gICAgICBtYXAobm9kZXMgPT4gbm9kZXMuZmlsdGVyKG5vZGUgPT4gcHJlZGljYXRlKG5vZGUudmFsdWUpKSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRmxhdHRlbnMgYSB0cmVlIGludG8gYSBzaW5nbGUgYXJyYXkgb2Ygbm9kZXMuIFRoZSByZXN1bHQgbm9kZXMgYXJlIHN0aWxsIHRyZWVzLlxuICAgKlxuICAgKiBUaGUgdHJlZSBpcyBmbGF0dGVuZWQgaW4gb3JkZXIgb2YgZGVwdGgtZmlyc3QtcHJlb3JkZXItdHJhdmVyc2FsLlxuICAgKlxuICAgKiBUaGUgcmVzdWx0IGlzIHJldHVybmVkIGFzIGFuIG9ic2VydmFibGUgYW5kIHJlLWVtaXRzIGV2ZXJ5IHRpbWUgYSBub2RlIGlzIGFkZGVkXG4gICAqIG9yIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS5cbiAgICovXG4gIGZsYXR0ZW4oKTogT2JzZXJ2YWJsZTxBcnJheTxPYnNlcnZhYmxlVHJlZTxUPj4+IHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5waXBlKFxuICAgICAgc3dpdGNoTWFwKGNoaWxkcmVuID0+IChjaGlsZHJlbi5sZW5ndGggPT09IDAgPyBvZihbXSkgOiBjb21iaW5lTGF0ZXN0KGNoaWxkcmVuLm1hcChjaGlsZCA9PiBjaGlsZC5mbGF0dGVuKCkpKSkpLFxuICAgICAgbWFwPEFycmF5PEFycmF5PE9ic2VydmFibGVUcmVlPFQ+Pj4sIEFycmF5PE9ic2VydmFibGVUcmVlPFQ+Pj4oZmxhdHRlbiksXG4gICAgICBtYXAoZmxhdCA9PiBbdGhpcywgLi4uZmxhdF0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSBzbmFwc2hvdCBvZiB0aGUgdHJlZS5cbiAgICovXG4gIHRvVHJlZSgpOiBPYnNlcnZhYmxlPFRyZWU8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5waXBlKFxuICAgICAgc3dpdGNoTWFwKGNoaWxkcmVuID0+IHtcbiAgICAgICAgY29uc3QgbWFwcGVkQ2hpbGRyZW4kID0gY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gb2YoW10pIDogY29tYmluZUxhdGVzdChjaGlsZHJlbi5tYXAoY2hpbGQgPT4gY2hpbGQudG9UcmVlKCkpKTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZENoaWxkcmVuJC5waXBlKG1hcCgobWFwcGVkQ2hpbGRyZW46IEFycmF5PFRyZWU8VD4+KSA9PiBuZXcgVHJlZSh0aGlzLnZhbHVlLCBtYXBwZWRDaGlsZHJlbikpKTtcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBMaWtlIGNvbWJpbmVMYXRlc3QgaW4gcnhqcywgYnV0IGZvciBhIHRyZWUgb2Ygb2JzZXJ2YWJsZXMsIGluc3RlYWQgb2ZcbiAqIGFuIGFycmF5IG9mIG9ic2VydmFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZVRyZWU8VD4odHJlZTogVHJlZTxPYnNlcnZhYmxlPFQ+Pik6IE9ic2VydmFibGU8VHJlZTxUPj4ge1xuICAvLyBDb252ZXJ0IGNoaWxkcmVuIGZyb20gQXJyYXk8VHJlZTxPYnNlcnZhYmxlPFQ+Pj4gdG8gT2JzZXJ2YWJsZTxBcnJheTxUcmVlPFQ+Pj5cbiAgY29uc3QgY2hpbGRyZW4kOiBPYnNlcnZhYmxlPEFycmF5PFRyZWU8VD4+PiA9XG4gICAgdHJlZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyBvZihbXSkgOiBjb21iaW5lTGF0ZXN0KHRyZWUuY2hpbGRyZW4ubWFwKGNvbWJpbmVUcmVlKSk7XG4gIHJldHVybiBjb21iaW5lTGF0ZXN0KFt0cmVlLnZhbHVlLCBjaGlsZHJlbiRdKS5waXBlKFxuICAgIG1hcCgoW3ZhbHVlLCBjaGlsZHJlbl06IFtULCBBcnJheTxUcmVlPFQ+Pl0pID0+IG5ldyBUcmVlPFQ+KHZhbHVlLCBjaGlsZHJlbikpLFxuICApO1xufVxuXG4vKipcbiAqIERlc2NyaWJlcyBhIG1vcmUgZ2VuZXJpYyB0cmVlIHRoYW4gb3VyIFwiVHJlZVwiIHR5cGUuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyBvbiBkaWZmZXJlbnRcbiAqIFwidHJlZVwiIGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgdGhpcyBpcyB0eXBlIHdoaWNoIGRlc2NyaWJlcyBhbiBhbmd1bGFyXG4gKiBgUm91dGVgIGFzIG91ciBnZW5lcmljIHRyZWUgdHlwZTpcbiAqIGB0eXBlIEFuZ3VsYXJSb3V0ZVRyZWUgPSBHZW5lcmljVHJlZTxSb3V0ZT47YFxuICpcbiAqIEFuZCB0aGlzIGRlc2NyaWJlcyBvdXIgYENvbXBvbmVudFJvdXRlVHJlZWBcbiAqIGB0eXBlIENvbXBvbmVudFRyZWUgPSBHZW5lcmljVHJlZTxUcmVlPEl0ZW1Sb3V0ZXM+PjtcbiAqL1xuZXhwb3J0IHR5cGUgR2VuZXJpY1RyZWU8VD4gPSBUICYge1xuICBjaGlsZHJlbj86IEFycmF5PEdlbmVyaWNUcmVlPFQ+Pjtcbn07XG5cbi8qKlxuICogRXh0cmFjdHMgYSBicmFuY2ggZnJvbSBhIHRyZWUgdGhhdCBzdGFydHMgYXQgdGhlIHJvb3QsIGFuZCBlbmRzIGF0IHRoZSBsZWFmXG4gKiBub2RlLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBwcmVkaWNhdGUgKHJldHVybnMgYSBsaW5rZWQgbGlzdCkuXG4gKlxuICogSWYgdGhlIGVsZW1lbnQgaXMgbm90IGZvdW5kLCB0aGUgcmVzdWx0IGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gcHJlZGljYXRlIHByZWRpY2F0ZSBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBub2RlIG9mIHRoZSB0cmVlLCB1bnRpbCBhXG4gKiBub2RlIGlzIGZvdW5kLiBUaGUgcHJlZGljYXRlIGlzIGNhbGxlZCBpbiBvcmRlciBvZiBkZXB0aC1maXJzdC1wcmVvcmRlci10cmF2ZXJzYWwuXG4gKi9cbmV4cG9ydCBjb25zdCB0cmVlQnJhbmNoID0gPFQ+KFxuICB0cmVlOiBHZW5lcmljVHJlZTxUPixcbiAgcHJlZGljYXRlOiAodmFsdWU6IFQsIGluZGV4PzogbnVtYmVyLCBwYXJlbnQ/OiBUKSA9PiBib29sZWFuLFxuKTogTGlua2VkTGlzdDxUPiB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IHdhbGtUcmVlID0gKFxuICAgIHRyZWVJbm5lcjogR2VuZXJpY1RyZWU8VD4sXG4gICAgaW5kZXg/OiBudW1iZXIsXG4gICAgcGFyZW50VHJlZT86IEdlbmVyaWNUcmVlPFQ+LFxuICApOiBMaW5rZWRMaXN0PFQ+IHwgdW5kZWZpbmVkID0+IHtcbiAgICBpZiAocHJlZGljYXRlKHRyZWVJbm5lciwgaW5kZXgsIHBhcmVudFRyZWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdHJlZUlubmVyLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXRyZWVJbm5lci5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWVJbm5lci5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZm91bmRJbkNoaWxkID0gd2Fsa1RyZWUodHJlZUlubmVyLmNoaWxkcmVuW2ldLCBpLCB0cmVlSW5uZXIpO1xuICAgICAgaWYgKGZvdW5kSW5DaGlsZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB0cmVlSW5uZXIsXG4gICAgICAgICAgbmV4dDogZm91bmRJbkNoaWxkLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIHdhbGtUcmVlKHRyZWUpO1xufTtcbiJdfQ==