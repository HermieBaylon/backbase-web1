export const map = (callbackfn, arr) => arr.map(callbackfn);
export const flatten = (arr) => arr.reduce((acc, a) => [...acc, ...a], []);
export const flatMap = (callbackfn, arr) => flatten(map(callbackfn, arr));
export const uniq = (array) => Array.from(new Set(array));
export const hasDuplicates = (array) => array.length !== uniq(array).length;
/**
 * Creates a new list out of the two supplied by pairing up equally-positioned
 * items from both lists. The returned list is the length of the longer of two
 * lists. If one of the lists is shorter, the values will be set to "undefined".
 *
 * @param left
 * @param right
 */
export const pairs = (left, right) => {
    const max = Math.max(left.length, right.length);
    let idx = 0;
    const returnZip = [];
    while (idx < max) {
        returnZip[idx] = [left[idx], right[idx]];
        idx++;
    }
    return returnZip;
};
/**
 * This helper checks if the value is array of strings.
 * @param value a value to be evaluated
 * @returns true for array of strings and false for any other values
 */
export const isArrayOfStrings = (value) => Array.isArray(value) && value.every(item => typeof item === 'string');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL21vZGVscy9hcnJheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBTyxVQUEyQixFQUFFLEdBQWEsRUFBWSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBSSxVQUFVLENBQUMsQ0FBQztBQUUxRyxNQUFNLENBQUMsTUFBTSxPQUFPLEdBQUcsQ0FBSSxHQUFvQixFQUFZLEVBQUUsQ0FDM0QsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQWEsRUFBRSxDQUFXLEVBQVksRUFBRSxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFjLENBQUMsQ0FBQztBQUV2RixNQUFNLENBQUMsTUFBTSxPQUFPLEdBQUcsQ0FBTyxVQUFrQyxFQUFFLEdBQWEsRUFBWSxFQUFFLENBQzNGLE9BQU8sQ0FBSSxHQUFHLENBQWMsVUFBVSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFFaEQsTUFBTSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUksS0FBZSxFQUFZLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFJLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDcEYsTUFBTSxDQUFDLE1BQU0sYUFBYSxHQUFHLENBQUMsS0FBcUIsRUFBVyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBRXJHOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxLQUFLLEdBQUcsQ0FBTyxJQUFjLEVBQUUsS0FBZSxFQUF5QyxFQUFFO0lBQ3BHLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEQsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBRVosTUFBTSxTQUFTLEdBQTBDLEVBQUUsQ0FBQztJQUM1RCxPQUFPLEdBQUcsR0FBRyxHQUFHLEVBQUU7UUFDaEIsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3pDLEdBQUcsRUFBRSxDQUFDO0tBQ1A7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUM7QUFFRjs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFVLEVBQTBCLEVBQUUsQ0FDckUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxJQUFJLEtBQUssUUFBUSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbWFwID0gPFQsIFI+KGNhbGxiYWNrZm46ICh2YWx1ZTogVCkgPT4gUiwgYXJyOiBBcnJheTxUPik6IEFycmF5PFI+ID0+IGFyci5tYXA8Uj4oY2FsbGJhY2tmbik7XG5cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gPFQ+KGFycjogQXJyYXk8QXJyYXk8VD4+KTogQXJyYXk8VD4gPT5cbiAgYXJyLnJlZHVjZSgoYWNjOiBBcnJheTxUPiwgYTogQXJyYXk8VD4pOiBBcnJheTxUPiA9PiBbLi4uYWNjLCAuLi5hXSwgW10gYXMgQXJyYXk8VD4pO1xuXG5leHBvcnQgY29uc3QgZmxhdE1hcCA9IDxULCBSPihjYWxsYmFja2ZuOiAodmFsdWU6IFQpID0+IEFycmF5PFI+LCBhcnI6IEFycmF5PFQ+KTogQXJyYXk8Uj4gPT5cbiAgZmxhdHRlbjxSPihtYXA8VCwgQXJyYXk8Uj4+KGNhbGxiYWNrZm4sIGFycikpO1xuXG5leHBvcnQgY29uc3QgdW5pcSA9IDxUPihhcnJheTogQXJyYXk8VD4pOiBBcnJheTxUPiA9PiBBcnJheS5mcm9tKG5ldyBTZXQ8VD4oYXJyYXkpKTtcbmV4cG9ydCBjb25zdCBoYXNEdXBsaWNhdGVzID0gKGFycmF5OiBBcnJheTx1bmtub3duPik6IGJvb2xlYW4gPT4gYXJyYXkubGVuZ3RoICE9PSB1bmlxKGFycmF5KS5sZW5ndGg7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IHBhaXJpbmcgdXAgZXF1YWxseS1wb3NpdGlvbmVkXG4gKiBpdGVtcyBmcm9tIGJvdGggbGlzdHMuIFRoZSByZXR1cm5lZCBsaXN0IGlzIHRoZSBsZW5ndGggb2YgdGhlIGxvbmdlciBvZiB0d29cbiAqIGxpc3RzLiBJZiBvbmUgb2YgdGhlIGxpc3RzIGlzIHNob3J0ZXIsIHRoZSB2YWx1ZXMgd2lsbCBiZSBzZXQgdG8gXCJ1bmRlZmluZWRcIi5cbiAqXG4gKiBAcGFyYW0gbGVmdFxuICogQHBhcmFtIHJpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBwYWlycyA9IDxULCBSPihsZWZ0OiBBcnJheTxUPiwgcmlnaHQ6IEFycmF5PFI+KTogQXJyYXk8W1QgfCB1bmRlZmluZWQsIFIgfCB1bmRlZmluZWRdPiA9PiB7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KGxlZnQubGVuZ3RoLCByaWdodC5sZW5ndGgpO1xuICBsZXQgaWR4ID0gMDtcblxuICBjb25zdCByZXR1cm5aaXA6IEFycmF5PFtUIHwgdW5kZWZpbmVkLCBSIHwgdW5kZWZpbmVkXT4gPSBbXTtcbiAgd2hpbGUgKGlkeCA8IG1heCkge1xuICAgIHJldHVyblppcFtpZHhdID0gW2xlZnRbaWR4XSwgcmlnaHRbaWR4XV07XG4gICAgaWR4Kys7XG4gIH1cbiAgcmV0dXJuIHJldHVyblppcDtcbn07XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgY2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIHZhbHVlIGEgdmFsdWUgdG8gYmUgZXZhbHVhdGVkXG4gKiBAcmV0dXJucyB0cnVlIGZvciBhcnJheSBvZiBzdHJpbmdzIGFuZCBmYWxzZSBmb3IgYW55IG90aGVyIHZhbHVlc1xuICovXG5leHBvcnQgY29uc3QgaXNBcnJheU9mU3RyaW5ncyA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgQXJyYXk8c3RyaW5nPiA9PlxuICBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyk7XG4iXX0=