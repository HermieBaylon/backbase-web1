import { Injectable } from '@angular/core';
import { PRIMARY_OUTLET, Router, UrlSegment, UrlSegmentGroup, ActivatedRoute, } from '@angular/router';
import { linkedListSlice, linkedListFind, linkedListToArray, linkedListFromArray, linkedListLast, } from '../../models/linked-list';
import { pairs, flatMap } from '../../models/array';
const hasNamedOutlet = (node) => node.outlet !== PRIMARY_OUTLET;
const ɵ0 = hasNamedOutlet;
const routeSegmentToUrlSegment = (node) => new UrlSegment(node.path, node.params || {});
const ɵ1 = routeSegmentToUrlSegment;
export class RouterNavigationService {
    constructor(router) {
        this.router = router;
    }
    /**
     * Set (merge) the params on a given `ActivatedRoute`, preserving the active children's states.
     *
     * This allows updating the params in an arbitrary route in the active route
     * tree without needing to know the state of every child route.
     *
     * @param params The route params that should be set on the given route
     * @param from The route to set the params on
     * @returns The new URLTree
     */
    setParams(params, from) {
        const snapshot = from instanceof ActivatedRoute ? from.snapshot : from;
        const navigationRoute = linkedListFromArray(flatMap((route) => route.url.map((url) => ({
            path: url.path,
            outlet: route.outlet,
            params: url.parameters,
        })), snapshot.pathFromRoot));
        if (!navigationRoute) {
            throw new Error('No route to set params on');
        }
        const last = linkedListLast(navigationRoute);
        last.value.params = last.value.params ? Object.assign(Object.assign({}, last.value.params), params) : params;
        return this.createUrlTree(navigationRoute);
    }
    createUrlTree(routeBranch) {
        const tree = this.router.parseUrl('/'); // @todo: is there no better way to make a tree?
        const rootRouteSegment = routeBranch.value;
        tree.root.children[rootRouteSegment.outlet] = this.urlSegmentGroupForRoute(routeBranch);
        return tree;
    }
    /*
     * A segment group is a node in the UrlTree. The node itself is an array
     * of segments, which are all considered on the "primary" outlet.
     * The children of this node are the paths on the "non-primary" outlets.
     * There will only be a single "child" for the NavigationRoute (as it
     * represents a single branch through a UrlTree).
     */
    urlSegmentGroupForRoute(routeBranch) {
        // Find all paths up to the first non-primary outlet - these will be the segments.
        const routeSegments = {
            value: routeBranch.value,
            next: routeBranch.next ? linkedListSlice(routeBranch.next, undefined, hasNamedOutlet) : undefined,
        };
        const segments = linkedListToArray(routeSegments).map(routeSegmentToUrlSegment);
        // Find the first non-primary outlet - this will be the child.
        const nextOutlet = routeBranch.next && linkedListFind(routeBranch.next, hasNamedOutlet);
        const segmentGroupChildren = nextOutlet
            ? { [nextOutlet.value.outlet]: this.urlSegmentGroupForRoute(nextOutlet) }
            : {};
        return new UrlSegmentGroup(segments, segmentGroupChildren);
    }
    /**
     * Merge a new `UrlTree` into the current active `UrlTree`.
     *
     * @param newTree
     */
    navigate(newTree) {
        const activeTree = this.router.parseUrl(this.router.url);
        const mergedTree = this.router.parseUrl('/');
        mergedTree.root.children = this.mergeUrlSegmentGroupChildren(activeTree.root.children, newTree.root.children);
        return this.router.navigateByUrl(mergedTree);
    }
    /**
     * Merge new children of a `UrlSegmentGroup` children into the children of the
     * current active `UrlSegmentGroup`.
     *
     * @param activeChildren
     * @param newChildren
     */
    mergeUrlSegmentGroupChildren(activeChildren, newChildren) {
        const mergedChildren = Object.keys(newChildren).reduce((acc, outletName) => {
            if (!activeChildren[outletName]) {
                return acc;
            }
            return Object.assign(Object.assign({}, acc), { [outletName]: this.mergeUrlTreeSegmentGroup(activeChildren[outletName], newChildren[outletName]) });
        }, newChildren);
        /**
         * Sibling routes can be preserved, or not.
         *
         * Because the current active route is a tree (for example, when you have multiple named
         * outlets and they are active) when you navigate to a new route it is possible to preserve
         * active routes that are siblings to the route you're navigating to.
         *
         * For example, when navigating from URL `/a/(b//x:c)` to `/a/c`, should the `x:c` or `b`
         * be preserved. The URL can be visualised as a tree (where a double slash `//` shows siblings
         * in the tree):
         *
         * ```
         *  -a
         *   `- b
         *   `- x:c
         * ```
         *
         * When set to true, all sibling will be preserved. For example, when navigating to `/a/d`
         * the `x:c` branch will be preserved and the new URL will be `/a/(d//x:c)`. Similarly,
         * when navigating to `/a/(x:e)`, the `b` branch will be preserved and the new URL will
         * be `/a/(b//x:e)`.
         *
         * Merging is disabled by default, but can be enabled with a feature flag.
         */
        return Object.assign(Object.assign({}, activeChildren), mergedChildren);
    }
    /**
     * Merge a new `UrlSegmentGroup` into the current active `UrlSegmentGroup`.
     *
     * @param activeSegmentGroup
     * @param newSegmentGroup
     */
    mergeUrlTreeSegmentGroup(activeSegmentGroup, newSegmentGroup) {
        return new UrlSegmentGroup(this.mergeUrlSegments(activeSegmentGroup.segments, newSegmentGroup.segments), this.mergeUrlSegmentGroupChildren(activeSegmentGroup.children, newSegmentGroup.children));
    }
    /**
     * Merge an array of new `UrlSegment` into the current active `UrlSegment` array.
     *
     * @param activeSegments
     * @param newSegments
     */
    mergeUrlSegments(activeSegments, newSegments) {
        // Determine if any params are being set.
        const preserveActiveTailSegments = !!newSegments.find(segment => Object.keys(segment.parameters).length > 0);
        // When the new segments change path from the active segment, then they
        // should no longer be preserved, so they get set to undefined.
        const removeActiveSegments = () => {
            let matches = true;
            return ([activeSegment, newSegment]) => {
                if (matches && activeSegment && newSegment) {
                    matches = activeSegment.path === newSegment.path;
                }
                return [matches ? activeSegment : undefined, newSegment];
            };
        };
        // pair the segments into a single array
        return pairs(activeSegments, newSegments)
            .map(removeActiveSegments())
            .map(([activeSegment, newSegment]) => this.mergeUrlSegment(activeSegment, newSegment, preserveActiveTailSegments))
            .filter((a) => a !== undefined);
    }
    /**
     * Merge a new `UrlSegment` into the current active `UrlSegment`.
     *
     * If there is both an active and new segment it is assumed that the path
     * is the same already.
     *
     * @param activeSegment
     * @param newSegment
     * @param isSettingParams
     */
    mergeUrlSegment(activeSegment, newSegment, preserveActiveTailSegments) {
        /**
         * There are 3 different strategies for how to preserve any "tail" segments in
         * the route: 'never' | 'on-param-set' | 'always'.
         *
         * This is only relevant when any route branch you're navigating to is a subset
         * of a current active route. For example, when navigating from URL `/a/b` to
         * `/a`, should `b` be preserved?
         *
         * When set to 'never' the children will be discarded, and the new URL will simply
         * be `/a`.
         *
         * When set to 'always' the children will always be preserved (this means it would
         * be impossible to navigate to a parent route).
         *
         * When set to 'on-param-set' the children will only be preserved if params are being
         * set on the route. For example, when navigating from `/a/b` to
         * `/a;data=foo` then the new URL will be `/a:data=foo/b`.
         *
         * This is implemented using the 'never' OR 'on-param-set' strategy depending on the
         * `preserveActiveTailSegments` flag.
         */
        if (activeSegment && !newSegment && preserveActiveTailSegments) {
            return new UrlSegment(activeSegment.path, activeSegment.parameters);
        }
        else if (newSegment) {
            const activeSegmentParams = (activeSegment && activeSegment.parameters) || {};
            return new UrlSegment(newSegment.path, this.mergeUrlSegmentParams(activeSegmentParams, newSegment.parameters));
        }
        return undefined;
    }
    mergeUrlSegmentParams(activeSegmentParams, newSegmentParams) {
        /**
         * There 3 different strategies for how to preserve any route-parameters in the
         * route: 'never' | 'overwrite' | 'merge'.
         *
         * For example, when navigating from URL `/a;data=foo/b` to `/a;x=y/c`, should the
         * 'data' param be preserved.
         *
         * When `never` the params will be discarded, and the new URL will simply be `/a;x=y/c`.
         *
         * When `merge`, then the params will be preserved, and the new URL will be
         * `/a;data=foo;x=y/c`.
         *
         * When 'overwrite', then the params will be only be preserved if there are no *other*
         * params being set on that segment. For example, when navigating instead to:
         * `/a/c;foo=bar`, the new URL will be `/a;data=foo/c;foo=bar`.
         *
         * This is implemented using the "overwrite" strategy.
         */
        return Object.keys(newSegmentParams).length === 0 ? activeSegmentParams : newSegmentParams;
    }
}
RouterNavigationService.decorators = [
    { type: Injectable }
];
RouterNavigationService.ctorParameters = () => [
    { type: Router }
];
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLW5hdmlnYXRpb24uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2NvcmUvc3JjL2JhY2tiYXNlLWNvcmUvcm91dGluZy9uYXZpZ2F0aW9uL3JvdXRlci1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQ0wsY0FBYyxFQUNkLE1BQU0sRUFDTixVQUFVLEVBQ1YsZUFBZSxFQUVmLGNBQWMsR0FFZixNQUFNLGlCQUFpQixDQUFDO0FBRXpCLE9BQU8sRUFDTCxlQUFlLEVBRWYsY0FBYyxFQUNkLGlCQUFpQixFQUNqQixtQkFBbUIsRUFDbkIsY0FBYyxHQUNmLE1BQU0sMEJBQTBCLENBQUM7QUFDbEMsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQWtCcEQsTUFBTSxjQUFjLEdBQUcsQ0FBQyxJQUFrQixFQUFXLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxLQUFLLGNBQWMsQ0FBQzs7QUFFdkYsTUFBTSx3QkFBd0IsR0FBRyxDQUFDLElBQWtCLEVBQWMsRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQzs7QUFHbEgsTUFBTSxPQUFPLHVCQUF1QjtJQUNsQyxZQUE2QixNQUFjO1FBQWQsV0FBTSxHQUFOLE1BQU0sQ0FBUTtJQUFHLENBQUM7SUFFL0M7Ozs7Ozs7OztPQVNHO0lBQ0gsU0FBUyxDQUFDLE1BQTBCLEVBQUUsSUFBNkM7UUFDakYsTUFBTSxRQUFRLEdBQUcsSUFBSSxZQUFZLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENB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QUFDLENBQUM7U0FDckU7YUFBTSxJQUFJLFVBQVUsRUFBRTtZQUNyQixNQUFNLG1CQUFtQixHQUFHLENBQUMsYUFBYSxJQUFJLGFBQWEsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDOUUsT0FBTyxJQUFJLFVBQVUsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxtQkFBbUIsRUFBRSxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUNoSDtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFTyxxQkFBcUIsQ0FBQyxtQkFBdUMsRUFBRSxnQkFBb0M7UUFDekc7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBaUJHO1FBQ0gsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDO0lBQzdGLENBQUM7OztZQWpQRixVQUFVOzs7WUF0Q1QsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIFBSSU1BUllfT1VUTEVULFxuICBSb3V0ZXIsXG4gIFVybFNlZ21lbnQsXG4gIFVybFNlZ21lbnRHcm91cCxcbiAgVXJsVHJlZSxcbiAgQWN0aXZhdGVkUm91dGUsXG4gIEFjdGl2YXRlZFJvdXRlU25hcHNob3QsXG59IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbmltcG9ydCB7XG4gIGxpbmtlZExpc3RTbGljZSxcbiAgTGlua2VkTGlzdCxcbiAgbGlua2VkTGlzdEZpbmQsXG4gIGxpbmtlZExpc3RUb0FycmF5LFxuICBsaW5rZWRMaXN0RnJvbUFycmF5LFxuICBsaW5rZWRMaXN0TGFzdCxcbn0gZnJvbSAnLi4vLi4vbW9kZWxzL2xpbmtlZC1saXN0JztcbmltcG9ydCB7IHBhaXJzLCBmbGF0TWFwIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2FycmF5JztcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVNlZ21lbnRQYXJhbXMge1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVTZWdtZW50IHtcbiAgcGF0aDogc3RyaW5nO1xuICBvdXRsZXQ6IHN0cmluZztcbiAgcGFyYW1zPzogUm91dGVTZWdtZW50UGFyYW1zO1xufVxuXG5leHBvcnQgdHlwZSBOYXZpZ2F0aW9uUm91dGUgPSBMaW5rZWRMaXN0PFJvdXRlU2VnbWVudD47XG5cbmRlY2xhcmUgaW50ZXJmYWNlIFVybFNlZ21lbnRHcm91cENoaWxkcmVuIHtcbiAgW2tleTogc3RyaW5nXTogVXJsU2VnbWVudEdyb3VwO1xufVxuXG5jb25zdCBoYXNOYW1lZE91dGxldCA9IChub2RlOiBSb3V0ZVNlZ21lbnQpOiBib29sZWFuID0+IG5vZGUub3V0bGV0ICE9PSBQUklNQVJZX09VVExFVDtcblxuY29uc3Qgcm91dGVTZWdtZW50VG9VcmxTZWdtZW50ID0gKG5vZGU6IFJvdXRlU2VnbWVudCk6IFVybFNlZ21lbnQgPT4gbmV3IFVybFNlZ21lbnQobm9kZS5wYXRoLCBub2RlLnBhcmFtcyB8fCB7fSk7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSb3V0ZXJOYXZpZ2F0aW9uU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcm91dGVyOiBSb3V0ZXIpIHt9XG5cbiAgLyoqXG4gICAqIFNldCAobWVyZ2UpIHRoZSBwYXJhbXMgb24gYSBnaXZlbiBgQWN0aXZhdGVkUm91dGVgLCBwcmVzZXJ2aW5nIHRoZSBhY3RpdmUgY2hpbGRyZW4ncyBzdGF0ZXMuXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHVwZGF0aW5nIHRoZSBwYXJhbXMgaW4gYW4gYXJiaXRyYXJ5IHJvdXRlIGluIHRoZSBhY3RpdmUgcm91dGVcbiAgICogdHJlZSB3aXRob3V0IG5lZWRpbmcgdG8ga25vdyB0aGUgc3RhdGUgb2YgZXZlcnkgY2hpbGQgcm91dGUuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMgVGhlIHJvdXRlIHBhcmFtcyB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlIGdpdmVuIHJvdXRlXG4gICAqIEBwYXJhbSBmcm9tIFRoZSByb3V0ZSB0byBzZXQgdGhlIHBhcmFtcyBvblxuICAgKiBAcmV0dXJucyBUaGUgbmV3IFVSTFRyZWVcbiAgICovXG4gIHNldFBhcmFtcyhwYXJhbXM6IFJvdXRlU2VnbWVudFBhcmFtcywgZnJvbTogQWN0aXZhdGVkUm91dGUgfCBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KTogVXJsVHJlZSB7XG4gICAgY29uc3Qgc25hcHNob3QgPSBmcm9tIGluc3RhbmNlb2YgQWN0aXZhdGVkUm91dGUgPyBmcm9tLnNuYXBzaG90IDogZnJvbTtcbiAgICBjb25zdCBuYXZpZ2F0aW9uUm91dGU6IE5hdmlnYXRpb25Sb3V0ZSB8IHVuZGVmaW5lZCA9IGxpbmtlZExpc3RGcm9tQXJyYXkoXG4gICAgICBmbGF0TWFwKFxuICAgICAgICAocm91dGU6IEFjdGl2YXRlZFJvdXRlU25hcHNob3QpOiBBcnJheTxSb3V0ZVNlZ21lbnQ+ID0+XG4gICAgICAgICAgcm91dGUudXJsLm1hcCgodXJsOiBVcmxTZWdtZW50KSA9PiAoe1xuICAgICAgICAgICAgcGF0aDogdXJsLnBhdGgsXG4gICAgICAgICAgICBvdXRsZXQ6IHJvdXRlLm91dGxldCxcbiAgICAgICAgICAgIHBhcmFtczogdXJsLnBhcmFtZXRlcnMsXG4gICAgICAgICAgfSkpLFxuICAgICAgICBzbmFwc2hvdC5wYXRoRnJvbVJvb3QsXG4gICAgICApLFxuICAgICk7XG4gICAgaWYgKCFuYXZpZ2F0aW9uUm91dGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcm91dGUgdG8gc2V0IHBhcmFtcyBvbicpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gbGlua2VkTGlzdExhc3QobmF2aWdhdGlvblJvdXRlKTtcbiAgICBsYXN0LnZhbHVlLnBhcmFtcyA9IGxhc3QudmFsdWUucGFyYW1zID8geyAuLi5sYXN0LnZhbHVlLnBhcmFtcywgLi4ucGFyYW1zIH0gOiBwYXJhbXM7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJsVHJlZShuYXZpZ2F0aW9uUm91dGUpO1xuICB9XG5cbiAgY3JlYXRlVXJsVHJlZShyb3V0ZUJyYW5jaDogTmF2aWdhdGlvblJvdXRlKTogVXJsVHJlZSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMucm91dGVyLnBhcnNlVXJsKCcvJyk7IC8vIEB0b2RvOiBpcyB0aGVyZSBubyBiZXR0ZXIgd2F5IHRvIG1ha2UgYSB0cmVlP1xuICAgIGNvbnN0IHJvb3RSb3V0ZVNlZ21lbnQgPSByb3V0ZUJyYW5jaC52YWx1ZTtcbiAgICB0cmVlLnJvb3QuY2hpbGRyZW5bcm9vdFJvdXRlU2VnbWVudC5vdXRsZXRdID0gdGhpcy51cmxTZWdtZW50R3JvdXBGb3JSb3V0ZShyb3V0ZUJyYW5jaCk7XG4gICAgcmV0dXJuIHRyZWU7XG4gIH1cblxuICAvKlxuICAgKiBBIHNlZ21lbnQgZ3JvdXAgaXMgYSBub2RlIGluIHRoZSBVcmxUcmVlLiBUaGUgbm9kZSBpdHNlbGYgaXMgYW4gYXJyYXlcbiAgICogb2Ygc2VnbWVudHMsIHdoaWNoIGFyZSBhbGwgY29uc2lkZXJlZCBvbiB0aGUgXCJwcmltYXJ5XCIgb3V0bGV0LlxuICAgKiBUaGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlIGFyZSB0aGUgcGF0aHMgb24gdGhlIFwibm9uLXByaW1hcnlcIiBvdXRsZXRzLlxuICAgKiBUaGVyZSB3aWxsIG9ubHkgYmUgYSBzaW5nbGUgXCJjaGlsZFwiIGZvciB0aGUgTmF2aWdhdGlvblJvdXRlIChhcyBpdFxuICAgKiByZXByZXNlbnRzIGEgc2luZ2xlIGJyYW5jaCB0aHJvdWdoIGEgVXJsVHJlZSkuXG4gICAqL1xuICBwcml2YXRlIHVybFNlZ21lbnRHcm91cEZvclJvdXRlKHJvdXRlQnJhbmNoOiBOYXZpZ2F0aW9uUm91dGUpOiBVcmxTZWdtZW50R3JvdXAge1xuICAgIC8vIEZpbmQgYWxsIHBhdGhzIHVwIHRvIHRoZSBmaXJzdCBub24tcHJpbWFyeSBvdXRsZXQgLSB0aGVzZSB3aWxsIGJlIHRoZSBzZWdtZW50cy5cbiAgICBjb25zdCByb3V0ZVNlZ21lbnRzOiBOYXZpZ2F0aW9uUm91dGUgPSB7XG4gICAgICB2YWx1ZTogcm91dGVCcmFuY2gudmFsdWUsXG4gICAgICBuZXh0OiByb3V0ZUJyYW5jaC5uZXh0ID8gbGlua2VkTGlzdFNsaWNlKHJvdXRlQnJhbmNoLm5leHQsIHVuZGVmaW5lZCwgaGFzTmFtZWRPdXRsZXQpIDogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgY29uc3Qgc2VnbWVudHM6IEFycmF5PFVybFNlZ21lbnQ+ID0gbGlua2VkTGlzdFRvQXJyYXkocm91dGVTZWdtZW50cykubWFwKHJvdXRlU2VnbWVudFRvVXJsU2VnbWVudCk7XG5cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBub24tcHJpbWFyeSBvdXRsZXQgLSB0aGlzIHdpbGwgYmUgdGhlIGNoaWxkLlxuICAgIGNvbnN0IG5leHRPdXRsZXQgPSByb3V0ZUJyYW5jaC5uZXh0ICYmIGxpbmtlZExpc3RGaW5kKHJvdXRlQnJhbmNoLm5leHQsIGhhc05hbWVkT3V0bGV0KTtcbiAgICBjb25zdCBzZWdtZW50R3JvdXBDaGlsZHJlbiA9IG5leHRPdXRsZXRcbiAgICAgID8geyBbbmV4dE91dGxldC52YWx1ZS5vdXRsZXRdOiB0aGlzLnVybFNlZ21lbnRHcm91cEZvclJvdXRlKG5leHRPdXRsZXQpIH1cbiAgICAgIDoge307XG5cbiAgICByZXR1cm4gbmV3IFVybFNlZ21lbnRHcm91cChzZWdtZW50cywgc2VnbWVudEdyb3VwQ2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGEgbmV3IGBVcmxUcmVlYCBpbnRvIHRoZSBjdXJyZW50IGFjdGl2ZSBgVXJsVHJlZWAuXG4gICAqXG4gICAqIEBwYXJhbSBuZXdUcmVlXG4gICAqL1xuICBuYXZpZ2F0ZShuZXdUcmVlOiBVcmxUcmVlKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgYWN0aXZlVHJlZSA9IHRoaXMucm91dGVyLnBhcnNlVXJsKHRoaXMucm91dGVyLnVybCk7XG4gICAgY29uc3QgbWVyZ2VkVHJlZSA9IHRoaXMucm91dGVyLnBhcnNlVXJsKCcvJyk7XG4gICAgbWVyZ2VkVHJlZS5yb290LmNoaWxkcmVuID0gdGhpcy5tZXJnZVVybFNlZ21lbnRHcm91cENoaWxkcmVuKGFjdGl2ZVRyZWUucm9vdC5jaGlsZHJlbiwgbmV3VHJlZS5yb290LmNoaWxkcmVuKTtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChtZXJnZWRUcmVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBuZXcgY2hpbGRyZW4gb2YgYSBgVXJsU2VnbWVudEdyb3VwYCBjaGlsZHJlbiBpbnRvIHRoZSBjaGlsZHJlbiBvZiB0aGVcbiAgICogY3VycmVudCBhY3RpdmUgYFVybFNlZ21lbnRHcm91cGAuXG4gICAqXG4gICAqIEBwYXJhbSBhY3RpdmVDaGlsZHJlblxuICAgKiBAcGFyYW0gbmV3Q2hpbGRyZW5cbiAgICovXG4gIHByaXZhdGUgbWVyZ2VVcmxTZWdtZW50R3JvdXBDaGlsZHJlbihcbiAgICBhY3RpdmVDaGlsZHJlbjogVXJsU2VnbWVudEdyb3VwQ2hpbGRyZW4sXG4gICAgbmV3Q2hpbGRyZW46IFVybFNlZ21lbnRHcm91cENoaWxkcmVuLFxuICApOiBVcmxTZWdtZW50R3JvdXBDaGlsZHJlbiB7XG4gICAgY29uc3QgbWVyZ2VkQ2hpbGRyZW4gPSBPYmplY3Qua2V5cyhuZXdDaGlsZHJlbikucmVkdWNlKFxuICAgICAgKGFjYzogVXJsU2VnbWVudEdyb3VwQ2hpbGRyZW4sIG91dGxldE5hbWU6IHN0cmluZyk6IFVybFNlZ21lbnRHcm91cENoaWxkcmVuID0+IHtcbiAgICAgICAgaWYgKCFhY3RpdmVDaGlsZHJlbltvdXRsZXROYW1lXSkge1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICBbb3V0bGV0TmFtZV06IHRoaXMubWVyZ2VVcmxUcmVlU2VnbWVudEdyb3VwKGFjdGl2ZUNoaWxkcmVuW291dGxldE5hbWVdLCBuZXdDaGlsZHJlbltvdXRsZXROYW1lXSksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbmV3Q2hpbGRyZW4sXG4gICAgKTtcblxuICAgIC8qKlxuICAgICAqIFNpYmxpbmcgcm91dGVzIGNhbiBiZSBwcmVzZXJ2ZWQsIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIEJlY2F1c2UgdGhlIGN1cnJlbnQgYWN0aXZlIHJvdXRlIGlzIGEgdHJlZSAoZm9yIGV4YW1wbGUsIHdoZW4geW91IGhhdmUgbXVsdGlwbGUgbmFtZWRcbiAgICAgKiBvdXRsZXRzIGFuZCB0aGV5IGFyZSBhY3RpdmUpIHdoZW4geW91IG5hdmlnYXRlIHRvIGEgbmV3IHJvdXRlIGl0IGlzIHBvc3NpYmxlIHRvIHByZXNlcnZlXG4gICAgICogYWN0aXZlIHJvdXRlcyB0aGF0IGFyZSBzaWJsaW5ncyB0byB0aGUgcm91dGUgeW91J3JlIG5hdmlnYXRpbmcgdG8uXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBuYXZpZ2F0aW5nIGZyb20gVVJMIGAvYS8oYi8veDpjKWAgdG8gYC9hL2NgLCBzaG91bGQgdGhlIGB4OmNgIG9yIGBiYFxuICAgICAqIGJlIHByZXNlcnZlZC4gVGhlIFVSTCBjYW4gYmUgdmlzdWFsaXNlZCBhcyBhIHRyZWUgKHdoZXJlIGEgZG91YmxlIHNsYXNoIGAvL2Agc2hvd3Mgc2libGluZ3NcbiAgICAgKiBpbiB0aGUgdHJlZSk6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgLWFcbiAgICAgKiAgIGAtIGJcbiAgICAgKiAgIGAtIHg6Y1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlbiBzZXQgdG8gdHJ1ZSwgYWxsIHNpYmxpbmcgd2lsbCBiZSBwcmVzZXJ2ZWQuIEZvciBleGFtcGxlLCB3aGVuIG5hdmlnYXRpbmcgdG8gYC9hL2RgXG4gICAgICogdGhlIGB4OmNgIGJyYW5jaCB3aWxsIGJlIHByZXNlcnZlZCBhbmQgdGhlIG5ldyBVUkwgd2lsbCBiZSBgL2EvKGQvL3g6YylgLiBTaW1pbGFybHksXG4gICAgICogd2hlbiBuYXZpZ2F0aW5nIHRvIGAvYS8oeDplKWAsIHRoZSBgYmAgYnJhbmNoIHdpbGwgYmUgcHJlc2VydmVkIGFuZCB0aGUgbmV3IFVSTCB3aWxsXG4gICAgICogYmUgYC9hLyhiLy94OmUpYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBlbmFibGVkIHdpdGggYSBmZWF0dXJlIGZsYWcuXG4gICAgICovXG4gICAgcmV0dXJuIHsgLi4uYWN0aXZlQ2hpbGRyZW4sIC4uLm1lcmdlZENoaWxkcmVuIH07XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgYSBuZXcgYFVybFNlZ21lbnRHcm91cGAgaW50byB0aGUgY3VycmVudCBhY3RpdmUgYFVybFNlZ21lbnRHcm91cGAuXG4gICAqXG4gICAqIEBwYXJhbSBhY3RpdmVTZWdtZW50R3JvdXBcbiAgICogQHBhcmFtIG5ld1NlZ21lbnRHcm91cFxuICAgKi9cbiAgcHJpdmF0ZSBtZXJnZVVybFRyZWVTZWdtZW50R3JvdXAoXG4gICAgYWN0aXZlU2VnbWVudEdyb3VwOiBVcmxTZWdtZW50R3JvdXAsXG4gICAgbmV3U2VnbWVudEdyb3VwOiBVcmxTZWdtZW50R3JvdXAsXG4gICk6IFVybFNlZ21lbnRHcm91cCB7XG4gICAgcmV0dXJuIG5ldyBVcmxTZWdtZW50R3JvdXAoXG4gICAgICB0aGlzLm1lcmdlVXJsU2VnbWVudHMoYWN0aXZlU2VnbWVudEdyb3VwLnNlZ21lbnRzLCBuZXdTZWdtZW50R3JvdXAuc2VnbWVudHMpLFxuICAgICAgdGhpcy5tZXJnZVVybFNlZ21lbnRHcm91cENoaWxkcmVuKGFjdGl2ZVNlZ21lbnRHcm91cC5jaGlsZHJlbiwgbmV3U2VnbWVudEdyb3VwLmNoaWxkcmVuKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIG5ldyBgVXJsU2VnbWVudGAgaW50byB0aGUgY3VycmVudCBhY3RpdmUgYFVybFNlZ21lbnRgIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0gYWN0aXZlU2VnbWVudHNcbiAgICogQHBhcmFtIG5ld1NlZ21lbnRzXG4gICAqL1xuICBwcml2YXRlIG1lcmdlVXJsU2VnbWVudHMoYWN0aXZlU2VnbWVudHM6IEFycmF5PFVybFNlZ21lbnQ+LCBuZXdTZWdtZW50czogQXJyYXk8VXJsU2VnbWVudD4pOiBBcnJheTxVcmxTZWdtZW50PiB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIGFueSBwYXJhbXMgYXJlIGJlaW5nIHNldC5cbiAgICBjb25zdCBwcmVzZXJ2ZUFjdGl2ZVRhaWxTZWdtZW50cyA9ICEhbmV3U2VnbWVudHMuZmluZChzZWdtZW50ID0+IE9iamVjdC5rZXlzKHNlZ21lbnQucGFyYW1ldGVycykubGVuZ3RoID4gMCk7XG5cbiAgICAvLyBXaGVuIHRoZSBuZXcgc2VnbWVudHMgY2hhbmdlIHBhdGggZnJvbSB0aGUgYWN0aXZlIHNlZ21lbnQsIHRoZW4gdGhleVxuICAgIC8vIHNob3VsZCBubyBsb25nZXIgYmUgcHJlc2VydmVkLCBzbyB0aGV5IGdldCBzZXQgdG8gdW5kZWZpbmVkLlxuICAgIGNvbnN0IHJlbW92ZUFjdGl2ZVNlZ21lbnRzID0gKCkgPT4ge1xuICAgICAgbGV0IG1hdGNoZXMgPSB0cnVlO1xuICAgICAgdHlwZSBTZWdtZW50VHVwcGxlID0gW1VybFNlZ21lbnQgfCB1bmRlZmluZWQsIFVybFNlZ21lbnQgfCB1bmRlZmluZWRdO1xuICAgICAgcmV0dXJuIChbYWN0aXZlU2VnbWVudCwgbmV3U2VnbWVudF06IFNlZ21lbnRUdXBwbGUpOiBTZWdtZW50VHVwcGxlID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZXMgJiYgYWN0aXZlU2VnbWVudCAmJiBuZXdTZWdtZW50KSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IGFjdGl2ZVNlZ21lbnQucGF0aCA9PT0gbmV3U2VnbWVudC5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWF0Y2hlcyA/IGFjdGl2ZVNlZ21lbnQgOiB1bmRlZmluZWQsIG5ld1NlZ21lbnRdO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gcGFpciB0aGUgc2VnbWVudHMgaW50byBhIHNpbmdsZSBhcnJheVxuICAgIHJldHVybiBwYWlycyhhY3RpdmVTZWdtZW50cywgbmV3U2VnbWVudHMpXG4gICAgICAubWFwKHJlbW92ZUFjdGl2ZVNlZ21lbnRzKCkpXG4gICAgICAubWFwKChbYWN0aXZlU2VnbWVudCwgbmV3U2VnbWVudF0pID0+IHRoaXMubWVyZ2VVcmxTZWdtZW50KGFjdGl2ZVNlZ21lbnQsIG5ld1NlZ21lbnQsIHByZXNlcnZlQWN0aXZlVGFpbFNlZ21lbnRzKSlcbiAgICAgIC5maWx0ZXIoKGEpOiBhIGlzIFVybFNlZ21lbnQgPT4gYSAhPT0gdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBhIG5ldyBgVXJsU2VnbWVudGAgaW50byB0aGUgY3VycmVudCBhY3RpdmUgYFVybFNlZ21lbnRgLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBib3RoIGFuIGFjdGl2ZSBhbmQgbmV3IHNlZ21lbnQgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXRoXG4gICAqIGlzIHRoZSBzYW1lIGFscmVhZHkuXG4gICAqXG4gICAqIEBwYXJhbSBhY3RpdmVTZWdtZW50XG4gICAqIEBwYXJhbSBuZXdTZWdtZW50XG4gICAqIEBwYXJhbSBpc1NldHRpbmdQYXJhbXNcbiAgICovXG4gIHByaXZhdGUgbWVyZ2VVcmxTZWdtZW50KFxuICAgIGFjdGl2ZVNlZ21lbnQ6IFVybFNlZ21lbnQgfCB1bmRlZmluZWQsXG4gICAgbmV3U2VnbWVudDogVXJsU2VnbWVudCB8IHVuZGVmaW5lZCxcbiAgICBwcmVzZXJ2ZUFjdGl2ZVRhaWxTZWdtZW50czogYm9vbGVhbixcbiAgKTogVXJsU2VnbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIDMgZGlmZmVyZW50IHN0cmF0ZWdpZXMgZm9yIGhvdyB0byBwcmVzZXJ2ZSBhbnkgXCJ0YWlsXCIgc2VnbWVudHMgaW5cbiAgICAgKiB0aGUgcm91dGU6ICduZXZlcicgfCAnb24tcGFyYW0tc2V0JyB8ICdhbHdheXMnLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBvbmx5IHJlbGV2YW50IHdoZW4gYW55IHJvdXRlIGJyYW5jaCB5b3UncmUgbmF2aWdhdGluZyB0byBpcyBhIHN1YnNldFxuICAgICAqIG9mIGEgY3VycmVudCBhY3RpdmUgcm91dGUuIEZvciBleGFtcGxlLCB3aGVuIG5hdmlnYXRpbmcgZnJvbSBVUkwgYC9hL2JgIHRvXG4gICAgICogYC9hYCwgc2hvdWxkIGBiYCBiZSBwcmVzZXJ2ZWQ/XG4gICAgICpcbiAgICAgKiBXaGVuIHNldCB0byAnbmV2ZXInIHRoZSBjaGlsZHJlbiB3aWxsIGJlIGRpc2NhcmRlZCwgYW5kIHRoZSBuZXcgVVJMIHdpbGwgc2ltcGx5XG4gICAgICogYmUgYC9hYC5cbiAgICAgKlxuICAgICAqIFdoZW4gc2V0IHRvICdhbHdheXMnIHRoZSBjaGlsZHJlbiB3aWxsIGFsd2F5cyBiZSBwcmVzZXJ2ZWQgKHRoaXMgbWVhbnMgaXQgd291bGRcbiAgICAgKiBiZSBpbXBvc3NpYmxlIHRvIG5hdmlnYXRlIHRvIGEgcGFyZW50IHJvdXRlKS5cbiAgICAgKlxuICAgICAqIFdoZW4gc2V0IHRvICdvbi1wYXJhbS1zZXQnIHRoZSBjaGlsZHJlbiB3aWxsIG9ubHkgYmUgcHJlc2VydmVkIGlmIHBhcmFtcyBhcmUgYmVpbmdcbiAgICAgKiBzZXQgb24gdGhlIHJvdXRlLiBGb3IgZXhhbXBsZSwgd2hlbiBuYXZpZ2F0aW5nIGZyb20gYC9hL2JgIHRvXG4gICAgICogYC9hO2RhdGE9Zm9vYCB0aGVuIHRoZSBuZXcgVVJMIHdpbGwgYmUgYC9hOmRhdGE9Zm9vL2JgLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgJ25ldmVyJyBPUiAnb24tcGFyYW0tc2V0JyBzdHJhdGVneSBkZXBlbmRpbmcgb24gdGhlXG4gICAgICogYHByZXNlcnZlQWN0aXZlVGFpbFNlZ21lbnRzYCBmbGFnLlxuICAgICAqL1xuICAgIGlmIChhY3RpdmVTZWdtZW50ICYmICFuZXdTZWdtZW50ICYmIHByZXNlcnZlQWN0aXZlVGFpbFNlZ21lbnRzKSB7XG4gICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnQoYWN0aXZlU2VnbWVudC5wYXRoLCBhY3RpdmVTZWdtZW50LnBhcmFtZXRlcnMpO1xuICAgIH0gZWxzZSBpZiAobmV3U2VnbWVudCkge1xuICAgICAgY29uc3QgYWN0aXZlU2VnbWVudFBhcmFtcyA9IChhY3RpdmVTZWdtZW50ICYmIGFjdGl2ZVNlZ21lbnQucGFyYW1ldGVycykgfHwge307XG4gICAgICByZXR1cm4gbmV3IFVybFNlZ21lbnQobmV3U2VnbWVudC5wYXRoLCB0aGlzLm1lcmdlVXJsU2VnbWVudFBhcmFtcyhhY3RpdmVTZWdtZW50UGFyYW1zLCBuZXdTZWdtZW50LnBhcmFtZXRlcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgbWVyZ2VVcmxTZWdtZW50UGFyYW1zKGFjdGl2ZVNlZ21lbnRQYXJhbXM6IFJvdXRlU2VnbWVudFBhcmFtcywgbmV3U2VnbWVudFBhcmFtczogUm91dGVTZWdtZW50UGFyYW1zKSB7XG4gICAgLyoqXG4gICAgICogVGhlcmUgMyBkaWZmZXJlbnQgc3RyYXRlZ2llcyBmb3IgaG93IHRvIHByZXNlcnZlIGFueSByb3V0ZS1wYXJhbWV0ZXJzIGluIHRoZVxuICAgICAqIHJvdXRlOiAnbmV2ZXInIHwgJ292ZXJ3cml0ZScgfCAnbWVyZ2UnLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gbmF2aWdhdGluZyBmcm9tIFVSTCBgL2E7ZGF0YT1mb28vYmAgdG8gYC9hO3g9eS9jYCwgc2hvdWxkIHRoZVxuICAgICAqICdkYXRhJyBwYXJhbSBiZSBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGBuZXZlcmAgdGhlIHBhcmFtcyB3aWxsIGJlIGRpc2NhcmRlZCwgYW5kIHRoZSBuZXcgVVJMIHdpbGwgc2ltcGx5IGJlIGAvYTt4PXkvY2AuXG4gICAgICpcbiAgICAgKiBXaGVuIGBtZXJnZWAsIHRoZW4gdGhlIHBhcmFtcyB3aWxsIGJlIHByZXNlcnZlZCwgYW5kIHRoZSBuZXcgVVJMIHdpbGwgYmVcbiAgICAgKiBgL2E7ZGF0YT1mb287eD15L2NgLlxuICAgICAqXG4gICAgICogV2hlbiAnb3ZlcndyaXRlJywgdGhlbiB0aGUgcGFyYW1zIHdpbGwgYmUgb25seSBiZSBwcmVzZXJ2ZWQgaWYgdGhlcmUgYXJlIG5vICpvdGhlcipcbiAgICAgKiBwYXJhbXMgYmVpbmcgc2V0IG9uIHRoYXQgc2VnbWVudC4gRm9yIGV4YW1wbGUsIHdoZW4gbmF2aWdhdGluZyBpbnN0ZWFkIHRvOlxuICAgICAqIGAvYS9jO2Zvbz1iYXJgLCB0aGUgbmV3IFVSTCB3aWxsIGJlIGAvYTtkYXRhPWZvby9jO2Zvbz1iYXJgLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyB0aGUgXCJvdmVyd3JpdGVcIiBzdHJhdGVneS5cbiAgICAgKi9cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobmV3U2VnbWVudFBhcmFtcykubGVuZ3RoID09PSAwID8gYWN0aXZlU2VnbWVudFBhcmFtcyA6IG5ld1NlZ21lbnRQYXJhbXM7XG4gIH1cbn1cbiJdfQ==