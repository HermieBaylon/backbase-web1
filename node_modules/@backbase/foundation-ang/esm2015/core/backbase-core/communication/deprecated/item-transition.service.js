import { Injectable } from '@angular/core';
import { FlowsService } from './flows.service';
import { ӨItemNavigationService } from '../item-navigation.service';
export class ItemTransitionService {
    constructor(flows, navigationService) {
        this.flows = flows;
        this.navigationService = navigationService;
    }
    transition(fromItem, fromOutput, toItem, toInput, ancestors, payload) {
        // Deprecated
        const flows = this.flows.getFlows(fromItem.ɵclassId, fromOutput, [...ancestors.map(item => item.ɵclassId)], toInput);
        if (flows.length === 0) {
            flows.push({ output: fromOutput, input: toInput });
        }
        const params = this.mapFlows(flows, toInput, payload);
        return this.navigationService.navigateToItem(toItem.name, params);
    }
    mapFlows(flows, toInput, payload) {
        return flows.reduce((acc, flow) => {
            const inputName = toInput || flow.input || flow.output;
            const value = flow.map ? flow.map(payload) : payload;
            if (value === undefined) {
                return acc; // @todo: should it be possible to "clear" a param with undefined?
            }
            // Note: if 2 flows map to the same input, the 2nd will overwrite
            return Object.assign(Object.assign({}, acc), { [inputName]: value });
        }, {});
    }
}
ItemTransitionService.decorators = [
    { type: Injectable }
];
ItemTransitionService.ctorParameters = () => [
    { type: FlowsService },
    { type: ӨItemNavigationService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXRlbS10cmFuc2l0aW9uLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL2NvbW11bmljYXRpb24vZGVwcmVjYXRlZC9pdGVtLXRyYW5zaXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBUSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUlwRSxNQUFNLE9BQU8scUJBQXFCO0lBQ2hDLFlBQTZCLEtBQW1CLEVBQW1CLGlCQUF5QztRQUEvRSxVQUFLLEdBQUwsS0FBSyxDQUFjO1FBQW1CLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBd0I7SUFBRyxDQUFDO0lBRWhILFVBQVUsQ0FDUixRQUFtQixFQUNuQixVQUFrQixFQUNsQixNQUFpQixFQUNqQixPQUEyQixFQUMzQixTQUEyQixFQUMzQixPQUFZO1FBRVosYUFBYTtRQUNiLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUMvQixRQUFRLENBQUMsUUFBUSxFQUNqQixVQUFVLEVBQ1YsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFDekMsT0FBTyxDQUNSLENBQUM7UUFDRixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQ3BEO1FBQ0QsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3RELE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFTyxRQUFRLENBQUMsS0FBa0IsRUFBRSxPQUEyQixFQUFFLE9BQVk7UUFDNUUsT0FBTyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ2hDLE1BQU0sU0FBUyxHQUFHLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDdkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO1lBQ3JELElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtnQkFDdkIsT0FBTyxHQUFHLENBQUMsQ0FBQyxrRUFBa0U7YUFDL0U7WUFDRCxpRUFBaUU7WUFDakUsdUNBQ0ssR0FBRyxLQUNOLENBQUMsU0FBUyxDQUFDLEVBQUUsS0FBSyxJQUNsQjtRQUNKLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7OztZQXZDRixVQUFVOzs7WUFKSSxZQUFZO1lBQ2xCLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZsb3csIEZsb3dzU2VydmljZSB9IGZyb20gJy4vZmxvd3Muc2VydmljZSc7XG5pbXBvcnQgeyDTqEl0ZW1OYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2l0ZW0tbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IEl0ZW1Nb2RlbCB9IGZyb20gJy4uLy4uL21vZGVscy9pdGVtLW1vZGVsJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEl0ZW1UcmFuc2l0aW9uU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZmxvd3M6IEZsb3dzU2VydmljZSwgcHJpdmF0ZSByZWFkb25seSBuYXZpZ2F0aW9uU2VydmljZTog06hJdGVtTmF2aWdhdGlvblNlcnZpY2UpIHt9XG5cbiAgdHJhbnNpdGlvbihcbiAgICBmcm9tSXRlbTogSXRlbU1vZGVsLFxuICAgIGZyb21PdXRwdXQ6IHN0cmluZyxcbiAgICB0b0l0ZW06IEl0ZW1Nb2RlbCxcbiAgICB0b0lucHV0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgYW5jZXN0b3JzOiBBcnJheTxJdGVtTW9kZWw+LFxuICAgIHBheWxvYWQ6IGFueSxcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gRGVwcmVjYXRlZFxuICAgIGNvbnN0IGZsb3dzID0gdGhpcy5mbG93cy5nZXRGbG93cyhcbiAgICAgIGZyb21JdGVtLsm1Y2xhc3NJZCxcbiAgICAgIGZyb21PdXRwdXQsXG4gICAgICBbLi4uYW5jZXN0b3JzLm1hcChpdGVtID0+IGl0ZW0uybVjbGFzc0lkKV0sXG4gICAgICB0b0lucHV0LFxuICAgICk7XG4gICAgaWYgKGZsb3dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZmxvd3MucHVzaCh7IG91dHB1dDogZnJvbU91dHB1dCwgaW5wdXQ6IHRvSW5wdXQgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMubWFwRmxvd3MoZmxvd3MsIHRvSW5wdXQsIHBheWxvYWQpO1xuICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLm5hdmlnYXRlVG9JdGVtKHRvSXRlbS5uYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBtYXBGbG93cyhmbG93czogQXJyYXk8Rmxvdz4sIHRvSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcGF5bG9hZDogYW55KTogYW55IHtcbiAgICByZXR1cm4gZmxvd3MucmVkdWNlKChhY2MsIGZsb3cpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0TmFtZSA9IHRvSW5wdXQgfHwgZmxvdy5pbnB1dCB8fCBmbG93Lm91dHB1dDtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmxvdy5tYXAgPyBmbG93Lm1hcChwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYWNjOyAvLyBAdG9kbzogc2hvdWxkIGl0IGJlIHBvc3NpYmxlIHRvIFwiY2xlYXJcIiBhIHBhcmFtIHdpdGggdW5kZWZpbmVkP1xuICAgICAgfVxuICAgICAgLy8gTm90ZTogaWYgMiBmbG93cyBtYXAgdG8gdGhlIHNhbWUgaW5wdXQsIHRoZSAybmQgd2lsbCBvdmVyd3JpdGVcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFjYyxcbiAgICAgICAgW2lucHV0TmFtZV06IHZhbHVlLFxuICAgICAgfTtcbiAgICB9LCB7fSk7XG4gIH1cbn1cbiJdfQ==