import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { PRIMARY_OUTLET } from '@angular/router';
import { createRouteComponentStrategy } from '../routing/strategies/routing-decorators';
import { RouterConfigService } from '../routing/config/router-config.service';
import { take } from 'rxjs/operators';
import { treeBranch } from '../models/tree';
import { isRoutable } from '../routing/config/routing-tree';
import { mapLinkedList, linkedListFindLast, linkedListLast } from '../models/linked-list';
import { RouterNavigationService, } from '../routing/navigation/router-navigation.service';
/**
 * Extracts a tree branch from the component route tree up to the given item and
 * unwraps the value.
 *
 * It unwraps it so we don't end up with a `LinkedList<Tree>`, where each node
 * would have value`.value`.
 *
 * @param itemRouteTree
 * @param itemName
 */
const itemRoutesBranch = (findRoute, itemRouteTree) => {
    const branch = treeBranch(itemRouteTree, findRoute);
    if (branch === undefined) {
        return undefined;
    }
    return mapLinkedList(branch, tree => tree.value);
};
const ɵ0 = itemRoutesBranch;
/**
 * Maps a LinkedList<Route> to a NavigationRoute, to ensure each route is a
 * part of a URL segment.
 */
const mapToNavigationRoute = (routeBranch) => mapLinkedList(routeBranch, route => {
    if (route.path === undefined) {
        throw new Error(`Can't find route to item as route has no path`);
    }
    return {
        path: route.path,
        outlet: route.outlet || PRIMARY_OUTLET,
    };
});
const ɵ1 = mapToNavigationRoute;
/**
 * @internal
 */
export class ӨItemNavigationService {
    constructor(routerConfig, navigationService) {
        this.routerConfig = routerConfig;
        this.navigationService = navigationService;
    }
    navigateToItem(itemName, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const isItemByName = (tree) => tree.value.item === itemName;
            return this.navigateToRoute(isItemByName, params);
        });
    }
    isItemChild(navigateToParent, childIndex) {
        return (tree, index, parent) => {
            if (parent) {
                const isChild = parent.value.item === navigateToParent;
                const isNthChild = index === childIndex;
                if (isChild && isNthChild) {
                    return true;
                }
                const isLastChild = index === parent.children.length - 1;
                const isIndexOutOfRange = childIndex > parent.children.length - 1;
                if (isChild && isLastChild && isIndexOutOfRange) {
                    return true;
                }
            }
            const noChildren = tree.children.length === 0;
            const isParent = tree.value.item === navigateToParent;
            if (isParent && noChildren) {
                return true;
            }
            return false;
        };
    }
    navigateToChild(navigateToParent, childIndex, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.navigateToRoute(this.isItemChild(navigateToParent, childIndex), params);
        });
    }
    navigateToRoute(findRoute, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const route = yield this.routeToItem(findRoute);
            if (!route) {
                // If there is no route, then this item should already be visible, as it means
                // it's somewhere in the component tree above any routable item.
                if (Object.keys(params).length) {
                    // If trying to pass params, this can't work, so throw
                    return Promise.reject(`Can't pass params to an item that isn't within a routable item`);
                }
                // Otherwise, there is no need to navigate, navigation has failed
                return Promise.resolve(false);
            }
            const navigationRoute = mapToNavigationRoute(route);
            // Set the params on the last path in the route.
            linkedListLast(navigationRoute).value.params = params;
            return this.navigationService.navigate(this.navigationService.createUrlTree(navigationRoute));
        });
    }
    /**
     * Search the component tree for a given item, and return the route to that item.
     *
     * @param itemName The CXP instance name of the item to route to.
     */
    routeToItem(findRoute) {
        // Take a snapshot of the current state of the route tree.
        return this.routerConfig.ɵrouteTree
            .pipe(take(1))
            .toPromise()
            .then((routeTree) => this.findItemRoute(findRoute, routeTree));
    }
    /**
     * Breadth-first-search of routes, to find a route to a given item.
     *
     * 1. Find the branch to this item in the component route tree.
     * 2. Once found, find the closest routable parent.
     * 3. Take the child of the routable parent.
     * 4. For each route in the parent, use the "RouteComponentStrategy" to determine
     *      which route the route-child is rendered in.
     * 5. Once the route is found, flatten the routes of the componentRouteTree up to that route.
     *
     * @param itemName
     * @param routes
     */
    findItemRoute(findRoute, componentRouteTree) {
        // 1. Find the branch containing the item.
        const branch = itemRoutesBranch(findRoute, componentRouteTree);
        if (!branch) {
            // item not in tree
            throw new Error(`No matching route found in model.`);
        }
        const foundNode = linkedListLast(branch);
        // 2. Find the closest *routable* parent (depth-first search, so it searches from TAIL to HEAD)
        const isParent = (node) => node.item !== foundNode.value.item;
        const isRoutableParent = (node) => isRoutable(node) && isParent(node);
        const routableNode = linkedListFindLast(branch, isRoutableParent);
        if (!routableNode) {
            return undefined;
        }
        // 3. Take the child of the routable node.
        const routableNodeChild = routableNode.next;
        // 4. Determine which route the child is rendered in.
        const foundItemInRoute = routableNodeChild &&
            routableNode.value.routes.find(route => this.isItemInRoute(routableNodeChild.value.item, route));
        // 5. Find the branch in the route tree up to that route (similar to step 1).
        // Except that "Routes" is really like an array of trees, so we loop through them.
        for (const rootRoute of componentRouteTree.value.routes) {
            const routeBranch = treeBranch(rootRoute, route => route === foundItemInRoute);
            if (routeBranch) {
                return routeBranch;
            }
        }
        return undefined;
    }
    isItemInRoute(itemName, route) {
        if (!route.component) {
            return false;
        }
        return createRouteComponentStrategy(route.component).isItemInRoute(itemName, route);
    }
}
ӨItemNavigationService.decorators = [
    { type: Injectable }
];
ӨItemNavigationService.ctorParameters = () => [
    { type: RouterConfigService },
    { type: RouterNavigationService }
];
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXRlbS1uYXZpZ2F0aW9uLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL2NvbW11bmljYXRpb24vaXRlbS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFTLGNBQWMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3hELE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQ3hGLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN0QyxPQUFPLEVBQVEsVUFBVSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFjLFVBQVUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3hFLE9BQU8sRUFBYyxhQUFhLEVBQUUsa0JBQWtCLEVBQUUsY0FBYyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEcsT0FBTyxFQUlMLHVCQUF1QixHQUN4QixNQUFNLGlEQUFpRCxDQUFDO0FBSXpEOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sZ0JBQWdCLEdBQUcsQ0FDdkIsU0FBeUYsRUFDekYsYUFBK0IsRUFDSyxFQUFFO0lBQ3RDLE1BQU0sTUFBTSxHQUFHLFVBQVUsQ0FBbUIsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3RFLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtRQUN4QixPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELE9BQU8sYUFBYSxDQUErQixNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7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eElGLFVBQVU7OztZQXJERixtQkFBbUI7WUFTMUIsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGUsIFBSSU1BUllfT1VUTEVUIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IGNyZWF0ZVJvdXRlQ29tcG9uZW50U3RyYXRlZ3kgfSBmcm9tICcuLi9yb3V0aW5nL3N0cmF0ZWdpZXMvcm91dGluZy1kZWNvcmF0b3JzJztcbmltcG9ydCB7IFJvdXRlckNvbmZpZ1NlcnZpY2UgfSBmcm9tICcuLi9yb3V0aW5nL2NvbmZpZy9yb3V0ZXItY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHsgdGFrZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRyZWUsIHRyZWVCcmFuY2ggfSBmcm9tICcuLi9tb2RlbHMvdHJlZSc7XG5pbXBvcnQgeyBJdGVtUm91dGVzLCBpc1JvdXRhYmxlIH0gZnJvbSAnLi4vcm91dGluZy9jb25maWcvcm91dGluZy10cmVlJztcbmltcG9ydCB7IExpbmtlZExpc3QsIG1hcExpbmtlZExpc3QsIGxpbmtlZExpc3RGaW5kTGFzdCwgbGlua2VkTGlzdExhc3QgfSBmcm9tICcuLi9tb2RlbHMvbGlua2VkLWxpc3QnO1xuaW1wb3J0IHtcbiAgUm91dGVTZWdtZW50UGFyYW1zLFxuICBOYXZpZ2F0aW9uUm91dGUsXG4gIFJvdXRlU2VnbWVudCxcbiAgUm91dGVyTmF2aWdhdGlvblNlcnZpY2UsXG59IGZyb20gJy4uL3JvdXRpbmcvbmF2aWdhdGlvbi9yb3V0ZXItbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuZXhwb3J0IHR5cGUgRmluZFJvdXRlRnVuY3Rpb24gPSAodHJlZTogVHJlZTxJdGVtUm91dGVzPiwgaW5kZXg/OiBudW1iZXIsIHBhcmVudD86IFRyZWU8SXRlbVJvdXRlcz4pID0+IGJvb2xlYW47XG5cbi8qKlxuICogRXh0cmFjdHMgYSB0cmVlIGJyYW5jaCBmcm9tIHRoZSBjb21wb25lbnQgcm91dGUgdHJlZSB1cCB0byB0aGUgZ2l2ZW4gaXRlbSBhbmRcbiAqIHVud3JhcHMgdGhlIHZhbHVlLlxuICpcbiAqIEl0IHVud3JhcHMgaXQgc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGggYSBgTGlua2VkTGlzdDxUcmVlPmAsIHdoZXJlIGVhY2ggbm9kZVxuICogd291bGQgaGF2ZSB2YWx1ZWAudmFsdWVgLlxuICpcbiAqIEBwYXJhbSBpdGVtUm91dGVUcmVlXG4gKiBAcGFyYW0gaXRlbU5hbWVcbiAqL1xuY29uc3QgaXRlbVJvdXRlc0JyYW5jaCA9IChcbiAgZmluZFJvdXRlOiAodHJlZTogVHJlZTxJdGVtUm91dGVzPiwgaW5kZXg/OiBudW1iZXIsIHBhcmVudD86IFRyZWU8SXRlbVJvdXRlcz4pID0+IGJvb2xlYW4sXG4gIGl0ZW1Sb3V0ZVRyZWU6IFRyZWU8SXRlbVJvdXRlcz4sXG4pOiBMaW5rZWRMaXN0PEl0ZW1Sb3V0ZXM+IHwgdW5kZWZpbmVkID0+IHtcbiAgY29uc3QgYnJhbmNoID0gdHJlZUJyYW5jaDxUcmVlPEl0ZW1Sb3V0ZXM+PihpdGVtUm91dGVUcmVlLCBmaW5kUm91dGUpO1xuICBpZiAoYnJhbmNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBtYXBMaW5rZWRMaXN0PFRyZWU8SXRlbVJvdXRlcz4sIEl0ZW1Sb3V0ZXM+KGJyYW5jaCwgdHJlZSA9PiB0cmVlLnZhbHVlKTtcbn07XG5cbi8qKlxuICogTWFwcyBhIExpbmtlZExpc3Q8Um91dGU+IHRvIGEgTmF2aWdhdGlvblJvdXRlLCB0byBlbnN1cmUgZWFjaCByb3V0ZSBpcyBhXG4gKiBwYXJ0IG9mIGEgVVJMIHNlZ21lbnQuXG4gKi9cbmNvbnN0IG1hcFRvTmF2aWdhdGlvblJvdXRlID0gKHJvdXRlQnJhbmNoOiBMaW5rZWRMaXN0PFJvdXRlPik6IE5hdmlnYXRpb25Sb3V0ZSA9PlxuICBtYXBMaW5rZWRMaXN0PFJvdXRlLCBSb3V0ZVNlZ21lbnQ+KHJvdXRlQnJhbmNoLCByb3V0ZSA9PiB7XG4gICAgaWYgKHJvdXRlLnBhdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIHJvdXRlIHRvIGl0ZW0gYXMgcm91dGUgaGFzIG5vIHBhdGhgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHJvdXRlLnBhdGgsXG4gICAgICBvdXRsZXQ6IHJvdXRlLm91dGxldCB8fCBQUklNQVJZX09VVExFVCxcbiAgICB9O1xuICB9KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzINOoSXRlbU5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSByb3V0ZXJDb25maWc6IFJvdXRlckNvbmZpZ1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYXZpZ2F0aW9uU2VydmljZTogUm91dGVyTmF2aWdhdGlvblNlcnZpY2UsXG4gICkge31cbiAgYXN5bmMgbmF2aWdhdGVUb0l0ZW0oaXRlbU5hbWU6IHN0cmluZywgcGFyYW1zOiBSb3V0ZVNlZ21lbnRQYXJhbXMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBpc0l0ZW1CeU5hbWUgPSAodHJlZTogVHJlZTxJdGVtUm91dGVzPikgPT4gdHJlZS52YWx1ZS5pdGVtID09PSBpdGVtTmFtZTtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZVRvUm91dGUoaXNJdGVtQnlOYW1lLCBwYXJhbXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0l0ZW1DaGlsZChuYXZpZ2F0ZVRvUGFyZW50OiBzdHJpbmcsIGNoaWxkSW5kZXg6IG51bWJlcik6IEZpbmRSb3V0ZUZ1bmN0aW9uIHtcbiAgICByZXR1cm4gKHRyZWU6IFRyZWU8SXRlbVJvdXRlcz4sIGluZGV4PzogbnVtYmVyLCBwYXJlbnQ/OiBUcmVlPEl0ZW1Sb3V0ZXM+KTogYm9vbGVhbiA9PiB7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGlzQ2hpbGQgPSBwYXJlbnQudmFsdWUuaXRlbSA9PT0gbmF2aWdhdGVUb1BhcmVudDtcbiAgICAgICAgY29uc3QgaXNOdGhDaGlsZCA9IGluZGV4ID09PSBjaGlsZEluZGV4O1xuICAgICAgICBpZiAoaXNDaGlsZCAmJiBpc050aENoaWxkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0xhc3RDaGlsZCA9IGluZGV4ID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgaXNJbmRleE91dE9mUmFuZ2UgPSBjaGlsZEluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpc0NoaWxkICYmIGlzTGFzdENoaWxkICYmIGlzSW5kZXhPdXRPZlJhbmdlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9DaGlsZHJlbiA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgICAgY29uc3QgaXNQYXJlbnQgPSB0cmVlLnZhbHVlLml0ZW0gPT09IG5hdmlnYXRlVG9QYXJlbnQ7XG5cbiAgICAgIGlmIChpc1BhcmVudCAmJiBub0NoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIG5hdmlnYXRlVG9DaGlsZChuYXZpZ2F0ZVRvUGFyZW50OiBzdHJpbmcsIGNoaWxkSW5kZXg6IG51bWJlciwgcGFyYW1zOiBSb3V0ZVNlZ21lbnRQYXJhbXMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0ZVRvUm91dGUodGhpcy5pc0l0ZW1DaGlsZChuYXZpZ2F0ZVRvUGFyZW50LCBjaGlsZEluZGV4KSwgcGFyYW1zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbmF2aWdhdGVUb1JvdXRlKGZpbmRSb3V0ZTogRmluZFJvdXRlRnVuY3Rpb24sIHBhcmFtczogUm91dGVTZWdtZW50UGFyYW1zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3Qgcm91dGUgPSBhd2FpdCB0aGlzLnJvdXRlVG9JdGVtKGZpbmRSb3V0ZSk7XG5cbiAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyByb3V0ZSwgdGhlbiB0aGlzIGl0ZW0gc2hvdWxkIGFscmVhZHkgYmUgdmlzaWJsZSwgYXMgaXQgbWVhbnNcbiAgICAgIC8vIGl0J3Mgc29tZXdoZXJlIGluIHRoZSBjb21wb25lbnQgdHJlZSBhYm92ZSBhbnkgcm91dGFibGUgaXRlbS5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0cnlpbmcgdG8gcGFzcyBwYXJhbXMsIHRoaXMgY2FuJ3Qgd29yaywgc28gdGhyb3dcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW4ndCBwYXNzIHBhcmFtcyB0byBhbiBpdGVtIHRoYXQgaXNuJ3Qgd2l0aGluIGEgcm91dGFibGUgaXRlbWApO1xuICAgICAgfVxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGVyZSBpcyBubyBuZWVkIHRvIG5hdmlnYXRlLCBuYXZpZ2F0aW9uIGhhcyBmYWlsZWRcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IG5hdmlnYXRpb25Sb3V0ZSA9IG1hcFRvTmF2aWdhdGlvblJvdXRlKHJvdXRlKTtcbiAgICAvLyBTZXQgdGhlIHBhcmFtcyBvbiB0aGUgbGFzdCBwYXRoIGluIHRoZSByb3V0ZS5cbiAgICBsaW5rZWRMaXN0TGFzdChuYXZpZ2F0aW9uUm91dGUpLnZhbHVlLnBhcmFtcyA9IHBhcmFtcztcbiAgICByZXR1cm4gdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5uYXZpZ2F0ZSh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmNyZWF0ZVVybFRyZWUobmF2aWdhdGlvblJvdXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIHRoZSBjb21wb25lbnQgdHJlZSBmb3IgYSBnaXZlbiBpdGVtLCBhbmQgcmV0dXJuIHRoZSByb3V0ZSB0byB0aGF0IGl0ZW0uXG4gICAqXG4gICAqIEBwYXJhbSBpdGVtTmFtZSBUaGUgQ1hQIGluc3RhbmNlIG5hbWUgb2YgdGhlIGl0ZW0gdG8gcm91dGUgdG8uXG4gICAqL1xuICBwcml2YXRlIHJvdXRlVG9JdGVtKFxuICAgIGZpbmRSb3V0ZTogKHRyZWU6IFRyZWU8SXRlbVJvdXRlcz4sIGluZGV4PzogbnVtYmVyLCBwYXJlbnQ/OiBUcmVlPEl0ZW1Sb3V0ZXM+KSA9PiBib29sZWFuLFxuICApOiBQcm9taXNlPExpbmtlZExpc3Q8Um91dGU+IHwgdW5kZWZpbmVkPiB7XG4gICAgLy8gVGFrZSBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByb3V0ZSB0cmVlLlxuICAgIHJldHVybiB0aGlzLnJvdXRlckNvbmZpZy7JtXJvdXRlVHJlZVxuICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgIC50b1Byb21pc2UoKVxuICAgICAgLnRoZW4oKHJvdXRlVHJlZTogVHJlZTxJdGVtUm91dGVzPikgPT4gdGhpcy5maW5kSXRlbVJvdXRlKGZpbmRSb3V0ZSwgcm91dGVUcmVlKSk7XG4gIH1cblxuICAvKipcbiAgICogQnJlYWR0aC1maXJzdC1zZWFyY2ggb2Ygcm91dGVzLCB0byBmaW5kIGEgcm91dGUgdG8gYSBnaXZlbiBpdGVtLlxuICAgKlxuICAgKiAxLiBGaW5kIHRoZSBicmFuY2ggdG8gdGhpcyBpdGVtIGluIHRoZSBjb21wb25lbnQgcm91dGUgdHJlZS5cbiAgICogMi4gT25jZSBmb3VuZCwgZmluZCB0aGUgY2xvc2VzdCByb3V0YWJsZSBwYXJlbnQuXG4gICAqIDMuIFRha2UgdGhlIGNoaWxkIG9mIHRoZSByb3V0YWJsZSBwYXJlbnQuXG4gICAqIDQuIEZvciBlYWNoIHJvdXRlIGluIHRoZSBwYXJlbnQsIHVzZSB0aGUgXCJSb3V0ZUNvbXBvbmVudFN0cmF0ZWd5XCIgdG8gZGV0ZXJtaW5lXG4gICAqICAgICAgd2hpY2ggcm91dGUgdGhlIHJvdXRlLWNoaWxkIGlzIHJlbmRlcmVkIGluLlxuICAgKiA1LiBPbmNlIHRoZSByb3V0ZSBpcyBmb3VuZCwgZmxhdHRlbiB0aGUgcm91dGVzIG9mIHRoZSBjb21wb25lbnRSb3V0ZVRyZWUgdXAgdG8gdGhhdCByb3V0ZS5cbiAgICpcbiAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAqIEBwYXJhbSByb3V0ZXNcbiAgICovXG4gIHByaXZhdGUgZmluZEl0ZW1Sb3V0ZShcbiAgICBmaW5kUm91dGU6ICh0cmVlOiBUcmVlPEl0ZW1Sb3V0ZXM+LCBpbmRleD86IG51bWJlciwgcGFyZW50PzogVHJlZTxJdGVtUm91dGVzPikgPT4gYm9vbGVhbixcbiAgICBjb21wb25lbnRSb3V0ZVRyZWU6IFRyZWU8SXRlbVJvdXRlcz4sXG4gICk6IExpbmtlZExpc3Q8Um91dGU+IHwgdW5kZWZpbmVkIHtcbiAgICAvLyAxLiBGaW5kIHRoZSBicmFuY2ggY29udGFpbmluZyB0aGUgaXRlbS5cbiAgICBjb25zdCBicmFuY2g6IExpbmtlZExpc3Q8SXRlbVJvdXRlcz4gfCB1bmRlZmluZWQgPSBpdGVtUm91dGVzQnJhbmNoKGZpbmRSb3V0ZSwgY29tcG9uZW50Um91dGVUcmVlKTtcblxuICAgIGlmICghYnJhbmNoKSB7XG4gICAgICAvLyBpdGVtIG5vdCBpbiB0cmVlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoaW5nIHJvdXRlIGZvdW5kIGluIG1vZGVsLmApO1xuICAgIH1cbiAgICBjb25zdCBmb3VuZE5vZGUgPSBsaW5rZWRMaXN0TGFzdChicmFuY2gpO1xuXG4gICAgLy8gMi4gRmluZCB0aGUgY2xvc2VzdCAqcm91dGFibGUqIHBhcmVudCAoZGVwdGgtZmlyc3Qgc2VhcmNoLCBzbyBpdCBzZWFyY2hlcyBmcm9tIFRBSUwgdG8gSEVBRClcbiAgICBjb25zdCBpc1BhcmVudCA9IChub2RlOiBJdGVtUm91dGVzKSA9PiBub2RlLml0ZW0gIT09IGZvdW5kTm9kZS52YWx1ZS5pdGVtO1xuICAgIGNvbnN0IGlzUm91dGFibGVQYXJlbnQgPSAobm9kZTogSXRlbVJvdXRlcykgPT4gaXNSb3V0YWJsZShub2RlKSAmJiBpc1BhcmVudChub2RlKTtcbiAgICBjb25zdCByb3V0YWJsZU5vZGUgPSBsaW5rZWRMaXN0RmluZExhc3QoYnJhbmNoLCBpc1JvdXRhYmxlUGFyZW50KTtcbiAgICBpZiAoIXJvdXRhYmxlTm9kZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyAzLiBUYWtlIHRoZSBjaGlsZCBvZiB0aGUgcm91dGFibGUgbm9kZS5cbiAgICBjb25zdCByb3V0YWJsZU5vZGVDaGlsZCA9IHJvdXRhYmxlTm9kZS5uZXh0O1xuXG4gICAgLy8gNC4gRGV0ZXJtaW5lIHdoaWNoIHJvdXRlIHRoZSBjaGlsZCBpcyByZW5kZXJlZCBpbi5cbiAgICBjb25zdCBmb3VuZEl0ZW1JblJvdXRlID1cbiAgICAgIHJvdXRhYmxlTm9kZUNoaWxkICYmXG4gICAgICByb3V0YWJsZU5vZGUudmFsdWUucm91dGVzLmZpbmQocm91dGUgPT4gdGhpcy5pc0l0ZW1JblJvdXRlKHJvdXRhYmxlTm9kZUNoaWxkLnZhbHVlLml0ZW0sIHJvdXRlKSk7XG5cbiAgICAvLyA1LiBGaW5kIHRoZSBicmFuY2ggaW4gdGhlIHJvdXRlIHRyZWUgdXAgdG8gdGhhdCByb3V0ZSAoc2ltaWxhciB0byBzdGVwIDEpLlxuICAgIC8vIEV4Y2VwdCB0aGF0IFwiUm91dGVzXCIgaXMgcmVhbGx5IGxpa2UgYW4gYXJyYXkgb2YgdHJlZXMsIHNvIHdlIGxvb3AgdGhyb3VnaCB0aGVtLlxuICAgIGZvciAoY29uc3Qgcm9vdFJvdXRlIG9mIGNvbXBvbmVudFJvdXRlVHJlZS52YWx1ZS5yb3V0ZXMpIHtcbiAgICAgIGNvbnN0IHJvdXRlQnJhbmNoID0gdHJlZUJyYW5jaDxSb3V0ZT4ocm9vdFJvdXRlLCByb3V0ZSA9PiByb3V0ZSA9PT0gZm91bmRJdGVtSW5Sb3V0ZSk7XG4gICAgICBpZiAocm91dGVCcmFuY2gpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlQnJhbmNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBwcml2YXRlIGlzSXRlbUluUm91dGUoaXRlbU5hbWU6IHN0cmluZywgcm91dGU6IFJvdXRlKTogYm9vbGVhbiB7XG4gICAgaWYgKCFyb3V0ZS5jb21wb25lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlQ29tcG9uZW50U3RyYXRlZ3kocm91dGUuY29tcG9uZW50KS5pc0l0ZW1JblJvdXRlKGl0ZW1OYW1lLCByb3V0ZSk7XG4gIH1cbn1cbiJdfQ==