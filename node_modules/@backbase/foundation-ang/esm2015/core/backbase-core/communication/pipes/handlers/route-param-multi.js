import { ӨItemNavigationService } from '../../item-navigation.service';
import { InjectionToken } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { RouterNavigationService } from '../../../routing/navigation/router-navigation.service';
export const createRouteParamsMulti = (activatedRoute, routerService, itemNavigation) => ({
    sink: (targetName) => (stdin) => {
        stdin.subscribe(params => {
            if (!targetName) {
                routerService.navigate(routerService.setParams(params, activatedRoute));
            }
            else {
                itemNavigation.navigateToItem(targetName, params);
            }
        });
    },
});
/**
 * Configure the `RouteParamsMultiSink`.
 *
 * Use the string 'route-param-multi' to configure this handler.
 *
 * @usageNotes
 *
 * Store some 2-way bound states to the router as "paramName"
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": "route-param-multi",
 *     "input.myInput": "route-param input1", // assuming input1 is set via myOutput
 *     "input.myInput2": "route-param input2" // assuming input2 is set via myOutput
 *   }
 * }
 * ```
 *
 * Navigate to widget-b and pass data via route-param
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": "route-param-multi widget-b"
 *   }
 * },
 * {
 *   "name": "widget-b",
 *   "properties": {
 *     "input.myInput": "route-param input1",
 *     "input.myInput2": "route-param input2"
 *   }
 * }
 * ```
 *
 * See `RouteParamsMultiSink` for more options.
 *
 * Also see:
 *  - `routeParamsProcessorConfig`
 *  -
 */
export const routeParamsMultiProcessorConfig = {
    name: 'route-param-multi',
    provider: {
        provide: new InjectionToken('Route param multi pipeline handler'),
        useFactory: createRouteParamsMulti,
        deps: [ActivatedRoute, RouterNavigationService, ӨItemNavigationService],
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGUtcGFyYW0tbXVsdGkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL2NvbW11bmljYXRpb24vcGlwZXMvaGFuZGxlcnMvcm91dGUtcGFyYW0tbXVsdGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDdkUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUvQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDakQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sdURBQXVELENBQUM7QUFxQmhHLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLENBQ3BDLGNBQThCLEVBQzlCLGFBQXNDLEVBQ3RDLGNBQXNDLEVBQ2hCLEVBQUUsQ0FBQyxDQUFDO0lBQzFCLElBQUksRUFBRSxDQUFDLFVBQW1CLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBOEIsRUFBRSxFQUFFO1FBQ2hFLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFVBQVUsRUFBRTtnQkFDZixhQUFhLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7YUFDekU7aUJBQU07Z0JBQ0wsY0FBYyxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDbkQ7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRixDQUFDLENBQUM7QUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTJDRztBQUNILE1BQU0sQ0FBQyxNQUFNLCtCQUErQixHQUFpRDtJQUMzRixJQUFJLEVBQUUsbUJBQW1CO0lBQ3pCLFFBQVEsRUFBRTtRQUNSLE9BQU8sRUFBRSxJQUFJLGNBQWMsQ0FBQyxvQ0FBb0MsQ0FBQztRQUNqRSxVQUFVLEVBQUUsc0JBQXNCO1FBQ2xDLElBQUksRUFBRSxDQUFDLGNBQWMsRUFBRSx1QkFBdUIsRUFBRSxzQkFBc0IsQ0FBQztLQUN4RTtDQUNGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQaXBlbGluZVNpbmssIFNpbmsgfSBmcm9tICcuLi9waXBlbGluZS1pbnRlcmZhY2UnO1xuaW1wb3J0IHsg06hJdGVtTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9pdGVtLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGlwZWxpbmVQcm9jZXNzb3JDb25maWcgfSBmcm9tICcuLi9waXBlbGluZS1yZWdpc3RyeSc7XG5pbXBvcnQgeyBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBSb3V0ZXJOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3JvdXRpbmcvbmF2aWdhdGlvbi9yb3V0ZXItbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVBhcmFtcyB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVBhcmFtc011bHRpU2luayBleHRlbmRzIFBpcGVsaW5lU2luazxSb3V0ZVBhcmFtcz4ge1xuICAvKipcbiAgICogU2F2ZSB0aGUgZ2l2ZW4gcm91dGUgcGFyYW1zIHRvIHRoZSBjdXJyZW50IHJvdXRlLlxuICAgKlxuICAgKiBJZiBgdGFyZ2V0TmFtZWAgaXMgZ2l2ZW4gaXQgd2lsbCBhbHNvIG5hdmlnYXRlIHRvIHRoYXQgaXRlbS5cbiAgICpcbiAgICogTm90ZTogVGhpcyBzaW5rIG9ubHkgKndyaXRlcyogdG8gdGhlIHJvdXRlLiBUbyByZWFkIHRoZSBwYXJhbXMgaW50byBhXG4gICAqIGNvbXBvbmVudCBpbnB1dCB5b3UgbXVzdCB1c2UgdGhlIGBSb3V0ZVBhcmFtc1N0b3JlYC5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldE5hbWUgT3B0aW9uYWxseSBuYXZpZ2F0ZSB0byB0aGUgZ2l2ZW4gY3hwIGl0ZW0gYnkgbmFtZSBhbmQgc2F2ZSB0b1xuICAgKiAgIHRoaXMgaXRlbSdzIHJvdXRlLlxuICAgKi9cbiAgc2luazogKHRhcmdldE5hbWU/OiBzdHJpbmcpID0+IFNpbms8Um91dGVQYXJhbXM+O1xufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVQYXJhbXNNdWx0aSA9IChcbiAgYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlLFxuICByb3V0ZXJTZXJ2aWNlOiBSb3V0ZXJOYXZpZ2F0aW9uU2VydmljZSxcbiAgaXRlbU5hdmlnYXRpb246INOoSXRlbU5hdmlnYXRpb25TZXJ2aWNlLFxuKTogUm91dGVQYXJhbXNNdWx0aVNpbmsgPT4gKHtcbiAgc2luazogKHRhcmdldE5hbWU/OiBzdHJpbmcpID0+IChzdGRpbjogT2JzZXJ2YWJsZTxSb3V0ZVBhcmFtcz4pID0+IHtcbiAgICBzdGRpbi5zdWJzY3JpYmUocGFyYW1zID0+IHtcbiAgICAgIGlmICghdGFyZ2V0TmFtZSkge1xuICAgICAgICByb3V0ZXJTZXJ2aWNlLm5hdmlnYXRlKHJvdXRlclNlcnZpY2Uuc2V0UGFyYW1zKHBhcmFtcywgYWN0aXZhdGVkUm91dGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1OYXZpZ2F0aW9uLm5hdmlnYXRlVG9JdGVtKHRhcmdldE5hbWUsIHBhcmFtcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG59KTtcblxuLyoqXG4gKiBDb25maWd1cmUgdGhlIGBSb3V0ZVBhcmFtc011bHRpU2lua2AuXG4gKlxuICogVXNlIHRoZSBzdHJpbmcgJ3JvdXRlLXBhcmFtLW11bHRpJyB0byBjb25maWd1cmUgdGhpcyBoYW5kbGVyLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogU3RvcmUgc29tZSAyLXdheSBib3VuZCBzdGF0ZXMgdG8gdGhlIHJvdXRlciBhcyBcInBhcmFtTmFtZVwiXG4gKlxuICogYGBganNvblxuICoge1xuICogICBcIm5hbWVcIjogXCJ3aWRnZXQtYVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwib3V0cHV0Lm15T3V0cHV0XCI6IFwicm91dGUtcGFyYW0tbXVsdGlcIixcbiAqICAgICBcImlucHV0Lm15SW5wdXRcIjogXCJyb3V0ZS1wYXJhbSBpbnB1dDFcIiwgLy8gYXNzdW1pbmcgaW5wdXQxIGlzIHNldCB2aWEgbXlPdXRwdXRcbiAqICAgICBcImlucHV0Lm15SW5wdXQyXCI6IFwicm91dGUtcGFyYW0gaW5wdXQyXCIgLy8gYXNzdW1pbmcgaW5wdXQyIGlzIHNldCB2aWEgbXlPdXRwdXRcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogTmF2aWdhdGUgdG8gd2lkZ2V0LWIgYW5kIHBhc3MgZGF0YSB2aWEgcm91dGUtcGFyYW1cbiAqXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwibmFtZVwiOiBcIndpZGdldC1hXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJvdXRwdXQubXlPdXRwdXRcIjogXCJyb3V0ZS1wYXJhbS1tdWx0aSB3aWRnZXQtYlwiXG4gKiAgIH1cbiAqIH0sXG4gKiB7XG4gKiAgIFwibmFtZVwiOiBcIndpZGdldC1iXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJpbnB1dC5teUlucHV0XCI6IFwicm91dGUtcGFyYW0gaW5wdXQxXCIsXG4gKiAgICAgXCJpbnB1dC5teUlucHV0MlwiOiBcInJvdXRlLXBhcmFtIGlucHV0MlwiXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFNlZSBgUm91dGVQYXJhbXNNdWx0aVNpbmtgIGZvciBtb3JlIG9wdGlvbnMuXG4gKlxuICogQWxzbyBzZWU6XG4gKiAgLSBgcm91dGVQYXJhbXNQcm9jZXNzb3JDb25maWdgXG4gKiAgLVxuICovXG5leHBvcnQgY29uc3Qgcm91dGVQYXJhbXNNdWx0aVByb2Nlc3NvckNvbmZpZzogUGlwZWxpbmVQcm9jZXNzb3JDb25maWc8J3JvdXRlLXBhcmFtLW11bHRpJz4gPSB7XG4gIG5hbWU6ICdyb3V0ZS1wYXJhbS1tdWx0aScsXG4gIHByb3ZpZGVyOiB7XG4gICAgcHJvdmlkZTogbmV3IEluamVjdGlvblRva2VuKCdSb3V0ZSBwYXJhbSBtdWx0aSBwaXBlbGluZSBoYW5kbGVyJyksXG4gICAgdXNlRmFjdG9yeTogY3JlYXRlUm91dGVQYXJhbXNNdWx0aSxcbiAgICBkZXBzOiBbQWN0aXZhdGVkUm91dGUsIFJvdXRlck5hdmlnYXRpb25TZXJ2aWNlLCDTqEl0ZW1OYXZpZ2F0aW9uU2VydmljZV0sXG4gIH0sXG59O1xuIl19