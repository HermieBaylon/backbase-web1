import { InjectionToken } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';
import { createPipelineProcessorConfig } from '../pipeline-registry';
import { getRouteParam } from './route-param';
const TAG = 'router.navigate';
const isDefined = (param) => param !== undefined;
const ɵ0 = isDefined;
/**
 * @deprecated Will be removed in v7.0.0
 */
export const PARAM_PLACEHOLDER_BUILDER = Symbol('Param Placeholder Builder');
/**
 * @deprecated Will be removed in v7.0.0
 * Placeholder to use for a named optional matrix param in `RouterNavigate`.
 *
 * This class is private. Use `RouterNavigateSink.param` to create a placeholder.
 */
export class RouterNavigateParamPlaceholder {
    constructor(paramName) {
        this.paramName = paramName;
    }
    /**
     * @internal
     */
    static [PARAM_PLACEHOLDER_BUILDER](name) {
        return new RouterNavigateParamPlaceholder(name);
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Serialize the command generated with TS to pipeline source argument strings for the model.
 *
 * - Path commands are serialized as the path string.
 * - Single named optional params are serialzed as {paramName}
 * @param commands
 */
export const serializeCommands = (commands) => {
    // Validate that there is only max one placeholder
    if (commands.filter(command => command instanceof RouterNavigateParamPlaceholder).length > 1) {
        throw new Error('RouterNavigate: Only a single placeholder can be configured');
    }
    return commands.map(command => {
        if (command instanceof RouterNavigateParamPlaceholder) {
            return `{${command.paramName}}`;
        }
        else {
            return command;
        }
    });
};
/**
 * Deserialize the pipeline string arguments to commands for Router.navigate.
 * @param commands
 */
const deserializeCommands = (commands) => commands.map(command => {
    const paramNameMatches = command.match(/^{([^}]+)}$/);
    if (!paramNameMatches) {
        return command;
    }
    return RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER](paramNameMatches[1]);
});
const ɵ1 = deserializeCommands;
/**
 * @deprecated Will be removed in v7.0.0
 * Helper to configure output properties to write to the `RouterNavigateStore`
 *
 * @usageNotes
 *
 * To navigate like:
 *
 * ```ts
 * myOutput.subscribe(() => Router.navigate(['items']);)
 * ```
 *
 * Configure your model like:
 *
 * ```json
 *  {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouterNavigateSink.navigate(['items']),
 *   }
 * }
 * ```
 *
 * To navigate to nested paths like:
 *
 * ```ts
 * myOutput.subscribe(() => Router.navigate(['dashboard', 'transactions']);)
 * ```
 *
 * Configure your model like:
 *
 * ```json
 *  {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouterNavigateSink.navigate(['dashboard', 'transactions']),
 *   }
 * }
 * ```
 *
 * To navigate passing [optional route
 * params](https://angular.io/guide/router-tutorial-toh#heroes-list-optionally-selecting-a-hero),
 * eg in Angular it would be:
 *
 * ```ts
 * heroId.subscribe((heroId) => Router.navigate(['heroes', { id: heroId }]));
 * ```
 *
 * Configure your model like:
 *
 * ```json
 * {
 *   "output.heroId": RouterNavigateSink.navigate(['heroes', RouterNavigateSink.param('id')]),
 * }
 * ```
 *
 * To read a param you can connect an input to the `RouterNavigateSource`.
 */
export class RouterNavigateSink {
    /**
     * Generate a serialized `PipelineSink` configuration suitable for use as a Widget Output property value.
     *
     * @param commands The commands to use for navigation.
     */
    static navigate(commands) {
        return `${TAG} ${serializeCommands(commands).join(' ')}`;
    }
    /**
     * Create a param placeholder to use in a `RouterNavigateSink`.
     *
     * @param paramName
     */
    static param(paramName) {
        if (!paramName) {
            throw new Error('RouterNavigateSink.param: paramName must be set');
        }
        return RouterNavigateParamPlaceholder[PARAM_PLACEHOLDER_BUILDER](paramName);
    }
}
/**
 * @deprecated Will be removed in v7.0.0
 * Helper to configure input properties to read from the `RouterNavigateStore`
 *
 * @usageNotes
 *
 *
 * To read a param into an input property:
 *
 * ```json
 * {
 *   "input.heroId": RouterNavigateSource.param('id')
 * }
 * ```
 */
export class RouterNavigateSource {
    /**
     * Generate a serialized `PipelineSource` configuration suitable for use as a Widget Input property value.
     *
     * @param paramName The name of the param to read from the URL.
     */
    static param(paramName) {
        return `${TAG} ${paramName}`;
    }
}
const matrixParam = (param, paramValue) => isDefined(paramValue) ? { [param.paramName]: `${paramValue}` } : paramValue;
const ɵ2 = matrixParam;
// Convert configured navigate commands to actual angular Router.navigate commands
const navigateCommands = (commands, paramValue) => commands
    .map(command => (command instanceof RouterNavigateParamPlaceholder ? matrixParam(command, paramValue) : command))
    .filter(isDefined);
const ɵ3 = navigateCommands;
/**
 * @deprecated Will be removed in v7.0.0
 */
export const createRouterNavigateStore = (router, activatedRoute) => ({
    sink: (...serializedCommands) => {
        const commands = deserializeCommands(serializedCommands);
        return stdin => {
            stdin.subscribe(paramValue => {
                router.navigate(navigateCommands(commands, paramValue));
            });
        };
    },
    source: (paramName) => () => getRouteParam(activatedRoute, paramName),
});
/**
 * @deprecated Will be removed in v7.0.0
 */
export const routerNavigateProcessorConfig = createPipelineProcessorConfig(TAG, {
    provide: new InjectionToken('Router.Navigate pipeline handler'),
    useFactory: createRouterNavigateStore,
    deps: [Router, ActivatedRoute],
});
export { ɵ0, ɵ1, ɵ2, ɵ3 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm91dGVyLW5hdmlnYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYmFja2Jhc2UvZm91bmRhdGlvbi1hbmcvY29yZS9zcmMvYmFja2Jhc2UtY29yZS9jb21tdW5pY2F0aW9uL3BpcGVzL2hhbmRsZXJzL3JvdXRlci1uYXZpZ2F0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQy9DLE9BQU8sRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFekQsT0FBTyxFQUFFLDZCQUE2QixFQUEyQixNQUFNLHNCQUFzQixDQUFDO0FBQzlGLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFROUMsTUFBTSxHQUFHLEdBQXNCLGlCQUFpQixDQUFDO0FBRWpELE1BQU0sU0FBUyxHQUFHLENBQUksS0FBb0IsRUFBYyxFQUFFLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQzs7QUFDL0U7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQztBQUU3RTs7Ozs7R0FLRztBQUNILE1BQU0sT0FBTyw4QkFBOEI7SUFDekMsWUFBb0MsU0FBaUI7UUFBakIsY0FBUyxHQUFULFNBQVMsQ0FBUTtJQUFHLENBQUM7SUFFekQ7O09BRUc7SUFDSCxNQUFNLENBQUMsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLElBQVk7UUFDN0MsT0FBTyxJQUFJLDhCQUE4QixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2xELENBQUM7Q0FDRjtBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBRyxDQUFDLFFBQTJELEVBQWlCLEVBQUU7SUFDOUcsa0RBQWtEO0lBQ2xELElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFP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LEtBQUssQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQzNCLE1BQU0sQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDMUQsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7SUFDSixDQUFDO0lBQ0QsTUFBTSxFQUFFLENBQUMsU0FBaUIsRUFBRSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDLGNBQWMsRUFBRSxTQUFTLENBQUM7Q0FDOUUsQ0FBQyxDQUFDO0FBQ0g7O0dBRUc7QUFDSCxNQUFNLENBQUMsTUFBTSw2QkFBNkIsR0FBNEIsNkJBQTZCLENBQUMsR0FBRyxFQUFFO0lBQ3ZHLE9BQU8sRUFBRSxJQUFJLGNBQWMsQ0FBQyxrQ0FBa0MsQ0FBQztJQUMvRCxVQUFVLEVBQUUseUJBQXlCO0lBQ3JDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUM7Q0FDL0IsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlciwgQWN0aXZhdGVkUm91dGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgUGlwZWxpbmVTaW5rLCBTaW5rLCBTb3VyY2UsIFBpcGVsaW5lU291cmNlIH0gZnJvbSAnLi4vcGlwZWxpbmUtaW50ZXJmYWNlJztcbmltcG9ydCB7IGNyZWF0ZVBpcGVsaW5lUHJvY2Vzc29yQ29uZmlnLCBQaXBlbGluZVByb2Nlc3NvckNvbmZpZyB9IGZyb20gJy4uL3BpcGVsaW5lLXJlZ2lzdHJ5JztcbmltcG9ydCB7IGdldFJvdXRlUGFyYW0gfSBmcm9tICcuL3JvdXRlLXBhcmFtJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKiBQYXRoIGZyYWdtZW50XG4gKi9cbmV4cG9ydCB0eXBlIFJvdXRlUGF0aCA9IHN0cmluZztcblxuY29uc3QgVEFHOiAncm91dGVyLm5hdmlnYXRlJyA9ICdyb3V0ZXIubmF2aWdhdGUnO1xuXG5jb25zdCBpc0RlZmluZWQgPSA8VD4ocGFyYW06IHVuZGVmaW5lZCB8IFQpOiBwYXJhbSBpcyBUID0+IHBhcmFtICE9PSB1bmRlZmluZWQ7XG4vKipcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4wLjBcbiAqL1xuZXhwb3J0IGNvbnN0IFBBUkFNX1BMQUNFSE9MREVSX0JVSUxERVIgPSBTeW1ib2woJ1BhcmFtIFBsYWNlaG9sZGVyIEJ1aWxkZXInKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKiBQbGFjZWhvbGRlciB0byB1c2UgZm9yIGEgbmFtZWQgb3B0aW9uYWwgbWF0cml4IHBhcmFtIGluIGBSb3V0ZXJOYXZpZ2F0ZWAuXG4gKlxuICogVGhpcyBjbGFzcyBpcyBwcml2YXRlLiBVc2UgYFJvdXRlck5hdmlnYXRlU2luay5wYXJhbWAgdG8gY3JlYXRlIGEgcGxhY2Vob2xkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3V0ZXJOYXZpZ2F0ZVBhcmFtUGxhY2Vob2xkZXIge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBwYXJhbU5hbWU6IHN0cmluZykge31cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgW1BBUkFNX1BMQUNFSE9MREVSX0JVSUxERVJdKG5hbWU6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgUm91dGVyTmF2aWdhdGVQYXJhbVBsYWNlaG9sZGVyKG5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICogU2VyaWFsaXplIHRoZSBjb21tYW5kIGdlbmVyYXRlZCB3aXRoIFRTIHRvIHBpcGVsaW5lIHNvdXJjZSBhcmd1bWVudCBzdHJpbmdzIGZvciB0aGUgbW9kZWwuXG4gKlxuICogLSBQYXRoIGNvbW1hbmRzIGFyZSBzZXJpYWxpemVkIGFzIHRoZSBwYXRoIHN0cmluZy5cbiAqIC0gU2luZ2xlIG5hbWVkIG9wdGlvbmFsIHBhcmFtcyBhcmUgc2VyaWFsemVkIGFzIHtwYXJhbU5hbWV9XG4gKiBAcGFyYW0gY29tbWFuZHNcbiAqL1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZUNvbW1hbmRzID0gKGNvbW1hbmRzOiBBcnJheTxSb3V0ZVBhdGggfCBSb3V0ZXJOYXZpZ2F0ZVBhcmFtUGxhY2Vob2xkZXI+KTogQXJyYXk8c3RyaW5nPiA9PiB7XG4gIC8vIFZhbGlkYXRlIHRoYXQgdGhlcmUgaXMgb25seSBtYXggb25lIHBsYWNlaG9sZGVyXG4gIGlmIChjb21tYW5kcy5maWx0ZXIoY29tbWFuZCA9PiBjb21tYW5kIGluc3RhbmNlb2YgUm91dGVyTmF2aWdhdGVQYXJhbVBsYWNlaG9sZGVyKS5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZXJOYXZpZ2F0ZTogT25seSBhIHNpbmdsZSBwbGFjZWhvbGRlciBjYW4gYmUgY29uZmlndXJlZCcpO1xuICB9XG5cbiAgcmV0dXJuIGNvbW1hbmRzLm1hcChjb21tYW5kID0+IHtcbiAgICBpZiAoY29tbWFuZCBpbnN0YW5jZW9mIFJvdXRlck5hdmlnYXRlUGFyYW1QbGFjZWhvbGRlcikge1xuICAgICAgcmV0dXJuIGB7JHtjb21tYW5kLnBhcmFtTmFtZX19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbW1hbmQ7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemUgdGhlIHBpcGVsaW5lIHN0cmluZyBhcmd1bWVudHMgdG8gY29tbWFuZHMgZm9yIFJvdXRlci5uYXZpZ2F0ZS5cbiAqIEBwYXJhbSBjb21tYW5kc1xuICovXG5jb25zdCBkZXNlcmlhbGl6ZUNvbW1hbmRzID0gKGNvbW1hbmRzOiBBcnJheTxzdHJpbmc+KTogQXJyYXk8Um91dGVQYXRoIHwgUm91dGVyTmF2aWdhdGVQYXJhbVBsYWNlaG9sZGVyPiA9PlxuICBjb21tYW5kcy5tYXAoY29tbWFuZCA9PiB7XG4gICAgY29uc3QgcGFyYW1OYW1lTWF0Y2hlcyA9IGNvbW1hbmQubWF0Y2goL157KFtefV0rKX0kLyk7XG4gICAgaWYgKCFwYXJhbU5hbWVNYXRjaGVzKSB7XG4gICAgICByZXR1cm4gY29tbWFuZDtcbiAgICB9XG4gICAgcmV0dXJuIFJvdXRlck5hdmlnYXRlUGFyYW1QbGFjZWhvbGRlcltQQVJBTV9QTEFDRUhPTERFUl9CVUlMREVSXShwYXJhbU5hbWVNYXRjaGVzWzFdKTtcbiAgfSk7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICogSGVscGVyIHRvIGNvbmZpZ3VyZSBvdXRwdXQgcHJvcGVydGllcyB0byB3cml0ZSB0byB0aGUgYFJvdXRlck5hdmlnYXRlU3RvcmVgXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiBUbyBuYXZpZ2F0ZSBsaWtlOlxuICpcbiAqIGBgYHRzXG4gKiBteU91dHB1dC5zdWJzY3JpYmUoKCkgPT4gUm91dGVyLm5hdmlnYXRlKFsnaXRlbXMnXSk7KVxuICogYGBgXG4gKlxuICogQ29uZmlndXJlIHlvdXIgbW9kZWwgbGlrZTpcbiAqXG4gKiBgYGBqc29uXG4gKiAge1xuICogICBcIm5hbWVcIjogXCJ3aWRnZXQtYVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwib3V0cHV0Lm15T3V0cHV0XCI6IFJvdXRlck5hdmlnYXRlU2luay5uYXZpZ2F0ZShbJ2l0ZW1zJ10pLFxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUbyBuYXZpZ2F0ZSB0byBuZXN0ZWQgcGF0aHMgbGlrZTpcbiAqXG4gKiBgYGB0c1xuICogbXlPdXRwdXQuc3Vic2NyaWJlKCgpID0+IFJvdXRlci5uYXZpZ2F0ZShbJ2Rhc2hib2FyZCcsICd0cmFuc2FjdGlvbnMnXSk7KVxuICogYGBgXG4gKlxuICogQ29uZmlndXJlIHlvdXIgbW9kZWwgbGlrZTpcbiAqXG4gKiBgYGBqc29uXG4gKiAge1xuICogICBcIm5hbWVcIjogXCJ3aWRnZXQtYVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwib3V0cHV0Lm15T3V0cHV0XCI6IFJvdXRlck5hdmlnYXRlU2luay5uYXZpZ2F0ZShbJ2Rhc2hib2FyZCcsICd0cmFuc2FjdGlvbnMnXSksXG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIG5hdmlnYXRlIHBhc3NpbmcgW29wdGlvbmFsIHJvdXRlXG4gKiBwYXJhbXNdKGh0dHBzOi8vYW5ndWxhci5pby9ndWlkZS9yb3V0ZXItdHV0b3JpYWwtdG9oI2hlcm9lcy1saXN0LW9wdGlvbmFsbHktc2VsZWN0aW5nLWEtaGVybyksXG4gKiBlZyBpbiBBbmd1bGFyIGl0IHdvdWxkIGJlOlxuICpcbiAqIGBgYHRzXG4gKiBoZXJvSWQuc3Vic2NyaWJlKChoZXJvSWQpID0+IFJvdXRlci5uYXZpZ2F0ZShbJ2hlcm9lcycsIHsgaWQ6IGhlcm9JZCB9XSkpO1xuICogYGBgXG4gKlxuICogQ29uZmlndXJlIHlvdXIgbW9kZWwgbGlrZTpcbiAqXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwib3V0cHV0Lmhlcm9JZFwiOiBSb3V0ZXJOYXZpZ2F0ZVNpbmsubmF2aWdhdGUoWydoZXJvZXMnLCBSb3V0ZXJOYXZpZ2F0ZVNpbmsucGFyYW0oJ2lkJyldKSxcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHJlYWQgYSBwYXJhbSB5b3UgY2FuIGNvbm5lY3QgYW4gaW5wdXQgdG8gdGhlIGBSb3V0ZXJOYXZpZ2F0ZVNvdXJjZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb3V0ZXJOYXZpZ2F0ZVNpbmsge1xuICAvKipcbiAgICogR2VuZXJhdGUgYSBzZXJpYWxpemVkIGBQaXBlbGluZVNpbmtgIGNvbmZpZ3VyYXRpb24gc3VpdGFibGUgZm9yIHVzZSBhcyBhIFdpZGdldCBPdXRwdXQgcHJvcGVydHkgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSBjb21tYW5kcyBUaGUgY29tbWFuZHMgdG8gdXNlIGZvciBuYXZpZ2F0aW9uLlxuICAgKi9cbiAgc3RhdGljIG5hdmlnYXRlKGNvbW1hbmRzOiBBcnJheTxSb3V0ZVBhdGggfCBSb3V0ZXJOYXZpZ2F0ZVBhcmFtUGxhY2Vob2xkZXI+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7VEFHfSAke3NlcmlhbGl6ZUNvbW1hbmRzKGNvbW1hbmRzKS5qb2luKCcgJyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwYXJhbSBwbGFjZWhvbGRlciB0byB1c2UgaW4gYSBgUm91dGVyTmF2aWdhdGVTaW5rYC5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtTmFtZVxuICAgKi9cbiAgc3RhdGljIHBhcmFtKHBhcmFtTmFtZTogc3RyaW5nKTogUm91dGVyTmF2aWdhdGVQYXJhbVBsYWNlaG9sZGVyIHtcbiAgICBpZiAoIXBhcmFtTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZXJOYXZpZ2F0ZVNpbmsucGFyYW06IHBhcmFtTmFtZSBtdXN0IGJlIHNldCcpO1xuICAgIH1cbiAgICByZXR1cm4gUm91dGVyTmF2aWdhdGVQYXJhbVBsYWNlaG9sZGVyW1BBUkFNX1BMQUNFSE9MREVSX0JVSUxERVJdKHBhcmFtTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKiBIZWxwZXIgdG8gY29uZmlndXJlIGlucHV0IHByb3BlcnRpZXMgdG8gcmVhZCBmcm9tIHRoZSBgUm91dGVyTmF2aWdhdGVTdG9yZWBcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqXG4gKiBUbyByZWFkIGEgcGFyYW0gaW50byBhbiBpbnB1dCBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwiaW5wdXQuaGVyb0lkXCI6IFJvdXRlck5hdmlnYXRlU291cmNlLnBhcmFtKCdpZCcpXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFJvdXRlck5hdmlnYXRlU291cmNlIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgc2VyaWFsaXplZCBgUGlwZWxpbmVTb3VyY2VgIGNvbmZpZ3VyYXRpb24gc3VpdGFibGUgZm9yIHVzZSBhcyBhIFdpZGdldCBJbnB1dCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtTmFtZSBUaGUgbmFtZSBvZiB0aGUgcGFyYW0gdG8gcmVhZCBmcm9tIHRoZSBVUkwuXG4gICAqL1xuICBzdGF0aWMgcGFyYW0ocGFyYW1OYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHtUQUd9ICR7cGFyYW1OYW1lfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKiBBIGBQaXBlbGluZVByb2Nlc3NvcmAgd2hpY2ggY2FuIGJlIHVzZWQgYXMgYSBzaW5rIHRvIG5hdmlnYXRlIGxpa2UgQW5ndWxhcidzIGBSb3V0ZXIuTmF2aWdhdGVgIGRvZXMuXG4gKlxuICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW0gY2FuIGJlIHBhc3NlZCBhcyBhbiBvcHRpb25hbCBwYXJhbWV0ZXIuXG4gKlxuICogSXQgY2FuIGFsc28gYmUgdXNlZCBhcyBhIHNvdXJjZSB0byByZWFkIHRoZSBwYXJhbXMgaW50byBhIHdpZGdldCdzIGlucHV0cy5cbiAqXG4gKiBUaGVyZSBhcmUgc29tZSBrbm93biBsaW1pdGF0aW9ucyB0byB0aGUgbmF2aWdhdGUgc2luazpcbiAqXG4gKiAgMS4gWW91IGNhbiBvbmx5IG5hdmlnYXRlIHdpdGggdGhlIHByaW1hcnkgb3V0bGV0LCBub3QgbmFtZWQgb3V0bGV0cy5cbiAqICAyLiBZb3UgY2Fubm90IG5hdmlnYXRlIHRvIHBhdGhzIHdpdGggcmVxdWlyZWQgcGFyYW1zLCBvbmx5IG9wdGlvbmFsIChtYXRyaXgpIHBhcmFtcy5cbiAqICAzLiBZb3UgY2FuIG9ubHkgcGFzcyBhIHNpbmdsZSBwYXJhbSBuYW1lL3ZhbHVlLlxuICogIDQuIFlvdSBjYW4gb25seSBwYXNzIGEgc3RyaW5nL251bWJlciB2YWx1ZS5cbiAqICA1LiBJZiB0aGVyZSBhcmUgb3RoZXIgb3V0bGV0cyBpbiB0aGUgY3VycmVudCBhY3RpdmF0ZSByb3V0ZSwgdGhleSBXaWxsIGJlIHJlbW92ZWQuXG4gKlxuICogSWYgeW91IHJlcXVpcmUgYSBtb3JlIGNvbXBsZXggbmF2aWdhdGlvbiwgaXQncyByZWNvbW1lbmRlZCB0byBjcmVhdGUgYSBzaW1wbGUgc2lua1xuICogb2YgeW91ciBvd24uIFNlZSBgUGlwZWxpbmVQcm9jZXNzb3JgIGFuZCBgUGlwZWxpbmVQcm9jZXNzb3JDb25maWdgLlxuICpcbiAqIFNlZSBgUm91dGVyTmF2aWdhdGVTaW5rYCBhbmQgYFJvdXRlck5hdmlnYXRlU291cmNlYCBmb3IgY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJOYXZpZ2F0ZVN0b3JlIGV4dGVuZHMgUGlwZWxpbmVTaW5rPHN0cmluZyB8IHVuZGVmaW5lZD4sIFBpcGVsaW5lU291cmNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAvKipcbiAgICogQSBgUGlwZWxpbmVQcm9jZXNzb3JgIHNpbmsgd2hpY2ggbmF2aWdhdGVzIHRvIGEgVVJMIHVzaW5nIGFuZ3VsYXIncyBgUm91dGVyLm5hdmlnYXRlYC5cbiAgICpcbiAgICogVG8gY29uZmlndXJlIGFuIG91dHB1dCBwcm9wZXJ0eSBmb3IgdGhpcyBzaW5rIHVzZSBgUm91dGVyTmF2aWdhdGVTaW5rYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbW1hbmRzIEFuIGFycmF5IG9mIFVSTCBmcmFnbWVudHMgd2l0aCB3aGljaCB0byBjb25zdHJ1Y3QgdGhlIG5ldyBVUkwgdHJlZS5cbiAgICovXG4gIHNpbms6ICguLi5jb21tYW5kczogQXJyYXk8c3RyaW5nPikgPT4gU2luazxzdHJpbmcgfCB1bmRlZmluZWQ+O1xuXG4gIC8qKlxuICAgKiBBIGBQaXBlbGluZVByb2Nlc3NvcmAgc291cmNlIHdoaWNoIHJlYWRzIGZyb20gYSBVUkwgcGFyYW0uXG4gICAqXG4gICAqIFRvIGNvbmZpZ3VyZSBhbiBpbnB1dCBwcm9wZXJ0eSBmb3IgdGhpcyBzb3VyY2UgdXNlIGBSb3V0ZXJOYXZpZ2F0ZVNvdXJjZWAuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbU5hbWVcbiAgICovXG4gIHNvdXJjZTogKHBhcmFtTmFtZTogc3RyaW5nKSA9PiBTb3VyY2U8c3RyaW5nIHwgdW5kZWZpbmVkPjtcbn1cblxuY29uc3QgbWF0cml4UGFyYW0gPSAoXG4gIHBhcmFtOiBSb3V0ZXJOYXZpZ2F0ZVBhcmFtUGxhY2Vob2xkZXIsXG4gIHBhcmFtVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZCxcbik6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gfCB1bmRlZmluZWQgPT5cbiAgaXNEZWZpbmVkKHBhcmFtVmFsdWUpID8geyBbcGFyYW0ucGFyYW1OYW1lXTogYCR7cGFyYW1WYWx1ZX1gIH0gOiBwYXJhbVZhbHVlO1xuXG4vLyBDb252ZXJ0IGNvbmZpZ3VyZWQgbmF2aWdhdGUgY29tbWFuZHMgdG8gYWN0dWFsIGFuZ3VsYXIgUm91dGVyLm5hdmlnYXRlIGNvbW1hbmRzXG5jb25zdCBuYXZpZ2F0ZUNvbW1hbmRzID0gKFxuICBjb21tYW5kczogQXJyYXk8Um91dGVQYXRoIHwgUm91dGVyTmF2aWdhdGVQYXJhbVBsYWNlaG9sZGVyPixcbiAgcGFyYW1WYWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuKTogQXJyYXk8c3RyaW5nIHwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4gPT5cbiAgY29tbWFuZHNcbiAgICAubWFwKGNvbW1hbmQgPT4gKGNvbW1hbmQgaW5zdGFuY2VvZiBSb3V0ZXJOYXZpZ2F0ZVBhcmFtUGxhY2Vob2xkZXIgPyBtYXRyaXhQYXJhbShjb21tYW5kLCBwYXJhbVZhbHVlKSA6IGNvbW1hbmQpKVxuICAgIC5maWx0ZXIoaXNEZWZpbmVkKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSb3V0ZXJOYXZpZ2F0ZVN0b3JlID0gKHJvdXRlcjogUm91dGVyLCBhY3RpdmF0ZWRSb3V0ZTogQWN0aXZhdGVkUm91dGUpOiBSb3V0ZXJOYXZpZ2F0ZVN0b3JlID0+ICh7XG4gIHNpbms6ICguLi5zZXJpYWxpemVkQ29tbWFuZHMpID0+IHtcbiAgICBjb25zdCBjb21tYW5kcyA9IGRlc2VyaWFsaXplQ29tbWFuZHMoc2VyaWFsaXplZENvbW1hbmRzKTtcbiAgICByZXR1cm4gc3RkaW4gPT4ge1xuICAgICAgc3RkaW4uc3Vic2NyaWJlKHBhcmFtVmFsdWUgPT4ge1xuICAgICAgICByb3V0ZXIubmF2aWdhdGUobmF2aWdhdGVDb21tYW5kcyhjb21tYW5kcywgcGFyYW1WYWx1ZSkpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcbiAgc291cmNlOiAocGFyYW1OYW1lOiBzdHJpbmcpID0+ICgpID0+IGdldFJvdXRlUGFyYW0oYWN0aXZhdGVkUm91dGUsIHBhcmFtTmFtZSksXG59KTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICovXG5leHBvcnQgY29uc3Qgcm91dGVyTmF2aWdhdGVQcm9jZXNzb3JDb25maWc6IFBpcGVsaW5lUHJvY2Vzc29yQ29uZmlnID0gY3JlYXRlUGlwZWxpbmVQcm9jZXNzb3JDb25maWcoVEFHLCB7XG4gIHByb3ZpZGU6IG5ldyBJbmplY3Rpb25Ub2tlbignUm91dGVyLk5hdmlnYXRlIHBpcGVsaW5lIGhhbmRsZXInKSxcbiAgdXNlRmFjdG9yeTogY3JlYXRlUm91dGVyTmF2aWdhdGVTdG9yZSxcbiAgZGVwczogW1JvdXRlciwgQWN0aXZhdGVkUm91dGVdLFxufSk7XG4iXX0=