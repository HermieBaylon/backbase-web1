import { InjectionToken, Inject, Injectable } from '@angular/core';
import { flatten } from '../../models/array';
import * as i0 from "@angular/core";
/**
 * @deprecated Will be removed in v7.0.0
 */
export const CONFIG_PIPELINE_PROCESSORS = new InjectionToken('@backbase/foundation Pipeline Handlers');
/**
 * @deprecated Will be removed in v7.0.0
 * Helper service wrapping around CONFIG_PIPELINE_PROCESSORS
 */
export class PipelineRegistry {
    constructor(processorsNested) {
        const allProcessors = flatten(processorsNested);
        this.registeredHandlers = new Map(allProcessors.map(({ name, provider }) => [name, provider]));
    }
    getProcessorProvider(name) {
        const provider = this.registeredHandlers.get(name);
        if (provider === undefined) {
            throw new Error(`No provider to pipeline handler ${name}`);
        }
        return Object.assign({ deps: [] }, provider);
    }
    getProcessorProviderToken(name) {
        return this.getProcessorProvider(name).provide;
    }
}
PipelineRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function PipelineRegistry_Factory() { return new PipelineRegistry(i0.ɵɵinject(CONFIG_PIPELINE_PROCESSORS)); }, token: PipelineRegistry, providedIn: "root" });
PipelineRegistry.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PipelineRegistry.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [CONFIG_PIPELINE_PROCESSORS,] }] }
];
/**
 * @deprecated Will be removed in v7.0.0
 */
export function createPipelineProcessorConfig(name, provider) {
    return {
        name,
        provider,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlwZWxpbmUtcmVnaXN0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL2NvbW11bmljYXRpb24vcGlwZXMvcGlwZWxpbmUtcmVnaXN0cnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQXdDLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7O0FBbUU3Qzs7R0FFRztBQUNILE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLElBQUksY0FBYyxDQUMxRCx3Q0FBd0MsQ0FDekMsQ0FBQztBQUVGOzs7R0FHRztBQUlILE1BQU0sT0FBTyxnQkFBZ0I7SUFHM0IsWUFFRSxnQkFDMkI7UUFFM0IsTUFBTSxhQUFhLEdBQW1DLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ2hGLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsQ0FDL0IsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUF1QyxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FDakcsQ0FBQztJQUNKLENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxJQUFZO1FBQy9CLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkQsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLElBQUksRUFBRSxDQUFDLENBQUM7U0FDNUQ7UUFDRCx1QkFDRSxJQUFJLEVBQUUsRUFBRSxJQUNMLFFBQVEsRUFDWDtJQUNKLENBQUM7SUFFRCx5QkFBeUIsQ0FBQyxJQUFZO1FBQ3BDLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUNqRCxDQUFDOzs7O1lBOUJGLFVBQVUsU0FBQztnQkFDVixVQUFVLEVBQUUsTUFBTTthQUNuQjs7O3dDQUtJLE1BQU0sU0FBQywwQkFBMEI7O0FBeUJ0Qzs7R0FFRztBQUNILE1BQU0sVUFBVSw2QkFBNkIsQ0FDM0MsSUFBTyxFQUNQLFFBQW1DO0lBRW5DLE9BQU87UUFDTCxJQUFJO1FBQ0osUUFBUTtLQUNULENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgVmFsdWVQcm92aWRlciwgRmFjdG9yeVByb3ZpZGVyLCBUeXBlLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmbGF0dGVuIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2FycmF5JztcblxuZXhwb3J0IHR5cGUgUHJvY2Vzc29yTmFtZSA9IHN0cmluZztcblxuLyoqXG4gKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICogQ29uZmlndXJlcyBhIHByb3ZpZGVyIGZvciBhIGBQaXBlbGluZVByb2Nlc3NvcmAgYnkgbmFtZS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIFJlZ2lzdGVyIGEgY3VzdG9tIHByb2Nlc3NvcjpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBCYWNrYmFzZUNvcmVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgIHBpcGVsaW5lUHJvY2Vzc29yczogW3tcbiAqICAgICBuYW1lOiAnY3VzdG9tLXBpcGUnLFxuICogICAgIHByb3ZpZGVyOiB7XG4gKiAgICAgICBwcm92aWRlOiBuZXcgSW5qZWN0aW9uVG9rZW4oJ0N1c3RvbSBoYW5kbGVyJyksXG4gKiAgICAgICB1c2VWYWx1ZToge1xuICogICAgICAgICBwaXBlOiAoKSA9PiAoc3RkaW46IE9ic2VydmFibGU8YW55PikgPT4gc3RkaW4ucGlwZSh0YXAoXG4gKiAgICAgICAgICAgKHZhbDogYW55KSA9PiBjb25zb2xlLmxvZyh2YWwpXG4gKiAgICAgICAgICkpLFxuICogICAgICAgfSxcbiAqICAgICB9LFxuICogICB9XSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBDb25maWd1cmUgY3VzdG9tIHByb2Nlc3NvciBpbiBtb2RlbDpcbiAqXG4gKiBgYGBqc29uXG4gKiB7XG4gKiAgIFwibmFtZVwiOiBcIm15LXdpZGdldFwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwib3V0cHV0Lm15T3V0cHV0XCI6IFwiY3VzdG9tLXBpcGVcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQaXBlbGluZVByb2Nlc3NvckNvbmZpZzxUIGV4dGVuZHMgUHJvY2Vzc29yTmFtZSA9IFByb2Nlc3Nvck5hbWU+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9jZXNzb3IsIHdoaWNoIGNhbiBiZSB1c2VkIGluIHRoZSBtb2RlbC5cbiAgICpcbiAgICogTm90ZTogdGhlIG5hbWUgbXVzdCBiZWdpbiB3aXRoIGEgbGV0dGVyIChhLXopLlxuICAgKi9cbiAgbmFtZTogVDtcbiAgLyoqXG4gICAqIEEgdmFsaWQgYW5ndWxhciBwcm92aWRlciB0aGF0IHdpbGwgYmUgaW5zdGFudGlhdGVkIHdoZW4gaXQgaXMgbmVlZGVkLlxuICAgKi9cbiAgcHJvdmlkZXI6IFBpcGVsaW5lUHJvY2Vzc29yUHJvdmlkZXI7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICogU2VlIGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29yZS9TdGF0aWNQcm92aWRlclxuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgU3RhdGljQ2xhc3NQcm92aWRlciB7XG4gIHVzZUNsYXNzOiBUeXBlPGFueT47XG4gIGRlcHM6IEFycmF5PGFueT47XG4gIHByb3ZpZGU6IGFueTtcbiAgbXVsdGk/OiBib29sZWFuO1xufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKi9cbmV4cG9ydCB0eXBlIFBpcGVsaW5lUHJvY2Vzc29yUHJvdmlkZXIgPSBTdGF0aWNDbGFzc1Byb3ZpZGVyIHwgRmFjdG9yeVByb3ZpZGVyIHwgVmFsdWVQcm92aWRlcjtcbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICovXG5leHBvcnQgY29uc3QgQ09ORklHX1BJUEVMSU5FX1BST0NFU1NPUlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48QXJyYXk8UGlwZWxpbmVQcm9jZXNzb3JDb25maWc+PihcbiAgJ0BiYWNrYmFzZS9mb3VuZGF0aW9uIFBpcGVsaW5lIEhhbmRsZXJzJyxcbik7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHY3LjAuMFxuICogSGVscGVyIHNlcnZpY2Ugd3JhcHBpbmcgYXJvdW5kIENPTkZJR19QSVBFTElORV9QUk9DRVNTT1JTXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBQaXBlbGluZVJlZ2lzdHJ5IHtcbiAgcHJpdmF0ZSByZWFkb25seSByZWdpc3RlcmVkSGFuZGxlcnM6IE1hcDxQcm9jZXNzb3JOYW1lLCBQaXBlbGluZVByb2Nlc3NvclByb3ZpZGVyPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KENPTkZJR19QSVBFTElORV9QUk9DRVNTT1JTKVxuICAgIHByb2Nlc3NvcnNOZXN0ZWQ6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYXJyYXktdHlwZVxuICAgIFBpcGVsaW5lUHJvY2Vzc29yQ29uZmlnW11bXSwgLy8gQW5ndWxhciBkb2Vzbid0IGxpa2UgbmVzdGVkIGFycmF5IHR5cGVzXG4gICkge1xuICAgIGNvbnN0IGFsbFByb2Nlc3NvcnM6IEFycmF5PFBpcGVsaW5lUHJvY2Vzc29yQ29uZmlnPiA9IGZsYXR0ZW4ocHJvY2Vzc29yc05lc3RlZCk7XG4gICAgdGhpcy5yZWdpc3RlcmVkSGFuZGxlcnMgPSBuZXcgTWFwKFxuICAgICAgYWxsUHJvY2Vzc29ycy5tYXAoKHsgbmFtZSwgcHJvdmlkZXIgfSk6IFtzdHJpbmcsIFBpcGVsaW5lUHJvY2Vzc29yUHJvdmlkZXJdID0+IFtuYW1lLCBwcm92aWRlcl0pLFxuICAgICk7XG4gIH1cblxuICBnZXRQcm9jZXNzb3JQcm92aWRlcihuYW1lOiBzdHJpbmcpOiBQaXBlbGluZVByb2Nlc3NvclByb3ZpZGVyIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucmVnaXN0ZXJlZEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICBpZiAocHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBwcm92aWRlciB0byBwaXBlbGluZSBoYW5kbGVyICR7bmFtZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlcHM6IFtdLFxuICAgICAgLi4ucHJvdmlkZXIsXG4gICAgfTtcbiAgfVxuXG4gIGdldFByb2Nlc3NvclByb3ZpZGVyVG9rZW4obmFtZTogc3RyaW5nKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5nZXRQcm9jZXNzb3JQcm92aWRlcihuYW1lKS5wcm92aWRlO1xuICB9XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBpcGVsaW5lUHJvY2Vzc29yQ29uZmlnPFQgZXh0ZW5kcyBQcm9jZXNzb3JOYW1lPihcbiAgbmFtZTogVCxcbiAgcHJvdmlkZXI6IFBpcGVsaW5lUHJvY2Vzc29yUHJvdmlkZXIsXG4pOiBQaXBlbGluZVByb2Nlc3NvckNvbmZpZzxUPiB7XG4gIHJldHVybiB7XG4gICAgbmFtZSxcbiAgICBwcm92aWRlcixcbiAgfTtcbn1cbiJdfQ==