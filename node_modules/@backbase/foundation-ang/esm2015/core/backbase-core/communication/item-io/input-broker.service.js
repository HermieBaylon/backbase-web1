import { ComponentFactoryResolver, Injectable, Inject, Optional } from '@angular/core';
import { take, takeUntil } from 'rxjs/operators';
import { ItemLifecycleService } from '../../rendering/item-lifecycle.service';
import { LAZY_MAP } from '../../rendering/lazy-config';
import { createComponentPipe } from '../pipes/handlers/component';
import { PipelineRegistry } from '../pipes/pipeline-registry';
import { PipelineService } from '../pipes/pipeline.service';
import { getProcessorNames, parseProperties } from './broker-helpers';
/**
 * The input broker service creates a communication pipeline
 * using the component input as a sink. The source of the pipeline
 * is determined by the item model.
 */
export class InputBrokerService {
    constructor(itemLifecycle, pipelineRegistry, componentFactoryResolver, lazyConfig) {
        this.itemLifecycle = itemLifecycle;
        this.pipelineRegistry = pipelineRegistry;
        this.componentFactoryResolver = componentFactoryResolver;
        this.lazyConfig = lazyConfig;
    }
    bootstrap() {
        // Model properties cannot be linked to the Inputs of lazy loaded items
        const lazyLoadedComponents = (this.lazyConfig
            ? this.lazyConfig.filter((config) => !!config.components)
            : []).reduce((acc, config) => [...acc, ...config.components], []);
        this.itemLifecycle.whenCreate().subscribe(({ itemModel, component }) => {
            const gc$ = this.itemLifecycle.whenRemove(itemModel.value.name).pipe(take(1));
            this.runInputPipelines(itemModel, component, gc$);
            if (!lazyLoadedComponents.includes(itemModel.value.ɵclassId)) {
                this.runModelInputs(itemModel, component, gc$);
            }
        });
    }
    runModelInputs(itemModel, ref, gc$) {
        this.componentFactoryResolver.resolveComponentFactory(ref.componentType).inputs.forEach(input => {
            // Abort if there is already an "input." property with the same name
            if (itemModel.value.ɵinputProperties[input.templateName] !== undefined)
                return;
            const modelValue = itemModel.value.ɵproperties[input.templateName];
            if (modelValue === undefined)
                return;
            const source = itemModel.value.property(input.templateName, modelValue);
            const sink = this.inputSink(ref, input.propName);
            return sink(source.pipe(takeUntil(gc$)));
        });
    }
    runInputPipelines(itemModel, ref, gc$) {
        const pipelineService = ref.injector.get(PipelineService);
        parseProperties(itemModel.value.ɵinputProperties).forEach(inputPipesConfig => {
            const sourceCommand = inputPipesConfig.pipeline;
            const sourceFn = pipelineService.createSource(sourceCommand.processorName, sourceCommand.args);
            const pipeline = {
                source: sourceFn,
                sink: this.inputSink(ref, inputPipesConfig.propertyName),
            };
            pipelineService.runPipeline(pipeline, gc$);
        });
    }
    inputSink(ref, inputName) {
        return createComponentPipe().sink(ref, inputName);
    }
    getItemProviders(item) {
        return getProcessorNames(item.ɵinputProperties).map(processorName => {
            try {
                return this.pipelineRegistry.getProcessorProvider(processorName);
            }
            catch (message) {
                throw new Error(`Input '${processorName}' on ${item.name} is misconfigured. ${message}`);
            }
        });
    }
}
InputBrokerService.decorators = [
    { type: Injectable }
];
InputBrokerService.ctorParameters = () => [
    { type: ItemLifecycleService },
    { type: PipelineRegistry },
    { type: ComponentFactoryResolver },
    { type: undefined, decorators: [{ type: Inject, args: [LAZY_MAP,] }, { type: Optional }] }
];
export function createInputBootstrap(Broker) {
    return Broker.bootstrap.bind(Broker);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtYnJva2VyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9iYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlL3NyYy9iYWNrYmFzZS1jb3JlL2NvbW11bmljYXRpb24vaXRlbS1pby9pbnB1dC1icm9rZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsd0JBQXdCLEVBQWdCLFVBQVUsRUFBa0IsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVySCxPQUFPLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSWpELE9BQU8sRUFBRSxvQkFBb0IsRUFBa0IsTUFBTSx3Q0FBd0MsQ0FBQztBQUM5RixPQUFPLEVBQUUsUUFBUSxFQUFvQyxNQUFNLDZCQUE2QixDQUFDO0FBQ3pGLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRWxFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzlELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFdEU7Ozs7R0FJRztBQUVILE1BQU0sT0FBTyxrQkFBa0I7SUFDN0IsWUFDbUIsYUFBbUMsRUFDbkMsZ0JBQWtDLEVBQ2xDLHdCQUFrRCxFQUdsRCxVQUE2QjtRQUw3QixrQkFBYSxHQUFiLGFBQWEsQ0FBc0I7UUFDbkMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyw2QkFBd0IsR0FBeEIsd0JBQXdCLENBQTBCO1FBR2xELGVBQVUsR0FBVixVQUFVLENBQW1CO0lBQzdDLENBQUM7SUFFSixTQUFTO1FBQ1AsdUVBQXVFO1FBQ3ZFLE1BQU0sb0JBQW9CLEdBQUcsQ0FB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QyxXQUFXLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzdDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLFNBQVMsQ0FBSSxHQUFvQixFQUFFLFNBQWlCO1FBQzFELE9BQU8sbUJBQW1CLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxJQUFlO1FBQzlCLE9BQU8saUJBQWlCLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ2xFLElBQUk7Z0JBQ0YsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDbEU7WUFBQyxPQUFPLE9BQU8sRUFBRTtnQkFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxVQUFVLGFBQWEsUUFBUSxJQUFJLENBQUMsSUFBSSxzQkFBc0IsT0FBTyxFQUFFLENBQUMsQ0FBQzthQUMxRjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7O1lBM0VGLFVBQVU7OztZQWJGLG9CQUFvQjtZQUlwQixnQkFBZ0I7WUFWaEIsd0JBQXdCOzRDQXlCNUIsTUFBTSxTQUFDLFFBQVEsY0FDZixRQUFROztBQXVFYixNQUFNLFVBQVUsb0JBQW9CLENBQUMsTUFBMEI7SUFDN0QsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN2QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBDb21wb25lbnRSZWYsIEluamVjdGFibGUsIFN0YXRpY1Byb3ZpZGVyLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEl0ZW1Nb2RlbCB9IGZyb20gJy4uLy4uL21vZGVscy9pdGVtLW1vZGVsJztcbmltcG9ydCB7IE9ic2VydmFibGVUcmVlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL29ic2VydmFibGUtdHJlZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSXRlbUxpZmVjeWNsZVNlcnZpY2UsIExpZmVjeWNsZUV2ZW50IH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL2l0ZW0tbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgTEFaWV9NQVAsIExhenlDb25maWcsIExhenlDb21wb25lbnRzQ29uZmlnIH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL2xhenktY29uZmlnJztcbmltcG9ydCB7IGNyZWF0ZUNvbXBvbmVudFBpcGUgfSBmcm9tICcuLi9waXBlcy9oYW5kbGVycy9jb21wb25lbnQnO1xuaW1wb3J0IHsgUGlwZWxpbmUsIFNpbmsgfSBmcm9tICcuLi9waXBlcy9waXBlbGluZS1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgUGlwZWxpbmVSZWdpc3RyeSB9IGZyb20gJy4uL3BpcGVzL3BpcGVsaW5lLXJlZ2lzdHJ5JztcbmltcG9ydCB7IFBpcGVsaW5lU2VydmljZSB9IGZyb20gJy4uL3BpcGVzL3BpcGVsaW5lLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ2V0UHJvY2Vzc29yTmFtZXMsIHBhcnNlUHJvcGVydGllcyB9IGZyb20gJy4vYnJva2VyLWhlbHBlcnMnO1xuXG4vKipcbiAqIFRoZSBpbnB1dCBicm9rZXIgc2VydmljZSBjcmVhdGVzIGEgY29tbXVuaWNhdGlvbiBwaXBlbGluZVxuICogdXNpbmcgdGhlIGNvbXBvbmVudCBpbnB1dCBhcyBhIHNpbmsuIFRoZSBzb3VyY2Ugb2YgdGhlIHBpcGVsaW5lXG4gKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBpdGVtIG1vZGVsLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSW5wdXRCcm9rZXJTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBpdGVtTGlmZWN5Y2xlOiBJdGVtTGlmZWN5Y2xlU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBpcGVsaW5lUmVnaXN0cnk6IFBpcGVsaW5lUmVnaXN0cnksXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBASW5qZWN0KExBWllfTUFQKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHJpdmF0ZSByZWFkb25seSBsYXp5Q29uZmlnOiBMYXp5Q29uZmlnIHwgbnVsbCxcbiAgKSB7fVxuXG4gIGJvb3RzdHJhcCgpIHtcbiAgICAvLyBNb2RlbCBwcm9wZXJ0aWVzIGNhbm5vdCBiZSBsaW5rZWQgdG8gdGhlIElucHV0cyBvZiBsYXp5IGxvYWRlZCBpdGVtc1xuICAgIGNvbnN0IGxhenlMb2FkZWRDb21wb25lbnRzID0gKHRoaXMubGF6eUNvbmZpZ1xuICAgICAgPyB0aGlzLmxhenlDb25maWcuZmlsdGVyKFxuICAgICAgICAgIChjb25maWcpOiBjb25maWcgaXMgTGF6eUNvbXBvbmVudHNDb25maWcgPT4gISEoY29uZmlnIGFzIExhenlDb21wb25lbnRzQ29uZmlnKS5jb21wb25lbnRzLFxuICAgICAgICApXG4gICAgICA6IFtdXG4gICAgKS5yZWR1Y2UoKGFjYywgY29uZmlnKSA9PiBbLi4uYWNjLCAuLi5jb25maWcuY29tcG9uZW50c10sIFtdIGFzIEFycmF5PHN0cmluZz4pO1xuXG4gICAgdGhpcy5pdGVtTGlmZWN5Y2xlLndoZW5DcmVhdGUoKS5zdWJzY3JpYmUoKHsgaXRlbU1vZGVsLCBjb21wb25lbnQgfSkgPT4ge1xuICAgICAgY29uc3QgZ2MkID0gdGhpcy5pdGVtTGlmZWN5Y2xlLndoZW5SZW1vdmUoaXRlbU1vZGVsLnZhbHVlLm5hbWUpLnBpcGUodGFrZSgxKSk7XG4gICAgICB0aGlzLnJ1bklucHV0UGlwZWxpbmVzKGl0ZW1Nb2RlbCwgY29tcG9uZW50LCBnYyQpO1xuICAgICAgaWYgKCFsYXp5TG9hZGVkQ29tcG9uZW50cy5pbmNsdWRlcyhpdGVtTW9kZWwudmFsdWUuybVjbGFzc0lkKSkge1xuICAgICAgICB0aGlzLnJ1bk1vZGVsSW5wdXRzKGl0ZW1Nb2RlbCwgY29tcG9uZW50LCBnYyQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBydW5Nb2RlbElucHV0czxDPihcbiAgICBpdGVtTW9kZWw6IE9ic2VydmFibGVUcmVlPEl0ZW1Nb2RlbD4sXG4gICAgcmVmOiBDb21wb25lbnRSZWY8Qz4sXG4gICAgZ2MkOiBPYnNlcnZhYmxlPExpZmVjeWNsZUV2ZW50PixcbiAgKSB7XG4gICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkocmVmLmNvbXBvbmVudFR5cGUpLmlucHV0cy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIC8vIEFib3J0IGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gXCJpbnB1dC5cIiBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWVcbiAgICAgIGlmIChpdGVtTW9kZWwudmFsdWUuybVpbnB1dFByb3BlcnRpZXNbaW5wdXQudGVtcGxhdGVOYW1lXSAhPT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICBjb25zdCBtb2RlbFZhbHVlID0gaXRlbU1vZGVsLnZhbHVlLsm1cHJvcGVydGllc1tpbnB1dC50ZW1wbGF0ZU5hbWVdO1xuICAgICAgaWYgKG1vZGVsVmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgY29uc3Qgc291cmNlID0gaXRlbU1vZGVsLnZhbHVlLnByb3BlcnR5KGlucHV0LnRlbXBsYXRlTmFtZSwgbW9kZWxWYWx1ZSk7XG4gICAgICBjb25zdCBzaW5rID0gdGhpcy5pbnB1dFNpbmsocmVmLCBpbnB1dC5wcm9wTmFtZSk7XG4gICAgICByZXR1cm4gc2luayhzb3VyY2UucGlwZSh0YWtlVW50aWwoZ2MkKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBydW5JbnB1dFBpcGVsaW5lczxDPihcbiAgICBpdGVtTW9kZWw6IE9ic2VydmFibGVUcmVlPEl0ZW1Nb2RlbD4sXG4gICAgcmVmOiBDb21wb25lbnRSZWY8Qz4sXG4gICAgZ2MkOiBPYnNlcnZhYmxlPExpZmVjeWNsZUV2ZW50PixcbiAgKSB7XG4gICAgY29uc3QgcGlwZWxpbmVTZXJ2aWNlID0gcmVmLmluamVjdG9yLmdldDxQaXBlbGluZVNlcnZpY2U+KFBpcGVsaW5lU2VydmljZSk7XG4gICAgcGFyc2VQcm9wZXJ0aWVzKGl0ZW1Nb2RlbC52YWx1ZS7JtWlucHV0UHJvcGVydGllcykuZm9yRWFjaChpbnB1dFBpcGVzQ29uZmlnID0+IHtcbiAgICAgIGNvbnN0IHNvdXJjZUNvbW1hbmQgPSBpbnB1dFBpcGVzQ29uZmlnLnBpcGVsaW5lO1xuICAgICAgY29uc3Qgc291cmNlRm4gPSBwaXBlbGluZVNlcnZpY2UuY3JlYXRlU291cmNlKHNvdXJjZUNvbW1hbmQucHJvY2Vzc29yTmFtZSwgc291cmNlQ29tbWFuZC5hcmdzKTtcbiAgICAgIGNvbnN0IHBpcGVsaW5lOiBQaXBlbGluZTxhbnk+ID0ge1xuICAgICAgICBzb3VyY2U6IHNvdXJjZUZuLFxuICAgICAgICBzaW5rOiB0aGlzLmlucHV0U2luazxDPihyZWYsIGlucHV0UGlwZXNDb25maWcucHJvcGVydHlOYW1lKSxcbiAgICAgIH07XG5cbiAgICAgIHBpcGVsaW5lU2VydmljZS5ydW5QaXBlbGluZShwaXBlbGluZSwgZ2MkKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgaW5wdXRTaW5rPEM+KHJlZjogQ29tcG9uZW50UmVmPEM+LCBpbnB1dE5hbWU6IHN0cmluZyk6IFNpbms8YW55PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudFBpcGUoKS5zaW5rKHJlZiwgaW5wdXROYW1lKTtcbiAgfVxuXG4gIGdldEl0ZW1Qcm92aWRlcnMoaXRlbTogSXRlbU1vZGVsKTogQXJyYXk8U3RhdGljUHJvdmlkZXI+IHtcbiAgICByZXR1cm4gZ2V0UHJvY2Vzc29yTmFtZXMoaXRlbS7JtWlucHV0UHJvcGVydGllcykubWFwKHByb2Nlc3Nvck5hbWUgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlwZWxpbmVSZWdpc3RyeS5nZXRQcm9jZXNzb3JQcm92aWRlcihwcm9jZXNzb3JOYW1lKTtcbiAgICAgIH0gY2F0Y2ggKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnJHtwcm9jZXNzb3JOYW1lfScgb24gJHtpdGVtLm5hbWV9IGlzIG1pc2NvbmZpZ3VyZWQuICR7bWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5wdXRCb290c3RyYXAoQnJva2VyOiBJbnB1dEJyb2tlclNlcnZpY2UpIHtcbiAgcmV0dXJuIEJyb2tlci5ib290c3RyYXAuYmluZChCcm9rZXIpO1xufVxuIl19