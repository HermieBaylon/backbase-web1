import { Injectable } from '@angular/core';
import { take } from 'rxjs/operators';
import { ItemLifecycleService } from '../../rendering/item-lifecycle.service';
import { createComponentPipe } from '../pipes/handlers/component';
import { PipelineRegistry } from '../pipes/pipeline-registry';
import { PipelineService } from '../pipes/pipeline.service';
import { getProcessorNames, parseProperties } from './broker-helpers';
/**
 * The output broker service creates a communication pipeline
 * using the component output as a source. The sink of the pipeline
 * is determined by the item model.
 */
export class OutputBrokerService {
    constructor(itemLifecycle, pipelineRegistry) {
        this.itemLifecycle = itemLifecycle;
        this.pipelineRegistry = pipelineRegistry;
    }
    bootstrap() {
        this.itemLifecycle.whenCreate().subscribe(({ itemModel, component }) => {
            const gc$ = this.itemLifecycle.whenRemove(itemModel.value.name).pipe(take(1));
            this.runOutputPipelines(itemModel, component, gc$);
        });
    }
    runOutputPipelines(itemModel, ref, gc$) {
        const pipelineService = ref.injector.get(PipelineService);
        parseProperties(itemModel.value.ɵoutputProperties).forEach(outputPipesConfig => {
            const sinkCommand = outputPipesConfig.pipeline;
            const sinkFn = pipelineService.createSink(sinkCommand.processorName, sinkCommand.args);
            const pipeline = {
                source: this.outputSource(ref, outputPipesConfig.propertyName),
                sink: sinkFn,
            };
            if (!pipeline.source()) {
                throw new Error(`${ref.componentType.name} does not have an output named '${outputPipesConfig.propertyName}'`);
            }
            pipelineService.runPipeline(pipeline, gc$);
        });
    }
    outputSource(ref, outputName) {
        return createComponentPipe().source(ref, outputName);
    }
    getItemProviders(item) {
        return getProcessorNames(item.ɵoutputProperties).map(processorName => {
            try {
                return this.pipelineRegistry.getProcessorProvider(processorName);
            }
            catch (message) {
                throw new Error(`Output '${processorName}' on ${item.name} is misconfigured. ${message}`);
            }
        });
    }
}
OutputBrokerService.decorators = [
    { type: Injectable }
];
OutputBrokerService.ctorParameters = () => [
    { type: ItemLifecycleService },
    { type: PipelineRegistry }
];
export function createOutputBootstrap(outputBroker) {
    return outputBroker.bootstrap.bind(outputBroker);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0cHV0LWJyb2tlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYmFja2Jhc2UvZm91bmRhdGlvbi1hbmcvY29yZS9zcmMvYmFja2Jhc2UtY29yZS9jb21tdW5pY2F0aW9uL2l0ZW0taW8vb3V0cHV0LWJyb2tlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBZ0IsVUFBVSxFQUFrQixNQUFNLGVBQWUsQ0FBQztBQUV6RSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFJdEMsT0FBTyxFQUFFLG9CQUFvQixFQUFrQixNQUFNLHdDQUF3QyxDQUFDO0FBQzlGLE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRWxFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzlELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFdEU7Ozs7R0FJRztBQUVILE1BQU0sT0FBTyxtQkFBbUI7SUFDOUIsWUFDbUIsYUFBbUMsRUFDbkMsZ0JBQWtDO1FBRGxDLGtCQUFhLEdBQWIsYUFBYSxDQUFzQjtRQUNuQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO0lBQ2xELENBQUM7SUFFSixTQUFTO1FBQ1AsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsRUFBRSxFQUFFO1lBQ3JFLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQzlFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ3JELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLGtCQUFrQixDQUN4QixTQUFvQyxFQUNwQyxHQUFvQixFQUNwQixHQUErQjtRQUUvQixNQUFNLGVBQWUsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBa0IsZUFBZSxDQUFDLENBQUM7UUFDM0UsZUFBZSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsRUFBRTtZQUM3RSxNQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUM7WUFDL0MsTUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN2RixNQUFNLFFBQVEsR0FBa0I7Z0JBQzlCLE1BQU0sRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFJLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxZQUFZLENBQUM7Z0JBQ2pFLElBQUksRUFBRSxNQUFNO2FBQ2IsQ0FBQztZQUVGLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksbUNBQW1DLGlCQUFpQixDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7YUFDaEg7WUFFRCxlQUFlLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM3QyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxZQUFZLENBQUksR0FBb0IsRUFBRSxVQUFrQjtRQUM5RCxPQUFPLG1CQUFtQixFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsSUFBZTtRQUM5QixPQUFPLGlCQUFpQixDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUNuRSxJQUFJO2dCQUNGLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ2xFO1lBQUMsT0FBTyxPQUFPLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsV0FBVyxhQUFhLFFBQVEsSUFBSSxDQUFDLElBQUksc0JBQXNCLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDM0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7OztZQWhERixVQUFVOzs7WUFaRixvQkFBb0I7WUFHcEIsZ0JBQWdCOztBQTREekIsTUFBTSxVQUFVLHFCQUFxQixDQUFDLFlBQWlDO0lBQ3JFLE9BQU8sWUFBWSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDbkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudFJlZiwgSW5qZWN0YWJsZSwgU3RhdGljUHJvdmlkZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IEl0ZW1Nb2RlbCB9IGZyb20gJy4uLy4uL21vZGVscy9pdGVtLW1vZGVsJztcbmltcG9ydCB7IE9ic2VydmFibGVUcmVlIH0gZnJvbSAnLi4vLi4vbW9kZWxzL29ic2VydmFibGUtdHJlZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSXRlbUxpZmVjeWNsZVNlcnZpY2UsIExpZmVjeWNsZUV2ZW50IH0gZnJvbSAnLi4vLi4vcmVuZGVyaW5nL2l0ZW0tbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHsgY3JlYXRlQ29tcG9uZW50UGlwZSB9IGZyb20gJy4uL3BpcGVzL2hhbmRsZXJzL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBQaXBlbGluZSwgU291cmNlIH0gZnJvbSAnLi4vcGlwZXMvcGlwZWxpbmUtaW50ZXJmYWNlJztcbmltcG9ydCB7IFBpcGVsaW5lUmVnaXN0cnkgfSBmcm9tICcuLi9waXBlcy9waXBlbGluZS1yZWdpc3RyeSc7XG5pbXBvcnQgeyBQaXBlbGluZVNlcnZpY2UgfSBmcm9tICcuLi9waXBlcy9waXBlbGluZS5zZXJ2aWNlJztcbmltcG9ydCB7IGdldFByb2Nlc3Nvck5hbWVzLCBwYXJzZVByb3BlcnRpZXMgfSBmcm9tICcuL2Jyb2tlci1oZWxwZXJzJztcblxuLyoqXG4gKiBUaGUgb3V0cHV0IGJyb2tlciBzZXJ2aWNlIGNyZWF0ZXMgYSBjb21tdW5pY2F0aW9uIHBpcGVsaW5lXG4gKiB1c2luZyB0aGUgY29tcG9uZW50IG91dHB1dCBhcyBhIHNvdXJjZS4gVGhlIHNpbmsgb2YgdGhlIHBpcGVsaW5lXG4gKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBpdGVtIG1vZGVsLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgT3V0cHV0QnJva2VyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaXRlbUxpZmVjeWNsZTogSXRlbUxpZmVjeWNsZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwaXBlbGluZVJlZ2lzdHJ5OiBQaXBlbGluZVJlZ2lzdHJ5LFxuICApIHt9XG5cbiAgYm9vdHN0cmFwKCkge1xuICAgIHRoaXMuaXRlbUxpZmVjeWNsZS53aGVuQ3JlYXRlKCkuc3Vic2NyaWJlKCh7IGl0ZW1Nb2RlbCwgY29tcG9uZW50IH0pID0+IHtcbiAgICAgIGNvbnN0IGdjJCA9IHRoaXMuaXRlbUxpZmVjeWNsZS53aGVuUmVtb3ZlKGl0ZW1Nb2RlbC52YWx1ZS5uYW1lKS5waXBlKHRha2UoMSkpO1xuICAgICAgdGhpcy5ydW5PdXRwdXRQaXBlbGluZXMoaXRlbU1vZGVsLCBjb21wb25lbnQsIGdjJCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHJ1bk91dHB1dFBpcGVsaW5lczxDPihcbiAgICBpdGVtTW9kZWw6IE9ic2VydmFibGVUcmVlPEl0ZW1Nb2RlbD4sXG4gICAgcmVmOiBDb21wb25lbnRSZWY8Qz4sXG4gICAgZ2MkOiBPYnNlcnZhYmxlPExpZmVjeWNsZUV2ZW50PixcbiAgKSB7XG4gICAgY29uc3QgcGlwZWxpbmVTZXJ2aWNlID0gcmVmLmluamVjdG9yLmdldDxQaXBlbGluZVNlcnZpY2U+KFBpcGVsaW5lU2VydmljZSk7XG4gICAgcGFyc2VQcm9wZXJ0aWVzKGl0ZW1Nb2RlbC52YWx1ZS7JtW91dHB1dFByb3BlcnRpZXMpLmZvckVhY2gob3V0cHV0UGlwZXNDb25maWcgPT4ge1xuICAgICAgY29uc3Qgc2lua0NvbW1hbmQgPSBvdXRwdXRQaXBlc0NvbmZpZy5waXBlbGluZTtcbiAgICAgIGNvbnN0IHNpbmtGbiA9IHBpcGVsaW5lU2VydmljZS5jcmVhdGVTaW5rKHNpbmtDb21tYW5kLnByb2Nlc3Nvck5hbWUsIHNpbmtDb21tYW5kLmFyZ3MpO1xuICAgICAgY29uc3QgcGlwZWxpbmU6IFBpcGVsaW5lPGFueT4gPSB7XG4gICAgICAgIHNvdXJjZTogdGhpcy5vdXRwdXRTb3VyY2U8Qz4ocmVmLCBvdXRwdXRQaXBlc0NvbmZpZy5wcm9wZXJ0eU5hbWUpLFxuICAgICAgICBzaW5rOiBzaW5rRm4sXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXBpcGVsaW5lLnNvdXJjZSgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWYuY29tcG9uZW50VHlwZS5uYW1lfSBkb2VzIG5vdCBoYXZlIGFuIG91dHB1dCBuYW1lZCAnJHtvdXRwdXRQaXBlc0NvbmZpZy5wcm9wZXJ0eU5hbWV9J2ApO1xuICAgICAgfVxuXG4gICAgICBwaXBlbGluZVNlcnZpY2UucnVuUGlwZWxpbmUocGlwZWxpbmUsIGdjJCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG91dHB1dFNvdXJjZTxDPihyZWY6IENvbXBvbmVudFJlZjxDPiwgb3V0cHV0TmFtZTogc3RyaW5nKTogU291cmNlPGFueT4ge1xuICAgIHJldHVybiBjcmVhdGVDb21wb25lbnRQaXBlKCkuc291cmNlKHJlZiwgb3V0cHV0TmFtZSk7XG4gIH1cblxuICBnZXRJdGVtUHJvdmlkZXJzKGl0ZW06IEl0ZW1Nb2RlbCk6IEFycmF5PFN0YXRpY1Byb3ZpZGVyPiB7XG4gICAgcmV0dXJuIGdldFByb2Nlc3Nvck5hbWVzKGl0ZW0uybVvdXRwdXRQcm9wZXJ0aWVzKS5tYXAocHJvY2Vzc29yTmFtZSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5waXBlbGluZVJlZ2lzdHJ5LmdldFByb2Nlc3NvclByb3ZpZGVyKHByb2Nlc3Nvck5hbWUpO1xuICAgICAgfSBjYXRjaCAobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCAnJHtwcm9jZXNzb3JOYW1lfScgb24gJHtpdGVtLm5hbWV9IGlzIG1pc2NvbmZpZ3VyZWQuICR7bWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3V0cHV0Qm9vdHN0cmFwKG91dHB1dEJyb2tlcjogT3V0cHV0QnJva2VyU2VydmljZSkge1xuICByZXR1cm4gb3V0cHV0QnJva2VyLmJvb3RzdHJhcC5iaW5kKG91dHB1dEJyb2tlcik7XG59XG4iXX0=