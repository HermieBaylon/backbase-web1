import { Injectable, InjectionToken, Inject, Optional } from '@angular/core';
import { LOG_DEPRECATIONS_CONFIG } from './deprecations.service';
import { AVAILABLE_FEATURES_CONFIG, FutureFeaturesModule, } from './future.module';
import * as i0 from "@angular/core";
import * as i1 from "./future.module";
import * as i2 from "./deprecations.service";
// @todo: separate util package that can be shared across entry points?
const flatten = (arr) => arr.reduce((acc, a) => [...acc, ...a], []);
const ɵ0 = flatten;
/**
 * @deprecated Will be removed in v7.0.0
 */
export const ENABLED_FEATURES_CONFIG = new InjectionToken('@backbase/foundation Enabled Feature Flags Configuration');
/**
 * @deprecated Will be removed in v7.0.0
 * @usageNotes
 *
 * ### Example
 *
 * Create a Feature Flag in the module that implements/uses it
 *
 * ```
 * export const FEATURE_EXAMPLE: AvailableFeature = {
 *  name: 'EXAMPLE',
 *  description: 'Describe the feature that will be enabled by this flag',
 * };
 * ```
 *
 * Check if the application has opted into the Feature Flag
 *
 * ```
 * if (featuresService.isEnabled(FEATURE_EXAMPLE)) {
 *   // Use new feature
 *   …
 * }
 * ```
 *
 * Make the feature flag available from the module that implements/uses it
 *
 * ```
 * @NgModule({
 *   imports: [
 *     FutureFeaturesModule.allowOptIn([FEATURE_EXAMPLE]),
 *     …
 *   ],
 *   …
 * })
 * export class MyModule {
 *   …
 * }
 * ```
 *
 * In the application, opt in to the new feature (and enable logging of configuration issues)
 *
 * ```
 * @NgModule({
 *   imports: [
 *     BackbaseCoreModule.forRoot({
 *       logDeprecations: true,
 *       features: {
 *          FEATURE_EXAMPLE: true,
 *       },
 *       …
 *     }),
 *     …
 *   ],
 *   …
 * })
 * export class AppModule {
 *   …
 * }
 * ```
 */
export class FeaturesService {
    constructor(availableConfigs, enabledConfigOrNull, logDeprecations) {
        this.logDeprecations = !!logDeprecations;
        const availableConfig = flatten(availableConfigs || []);
        const available = new Set(availableConfig.map(feature => feature.name));
        const enabledConfig = enabledConfigOrNull || {};
        this.enabled = new Map(Array.from(available.values()).map(token => [token, false]));
        Object.entries(enabledConfig).forEach(([name, enabled]) => {
            if (available.has(name)) {
                this.enabled.set(name, enabled);
            }
        });
        if (this.logDeprecations) {
            this.logConfigurationErrors(availableConfig, enabledConfig);
        }
    }
    isEnabled(feature) {
        const enabled = this.enabled.get(feature.name);
        if (enabled !== undefined) {
            return enabled;
        }
        throw new Error(`[FEATURE] Using unknown feature: ${feature.name}: ${feature.description}\nYou probably need to add it to the modules provided features.`);
    }
    logConfigurationErrors(availableConfig, enabledConfig) {
        const unconfiguredFeatures = availableConfig.filter(feature => enabledConfig[feature.name] === undefined);
        if (unconfiguredFeatures.length) {
            const unconfiguredFeaturesList = unconfiguredFeatures
                .map(feature => `${feature.name}: ${feature.description}`)
                .join('\n - ');
            console.warn('[DEPRECATED]', `Unconfigured features available:
          \n - ${unconfiguredFeaturesList}
          \nYou should opt-in to them in the App module as they will likely become defaults in the next major release.`);
        }
    }
}
FeaturesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FeaturesService_Factory() { return new FeaturesService(i0.ɵɵinject(i1.AVAILABLE_FEATURES_CONFIG, 8), i0.ɵɵinject(ENABLED_FEATURES_CONFIG, 8), i0.ɵɵinject(i2.LOG_DEPRECATIONS_CONFIG, 8)); }, token: FeaturesService, providedIn: i1.FutureFeaturesModule });
FeaturesService.decorators = [
    { type: Injectable, args: [{
                providedIn: FutureFeaturesModule,
            },] }
];
FeaturesService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [AVAILABLE_FEATURES_CONFIG,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ENABLED_FEATURES_CONFIG,] }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [LOG_DEPRECATIONS_CONFIG,] }] }
];
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmVhdHVyZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2Z1dHVyZS9zcmMvZmVhdHVyZXMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ2pFLE9BQU8sRUFHTCx5QkFBeUIsRUFDekIsb0JBQW9CLEdBQ3JCLE1BQU0saUJBQWlCLENBQUM7Ozs7QUFFekIsdUVBQXVFO0FBQ3ZFLE1BQU0sT0FBTyxHQUFHLENBQUksR0FBb0IsRUFBWSxFQUFFLENBQ3BELEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFhLEVBQUUsQ0FBVyxFQUFZLEVBQUUsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBYyxDQUFDLENBQUM7O0FBU3ZGOztHQUVHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sdUJBQXVCLEdBQUcsSUFBSSxjQUFjLENBQ3ZELDBEQUEwRCxDQUMzRCxDQUFDO0FBRUY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkRHO0FBSUgsTUFBTSxPQUFPLGVBQWU7SUFHMUIsWUFHRSxnQkFBdUQsRUFHdkQsbUJBQWlELEVBR2pELGVBQStCO1FBRS9CLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLGVBQWUsQ0FBQztRQUN6QyxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsZ0JBQWdCLElBQUksRUFBRSxDQUFDLENBQUM7UUFDeEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxHQUFHLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3hFLE1BQU0sYUFBYSxHQUFHLG1CQUFtQixJQUFJLEVBQUUsQ0FBQztRQUVoRCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksR0FBRyxDQUNwQixLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBb0IsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUMvRSxDQUFDO1FBQ0YsTUFBTSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFO1lBQ3hELElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ2pDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDeEIsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGVBQWUsRUFBRSxhQUFhLENBQUMsQ0FBQztTQUM3RDtJQUNILENBQUM7SUFFRCxTQUFTLENBQUMsT0FBeUI7UUFDakMsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtZQUN6QixPQUFPLE9BQU8sQ0FBQztTQUNoQjtRQUVELE1BQU0sSUFBSSxLQUFLLENBQ2Isb0NBQW9DLE9BQU8sQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLFdBQVcsaUVBQWlFLENBQzFJLENBQUM7SUFDSixDQUFDO0lBRU8sc0JBQXNCLENBQUMsZUFBd0MsRUFBRSxhQUFvQztRQUMzRyxNQUFNLG9CQUFvQixHQUE0QixlQUFlLENBQUMsTUFBTSxDQUMxRSxPQUFPLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssU0FBUyxDQUNyRCxDQUFDO1FBQ0YsSUFBSSxvQkFBb0IsQ0FBQyxNQUFNLEVBQUU7WUFDL0IsTUFBTSx3QkFBd0IsR0FBRyxvQkFBb0I7aUJBQ2xELEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksS0FBSyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7aUJBQ3pELElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqQixPQUFPLENBQUMsSUFBSSxDQUNWLGNBQWMsRUFDZDtpQkFDUyx3QkFBd0I7dUhBQzhFLENBQ2hILENBQUM7U0FDSDtJQUNILENBQUM7Ozs7WUE5REYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxvQkFBb0I7YUFDakM7OztZQU9xQixLQUFLLHVCQUZ0QixRQUFRLFlBQ1IsTUFBTSxTQUFDLHlCQUF5Qjs0Q0FFaEMsUUFBUSxZQUNSLE1BQU0sU0FBQyx1QkFBdUI7MENBRTlCLFFBQVEsWUFDUixNQUFNLFNBQUMsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExPR19ERVBSRUNBVElPTlNfQ09ORklHIH0gZnJvbSAnLi9kZXByZWNhdGlvbnMuc2VydmljZSc7XG5pbXBvcnQge1xuICBBdmFpbGFibGVGZWF0dXJlLFxuICBBdmFpbGFibGVGZWF0dXJlc0NvbmZpZyxcbiAgQVZBSUxBQkxFX0ZFQVRVUkVTX0NPTkZJRyxcbiAgRnV0dXJlRmVhdHVyZXNNb2R1bGUsXG59IGZyb20gJy4vZnV0dXJlLm1vZHVsZSc7XG5cbi8vIEB0b2RvOiBzZXBhcmF0ZSB1dGlsIHBhY2thZ2UgdGhhdCBjYW4gYmUgc2hhcmVkIGFjcm9zcyBlbnRyeSBwb2ludHM/XG5jb25zdCBmbGF0dGVuID0gPFQ+KGFycjogQXJyYXk8QXJyYXk8VD4+KTogQXJyYXk8VD4gPT5cbiAgYXJyLnJlZHVjZSgoYWNjOiBBcnJheTxUPiwgYTogQXJyYXk8VD4pOiBBcnJheTxUPiA9PiBbLi4uYWNjLCAuLi5hXSwgW10gYXMgQXJyYXk8VD4pO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4wLjBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbmFibGVkRmVhdHVyZXNDb25maWcge1xuICBbZmVhdHVyZTogc3RyaW5nXTogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKi9cbmV4cG9ydCBjb25zdCBFTkFCTEVEX0ZFQVRVUkVTX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxFbmFibGVkRmVhdHVyZXNDb25maWc+KFxuICAnQGJhY2tiYXNlL2ZvdW5kYXRpb24gRW5hYmxlZCBGZWF0dXJlIEZsYWdzIENvbmZpZ3VyYXRpb24nLFxuKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjcuMC4wXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogQ3JlYXRlIGEgRmVhdHVyZSBGbGFnIGluIHRoZSBtb2R1bGUgdGhhdCBpbXBsZW1lbnRzL3VzZXMgaXRcbiAqXG4gKiBgYGBcbiAqIGV4cG9ydCBjb25zdCBGRUFUVVJFX0VYQU1QTEU6IEF2YWlsYWJsZUZlYXR1cmUgPSB7XG4gKiAgbmFtZTogJ0VYQU1QTEUnLFxuICogIGRlc2NyaXB0aW9uOiAnRGVzY3JpYmUgdGhlIGZlYXR1cmUgdGhhdCB3aWxsIGJlIGVuYWJsZWQgYnkgdGhpcyBmbGFnJyxcbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBDaGVjayBpZiB0aGUgYXBwbGljYXRpb24gaGFzIG9wdGVkIGludG8gdGhlIEZlYXR1cmUgRmxhZ1xuICpcbiAqIGBgYFxuICogaWYgKGZlYXR1cmVzU2VydmljZS5pc0VuYWJsZWQoRkVBVFVSRV9FWEFNUExFKSkge1xuICogICAvLyBVc2UgbmV3IGZlYXR1cmVcbiAqICAg4oCmXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBNYWtlIHRoZSBmZWF0dXJlIGZsYWcgYXZhaWxhYmxlIGZyb20gdGhlIG1vZHVsZSB0aGF0IGltcGxlbWVudHMvdXNlcyBpdFxuICpcbiAqIGBgYFxuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIEZ1dHVyZUZlYXR1cmVzTW9kdWxlLmFsbG93T3B0SW4oW0ZFQVRVUkVfRVhBTVBMRV0pLFxuICogICAgIOKAplxuICogICBdLFxuICogICDigKZcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgTXlNb2R1bGUge1xuICogICDigKZcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEluIHRoZSBhcHBsaWNhdGlvbiwgb3B0IGluIHRvIHRoZSBuZXcgZmVhdHVyZSAoYW5kIGVuYWJsZSBsb2dnaW5nIG9mIGNvbmZpZ3VyYXRpb24gaXNzdWVzKVxuICpcbiAqIGBgYFxuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIEJhY2tiYXNlQ29yZU1vZHVsZS5mb3JSb290KHtcbiAqICAgICAgIGxvZ0RlcHJlY2F0aW9uczogdHJ1ZSxcbiAqICAgICAgIGZlYXR1cmVzOiB7XG4gKiAgICAgICAgICBGRUFUVVJFX0VYQU1QTEU6IHRydWUsXG4gKiAgICAgICB9LFxuICogICAgICAg4oCmXG4gKiAgICAgfSksXG4gKiAgICAg4oCmXG4gKiAgIF0sXG4gKiAgIOKAplxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICogICDigKZcbiAqIH1cbiAqIGBgYFxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46IEZ1dHVyZUZlYXR1cmVzTW9kdWxlLFxufSlcbmV4cG9ydCBjbGFzcyBGZWF0dXJlc1NlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IGVuYWJsZWQ6IE1hcDxzdHJpbmcsIGJvb2xlYW4+O1xuICBwcml2YXRlIHJlYWRvbmx5IGxvZ0RlcHJlY2F0aW9uczogYm9vbGVhbjtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KEFWQUlMQUJMRV9GRUFUVVJFU19DT05GSUcpXG4gICAgYXZhaWxhYmxlQ29uZmlnczogQXJyYXk8QXZhaWxhYmxlRmVhdHVyZXNDb25maWc+IHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoRU5BQkxFRF9GRUFUVVJFU19DT05GSUcpXG4gICAgZW5hYmxlZENvbmZpZ09yTnVsbDogRW5hYmxlZEZlYXR1cmVzQ29uZmlnIHwgbnVsbCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoTE9HX0RFUFJFQ0FUSU9OU19DT05GSUcpXG4gICAgbG9nRGVwcmVjYXRpb25zOiBib29sZWFuIHwgbnVsbCxcbiAgKSB7XG4gICAgdGhpcy5sb2dEZXByZWNhdGlvbnMgPSAhIWxvZ0RlcHJlY2F0aW9ucztcbiAgICBjb25zdCBhdmFpbGFibGVDb25maWcgPSBmbGF0dGVuKGF2YWlsYWJsZUNvbmZpZ3MgfHwgW10pO1xuICAgIGNvbnN0IGF2YWlsYWJsZSA9IG5ldyBTZXQoYXZhaWxhYmxlQ29uZmlnLm1hcChmZWF0dXJlID0+IGZlYXR1cmUubmFtZSkpO1xuICAgIGNvbnN0IGVuYWJsZWRDb25maWcgPSBlbmFibGVkQ29uZmlnT3JOdWxsIHx8IHt9O1xuXG4gICAgdGhpcy5lbmFibGVkID0gbmV3IE1hcChcbiAgICAgIEFycmF5LmZyb20oYXZhaWxhYmxlLnZhbHVlcygpKS5tYXA8W3N0cmluZywgYm9vbGVhbl0+KHRva2VuID0+IFt0b2tlbiwgZmFsc2VdKSxcbiAgICApO1xuICAgIE9iamVjdC5lbnRyaWVzKGVuYWJsZWRDb25maWcpLmZvckVhY2goKFtuYW1lLCBlbmFibGVkXSkgPT4ge1xuICAgICAgaWYgKGF2YWlsYWJsZS5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkLnNldChuYW1lLCBlbmFibGVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmxvZ0RlcHJlY2F0aW9ucykge1xuICAgICAgdGhpcy5sb2dDb25maWd1cmF0aW9uRXJyb3JzKGF2YWlsYWJsZUNvbmZpZywgZW5hYmxlZENvbmZpZyk7XG4gICAgfVxuICB9XG5cbiAgaXNFbmFibGVkKGZlYXR1cmU6IEF2YWlsYWJsZUZlYXR1cmUpOiBib29sZWFuIHtcbiAgICBjb25zdCBlbmFibGVkID0gdGhpcy5lbmFibGVkLmdldChmZWF0dXJlLm5hbWUpO1xuICAgIGlmIChlbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBlbmFibGVkO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBbRkVBVFVSRV0gVXNpbmcgdW5rbm93biBmZWF0dXJlOiAke2ZlYXR1cmUubmFtZX06ICR7ZmVhdHVyZS5kZXNjcmlwdGlvbn1cXG5Zb3UgcHJvYmFibHkgbmVlZCB0byBhZGQgaXQgdG8gdGhlIG1vZHVsZXMgcHJvdmlkZWQgZmVhdHVyZXMuYCxcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2dDb25maWd1cmF0aW9uRXJyb3JzKGF2YWlsYWJsZUNvbmZpZzogQXZhaWxhYmxlRmVhdHVyZXNDb25maWcsIGVuYWJsZWRDb25maWc6IEVuYWJsZWRGZWF0dXJlc0NvbmZpZyk6IHZvaWQge1xuICAgIGNvbnN0IHVuY29uZmlndXJlZEZlYXR1cmVzOiBBcnJheTxBdmFpbGFibGVGZWF0dXJlPiA9IGF2YWlsYWJsZUNvbmZpZy5maWx0ZXIoXG4gICAgICBmZWF0dXJlID0+IGVuYWJsZWRDb25maWdbZmVhdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkLFxuICAgICk7XG4gICAgaWYgKHVuY29uZmlndXJlZEZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdW5jb25maWd1cmVkRmVhdHVyZXNMaXN0ID0gdW5jb25maWd1cmVkRmVhdHVyZXNcbiAgICAgICAgLm1hcChmZWF0dXJlID0+IGAke2ZlYXR1cmUubmFtZX06ICR7ZmVhdHVyZS5kZXNjcmlwdGlvbn1gKVxuICAgICAgICAuam9pbignXFxuIC0gJyk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdbREVQUkVDQVRFRF0nLFxuICAgICAgICBgVW5jb25maWd1cmVkIGZlYXR1cmVzIGF2YWlsYWJsZTpcbiAgICAgICAgICBcXG4gLSAke3VuY29uZmlndXJlZEZlYXR1cmVzTGlzdH1cbiAgICAgICAgICBcXG5Zb3Ugc2hvdWxkIG9wdC1pbiB0byB0aGVtIGluIHRoZSBBcHAgbW9kdWxlIGFzIHRoZXkgd2lsbCBsaWtlbHkgYmVjb21lIGRlZmF1bHRzIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuYCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=