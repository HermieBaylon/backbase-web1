import { Inject, Injectable } from '@angular/core';
import { DOCUMENT, Location } from '@angular/common';
import { take, tap } from 'rxjs/operators';
import { AuthService } from './auth.service';
import * as i0 from "@angular/core";
import * as i1 from "./auth.service";
import * as i2 from "@angular/common";
/**
 * @deprecated Will be removed in v7.0.0
 */
export class AuthGuard {
    constructor(auth, location, document) {
        this.auth = auth;
        this.location = location;
        this.document = document;
    }
    canLoad() {
        return this.auth.isAuthenticated.pipe(take(1));
    }
    canActivate() {
        return this.redirectIfUnauthenticated();
    }
    canActivateChild() {
        return this.redirectIfUnauthenticated();
    }
    redirectIfUnauthenticated() {
        return this.auth.isAuthenticated.pipe(tap(loggedIn => {
            if (!loggedIn) {
                // Use an actual location path with hash instead of `RouterStateSnapshot.url`
                // because `Keycloak` uses `history.replaceState` on initialization to remove
                // auth data from the path.
                const actualPath = this.location.path(true);
                this.auth.login({
                    redirectUri: this.document.location.origin + this.location.prepareExternalUrl(actualPath),
                });
            }
        }));
    }
}
AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(i1.AuthService), i0.ɵɵinject(i2.Location), i0.ɵɵinject(i2.DOCUMENT)); }, token: AuthGuard, providedIn: "root" });
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
AuthGuard.ctorParameters = () => [
    { type: AuthService },
    { type: Location },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5ndWFyZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2JhY2tiYXNlL2ZvdW5kYXRpb24tYW5nL2F1dGgvc3JjL2RlcHJlY2F0ZWQvYXV0aC5ndWFyZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBR3JELE9BQU8sRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBRTdDOztHQUVHO0FBSUgsTUFBTSxPQUFPLFNBQVM7SUFDcEIsWUFBb0IsSUFBaUIsRUFBVSxRQUFrQixFQUE0QixRQUFhO1FBQXRGLFNBQUksR0FBSixJQUFJLENBQWE7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQTRCLGFBQVEsR0FBUixRQUFRLENBQUs7SUFBRyxDQUFDO0lBRTlHLE9BQU87UUFDTCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUVELGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7SUFDMUMsQ0FBQztJQUVPLHlCQUF5QjtRQUMvQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FDbkMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ2IsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDYiw2RUFBNkU7Z0JBQzdFLDZFQUE2RTtnQkFDN0UsMkJBQTJCO2dCQUMzQixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFFNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7b0JBQ2QsV0FBVyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQztpQkFDMUYsQ0FBQyxDQUFDO2FBQ0o7UUFDSCxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQzs7OztZQWpDRixVQUFVLFNBQUM7Z0JBQ1YsVUFBVSxFQUFFLE1BQU07YUFDbkI7OztZQVBRLFdBQVc7WUFKRCxRQUFROzRDQWEyQyxNQUFNLFNBQUMsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQsIExvY2F0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IENhbkFjdGl2YXRlLCBDYW5BY3RpdmF0ZUNoaWxkLCBDYW5Mb2FkIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2UsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEF1dGhTZXJ2aWNlIH0gZnJvbSAnLi9hdXRoLnNlcnZpY2UnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2Ny4wLjBcbiAqL1xuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEF1dGhHdWFyZCBpbXBsZW1lbnRzIENhbkFjdGl2YXRlLCBDYW5Mb2FkLCBDYW5BY3RpdmF0ZUNoaWxkIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoOiBBdXRoU2VydmljZSwgcHJpdmF0ZSBsb2NhdGlvbjogTG9jYXRpb24sIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgZG9jdW1lbnQ6IGFueSkge31cblxuICBjYW5Mb2FkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLmF1dGguaXNBdXRoZW50aWNhdGVkLnBpcGUodGFrZSgxKSk7XG4gIH1cblxuICBjYW5BY3RpdmF0ZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5yZWRpcmVjdElmVW5hdXRoZW50aWNhdGVkKCk7XG4gIH1cblxuICBjYW5BY3RpdmF0ZUNoaWxkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnJlZGlyZWN0SWZVbmF1dGhlbnRpY2F0ZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVkaXJlY3RJZlVuYXV0aGVudGljYXRlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5hdXRoLmlzQXV0aGVudGljYXRlZC5waXBlKFxuICAgICAgdGFwKGxvZ2dlZEluID0+IHtcbiAgICAgICAgaWYgKCFsb2dnZWRJbikge1xuICAgICAgICAgIC8vIFVzZSBhbiBhY3R1YWwgbG9jYXRpb24gcGF0aCB3aXRoIGhhc2ggaW5zdGVhZCBvZiBgUm91dGVyU3RhdGVTbmFwc2hvdC51cmxgXG4gICAgICAgICAgLy8gYmVjYXVzZSBgS2V5Y2xvYWtgIHVzZXMgYGhpc3RvcnkucmVwbGFjZVN0YXRlYCBvbiBpbml0aWFsaXphdGlvbiB0byByZW1vdmVcbiAgICAgICAgICAvLyBhdXRoIGRhdGEgZnJvbSB0aGUgcGF0aC5cbiAgICAgICAgICBjb25zdCBhY3R1YWxQYXRoID0gdGhpcy5sb2NhdGlvbi5wYXRoKHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5hdXRoLmxvZ2luKHtcbiAgICAgICAgICAgIHJlZGlyZWN0VXJpOiB0aGlzLmRvY3VtZW50LmxvY2F0aW9uLm9yaWdpbiArIHRoaXMubG9jYXRpb24ucHJlcGFyZUV4dGVybmFsVXJsKGFjdHVhbFBhdGgpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICApO1xuICB9XG59XG4iXX0=