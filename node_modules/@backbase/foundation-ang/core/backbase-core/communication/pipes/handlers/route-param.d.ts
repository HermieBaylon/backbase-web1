import { ActivatedRoute } from '@angular/router';
import { Observable } from 'rxjs';
import { ӨRootContainerService } from '../../../models/root-container.service';
import { ӨItemNavigationService } from '../../item-navigation.service';
import { PipelineSink, PipelineSource, Sink, Source } from '../pipeline-interface';
import { PipelineProcessorConfig } from '../pipeline-registry';
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface RouteParams {
    [key: string]: any;
}
/**
 * @deprecated Will be removed in v7.0.0
 * Use the router to store data.
 *
 * ```
 * [ Component Output ] -> [ Route Store ]
 * [ Route Store ] -> [ Component Input ]
 * ```
 *
 * See `RouteParam` for configuration.
 *
 * Note: you can use a single output to save multiple params
 * to a store by using `RouteParamsMultiSink`.
 */
export interface RouteParamsStore<T extends RouteParamPayload> extends PipelineSource<T | undefined>, PipelineSink<T> {
    /**
     * @param paramName The name of the param to save in the route
     */
    source: (group: string) => Source<T | undefined>;
    /**
     * @param paramName The name of the param to read from the route
     */
    sink: (group: string) => Sink<T>;
}
/**
 * @deprecated Will be removed in v7.0.0
 * Pipeable operator for normalizing value to `RouteParams`.
 *
 * @param paramNameArg
 */
export declare const routeParams: (paramNameArg: string) => (stdin: Observable<string | undefined>) => Observable<{
    [x: string]: string;
}>;
/**
 * @deprecated Will be removed in v7.0.0
 * RouteParam Communication Transport
 *
 * Can be used to configure communication using RouteParam.
 *
 * @usageNotes
 *
 * Store some 2-way bound state to the router as "paramName"
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouteParam.toProperty("paramName"),
 *     "input.myInput": RouteParam.toProperty("paramName")
 *   }
 * }
 * ```
 *
 * Navigate to widget-b and pass data via route-param
 *
 * ```json
 * {
 *   "name": "widget-a",
 *   "properties": {
 *     "output.myOutput": RouteParam.toProperty("inputName")
 *   }
 * },
 * {
 *   "name": "widget-b",
 *   "properties": {
 *     "input.myInput": RouteParam.toProperty("inputName")
 *   }
 * }
 * ```
 */
export declare class RouteParam {
    /**
     * Generate a serialized communication configuration suitable for use as a Widget Input or Output property value.
     *
     * @param group The name of the communication group to which the Input/Output belongs
     */
    static toProperty(group: string): string;
}
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare type RouteParamPayload = string | {
    [key: string]: string | number;
};
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare const getRouteParam: (activatedRoute: ActivatedRoute, group: string) => Observable<string | undefined>;
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare const createRouteParams: <T extends RouteParamPayload = string>(activatedRoute: ActivatedRoute, itemNavigation: ӨItemNavigationService, rootModel: ӨRootContainerService) => RouteParamsStore<T>;
/**
 * @deprecated Will be removed in v7.0.0
 */
export declare const routeParamsProcessorConfig: PipelineProcessorConfig;
