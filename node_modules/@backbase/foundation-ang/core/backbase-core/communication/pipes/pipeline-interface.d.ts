import { Observable } from 'rxjs';
export declare type Source<T> = () => Observable<T>;
export declare type SourceFactory<T> = (...args: Array<any>) => Source<T>;
export declare type Pipe<T, R> = (stdin: Observable<T>) => Observable<R>;
export declare type PipeFactory<T, R> = (...args: Array<any>) => Pipe<T, R>;
export declare type Sink<R> = (stdin: Observable<R>) => void;
export declare type SinkFactory<R> = (...args: Array<any>) => Sink<R>;
/**
 * @deprecated Will be removed in v7.0.0
 * A *source* `PipelineProcessor`.
 *
 * Defines a `SourceFn` factory, which takes some arguments and
 * returns a `SourceFn`.
 */
export interface PipelineSource<T> {
    source: SourceFactory<T>;
}
/**
 * @deprecated Will be removed in v7.0.0
 * A *pipe* `PipelineProcessor`.
 *
 * Defines a `PipeFn` factory, which takes some arguments and
 * returns a `PipeFn`.
 */
export interface PipelinePipe<T, R> {
    pipe: PipeFactory<T, R>;
}
/**
 * @deprecated Will be removed in v7.0.0
 * A *sink* `PipelineProcessor`.
 *
 * Defines a `PipeFn` factory, which takes some arguments and
 * returns a `PipeFn`.
 */
export interface PipelineSink<R> {
    sink: SinkFactory<R>;
}
/**
 * @deprecated Will be removed in v7.0.0
 * Functions to mix in to a pipeline.
 *
 * A pipeline is a combination of a `PipelineSource` to a `PipelineSink`.
 *
 *  - `PipelineSource`: Produces an output: `() => Observable<T>`
 *  - `PipelineSink`: Consumes an input: `(Observable<T>) => void`
 *
 * ```
 * [ PipelineSource ] -> [ Pipeline Sink ]
 * ```
 *
 * All component outputs can be used as a `PipelineSource`, and all component
 * inputs can be used as a `PipelineSink`.
 *
 * Processors are registered with a ID string. Registered processors
 * can be composed in an item's model `input.*` and `output.*` properties.
 *
 * ```
 * [ Component Output ] -> [ Registered Sink ]
 * [ Registered Source ] -> [ Component Input ]
 * ```
 *
 * Note: a single processor instance can be used multiple times for
 * a single item in the model.
 *
 * ## Configuring Outputs
 *
 * Because all component outputs are a `PipelineSource`, they can be configured to
 * connect to a registered `PipelineSink`. For example, you can use the registered
 * `DebugSink` to log a component's output to the console:
 *
 * ```typescript
 * @Component({ ... })
 * class FooOutputComponent {
 *   @Output() foo = new EventEmitter<string>();
 * }
 * ```
 *
 * ```json
 * {
 *   "name": "foo-output-demo",
 *   "properties": {
 *     "classId": "FooOutputComponent",
 *     "output.foo": "debug"
 *   }
 * }
 * ```
 *
 * ## Configuring Inputs
 *
 * Because all component inputs are a `PipelineSink`, they can be configured to
 * consume a registered `PipelineSource`. For example, you can use the registered
 * `ModelSource` to read an `ItemModel`'s property (which is an observable):
 *
 * ```typescript
 * @Component({
 *    template: '{{foo}}'
 * })
 * class FooInputComponent {
 *   @Input() foo: string = '';
 * }
 * ```
 *
 * ```json
 * {
 *   "name": "foo-input-demo",
 *   "properties": {
 *     "classId": "FooInputComponent",
 *     "foo": "bar",
 *     "input.foo": "model foo"
 *   }
 * }
 * ```
 *
 * ## Input/Output Model Format
 *
 * The general format of an input/output property is:
 *
 * ```json
 * {
 *   "input.input-name": "source-name args",
 *   "output.output-name": "sink-name args"
 * }
 * ```
 *
 * Where:
 * - **input-name**: is the name of the component's `@Input` property
 * - **output-name**: is the name of the component's `@Output` property
 * - **source-name**: is the name of the registered `PipelineSource` which
 *   produces a stream
 * - **sink-name**: is the name of a registered `PipelineSink` which
 *   consumes a stream
 * - **args** are *space* separated arguments passed to the factory of the
 *    handler.
 *
 * See `PipelineProcessorConfig` for details on registering custom processors.
 */
export declare type PipelineProcessor<T, R = T> = PipelineSource<T> | PipelinePipe<T, R> | PipelineSink<R>;
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface Pipeline<T> {
    source: Source<T>;
    sink: Sink<T>;
}
