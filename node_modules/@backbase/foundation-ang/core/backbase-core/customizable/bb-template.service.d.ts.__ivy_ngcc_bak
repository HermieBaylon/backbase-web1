import { OnChanges, OnDestroy, OnInit, SimpleChanges, TemplateRef, ViewContainerRef } from '@angular/core';
import { TemplateRegistry } from './template-registry';
/**
 * @deprecated Will be removed in v7.0.0
 */
export interface CustomTemplateContext<Host, ExtraContext> {
    readonly $implicit: Host;
    context: ExtraContext | undefined;
}
export declare type CustomTemplateRef<HostRef, Context> = TemplateRef<CustomTemplateContext<HostRef, Context>>;
/**
 *
 * @deprecated Will be removed in v7.0.0
 *
 * @description
 * Every custom template directive should extend this class.
 * See 'How to make widget customizable'
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * import { Component, Directive } from '@angular/core';
 * import { BbTemplate, ItemModel } from '@backbase/foundation-ang/core';
 *
 * @Component({
 *   selector: 'my-widget',
 *   template: `
 *   <li *ngFor="let item of pallete">
 *     My colors:
 *     <ng-container
 *       customItemTemplate
 *       [bbHostRef]="hostRef"
 *       [bbTemplateContext]="item"
 *     ></ng-container>
 *   </li>
 *
 *   <ng-template customItemTemplate let-hostRef let-item="context">
 *     Current name: {{ item.color }}
 *     Hex value: {{ hostRef.getHexColor(item.color) }}
 *   </ng-template>
 *   `,
 * })
 * export class MyWidgetComponent {
 *   readonly hostRef = this;
 *   readonly palette: Array<PaletteItem> = [{
 *     color: 'blue',
 *   }];
 *   readonly hexValues = {
 *     blue: '0000ff',
 *   };
 *
 *   constructor(private itemModel: ItemModel) {}
 *
 *   getHexColor(color: string): string | undefined {
 *     return this.hexValues[color];
 *   }
 * }
 *
 * type PaletteItem {
 *   color: string;
 * };
 *
 * @Directive({
 *   selector: '[customItemTemplate]',
 * })
 * export class customItemTemplate extends BbTemplate<MyWidgetComponent, PaletteItem> {}
 * ```
 */
export declare abstract class BbTemplate<HostRef, Context> implements OnInit, OnDestroy, OnChanges {
    private readonly viewContainerRef;
    private readonly registry;
    private readonly templateRef;
    /**
     * Custom context
     */
    bbTemplateContext: Context | undefined;
    /**
     * Context of the host component
     */
    bbHostRef: HostRef | undefined;
    private templateSubscription;
    private customTemplateContext;
    constructor(viewContainerRef: ViewContainerRef, registry: TemplateRegistry, templateRef: TemplateRef<CustomTemplateContext<HostRef, Context>>);
    /**
     * @internal
     */
    ngOnInit(): void;
    private templateId;
    private checkContainerHasHostRef;
    private checkNgTemplateIsNotUsedtoDefineSlot;
    /**
     * @internal
     */
    ngOnChanges(changes: SimpleChanges): void;
    private waitTemplate;
    /**
     * @internal
     */
    ngOnDestroy(): void;
    private createContext;
    private get isContainer();
}
