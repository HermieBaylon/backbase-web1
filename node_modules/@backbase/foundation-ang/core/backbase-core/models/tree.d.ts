import { LinkedList } from './linked-list';
import { Observable } from 'rxjs';
export declare type ChildrenUpdateFn<T> = (acc: Array<ObservableTree<T>>) => Array<ObservableTree<T>>;
/**
 * Abstract tree representation.
 */
export declare class Tree<T> {
    /**
     * The value of this node
     */
    value: T;
    /**
     * The children of this node
     */
    children: Array<Tree<T>>;
    constructor(
    /**
     * The value of this node
     */
    value: T, 
    /**
     * The children of this node
     */
    children: Array<Tree<T>>);
    map<R>(callbackfn: (value: T, oldChildren: Array<T>, newChildren: Array<R>) => R): Tree<R>;
    /**
     * Flattens the tree into a flat array of tree nodes.
     *
     * The tree is flattened by in order of depth-first-preorder-traversal.
     */
    flatten(): Array<Tree<T>>;
    pathTo(value: T): Array<T>;
    lowestCommonAncestor(left: T, right: T): T | undefined;
}
/**
 * @description
 * This is an operator that can be used with an Observable's `pipe`.
 *
 * The piped observable should be an observable of an array.
 *
 * The source array is mapped over with the provided callback function, and the
 * callback function should take an item (T) from the source array, and return an
 * *observable* of a new item (R).
 *
 * The result is a new observable of an array the same length as the source array
 * but with the Ts mapped to Rs.
 *
 * This is useful for mapping over the observable children of node in the model tree.
 *
 * @usageNotes
 *
 * ### Example
 * ```
 * const children: ObservableTree<ItemModel> = this.model.children;
 * const titleProperties: Observable<Array<string>> = this.model.children.pipe(
 *   mapObservableArray(item => item.value.property<string>('title', 'Default Title'))
 * );
 * ```
 * @param callback Function that produces an *observable* element of the new Array
 */
export declare const mapObservableArray: <T, R>(callback: (a: T) => Observable<R>) => (source: Observable<T[]>) => Observable<R[]>;
/**
 * An tree where each node's children are observable.
 */
export declare class ObservableTree<T> {
    /**
     * The value of this node
     */
    value: T;
    private readonly insertions;
    private readonly removals;
    private readonly initialChildren;
    private readonly insertUpdates;
    private readonly removalUpdates;
    private readonly reducers;
    /**
     * The children of this node
     */
    readonly children: Observable<Array<ObservableTree<T>>>;
    constructor(
    /**
     * The value of this node
     */
    value: T, initialChildren: Array<ObservableTree<T>>, insertions: Observable<{
        item: ObservableTree<T>;
        index: number;
    }>, removals: Observable<number>);
    /**
     * Find a node in the tree. Returns the result as an observable.
     *
     * If the element is found it is emitted, otherwise, the result emits undefined.
     *
     * The result observable will only emit again if the found node changes (ie: if
     * it is added or removed, or if it finds a different node).
     *
     * @param predicate predicate is called once for each node of the tree, until a
     * node is found. The predicate will be called again every time the tree changes
     * (ie: a node in the tree is added or removed). The predicate is called in order
     * of depth-first-preorder-traversal.
     */
    find(predicate: (value: T) => boolean): Observable<ObservableTree<T> | undefined>;
    pathTo(value: T): Observable<Array<T>>;
    lowestCommonAncestor(left: T, right: T): Observable<T | undefined>;
    filter(predicate: (value: T) => boolean): Observable<Array<ObservableTree<T>>>;
    /**
     * Flattens a tree into a single array of nodes. The result nodes are still trees.
     *
     * The tree is flattened in order of depth-first-preorder-traversal.
     *
     * The result is returned as an observable and re-emits every time a node is added
     * or removed from the tree.
     */
    flatten(): Observable<Array<ObservableTree<T>>>;
    /**
     * Takes a snapshot of the tree.
     */
    toTree(): Observable<Tree<T>>;
}
/**
 * Like combineLatest in rxjs, but for a tree of observables, instead of
 * an array of observables.
 */
export declare function combineTree<T>(tree: Tree<Observable<T>>): Observable<Tree<T>>;
/**
 * Describes a more generic tree than our "Tree" type.
 *
 * This is useful for performing operations on different
 * "tree" implementations.
 *
 * For example, this is type which describes an angular
 * `Route` as our generic tree type:
 * `type AngularRouteTree = GenericTree<Route>;`
 *
 * And this describes our `ComponentRouteTree`
 * `type ComponentTree = GenericTree<Tree<ItemRoutes>>;
 */
export declare type GenericTree<T> = T & {
    children?: Array<GenericTree<T>>;
};
/**
 * Extracts a branch from a tree that starts at the root, and ends at the leaf
 * node, as determined by the predicate (returns a linked list).
 *
 * If the element is not found, the result is undefined.
 *
 * @param predicate predicate is called once for each node of the tree, until a
 * node is found. The predicate is called in order of depth-first-preorder-traversal.
 */
export declare const treeBranch: <T>(tree: GenericTree<T>, predicate: (value: T, index?: number | undefined, parent?: T | undefined) => boolean) => LinkedList<T> | undefined;
