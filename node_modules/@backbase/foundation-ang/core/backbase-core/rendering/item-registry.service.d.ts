import { InjectionToken } from '@angular/core';
import { LoadChildrenCallback } from '@angular/router';
import { LazyConfigItem } from './lazy-config';
import * as ɵngcc0 from '@angular/core';
export declare type ComponentClass<T> = new (...args: Array<any>) => T;
export interface ComponentMap {
    [key: string]: ComponentClass<any>;
}
/**
 * ComponentRegistry configuration injection token
 */
export declare const CONFIG_COMPONENT_CLASS_MAP: InjectionToken<Map<string, ComponentClass<any>>>;
/**
 * ItemRegistryService stores a hashMap
 * of the components included into the app and
 * avaliable for usage. It's meant to be an extension
 * point which is used by a developer.
 */
export declare class ItemRegistryService {
    private readonly itemRegistry;
    private readonly lazyModuleConfig;
    /**
     * ItemRegistryService constructor which allows to define components
     * included into application
     * @param ComponentRegistry a hashMap of the component classes to be added
     */
    constructor(classMaps: Array<ComponentMap> | undefined, lazyConfig: Array<LazyConfigItem> | null);
    entries(): [string, ComponentClass<any>][];
    add(classId: string, componentClass: ComponentClass<any>): void;
    has(classId: string): boolean;
    /**
     * This method allows to retrieve Component by it's classId
     * @param classId classId key to get a component class
     * @returns componentType to be used by a ComponentFactoryResolver
     */
    getComponentValue(classId: string): ComponentClass<any> | undefined;
    getComponent(classId: string): Promise<ComponentClass<any>>;
    getModuleLoader(classId: string): LoadChildrenCallback | undefined;
    static ɵfac: ɵngcc0.ɵɵFactoryDeclaration<ItemRegistryService, [{ optional: true; }, { optional: true; }]>;
    static ɵprov: ɵngcc0.ɵɵInjectableDeclaration<ItemRegistryService>;
}

//# sourceMappingURL=item-registry.service.d.ts.map