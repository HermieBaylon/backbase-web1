import { Injectable } from '@angular/core';
import { catchError, distinctUntilChanged, finalize, map, scan, share, switchMap, tap, withLatestFrom, startWith, filter, } from 'rxjs/operators';
import { BehaviorSubject, combineLatest, of, Subject, zip } from 'rxjs';
import { NotificationsHttpService } from '@backbase/data-ang/notifications';
import { toISOExtendedFormat } from '@backbase/notifications-common-ang';
import { WidgetPropertiesService } from './widget-properties.service';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/notifications";
import * as i2 from "./widget-properties.service";
export class NotificationsPaginationService {
    constructor(notificationHttpService, properties) {
        this.notificationHttpService = notificationHttpService;
        this.properties = properties;
        /**
         * Stream with page size
         */
        this.sizeProperty$ = this.properties.pageSize$;
        this.pageSubject = new Subject();
        this.page$ = this.pageSubject.asObservable();
        /**
         * Stream with current page number (work with loadPage method)
         */
        this.pageFrom$ = this.page$.pipe(map(p => p.from));
        this.isLoadingSubject = new BehaviorSubject(false);
        /**
         * Stream with loading flag
         */
        this.isLoading$ = this.isLoadingSubject.asObservable();
        // eslint-disable-next-line
        this.totalCountSubject = new Subject();
        /**
         * Stream with total count of notifications
         */
        this.totalCount$ = this.totalCountSubject.asObservable();
        this.origins$ = this.properties.origins$;
        this.severityLevels$ = this.properties.severityLevels$;
        this.notificationsRequest$ = combineLatest([
            this.page$,
            this.sizeProperty$,
            this.origins$,
            this.severityLevels$,
        ]).pipe(switchMap(([page, size, origins, levels]) => {
            this.isLoadingSubject.next(true);
            return this.notificationHttpService
                .getNotifications(Object.assign(Object.assign({ toDate: page.createdOn && new Date(toISOExtendedFormat(page.createdOn)).toISOString().replace(/\.\d+Z/, 'Z'), from: page.from, size }, (origins.length && { origins })), (levels.length && { levels })), 'response')
                .pipe(tap(res => {
                this.totalCountSubject.next(Number(res.headers.get('x-total-count') || '0'));
            }), map(({ body, headers }) => ({ data: body || [], headers, error: undefined })), catchError(error => of({ data: [], headers: undefined, error })), finalize(() => {
                this.isLoadingSubject.next(false);
            }));
        }), share());
        this.notificationsPage$ = this.notificationsRequest$.pipe(map(({ data }) => data));
        this.markAllNotificationsAsRead = new BehaviorSubject(false);
        /**
         * Stream of notifications
         */
        this.notifications$ = combineLatest([
            zip(this.page$, this.notificationsPage$).pipe(
            // reset accumulator for every first page in Append mode or for every page in regular mode
            scan((allNotifications, [page, notifications]) => (!page.append || page.from === 0 ? [] : allNotifications).concat(notifications), [])),
            this.markAllNotificationsAsRead.pipe(startWith(true), filter(Boolean)),
        ]).pipe(withLatestFrom(this.markAllNotificationsAsRead), 
        // eslint-disable-next-line arrow-body-style
        map(([[notifications], allAsRead]) => {
            return allAsRead ? notifications.map(item => (!item.read && Object.assign(Object.assign({}, item), { read: true })) || item) : notifications;
        }));
        /**
         * Stream of errors
         */
        this.error$ = this.notificationsRequest$.pipe(map(({ error }) => error), distinctUntilChanged());
    }
    loadPageData(page, append = false, createdOn) {
        this.pageSubject.next({ from: page, append, createdOn: createdOn });
    }
    /**
     * Method to load notifications of specified page
     *
     * @param page Page number
     */
    loadPage(page) {
        this.loadPageData(page);
    }
    /**
     * Method to load next page of notifications
     *
     * @param page Page number
     * @param createdOn Created on notification date
     */
    loadMore(page, createdOn) {
        this.loadPageData(page, true, createdOn);
    }
    /**
     * Mark all notifications as read
     *
     * @param read Is read flag
     */
    markAllAsRead(read) {
        this.markAllNotificationsAsRead.next(read);
    }
}
/** @nocollapse */ NotificationsPaginationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPaginationService, deps: [{ token: i1.NotificationsHttpService }, { token: i2.WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPaginationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPaginationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPaginationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NotificationsHttpService }, { type: i2.WidgetPropertiesService }]; } });
//# sourceMappingURL=notifications-pagination.service.js.map