import { Injectable, NgZone } from '@angular/core';
import { NotificationsHttpService } from '@backbase/data-ang/notifications';
import { asyncScheduler, BehaviorSubject, combineLatest, merge, of, ReplaySubject, Subject } from 'rxjs';
import { catchError, delay, filter, first, map, observeOn, pairwise, switchMap, tap } from 'rxjs/operators';
import { enterZone, leaveZone, shareReplayOnce } from '@backbase/notifications-common-ang';
import { WidgetPropertiesService } from './widget-properties.service';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/notifications";
import * as i2 from "./widget-properties.service";
export class NotificationsPollingService {
    constructor(notificationHttpService, properties, ngZone) {
        this.notificationHttpService = notificationHttpService;
        this.properties = properties;
        this.ngZone = ngZone;
        this.forceUpdateCountersSubject = new Subject();
        this.requestsInterval$ = this.properties.unreadCountUpdateInterval$;
        this.repeat$ = new ReplaySubject(1);
        this.load$ = merge(of(''), this.forceUpdateCountersSubject, merge(this.forceUpdateCountersSubject, this.repeat$).pipe(switchMap(() => this.requestsInterval$), switchMap(interval => of('').pipe(delay(interval, leaveZone(this.ngZone, asyncScheduler)))), observeOn(enterZone(this.ngZone, asyncScheduler))));
        this.updateCountersErrorSubject$$ = new BehaviorSubject(undefined);
        /**
         * Stream with update counters request errors
         */
        this.updateCountersError$ = this.updateCountersErrorSubject$$.asObservable();
        /**
         * Stream with unread notifications count
         */
        this.unreadNotificationsCount$ = this.load$.pipe(switchMap(() => this.requestCount()), tap(() => this.repeat$.next()), filter(count => typeof count !== 'undefined'), shareReplayOnce());
        /**
         * Stream with flag of new available notifications
         */
        this.newNotificationsAvailable$ = this.unreadNotificationsCount$.pipe(pairwise(), map(([prev, cur]) => {
            if (prev === null || prev === undefined) {
                return false;
            }
            if (cur === null || cur === undefined) {
                return false;
            }
            return cur - prev > 0;
        }), filter(Boolean));
    }
    requestCount() {
        const origins$ = this.properties.origins$;
        const severityLevels$ = this.properties.severityLevels$;
        return combineLatest([origins$, severityLevels$]).pipe(first(), switchMap(([origins, levels]) => this.notificationHttpService.getUnreadCount(Object.assign(Object.assign({}, (origins.length && { origins })), (levels.length && { levels })))), map(body => {
            this.updateCountersErrorSubject$$.next(undefined);
            return body === null || body === void 0 ? void 0 : body.unread;
        }), catchError((error) => {
            this.updateCountersErrorSubject$$.next(error);
            return of(undefined);
        }));
    }
    /**
     * Method to trigger force update on unread notifications counter
     */
    forceUpdateCounters() {
        this.forceUpdateCountersSubject.next();
    }
}
/** @nocollapse */ NotificationsPollingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPollingService, deps: [{ token: i1.NotificationsHttpService }, { token: i2.WidgetPropertiesService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPollingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPollingService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPollingService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NotificationsHttpService }, { type: i2.WidgetPropertiesService }, { type: i0.NgZone }]; } });
//# sourceMappingURL=notifications-polling.service.js.map