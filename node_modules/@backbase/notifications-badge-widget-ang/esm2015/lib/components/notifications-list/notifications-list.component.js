import { Component, Directive, ElementRef, EventEmitter, Inject, Input, Output, } from '@angular/core';
import { BbTemplate } from '@backbase/foundation-ang/core';
import { asyncScheduler, BehaviorSubject, combineLatest, of, Subject } from 'rxjs';
import { filter, first, map, mapTo, observeOn, pairwise, skip, skipUntil, startWith, switchMap, take, takeUntil, tap, } from 'rxjs/operators';
import { shareReplayOnce } from '@backbase/notifications-common-ang';
import { NotificationService } from '@backbase/ui-ang/notification';
import { PUBSUB } from '@backbase/foundation-ang/web-sdk';
import { NotificationsPaginationService } from '../../services/notifications-pagination.service';
import { NotificationsPollingService } from '../../services/notifications-polling.service';
import { NotificationsDataService } from '../../services/notifications-data.service';
import { NotificationsRouterService } from '../../services/notifications-router.service';
import { WidgetPropertiesService } from '../../services/widget-properties.service';
import * as i0 from "@angular/core";
import * as i1 from "../../services/notifications-router.service";
import * as i2 from "../../services/notifications-pagination.service";
import * as i3 from "../../services/notifications-polling.service";
import * as i4 from "../../services/notifications-data.service";
import * as i5 from "@backbase/ui-ang/notification";
import * as i6 from "../../services/widget-properties.service";
import * as i7 from "@backbase/ui-ang/icon";
import * as i8 from "@backbase/ui-ang/alert";
import * as i9 from "../notifications-list-item/notifications-list-item.component";
import * as i10 from "@backbase/ui-ang/load-button";
import * as i11 from "../notification-details/notification-details.component";
import * as i12 from "@backbase/ui-ang/empty-state";
import * as i13 from "@backbase/ui-ang/loading-indicator";
import * as i14 from "@angular/common";
import * as i15 from "@backbase/ui-ang/button";
export const NOTIFICATIONS_BADGE_RELOAD_ON_NAVIGATE_EVENT = 'bb.event.notifications-badge.reload-on-navigate';
export class NotificationsListComponent {
    constructor(routerService, notificationsPaginationService, notificationsPollingService, notificationService, showNotificationService, element, properties, pubSub) {
        this.routerService = routerService;
        this.notificationsPaginationService = notificationsPaginationService;
        this.notificationsPollingService = notificationsPollingService;
        this.notificationService = notificationService;
        this.showNotificationService = showNotificationService;
        this.element = element;
        this.properties = properties;
        this.pubSub = pubSub;
        /**
         * Navigation event.
         */
        this.navigation = new EventEmitter();
        this.componentDestroyed$ = new Subject();
        /**
         * Stream of routes available for navigation.
         */
        this.allowedRoutes$ = this.properties.allowedRoutes$;
        /**
         * Stream of a flag that defines if we should display settings button.
         */
        this.displaySettingsButton$ = this.properties.displaySettingsButton$;
        /**
         * Stream with notifications items.
         */
        this.notifications$ = this.notificationsPaginationService.notifications$.pipe(takeUntil(this.componentDestroyed$), shareReplayOnce());
        /**
         * Stream with error while loading of notifications.
         */
        this.error$ = this.notificationsPaginationService.error$;
        /**
         * Stream with error while loading of notifications.
         */
        this.updateCountersError$ = this.notificationsPollingService.updateCountersError$;
        /**
         * Mark as read request error stream which shows if request has failed.
         */
        this.markAllAsReadError$ = this.notificationService.markAllNotificationAsReadError;
        /**
         * Stream with flag if notifications is loading now or no.
         */
        this.isLoading$ = this.notificationsPaginationService.isLoading$;
        this.firstNewNotificationId$ = this.notifications$.pipe(pairwise(), map(([prevNotifications, newNotifications]) => {
            let firstNewNotification = newNotifications[prevNotifications.length];
            // reset notification to the first page scenario
            if (prevNotifications.length >= newNotifications.length) {
                firstNewNotification = newNotifications[0];
            }
            return firstNewNotification && firstNewNotification.id;
        }));
        this.notificationWasReadSubject = new Subject();
        this.notificationWasRead$ = this.notificationWasReadSubject.asObservable();
        this.newNotificationsAvailableSubject = new BehaviorSubject(false);
        this.updateCounters$ = this.newNotificationsAvailableSubject.pipe(startWith(false), filter(i => !i), mapTo(true), shareReplayOnce());
        /**
         * Stream with total count of notifications.
         */
        this.totalCount$ = this.updateCounters$.pipe(switchMap(() => this.notificationsPaginationService.totalCount$));
        /**
         * Stream with notifications about new notification available
         */
        this.newNotificationsAvailable$ = this.newNotificationsAvailableSubject.asObservable();
        /**
         * Stream with page size.
         */
        this.pageSize$ = this.notificationsPaginationService.sizeProperty$;
        /**
         * Stream with unread notifications count
         */
        this.unreadCount$ = this.updateCounters$.pipe(switchMap(() => this.notificationsPollingService.unreadNotificationsCount$.pipe(switchMap(counter => this.notificationWasRead$.pipe(startWith(false), map(read => {
            if (!read || !counter) {
                return counter;
            }
            return --counter;
        }))))));
        /**
         * Steam with the starting page number.
         */
        this.pageFrom$ = this.notificationsPaginationService.pageFrom$;
    }
    /**
     * Preselected notification
     */
    set preselectedNotification(notification) {
        this.selectedNotification = notification;
    }
    ngOnInit() {
        this.firstNewNotificationId$
            .pipe(filter(Boolean), map(id => `.bb-nt-${id}`), observeOn(asyncScheduler), map(elemClass => this.element.nativeElement.querySelector(elemClass)), filter(Boolean), takeUntil(this.componentDestroyed$))
            .subscribe((elemScrollTo) => {
            var _a;
            (_a = elemScrollTo.firstChild) === null || _a === void 0 ? void 0 : _a.focus();
            elemScrollTo.scrollIntoView({ behavior: 'smooth' });
        });
        this.notificationsPollingService.newNotificationsAvailable$
            .pipe(takeUntil(this.componentDestroyed$))
            .subscribe(value => {
            this.newNotificationsAvailableSubject.next(value);
        });
        this.onLoadNewNotifications();
    }
    ngOnDestroy() {
        this.componentDestroyed$.next();
        this.componentDestroyed$.complete();
    }
    /**
     * Method to mark all notifications as read.
     */
    onReadAllNotifications() {
        this.notificationService.markAllNotificationAsRead().subscribe(() => {
            this.notificationsPaginationService.markAllAsRead(true);
        });
    }
    /**
     * Method to load new notifications by reloading of the first page.
     */
    onLoadNewNotifications() {
        this.notificationsPollingService.unreadNotificationsCount$
            .pipe(skip(1), // skip stored value to wait for unread notifications count load occurred
        first())
            .subscribe(() => {
            this.newNotificationsAvailableSubject.next(false);
            this.notificationsPaginationService.markAllAsRead(false);
            this.notificationsPaginationService.loadPage(0);
        });
        this.notificationsPollingService.forceUpdateCounters();
    }
    /**
     * Method to load next notifications page.
     */
    onLoadMore(totalCount, $event) {
        const asyncNotifications$ = this.notifications$.pipe(skipUntil(of(undefined).pipe(observeOn(asyncScheduler))));
        const lastNotification$ = this.notifications$.pipe(first(), map(notifications => notifications[notifications.length - 1]), map(({ id }) => `.bb-nt-${id} [data-role="notifications-list-item"]`), observeOn(asyncScheduler), map(selector => this.element.nativeElement.querySelector(selector)));
        this.notifications$.pipe(first()).subscribe(data => {
            const createdOn = data[0].createdOn;
            this.notificationsPaginationService.loadMore($event.from, createdOn);
        });
        combineLatest([asyncNotifications$, of(totalCount)])
            .pipe(take(1), filter(([notifications, total]) => notifications.length >= total), switchMap(() => lastNotification$))
            .subscribe(lastNotification => lastNotification.focus());
    }
    /**
     * Method to open notification settings.
     */
    onNotificationsSettingsOpen() {
        this.routerService.emitSettingsOpenedNavigation();
        this.navigation.emit();
    }
    /**
     * Method to show notification details view or to navigate to the notification routing URL if routing is enabled.
     */
    selectNotification(clickEvent, notification, openDetailsView) {
        clickEvent.preventDefault();
        this.allowedRoutes$.subscribe(routes => {
            const route = notification.routing && notification.routing['where-to'];
            if (!openDetailsView && notification.routing && routes.some(allowedRoute => route === allowedRoute)) {
                this.pubSub.publish(NOTIFICATIONS_BADGE_RELOAD_ON_NAVIGATE_EVENT, undefined);
                this.routerService.emitNotificationRouting(notification.routing);
                this.navigation.emit();
            }
            else {
                this.selectedNotification = notification;
                this.saveRefToNotification(clickEvent);
            }
        });
        if (!notification.read) {
            this.notificationService.markNotificationAsRead(notification.id).subscribe(() => {
                notification.read = true;
                this.notificationWasReadSubject.next(true);
            });
        }
    }
    /**
     * Method to delete notification.
     */
    deleteNotification() {
        if (this.selectedNotification) {
            this.notificationService
                .deleteNotification(this.selectedNotification.id)
                .pipe(take(1), tap(() => this.notificationsPaginationService.loadPage(0)))
                .subscribe(() => {
                this.selectedNotification = undefined;
            }, error => {
                this.showNotificationService.showNotification({
                    header: this.getErrorMessage(error),
                    modifier: 'error',
                    message: '',
                });
            });
        }
    }
    /**
     * Method to unselect notification and return back focus position.
     */
    unselectNotification() {
        this.selectedNotification = undefined;
        this.restoreFocusOnNotification();
    }
    /**
     * Method to differentiate notifications by IDs.
     *
     * @param _index List item index
     * @param notification Notification list item
     * @returns Notification id
     */
    trackById(_index, notification) {
        return notification.id;
    }
    saveRefToNotification(notificationClickEvent) {
        this.lastSelectedNotificationItemButton = notificationClickEvent.target.closest('[data-role="notifications-list-item"]');
    }
    restoreFocusOnNotification() {
        setTimeout(() => {
            if (!this.lastSelectedNotificationItemButton) {
                return;
            }
            this.lastSelectedNotificationItemButton.focus();
        }, 0);
    }
    getErrorMessage(error) {
        var _a, _b;
        return typeof error !== 'string'
            ? ((_b = (_a = error) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message) || error.message || 'Unknown Error'
            : error;
    }
}
/** @nocollapse */ NotificationsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListComponent, deps: [{ token: i1.NotificationsRouterService }, { token: i2.NotificationsPaginationService }, { token: i3.NotificationsPollingService }, { token: i4.NotificationsDataService }, { token: i5.NotificationService }, { token: i0.ElementRef }, { token: i6.WidgetPropertiesService }, { token: PUBSUB }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsListComponent, selector: "bb-notifications-list", inputs: { preselectedNotification: "preselectedNotification", dateFormat: "dateFormat" }, outputs: { navigation: "navigation" }, ngImport: i0, template: "<ng-container\n  bbNotificationsListCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    notifications: notifications$ | async,\n    error: error$ | async,\n    updateCountersError: updateCountersError$ | async,\n    isLoading: isLoading$ | async,\n    totalCount: totalCount$ | async,\n    pageSize: pageSize$ | async,\n    newNotificationsAvailable: newNotificationsAvailable$ | async,\n    unreadCount: unreadCount$ | async,\n    markAllAsReadError: markAllAsReadError$ | async,\n    pageFrom: pageFrom$ | async\n  }\"\n>\n</ng-container>\n\n<ng-template\n  bbNotificationsListCustomizable\n  let-hostRef\n  let-notifications=\"context.notifications\"\n  let-error=\"context.error\"\n  let-updateCountersError=\"context.updateCountersError\"\n  let-isLoading=\"context.isLoading\"\n  let-totalCount=\"context.totalCount\"\n  let-pageSize=\"context.pageSize\"\n  let-newNotificationsAvailable=\"context.newNotificationsAvailable\"\n  let-unreadCount=\"context.unreadCount\"\n  let-markAllAsReadError=\"context.markAllAsReadError\"\n  let-pageFrom=\"context.pageFrom\"\n>\n  <ng-container *ngIf=\"!hostRef.selectedNotification\">\n    <header data-role=\"notifications-list-header\" class=\"bb-card__header bb-stack\">\n      <span class=\"bb-stack__item\">\n        <span class=\"bb-heading-3\" i18n=\"Notifications modal label@@notifications.modalLabel\">Notifications</span>\n      </span>\n      <button\n        bbButton\n        *ngIf=\"hostRef.displaySettingsButton$ | async\"\n        class=\"bb-stack__item bb-stack__item--push-right\"\n        data-role=\"settings-button\"\n        color=\"link\"\n        circle=\"true\"\n        aria-label=\"Redirect to notification settings\"\n        i18n-aria-label=\"Aria-label for settings button@@notifications.notification-settings.aria-label\"\n        (click)=\"hostRef.onNotificationsSettingsOpen()\"\n      >\n        <bb-icon-ui class=\"text-dark\" name=\"settings\" size=\"md\"></bb-icon-ui>\n      </button>\n    </header>\n    <button\n      bbButton\n      *ngIf=\"newNotificationsAvailable\"\n      role=\"status\"\n      color=\"primary\"\n      [block]=\"true\"\n      i18n=\"Label for new notifications loading button@@notifications.new-notifications-available.button\"\n      aria-label=\"New Notification available. Click to refresh\"\n      i18n-aria-label=\"\n        Aria-label for new notifications loading button@@notifications.new-notifications-available.aria-label\"\n      class=\"bb-notifications-badge-widget__load-new-button\"\n      data-role=\"notifications-load-new-btn\"\n      (click)=\"hostRef.onLoadNewNotifications()\"\n    >\n      <span>New Notification available. Click to refresh</span>\n      <bb-icon-ui name=\"loading\" size=\"md\" cropped=\"true\"></bb-icon-ui>\n    </button>\n    <bb-alert-ui\n      *ngIf=\"markAllAsReadError\"\n      class=\"bb-notifications-badge-widget__alert\"\n      data-role=\"mark-all-read-error-alert\"\n      title=\"Error! Couldn\u2019t mark all as read.\"\n      i18n-title=\"Label for mark all as read error@@notifications.mark-all-read.alert.title\"\n      aria-label=\"Error! Couldn\u2019t mark all as read.\"\n      i18n-aria-label=\"Aria-label for mark all as read error@@notifications.mark-all-read.alert.aria-label\"\n      modifier=\"error\"\n      [dismissible]=\"false\"\n    >\n    </bb-alert-ui>\n    <div class=\"bb-notifications-badge-widget__all-read-button\" *ngIf=\"unreadCount > 0\">\n      <button\n        bbButton\n        data-role=\"mark-all-read-button\"\n        class=\"bb-subtitle\"\n        color=\"link-text\"\n        aria-label=\"Mark all notifcations as read\"\n        i18n-aria-label=\"Aria-label for mark all as read button@@notifications.mark-all-read.aria-label\"\n        (click)=\"hostRef.onReadAllNotifications()\"\n      >\n        <bb-icon-ui name=\"playlist-add-check\" size=\"md\" cropped=\"true\"></bb-icon-ui>\n        <span i18n=\"Label for mark all as read button@@notifications.mark-all-read.label\">Mark all as read</span>\n      </button>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"!error && !updateCountersError; else errorState\">\n    <ng-container *ngIf=\"notifications?.length; else emptyState\">\n      <div data-role=\"notifications-list-inner-wrapper\" [ngClass]=\"hostRef.selectedNotification ? 'd-none' : null\">\n        <p\n          aria-live=\"polite\"\n          class=\"sr-only\"\n          i18n=\"Label for new loaded notifications available@@notifications.new-loaded-notifications-available\"\n        >\n          { notifications.length, plural, =1 {new notification of {{ totalCount }}available} other {\n          {{ notifications.length }} new notifications of {{ totalCount }}available } }\n        </p>\n        <ul\n          tabindex=\"-1\"\n          class=\"bb-notifications-badge-widget__list bb-list bb-list--flush-lg\"\n          data-role=\"notifications-list-body\"\n        >\n          <li class=\"bb-list__item\" *ngFor=\"let notification of notifications; trackBy: hostRef.trackById\">\n            <bb-notifications-list-item\n              [notification]=\"notification\"\n              class=\"bb-nt-{{ notification.id }}\"\n              (keydown.enter)=\"hostRef.selectNotification($event, notification)\"\n              (keyup.space)=\"hostRef.selectNotification($event, notification)\"\n              (click)=\"hostRef.selectNotification($event, notification)\"\n              (openDetails)=\"hostRef.selectNotification($event, notification, true)\"\n              [dateFormat]=\"dateFormat\"\n            >\n            </bb-notifications-list-item>\n          </li>\n        </ul>\n\n        <footer class=\"bb-card__footer\">\n          <ng-container *ngIf=\"totalCount > pageSize\">\n            <div\n              *ngIf=\"notifications.length < totalCount; else LoadMoreDisabled\"\n              class=\"bb-button-bar bb-button-bar--center\"\n            >\n              <bb-load-button-ui\n                i18n=\"Load more button@@notifications.notification-list.load-more\"\n                class=\"bb-button-bar__button\"\n                color=\"link\"\n                [size]=\"pageSize\"\n                [from]=\"pageFrom\"\n                [totalCount]=\"totalCount\"\n                [isLoading]=\"isLoading\"\n                [block]=\"false\"\n                (paramChange)=\"hostRef.onLoadMore(totalCount, $event)\"\n              >\n                Load More\n              </bb-load-button-ui>\n            </div>\n            <ng-template #LoadMoreDisabled>\n              <div\n                data-role=\"notification-list-load-more-disabled-text\"\n                class=\"bb-subtitle bb-text-support bb-text-align-center\"\n                i18n=\"Load more disabled text@@notifications.notification-list.load-more-disabled\"\n              >\n                You\u2019ve reached the end of the list.\n              </div>\n            </ng-template>\n          </ng-container>\n        </footer>\n      </div>\n\n      <bb-notification-details\n        *ngIf=\"hostRef.selectedNotification\"\n        [notification]=\"hostRef.selectedNotification\"\n        (navigateBack)=\"hostRef.unselectNotification()\"\n        (delete)=\"hostRef.deleteNotification()\"\n        [dateFormat]=\"dateFormat\"\n      ></bb-notification-details>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #emptyState>\n    <div role=\"alert\" *ngIf=\"notifications && notifications.length === 0; else loadingState\">\n      <div class=\"bb-card__body\">\n        <bb-empty-state-ui\n          data-role=\"notifications-badge-empty-state\"\n          class=\"bb-state-container\"\n          i18n-title=\"Notifications empty state message title@@notifications.state.no-notifications.title\"\n          title=\"No Notifications\"\n          iconModifier=\"notifications-off\"\n          iconSize=\"xxl\"\n          i18n-subtitle=\"Notifications empty state message@@notifications.state.no-notifications.subtitle\"\n          subtitle=\"You don't have any notifications to be displayed\"\n        ></bb-empty-state-ui>\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #errorState>\n    <div role=\"alert\">\n      <div class=\"bb-card__body\">\n        <bb-empty-state-ui\n          data-role=\"notifications-badge-error-state\"\n          class=\"bb-state-container\"\n          iconSize=\"xxl\"\n          iconModifier=\"error-outline\"\n          title=\"Notifications couldn\u2019t load\"\n          i18n-title=\"Notifications are not loading title@@notifications.error-state.title\"\n          subtitle=\"Try to reload the page or contact the system administrator.\"\n          i18n-subtitle=\"Notifications are not loading subtitle@@notifications.error-state.subtitle\"\n        >\n        </bb-empty-state-ui>\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #loadingState>\n    <bb-loading-indicator-ui\n      loaderSize=\"md\"\n      text=\"Loading...\"\n      i18n-test=\"Loading title@@notifications.state.loading.title\"\n    ></bb-loading-indicator-ui>\n  </ng-template>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i7.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return i8.AlertComponent; }), selector: "bb-alert-ui", inputs: ["modifier", "dismissible", "title", "message"], outputs: ["close"] }, { type: i0.forwardRef(function () { return i9.NotificationsListItemComponent; }), selector: "bb-notifications-list-item", inputs: ["notification", "dateFormat"], outputs: ["openDetails"] }, { type: i0.forwardRef(function () { return i10.LoadButtonComponent; }), selector: "bb-load-button-ui", inputs: ["isLoading", "from", "size", "circle", "totalCount"], outputs: ["paramChange"] }, { type: i0.forwardRef(function () { return i11.NotificationDetailsComponent; }), selector: "bb-notification-details", inputs: ["notification", "dateFormat"], outputs: ["navigateBack", "delete"] }, { type: i0.forwardRef(function () { return i12.EmptyStateComponent; }), selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }, { type: i0.forwardRef(function () { return i13.LoadingIndicatorComponent; }), selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsListCustomizableDirective; }), selector: "[bbNotificationsListCustomizable]" }, { type: i0.forwardRef(function () { return i14.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i15.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i0.forwardRef(function () { return i14.NgClass; }), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i0.forwardRef(function () { return i14.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i0.forwardRef(function () { return i14.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-list',
                    templateUrl: './notifications-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.NotificationsRouterService }, { type: i2.NotificationsPaginationService }, { type: i3.NotificationsPollingService }, { type: i4.NotificationsDataService }, { type: i5.NotificationService }, { type: i0.ElementRef }, { type: i6.WidgetPropertiesService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }]; }, propDecorators: { navigation: [{
                type: Output
            }], preselectedNotification: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }] } });
export class NotificationsListCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsListCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsListCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsListCustomizableDirective, selector: "[bbNotificationsListCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsListCustomizable]',
                }]
        }] });
//# sourceMappingURL=notifications-list.component.js.map