import * as i0 from '@angular/core';
import { Injectable, Optional, Component, Input, Directive, EventEmitter, Output, Inject, ViewChild, NgModule } from '@angular/core';
import * as i14 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import * as i1 from '@backbase/foundation-ang/core';
import { BbTemplate, BackbaseCoreModule } from '@backbase/foundation-ang/core';
import * as i8$1 from '@ng-bootstrap/ng-bootstrap';
import { NgbDropdownModule } from '@ng-bootstrap/ng-bootstrap';
import * as i1$1 from '@backbase/data-ang/notifications';
import { BehaviorSubject, Subject, ReplaySubject, merge, of, asyncScheduler, combineLatest, zip, EMPTY } from 'rxjs';
import { map, first, switchMap, delay, observeOn, tap, filter, pairwise, catchError, finalize, share, scan, startWith, withLatestFrom, distinctUntilChanged, takeUntil, mapTo, skip, skipUntil, take, debounceTime } from 'rxjs/operators';
import * as i5 from '@backbase/notifications-common-ang';
import { BaseWidgetPropertiesService, getPropertyValue, modelItemToBoolean, shareReplayOnce, secondsToMilliseconds, leaveZone, enterZone, toISOExtendedFormat, NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, NotificationsCommonModule } from '@backbase/notifications-common-ang';
import { PUBSUB } from '@backbase/foundation-ang/web-sdk';
import * as i3$2 from '@backbase/ui-ang/media-query-lib';
import { MediaQueryModule } from '@backbase/ui-ang/media-query-lib';
import * as i2$1 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import * as i6 from '@backbase/ui-ang/badge-counter';
import { BadgeCounterModule } from '@backbase/ui-ang/badge-counter';
import * as i5$2 from '@backbase/ui-ang/notification';
import * as i8 from '@backbase/ui-ang/alert';
import { AlertModule } from '@backbase/ui-ang/alert';
import * as i3 from '@backbase/ui-ang/ellipsis';
import { EllipsisModule } from '@backbase/ui-ang/ellipsis';
import * as i2 from '@backbase/ui-ang/date-pipe';
import { BbDatePipeModule } from '@backbase/ui-ang/date-pipe';
import * as i10 from '@backbase/ui-ang/load-button';
import { LoadButtonModule } from '@backbase/ui-ang/load-button';
import * as i3$1 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';
import * as i4 from '@backbase/ui-ang/focus';
import { FocusModule } from '@backbase/ui-ang/focus';
import * as i5$1 from '@backbase/ui-ang/tooltip-directive';
import { TooltipModule } from '@backbase/ui-ang/tooltip-directive';
import * as i12 from '@backbase/ui-ang/empty-state';
import { EmptyStateModule } from '@backbase/ui-ang/empty-state';
import * as i13 from '@backbase/ui-ang/loading-indicator';
import { LoadingIndicatorModule } from '@backbase/ui-ang/loading-indicator';
import { ErrorCommonStateModule } from '@backbase/ui-ang/common-error-state';
import { BadgeModule } from '@backbase/ui-ang/badge';

const DefaultWidgetProperties = {
    displayRelativeTime: false,
    allowedRoutes: [],
    displaySettingsButton: true,
    notificationsMessageLineAmount: 2,
    displayShowMoreButtonInBadge: false,
    pageSize: 5,
    origins: [],
    severityLevels: [],
    unreadCountUpdateInterval: 15,
};
class WidgetPropertiesService extends BaseWidgetPropertiesService {
    constructor(itemModel) {
        super(itemModel);
        this.itemModel = itemModel;
        this.displayRelativeTime$$ = new BehaviorSubject(undefined);
        this.displaySettingsButton$$ = new BehaviorSubject(undefined);
        this.notificationsMessageLineAmount$$ = new BehaviorSubject(undefined);
        this.displayShowMoreButtonInBadge$$ = new BehaviorSubject(undefined);
        this.pageSize$$ = new BehaviorSubject(undefined);
        this.unreadCountUpdateInterval$$ = new BehaviorSubject(undefined);
        this.displayRelativeTime$ = getPropertyValue(this.displayRelativeTime$$, this.displayRelativeTime);
        this.displaySettingsButton$ = getPropertyValue(this.displaySettingsButton$$, this.displaySettingsButton);
        this.notificationsMessageLineAmount$ = getPropertyValue(this.notificationsMessageLineAmount$$, this.notificationsMessageLineAmount);
        this.displayShowMoreButtonInBadge$ = getPropertyValue(this.displayShowMoreButtonInBadge$$, this.displayShowMoreButtonInBadge);
        this.pageSize$ = getPropertyValue(this.pageSize$$, this.pageSize);
        this.unreadCountUpdateInterval$ = getPropertyValue(this.unreadCountUpdateInterval$$, this.unreadCountUpdateInterval);
    }
    get displayRelativeTime() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.displayRelativeTime);
        }
        return this.itemModel
            .property('displayRelativeTime', DefaultWidgetProperties.displayRelativeTime)
            .pipe(map(modelItemToBoolean), first());
    }
    get displaySettingsButton() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.displaySettingsButton);
        }
        return this.itemModel
            .property('displaySettingsButton', DefaultWidgetProperties.displaySettingsButton)
            .pipe(map(modelItemToBoolean), first());
    }
    get notificationsMessageLineAmount() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.notificationsMessageLineAmount);
        }
        return this.itemModel
            .property('notificationsMessageLineAmount', DefaultWidgetProperties.notificationsMessageLineAmount)
            .pipe(map(Number), first());
    }
    get displayShowMoreButtonInBadge() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.displayShowMoreButtonInBadge);
        }
        return this.itemModel
            .property('displayShowMoreButtonInBadge', DefaultWidgetProperties.displayShowMoreButtonInBadge)
            .pipe(map(modelItemToBoolean), first());
    }
    get pageSize() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.pageSize);
        }
        return this.itemModel.property('pageSize', DefaultWidgetProperties.pageSize).pipe(map(Number), shareReplayOnce());
    }
    get unreadCountUpdateInterval() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.unreadCountUpdateInterval * 1000);
        }
        return this.itemModel.property('unreadCountUpdateInterval', DefaultWidgetProperties.unreadCountUpdateInterval).pipe(map(Number), map(n => n * 1000), shareReplayOnce());
    }
    setDisplayRelativeTime(value) {
        this.displayRelativeTime$$.next(modelItemToBoolean(value));
    }
    setDisplaySettingsButton(value) {
        this.displaySettingsButton$$.next(modelItemToBoolean(value));
    }
    setNotificationsMessageLineAmount(value) {
        this.notificationsMessageLineAmount$$.next(Number(value));
    }
    setDisplayShowMoreButtonInBadge(value) {
        this.displayShowMoreButtonInBadge$$.next(modelItemToBoolean(value));
    }
    setPageSize(value) {
        this.pageSize$$.next(Number(value));
    }
    setUnreadCountUpdateInterval(value) {
        const updateInterval = Number(value);
        if (!isNaN(updateInterval) && updateInterval > 0) {
            this.unreadCountUpdateInterval$$.next(secondsToMilliseconds(updateInterval));
        }
    }
}
/** @nocollapse */ WidgetPropertiesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService, deps: [{ token: i1.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ WidgetPropertiesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.ItemModel, decorators: [{
                    type: Optional
                }] }]; } });

class NotificationsPollingService {
    constructor(notificationHttpService, properties, ngZone) {
        this.notificationHttpService = notificationHttpService;
        this.properties = properties;
        this.ngZone = ngZone;
        this.forceUpdateCountersSubject = new Subject();
        this.requestsInterval$ = this.properties.unreadCountUpdateInterval$;
        this.repeat$ = new ReplaySubject(1);
        this.load$ = merge(of(''), this.forceUpdateCountersSubject, merge(this.forceUpdateCountersSubject, this.repeat$).pipe(switchMap(() => this.requestsInterval$), switchMap(interval => of('').pipe(delay(interval, leaveZone(this.ngZone, asyncScheduler)))), observeOn(enterZone(this.ngZone, asyncScheduler))));
        this.updateCountersErrorSubject$$ = new BehaviorSubject(undefined);
        /**
         * Stream with update counters request errors
         */
        this.updateCountersError$ = this.updateCountersErrorSubject$$.asObservable();
        /**
         * Stream with unread notifications count
         */
        this.unreadNotificationsCount$ = this.load$.pipe(switchMap(() => this.requestCount()), tap(() => this.repeat$.next()), filter(count => typeof count !== 'undefined'), shareReplayOnce());
        /**
         * Stream with flag of new available notifications
         */
        this.newNotificationsAvailable$ = this.unreadNotificationsCount$.pipe(pairwise(), map(([prev, cur]) => {
            if (prev === null || prev === undefined) {
                return false;
            }
            if (cur === null || cur === undefined) {
                return false;
            }
            return cur - prev > 0;
        }), filter(Boolean));
    }
    requestCount() {
        const origins$ = this.properties.origins$;
        const severityLevels$ = this.properties.severityLevels$;
        return combineLatest([origins$, severityLevels$]).pipe(first(), switchMap(([origins, levels]) => this.notificationHttpService.getUnreadCount(Object.assign(Object.assign({}, (origins.length && { origins })), (levels.length && { levels })))), map(body => {
            this.updateCountersErrorSubject$$.next(undefined);
            return body === null || body === void 0 ? void 0 : body.unread;
        }), catchError((error) => {
            this.updateCountersErrorSubject$$.next(error);
            return of(undefined);
        }));
    }
    /**
     * Method to trigger force update on unread notifications counter
     */
    forceUpdateCounters() {
        this.forceUpdateCountersSubject.next();
    }
}
/** @nocollapse */ NotificationsPollingService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPollingService, deps: [{ token: i1$1.NotificationsHttpService }, { token: WidgetPropertiesService }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPollingService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPollingService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPollingService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.NotificationsHttpService }, { type: WidgetPropertiesService }, { type: i0.NgZone }]; } });

class NotificationsPaginationService {
    constructor(notificationHttpService, properties) {
        this.notificationHttpService = notificationHttpService;
        this.properties = properties;
        /**
         * Stream with page size
         */
        this.sizeProperty$ = this.properties.pageSize$;
        this.pageSubject = new Subject();
        this.page$ = this.pageSubject.asObservable();
        /**
         * Stream with current page number (work with loadPage method)
         */
        this.pageFrom$ = this.page$.pipe(map(p => p.from));
        this.isLoadingSubject = new BehaviorSubject(false);
        /**
         * Stream with loading flag
         */
        this.isLoading$ = this.isLoadingSubject.asObservable();
        // eslint-disable-next-line
        this.totalCountSubject = new Subject();
        /**
         * Stream with total count of notifications
         */
        this.totalCount$ = this.totalCountSubject.asObservable();
        this.origins$ = this.properties.origins$;
        this.severityLevels$ = this.properties.severityLevels$;
        this.notificationsRequest$ = combineLatest([
            this.page$,
            this.sizeProperty$,
            this.origins$,
            this.severityLevels$,
        ]).pipe(switchMap(([page, size, origins, levels]) => {
            this.isLoadingSubject.next(true);
            return this.notificationHttpService
                .getNotifications(Object.assign(Object.assign({ toDate: page.createdOn && new Date(toISOExtendedFormat(page.createdOn)).toISOString().replace(/\.\d+Z/, 'Z'), from: page.from, size }, (origins.length && { origins })), (levels.length && { levels })), 'response')
                .pipe(tap(res => {
                this.totalCountSubject.next(Number(res.headers.get('x-total-count') || '0'));
            }), map(({ body, headers }) => ({ data: body || [], headers, error: undefined })), catchError(error => of({ data: [], headers: undefined, error })), finalize(() => {
                this.isLoadingSubject.next(false);
            }));
        }), share());
        this.notificationsPage$ = this.notificationsRequest$.pipe(map(({ data }) => data));
        this.markAllNotificationsAsRead = new BehaviorSubject(false);
        /**
         * Stream of notifications
         */
        this.notifications$ = combineLatest([
            zip(this.page$, this.notificationsPage$).pipe(
            // reset accumulator for every first page in Append mode or for every page in regular mode
            scan((allNotifications, [page, notifications]) => (!page.append || page.from === 0 ? [] : allNotifications).concat(notifications), [])),
            this.markAllNotificationsAsRead.pipe(startWith(true), filter(Boolean)),
        ]).pipe(withLatestFrom(this.markAllNotificationsAsRead), 
        // eslint-disable-next-line arrow-body-style
        map(([[notifications], allAsRead]) => {
            return allAsRead ? notifications.map(item => (!item.read && Object.assign(Object.assign({}, item), { read: true })) || item) : notifications;
        }));
        /**
         * Stream of errors
         */
        this.error$ = this.notificationsRequest$.pipe(map(({ error }) => error), distinctUntilChanged());
    }
    loadPageData(page, append = false, createdOn) {
        this.pageSubject.next({ from: page, append, createdOn: createdOn });
    }
    /**
     * Method to load notifications of specified page
     *
     * @param page Page number
     */
    loadPage(page) {
        this.loadPageData(page);
    }
    /**
     * Method to load next page of notifications
     *
     * @param page Page number
     * @param createdOn Created on notification date
     */
    loadMore(page, createdOn) {
        this.loadPageData(page, true, createdOn);
    }
    /**
     * Mark all notifications as read
     *
     * @param read Is read flag
     */
    markAllAsRead(read) {
        this.markAllNotificationsAsRead.next(read);
    }
}
/** @nocollapse */ NotificationsPaginationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPaginationService, deps: [{ token: i1$1.NotificationsHttpService }, { token: WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPaginationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPaginationService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPaginationService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.NotificationsHttpService }, { type: WidgetPropertiesService }]; } });

class NotificationsDataService {
    constructor(notificationHttpService, notificationsPollingService) {
        this.notificationHttpService = notificationHttpService;
        this.notificationsPollingService = notificationsPollingService;
        this.markAllNotificationAsReadErrorSubject = new BehaviorSubject(false);
        /**
         * Mark all notification as read error subject
         */
        this.markAllNotificationAsReadError = this.markAllNotificationAsReadErrorSubject
            .asObservable()
            .pipe(finalize(() => this.markAllNotificationAsReadErrorSubject.next(false)));
    }
    /**
     *
     * Method to mark a notification as read by its id
     *
     * @param notificationId Notification
     * @returns  Mark as read stream
     */
    markNotificationAsRead(notificationId) {
        return this.notificationHttpService
            .putMarkAsRead({ id: notificationId, markAsReadPutRequestBody: { read: true } })
            .pipe(tap(() => {
            this.notificationsPollingService.forceUpdateCounters();
        }));
    }
    /**
     * Mark all notifications as read
     *
     * @returns Mark all notifications as read stream
     */
    markAllNotificationAsRead() {
        return this.notificationHttpService.putRead(undefined).pipe(catchError(() => {
            this.markAllNotificationAsReadErrorSubject.next(true);
            return EMPTY;
        }), tap(() => {
            this.markAllNotificationAsReadErrorSubject.next(false);
            this.notificationsPollingService.forceUpdateCounters();
        }));
    }
    /**
     * @param id Delete notification by id
     * @returns Notification delete stream
     */
    deleteNotification(id) {
        return this.notificationHttpService.deleteNotification({ id });
    }
}
/** @nocollapse */ NotificationsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsDataService, deps: [{ token: i1$1.NotificationsHttpService }, { token: NotificationsPollingService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsDataService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsDataService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.NotificationsHttpService }, { type: NotificationsPollingService }]; } });

class NotificationsRouterService {
    constructor() {
        this.notificationsSettingsOpenedSubject = new Subject();
        /**
         * Settings opened navigation subject
         */
        this.settingsOpenedNavigation$ = this.notificationsSettingsOpenedSubject.asObservable();
        this.notificationRoutingSubject = new Subject();
        /**
         * Notification routing subject
         */
        this.notificationRouting$ = this.notificationRoutingSubject.asObservable();
    }
    /**
     * Emit notification settings navigation
     */
    emitSettingsOpenedNavigation() {
        this.notificationsSettingsOpenedSubject.next();
    }
    /**
     * Emit notification routing
     *
     * @param routing Routing subject
     */
    emitNotificationRouting(routing) {
        this.notificationRoutingSubject.next(routing);
    }
}
/** @nocollapse */ NotificationsRouterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsRouterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsRouterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsRouterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsRouterService, decorators: [{
            type: Injectable
        }] });

var NotificationSeverity;
(function (NotificationSeverity) {
    NotificationSeverity["Alert"] = "ALERT";
    NotificationSeverity["Warning"] = "WARNING";
    NotificationSeverity["Info"] = "INFO";
    NotificationSeverity["Success"] = "SUCCESS";
})(NotificationSeverity || (NotificationSeverity = {}));

const severityLevelIconMap = {
    [NotificationSeverity.Success]: {
        icon: 'success',
        color: 'success',
    },
    [NotificationSeverity.Info]: {
        icon: 'info',
        color: 'primary',
    },
    [NotificationSeverity.Alert]: {
        icon: 'info',
        color: 'danger',
    },
    [NotificationSeverity.Warning]: {
        icon: 'warning',
        color: 'warning',
    },
};

const DEFAULT_FORMAT_FOR_DATE_IN_PAST = 'MM/dd/yy';
class HumanizedDateComponent {
    constructor() {
        this._isWithinHour = false;
        this._isToday = false;
        this._isYesterday = false;
        /**
         * Flag that defines if we should display relative time for today.
         */
        this.displayRelativeTime = false;
        this.today = new Date();
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        this.yesterday = yesterday;
    }
    /**
     * Notification date.
     */
    set date(value) {
        const date = this.parseDate(value);
        if (date) {
            this._date = date;
            this.setDateFlags();
        }
        else {
            this.resetStateToDefaults();
        }
    }
    get dateFormatForPast() {
        return this.dateFormat || DEFAULT_FORMAT_FOR_DATE_IN_PAST;
    }
    /**
     * Date getter.
     */
    // eslint-disable-next-line @typescript-eslint/adjacent-overload-signatures
    get date() {
        return this._date;
    }
    /**
     *
     * Is date within an hour from now flag getter.
     */
    get isWithinHour() {
        return this._isWithinHour;
    }
    /**
     * Is date within the current day flag getter.
     */
    get isToday() {
        return this._isToday;
    }
    /**
     * Is date within the yesterday date flag getter.
     */
    get isYesterday() {
        return this._isYesterday;
    }
    /**
     * How many minutes from now is the date getter.
     */
    get minutesFromNow() {
        return this._minutesFromNow;
    }
    setDateFlags() {
        this._minutesFromNow = this.getMinutesFromNow(this._date, this.today);
        this._isToday = this.isSameDay(this._date, this.today);
        this._isYesterday = this.isSameDay(this._date, this.yesterday);
        this._isWithinHour = Number(this.minutesFromNow) < 60;
    }
    resetStateToDefaults() {
        this._date = undefined;
        this._minutesFromNow = undefined;
        this._isWithinHour = false;
        this._isToday = false;
        this._isYesterday = false;
    }
    parseDate(value) {
        if (typeof value === 'undefined' || value instanceof Date)
            return value;
        return new Date(toISOExtendedFormat(value)).valueOf() ? new Date(toISOExtendedFormat(value)) : undefined;
    }
    isSameDay(date1, date2) {
        if (!date1 || !date2) {
            return false;
        }
        return date1.toDateString() === date2.toDateString();
    }
    getMinutesFromNow(dateTime, currentDateTime) {
        const minutesFromNow = Math.floor((currentDateTime.getTime() - dateTime.getTime()) / 60000);
        return minutesFromNow > 0 ? minutesFromNow : 0;
    }
}
/** @nocollapse */ HumanizedDateComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ HumanizedDateComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: HumanizedDateComponent, selector: "bb-humanized-date", inputs: { dateFormat: "dateFormat", displayRelativeTime: "displayRelativeTime", date: "date" }, ngImport: i0, template: "<ng-container bbHumanizedDateCustomizable [bbHostRef]=\"this\"></ng-container>\n\n<ng-template bbHumanizedDateCustomizable let-hostRef>\n  <div class=\"sr-only\" i18n=\"Humanized date title@@humanized.date.title\">,Date:</div>\n  <ng-container *ngIf=\"hostRef.date as date\">\n    <time *ngIf=\"hostRef.isToday\" class=\"bb-subheader bb-subheader--regular bb-text-nowrap\">\n      <ng-container *ngIf=\"hostRef.displayRelativeTime; else today\">\n        <ng-container\n          *ngIf=\"hostRef.isWithinHour; else moreThanHourAgo\"\n          i18n=\"Notifications time less than an hour ago date@@notifications.humanized-date.less-than-an-hour-ago\"\n        >\n          { hostRef.minutesFromNow, plural, =0 {now} other {{{hostRef.minutesFromNow}} min ago} }\n        </ng-container>\n\n        <ng-template #moreThanHourAgo>\n          {{ date | bbDate: 'shortTime' }}\n        </ng-template>\n      </ng-container>\n\n      <ng-template #today i18n=\"Notifications today date@@notifications.humanized-date.today\"> today </ng-template>\n    </time>\n\n    <time\n      *ngIf=\"hostRef.isYesterday\"\n      class=\"bb-subheader bb-subheader--regular\"\n      i18n=\"Notifications yesterday date@@notifications.humanized-date.yesterday\"\n    >\n      yesterday\n    </time>\n    <time\n      *ngIf=\"!hostRef.isToday && !hostRef.isYesterday\"\n      class=\"bb-subheader bb-subheader--regular\"\n      [attr.aria-label]=\"date | bbDate: 'mediumDate'\"\n    >\n      {{ date | bbDate: dateFormatForPast }}\n    </time>\n  </ng-container>\n</ng-template>\n", directives: [{ type: i0.forwardRef(function () { return HumanizedDateCustomizableDirective; }), selector: "[bbHumanizedDateCustomizable]" }, { type: i0.forwardRef(function () { return i14.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "bbDate": i0.forwardRef(function () { return i2.BbDatePipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-humanized-date',
                    templateUrl: './humanized-date.component.html',
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { dateFormat: [{
                type: Input
            }], displayRelativeTime: [{
                type: Input
            }], date: [{
                type: Input
            }] } });
class HumanizedDateCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ HumanizedDateCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ HumanizedDateCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: HumanizedDateCustomizableDirective, selector: "[bbHumanizedDateCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbHumanizedDateCustomizable]',
                }]
        }] });

class NotificationsListItemComponent {
    constructor(properties) {
        this.properties = properties;
        /**
         * The unique ID HTML property for each component instance.
         */
        this.id = `bb-notifications-badge-list-item-${NotificationsListItemComponent.idCounter++}`;
        /**
         * Event to open notification details.
         */
        this.openDetails = new EventEmitter();
        /**
         * Stream of widget property with the number of lines to show as a notification message.
         */
        this.notificationsMessageLineAmount$ = this.properties.notificationsMessageLineAmount$;
        /**
         * Stream of widget property with a flag that defines if we should display relative time for today.
         */
        this.displayRelativeTime$ = this.properties.displayRelativeTime$;
        /*
         * Stream of widget property with a flag that defines if we should display relative time for today.
         */
        this.displayShowMoreButtonInBadge$ = this.properties.displayShowMoreButtonInBadge$;
        /**
         * Notifications severity map
         */
        this.levelMap = severityLevelIconMap;
    }
    /**
     * Getter for icon name from severity level icon map due to level of notification.
     */
    get icon() {
        return this.levelMap[this.notification.level].icon;
    }
    /**
     * Getter for icon color from severity level icon map due to level of notification.
     */
    get color() {
        return this.levelMap[this.notification.level].color;
    }
    /**
     * Method to open notification details from the parent component.
     *
     * @param event Click event
     */
    openNotificationDetails(event) {
        event.stopPropagation();
        this.openDetails.emit(event);
    }
}
NotificationsListItemComponent.idCounter = 0;
/** @nocollapse */ NotificationsListItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListItemComponent, deps: [{ token: WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsListItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsListItemComponent, selector: "bb-notifications-list-item", inputs: { notification: "notification", dateFormat: "dateFormat" }, outputs: { openDetails: "openDetails" }, ngImport: i0, template: "<ng-container\n  bbNotificationsListItemCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    notificationsMessageLineAmount: notificationsMessageLineAmount$ | async\n  }\"\n></ng-container>\n\n<ng-template\n  bbNotificationsListItemCustomizable\n  let-hostRef\n  let-notificationsMessageLineAmount=\"context.notificationsMessageLineAmount\"\n>\n  <div\n    tabindex=\"0\"\n    class=\"bb-notifications-badge-list-item bb-notification bb-notification--flush\"\n    data-role=\"notifications-list-item\"\n    [class.bb-notifications-badge-list-item--unread]=\"!hostRef.notification.read\"\n  >\n    <span\n      class=\"sr-only\"\n      i18n=\"Notification item read/unread status@@notifications.list.notification-details.read-unread-status\"\n    >\n      { hostRef.notification.read, select, true { viewed } false { new } } notification,\n    </span>\n    <span\n      class=\"sr-only\"\n      i18n=\"Notification item severity level@@notifications.list.notification-details.read-unread-status\"\n    >\n      { hostRef.notification.level, select, ALERT { Alert } INFO { Info } SUCCESS { Success } WARNING { Warning } },\n    </span>\n    <bb-icon-ui\n      [name]=\"hostRef.icon\"\n      [color]=\"hostRef.color\"\n      class=\"bb-notification__icon\"\n      data-role=\"notifications-list-item-severity-level-icon\"\n    ></bb-icon-ui>\n    <div class=\"bb-notifications-badge-list-item__body bb-notification__body\">\n      <div\n        class=\"bb-notifications-badge-list-item__header bb-notification__title bb-stack\"\n        data-role=\"notification-heading\"\n      >\n        <bb-ellipsis-ui\n          class=\"bb-notifications-badge-list-item__title bb-stack__item bb-text-align-left\"\n          data-role=\"notifications-list-item-title\"\n        >\n          <span [innerHTML]=\"hostRef.notification | notificationLocalization: 'title'\"></span>\n        </bb-ellipsis-ui>\n        <bb-humanized-date\n          class=\"bb-stack__item bb-stack__item--push-right\"\n          [date]=\"hostRef.notification.createdOn\"\n          [displayRelativeTime]=\"hostRef.displayRelativeTime$ | async\"\n          data-role=\"notification-list-item-creation-date\"\n          [dateFormat]=\"dateFormat\"\n        ></bb-humanized-date>\n      </div>\n      <bb-ellipsis-ui\n        data-role=\"notifications-list-item-content\"\n        aria-hidden=\"true\"\n        class=\"bb-notifications-badge-list-item__content bb-text-align-left bb-stack bb-block bb-block--sm\"\n        [tooltipTriggers]=\"''\"\n        [lineClamp]=\"notificationsMessageLineAmount\"\n      >\n        <div\n          #notificationMessage\n          [innerHTML]=\"\n            hostRef.notification | notificationLocalization: 'message' | interpolateLink: hostRef.notification:false\n          \"\n        ></div>\n      </bb-ellipsis-ui>\n      <button\n        type=\"button\"\n        data-role=\"notifications-list-item-show-more-button\"\n        *ngIf=\"hostRef.displayShowMoreButtonInBadge$ | async\"\n        class=\"btn-link-text bb-text-bold bb-block bb-block--sm\"\n        (click)=\"hostRef.openNotificationDetails($event)\"\n        aria-label=\"See more notification details\"\n        i18n=\"Notification badge See more button@@notifications.list.see-more.button\"\n        i18n-aria-label=\"Aria-label for See more button@@notifications.list.see-more.button.aria-label\"\n      >\n        <span>See more</span>\n      </button>\n      <bb-notifications-capability-icon\n        aria-hidden=\"true\"\n        [origin]=\"hostRef.notification?.origin\"\n      ></bb-notifications-capability-icon>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return i3.EllipsisComponent; }), selector: "bb-ellipsis-ui", inputs: ["text", "tooltipTriggers", "lineClamp"] }, { type: i0.forwardRef(function () { return HumanizedDateComponent; }), selector: "bb-humanized-date", inputs: ["dateFormat", "displayRelativeTime", "date"] }, { type: i0.forwardRef(function () { return i5.NotificationsCapabilityIconComponent; }), selector: "bb-notifications-capability-icon", inputs: ["origin"] }], directives: [{ type: i0.forwardRef(function () { return NotificationListItemCustomizableDirective; }), selector: "[bbNotificationsListItemCustomizable]" }, { type: i0.forwardRef(function () { return i14.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i0.forwardRef(function () { return i14.AsyncPipe; }), "notificationLocalization": i0.forwardRef(function () { return i5.ӨNotificationLocalizationPipe; }), "interpolateLink": i0.forwardRef(function () { return i5.ӨInterpolateLinkPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-list-item',
                    templateUrl: './notifications-list-item.component.html',
                }]
        }], ctorParameters: function () { return [{ type: WidgetPropertiesService }]; }, propDecorators: { notification: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], openDetails: [{
                type: Output
            }] } });
class NotificationListItemCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationListItemCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationListItemCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationListItemCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationListItemCustomizableDirective, selector: "[bbNotificationsListItemCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationListItemCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsListItemCustomizable]',
                }]
        }] });

class NotificationDetailsItemComponent {
    constructor(properties) {
        this.properties = properties;
        /**
         * Notifications severity map
         */
        this.levelMap = severityLevelIconMap;
        /**
         * Stream of a flag that defines if we should display relative time for today.
         */
        this.displayRelativeTime$ = this.properties.displayRelativeTime$;
    }
    /**
     * Getter for icon name from severity level icon map due to level of notification.
     */
    get icon() {
        return this.levelMap[this.notification.level].icon;
    }
    /**
     * Getter for icon color from severity level icon map due to level of notification.
     */
    get color() {
        return this.levelMap[this.notification.level].color;
    }
}
/** @nocollapse */ NotificationDetailsItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsItemComponent, deps: [{ token: WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationDetailsItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationDetailsItemComponent, selector: "bb-notification-details-item", inputs: { notification: "notification", dateFormat: "dateFormat" }, ngImport: i0, template: "<ng-container bbNotificationDetailsItemCustomizable [bbHostRef]=\"this\"></ng-container>\n\n<ng-template bbNotificationDetailsItemCustomizable let-hostRef>\n  <div class=\"bb-notification bb-notification--flush\">\n    <bb-icon-ui\n      class=\"bb-notification__icon\"\n      [name]=\"hostRef.icon\"\n      [color]=\"hostRef.color\"\n      data-role=\"notification-details-icon\"\n    ></bb-icon-ui>\n    <div class=\"bb-notification__body\">\n      <div class=\"bb-notification__title bb-stack\">\n        <span\n          class=\"bb-stack__item break-word bb-text-default\"\n          data-role=\"notification-details-title\"\n          [innerHTML]=\"hostRef.notification | notificationLocalization: 'title'\"\n        ></span>\n        <bb-humanized-date\n          class=\"bb-stack__item bb-stack__item--push-right\"\n          [date]=\"hostRef.notification.createdOn\"\n          [displayRelativeTime]=\"hostRef.displayRelativeTime$ | async\"\n          [dateFormat]=\"dateFormat\"\n          data-role=\"notification-details-message\"\n        ></bb-humanized-date>\n      </div>\n      <div class=\"bb-stack bb-block bb-block--sm\">\n        <div\n          data-role=\"notification-details-message-text\"\n          class=\"break-word bb-text-align-left\"\n          [innerHTML]=\"\n            hostRef.notification | notificationLocalization: 'message' | interpolateLink: hostRef.notification\n          \"\n        ></div>\n      </div>\n      <bb-notifications-capability-icon [origin]=\"hostRef.notification?.origin\"></bb-notifications-capability-icon>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return HumanizedDateComponent; }), selector: "bb-humanized-date", inputs: ["dateFormat", "displayRelativeTime", "date"] }, { type: i0.forwardRef(function () { return i5.NotificationsCapabilityIconComponent; }), selector: "bb-notifications-capability-icon", inputs: ["origin"] }], directives: [{ type: i0.forwardRef(function () { return NotificationDetailsItemCustomizableDirective; }), selector: "[bbNotificationDetailsItemCustomizable]" }], pipes: { "notificationLocalization": i0.forwardRef(function () { return i5.ӨNotificationLocalizationPipe; }), "async": i0.forwardRef(function () { return i14.AsyncPipe; }), "interpolateLink": i0.forwardRef(function () { return i5.ӨInterpolateLinkPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notification-details-item',
                    templateUrl: './notification-details-item.component.html',
                }]
        }], ctorParameters: function () { return [{ type: WidgetPropertiesService }]; }, propDecorators: { notification: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }] } });
class NotificationDetailsItemCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationDetailsItemCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsItemCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationDetailsItemCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationDetailsItemCustomizableDirective, selector: "[bbNotificationDetailsItemCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsItemCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationDetailsItemCustomizable]',
                }]
        }] });

class NotificationDetailsComponent {
    constructor() {
        /**
         * Event to navigate back to notifications list.
         */
        this.navigateBack = new EventEmitter();
        /**
         * Event to delete notification.
         */
        this.delete = new EventEmitter();
    }
    /**
     * Method to emit delete notification event.
     */
    deleteNotification() {
        this.delete.emit();
    }
}
/** @nocollapse */ NotificationDetailsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationDetailsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationDetailsComponent, selector: "bb-notification-details", inputs: { notification: "notification", dateFormat: "dateFormat" }, outputs: { navigateBack: "navigateBack", delete: "delete" }, ngImport: i0, template: "<ng-container bbNotificationDetailsCustomizable [bbHostRef]=\"this\"> </ng-container>\n\n<ng-template bbNotificationDetailsCustomizable let-hostRef>\n  <div role=\"dialog\" aria-modal=\"false\">\n    <div class=\"bb-card__header\">\n      <div class=\"bb-notifications-badge-widget__back-button bb-stack\">\n        <button\n          bbFocus\n          bbButton\n          color=\"link-text\"\n          class=\"bb-stack__item--push-left\"\n          data-role=\"notification-details-go-back-btn\"\n          (click)=\"hostRef.navigateBack.emit()\"\n        >\n          <bb-icon-ui name=\"arrow-back\" color=\"info\"></bb-icon-ui>\n          <span i18n=\"Notifications details Go back button@@notifications.details.go-back-button\">\n            Back to notifications\n          </span>\n        </button>\n        <button\n          bbButton\n          class=\"bb-stack__item--push-right\"\n          color=\"link\"\n          circle=\"true\"\n          aria-label=\"delete\"\n          i18n-aria-label=\"delete aria-label@@notifications.details.delete-button-aria-label\"\n          bbTooltip=\"Delete\"\n          container=\"body\"\n          i18n-bbTooltip=\"Delete|Button text to delete notification@@notifications.details.delete-button\"\n          triggers=\"hover\"\n          placement=\"top\"\n          data-role=\"notification-details-delete-btn\"\n          (click)=\"hostRef.deleteNotification()\"\n        >\n          <bb-icon-ui name=\"delete\" class=\"bb-text-support\"></bb-icon-ui>\n        </button>\n      </div>\n    </div>\n    <div class=\"bb-block bb-block--lg\">\n      <bb-notification-details-item\n        [notification]=\"hostRef.notification\"\n        [dateFormat]=\"dateFormat\"\n      ></bb-notification-details-item>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return NotificationDetailsItemComponent; }), selector: "bb-notification-details-item", inputs: ["notification", "dateFormat"] }], directives: [{ type: i0.forwardRef(function () { return NotificationDetailsCustomizableDirective; }), selector: "[bbNotificationDetailsCustomizable]" }, { type: i0.forwardRef(function () { return i3$1.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i0.forwardRef(function () { return i4.FocusDirective; }), selector: "[bbFocus]", inputs: ["bbFocus"], exportAs: ["bbFocus"] }, { type: i0.forwardRef(function () { return i5$1.TooltipDirective; }), selector: "[bbTooltip]", inputs: ["bbTooltip", "triggers"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notification-details',
                    templateUrl: './notification-details.component.html',
                }]
        }], propDecorators: { notification: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }], navigateBack: [{
                type: Output
            }], delete: [{
                type: Output
            }] } });
class NotificationDetailsCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationDetailsCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationDetailsCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationDetailsCustomizableDirective, selector: "[bbNotificationDetailsCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationDetailsCustomizable]',
                }]
        }] });

const NOTIFICATIONS_BADGE_RELOAD_ON_NAVIGATE_EVENT = 'bb.event.notifications-badge.reload-on-navigate';
class NotificationsListComponent {
    constructor(routerService, notificationsPaginationService, notificationsPollingService, notificationService, showNotificationService, element, properties, pubSub) {
        this.routerService = routerService;
        this.notificationsPaginationService = notificationsPaginationService;
        this.notificationsPollingService = notificationsPollingService;
        this.notificationService = notificationService;
        this.showNotificationService = showNotificationService;
        this.element = element;
        this.properties = properties;
        this.pubSub = pubSub;
        /**
         * Navigation event.
         */
        this.navigation = new EventEmitter();
        this.componentDestroyed$ = new Subject();
        /**
         * Stream of routes available for navigation.
         */
        this.allowedRoutes$ = this.properties.allowedRoutes$;
        /**
         * Stream of a flag that defines if we should display settings button.
         */
        this.displaySettingsButton$ = this.properties.displaySettingsButton$;
        /**
         * Stream with notifications items.
         */
        this.notifications$ = this.notificationsPaginationService.notifications$.pipe(takeUntil(this.componentDestroyed$), shareReplayOnce());
        /**
         * Stream with error while loading of notifications.
         */
        this.error$ = this.notificationsPaginationService.error$;
        /**
         * Stream with error while loading of notifications.
         */
        this.updateCountersError$ = this.notificationsPollingService.updateCountersError$;
        /**
         * Mark as read request error stream which shows if request has failed.
         */
        this.markAllAsReadError$ = this.notificationService.markAllNotificationAsReadError;
        /**
         * Stream with flag if notifications is loading now or no.
         */
        this.isLoading$ = this.notificationsPaginationService.isLoading$;
        this.firstNewNotificationId$ = this.notifications$.pipe(pairwise(), map(([prevNotifications, newNotifications]) => {
            let firstNewNotification = newNotifications[prevNotifications.length];
            // reset notification to the first page scenario
            if (prevNotifications.length >= newNotifications.length) {
                firstNewNotification = newNotifications[0];
            }
            return firstNewNotification && firstNewNotification.id;
        }));
        this.notificationWasReadSubject = new Subject();
        this.notificationWasRead$ = this.notificationWasReadSubject.asObservable();
        this.newNotificationsAvailableSubject = new BehaviorSubject(false);
        this.updateCounters$ = this.newNotificationsAvailableSubject.pipe(startWith(false), filter(i => !i), mapTo(true), shareReplayOnce());
        /**
         * Stream with total count of notifications.
         */
        this.totalCount$ = this.updateCounters$.pipe(switchMap(() => this.notificationsPaginationService.totalCount$));
        /**
         * Stream with notifications about new notification available
         */
        this.newNotificationsAvailable$ = this.newNotificationsAvailableSubject.asObservable();
        /**
         * Stream with page size.
         */
        this.pageSize$ = this.notificationsPaginationService.sizeProperty$;
        /**
         * Stream with unread notifications count
         */
        this.unreadCount$ = this.updateCounters$.pipe(switchMap(() => this.notificationsPollingService.unreadNotificationsCount$.pipe(switchMap(counter => this.notificationWasRead$.pipe(startWith(false), map(read => {
            if (!read || !counter) {
                return counter;
            }
            return --counter;
        }))))));
        /**
         * Steam with the starting page number.
         */
        this.pageFrom$ = this.notificationsPaginationService.pageFrom$;
    }
    /**
     * Preselected notification
     */
    set preselectedNotification(notification) {
        this.selectedNotification = notification;
    }
    ngOnInit() {
        this.firstNewNotificationId$
            .pipe(filter(Boolean), map(id => `.bb-nt-${id}`), observeOn(asyncScheduler), map(elemClass => this.element.nativeElement.querySelector(elemClass)), filter(Boolean), takeUntil(this.componentDestroyed$))
            .subscribe((elemScrollTo) => {
            var _a;
            (_a = elemScrollTo.firstChild) === null || _a === void 0 ? void 0 : _a.focus();
            elemScrollTo.scrollIntoView({ behavior: 'smooth' });
        });
        this.notificationsPollingService.newNotificationsAvailable$
            .pipe(takeUntil(this.componentDestroyed$))
            .subscribe(value => {
            this.newNotificationsAvailableSubject.next(value);
        });
        this.onLoadNewNotifications();
    }
    ngOnDestroy() {
        this.componentDestroyed$.next();
        this.componentDestroyed$.complete();
    }
    /**
     * Method to mark all notifications as read.
     */
    onReadAllNotifications() {
        this.notificationService.markAllNotificationAsRead().subscribe(() => {
            this.notificationsPaginationService.markAllAsRead(true);
        });
    }
    /**
     * Method to load new notifications by reloading of the first page.
     */
    onLoadNewNotifications() {
        this.notificationsPollingService.unreadNotificationsCount$
            .pipe(skip(1), // skip stored value to wait for unread notifications count load occurred
        first())
            .subscribe(() => {
            this.newNotificationsAvailableSubject.next(false);
            this.notificationsPaginationService.markAllAsRead(false);
            this.notificationsPaginationService.loadPage(0);
        });
        this.notificationsPollingService.forceUpdateCounters();
    }
    /**
     * Method to load next notifications page.
     */
    onLoadMore(totalCount, $event) {
        const asyncNotifications$ = this.notifications$.pipe(skipUntil(of(undefined).pipe(observeOn(asyncScheduler))));
        const lastNotification$ = this.notifications$.pipe(first(), map(notifications => notifications[notifications.length - 1]), map(({ id }) => `.bb-nt-${id} [data-role="notifications-list-item"]`), observeOn(asyncScheduler), map(selector => this.element.nativeElement.querySelector(selector)));
        this.notifications$.pipe(first()).subscribe(data => {
            const createdOn = data[0].createdOn;
            this.notificationsPaginationService.loadMore($event.from, createdOn);
        });
        combineLatest([asyncNotifications$, of(totalCount)])
            .pipe(take(1), filter(([notifications, total]) => notifications.length >= total), switchMap(() => lastNotification$))
            .subscribe(lastNotification => lastNotification.focus());
    }
    /**
     * Method to open notification settings.
     */
    onNotificationsSettingsOpen() {
        this.routerService.emitSettingsOpenedNavigation();
        this.navigation.emit();
    }
    /**
     * Method to show notification details view or to navigate to the notification routing URL if routing is enabled.
     */
    selectNotification(clickEvent, notification, openDetailsView) {
        clickEvent.preventDefault();
        this.allowedRoutes$.subscribe(routes => {
            const route = notification.routing && notification.routing['where-to'];
            if (!openDetailsView && notification.routing && routes.some(allowedRoute => route === allowedRoute)) {
                this.pubSub.publish(NOTIFICATIONS_BADGE_RELOAD_ON_NAVIGATE_EVENT, undefined);
                this.routerService.emitNotificationRouting(notification.routing);
                this.navigation.emit();
            }
            else {
                this.selectedNotification = notification;
                this.saveRefToNotification(clickEvent);
            }
        });
        if (!notification.read) {
            this.notificationService.markNotificationAsRead(notification.id).subscribe(() => {
                notification.read = true;
                this.notificationWasReadSubject.next(true);
            });
        }
    }
    /**
     * Method to delete notification.
     */
    deleteNotification() {
        if (this.selectedNotification) {
            this.notificationService
                .deleteNotification(this.selectedNotification.id)
                .pipe(take(1), tap(() => this.notificationsPaginationService.loadPage(0)))
                .subscribe(() => {
                this.selectedNotification = undefined;
            }, error => {
                this.showNotificationService.showNotification({
                    header: this.getErrorMessage(error),
                    modifier: 'error',
                    message: '',
                });
            });
        }
    }
    /**
     * Method to unselect notification and return back focus position.
     */
    unselectNotification() {
        this.selectedNotification = undefined;
        this.restoreFocusOnNotification();
    }
    /**
     * Method to differentiate notifications by IDs.
     *
     * @param _index List item index
     * @param notification Notification list item
     * @returns Notification id
     */
    trackById(_index, notification) {
        return notification.id;
    }
    saveRefToNotification(notificationClickEvent) {
        this.lastSelectedNotificationItemButton = notificationClickEvent.target.closest('[data-role="notifications-list-item"]');
    }
    restoreFocusOnNotification() {
        setTimeout(() => {
            if (!this.lastSelectedNotificationItemButton) {
                return;
            }
            this.lastSelectedNotificationItemButton.focus();
        }, 0);
    }
    getErrorMessage(error) {
        var _a, _b;
        return typeof error !== 'string'
            ? ((_b = (_a = error) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message) || error.message || 'Unknown Error'
            : error;
    }
}
/** @nocollapse */ NotificationsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListComponent, deps: [{ token: NotificationsRouterService }, { token: NotificationsPaginationService }, { token: NotificationsPollingService }, { token: NotificationsDataService }, { token: i5$2.NotificationService }, { token: i0.ElementRef }, { token: WidgetPropertiesService }, { token: PUBSUB }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsListComponent, selector: "bb-notifications-list", inputs: { preselectedNotification: "preselectedNotification", dateFormat: "dateFormat" }, outputs: { navigation: "navigation" }, ngImport: i0, template: "<ng-container\n  bbNotificationsListCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    notifications: notifications$ | async,\n    error: error$ | async,\n    updateCountersError: updateCountersError$ | async,\n    isLoading: isLoading$ | async,\n    totalCount: totalCount$ | async,\n    pageSize: pageSize$ | async,\n    newNotificationsAvailable: newNotificationsAvailable$ | async,\n    unreadCount: unreadCount$ | async,\n    markAllAsReadError: markAllAsReadError$ | async,\n    pageFrom: pageFrom$ | async\n  }\"\n>\n</ng-container>\n\n<ng-template\n  bbNotificationsListCustomizable\n  let-hostRef\n  let-notifications=\"context.notifications\"\n  let-error=\"context.error\"\n  let-updateCountersError=\"context.updateCountersError\"\n  let-isLoading=\"context.isLoading\"\n  let-totalCount=\"context.totalCount\"\n  let-pageSize=\"context.pageSize\"\n  let-newNotificationsAvailable=\"context.newNotificationsAvailable\"\n  let-unreadCount=\"context.unreadCount\"\n  let-markAllAsReadError=\"context.markAllAsReadError\"\n  let-pageFrom=\"context.pageFrom\"\n>\n  <ng-container *ngIf=\"!hostRef.selectedNotification\">\n    <header data-role=\"notifications-list-header\" class=\"bb-card__header bb-stack\">\n      <span class=\"bb-stack__item\">\n        <span class=\"bb-heading-3\" i18n=\"Notifications modal label@@notifications.modalLabel\">Notifications</span>\n      </span>\n      <button\n        bbButton\n        *ngIf=\"hostRef.displaySettingsButton$ | async\"\n        class=\"bb-stack__item bb-stack__item--push-right\"\n        data-role=\"settings-button\"\n        color=\"link\"\n        circle=\"true\"\n        aria-label=\"Redirect to notification settings\"\n        i18n-aria-label=\"Aria-label for settings button@@notifications.notification-settings.aria-label\"\n        (click)=\"hostRef.onNotificationsSettingsOpen()\"\n      >\n        <bb-icon-ui class=\"text-dark\" name=\"settings\" size=\"md\"></bb-icon-ui>\n      </button>\n    </header>\n    <button\n      bbButton\n      *ngIf=\"newNotificationsAvailable\"\n      role=\"status\"\n      color=\"primary\"\n      [block]=\"true\"\n      i18n=\"Label for new notifications loading button@@notifications.new-notifications-available.button\"\n      aria-label=\"New Notification available. Click to refresh\"\n      i18n-aria-label=\"\n        Aria-label for new notifications loading button@@notifications.new-notifications-available.aria-label\"\n      class=\"bb-notifications-badge-widget__load-new-button\"\n      data-role=\"notifications-load-new-btn\"\n      (click)=\"hostRef.onLoadNewNotifications()\"\n    >\n      <span>New Notification available. Click to refresh</span>\n      <bb-icon-ui name=\"loading\" size=\"md\" cropped=\"true\"></bb-icon-ui>\n    </button>\n    <bb-alert-ui\n      *ngIf=\"markAllAsReadError\"\n      class=\"bb-notifications-badge-widget__alert\"\n      data-role=\"mark-all-read-error-alert\"\n      title=\"Error! Couldn\u2019t mark all as read.\"\n      i18n-title=\"Label for mark all as read error@@notifications.mark-all-read.alert.title\"\n      aria-label=\"Error! Couldn\u2019t mark all as read.\"\n      i18n-aria-label=\"Aria-label for mark all as read error@@notifications.mark-all-read.alert.aria-label\"\n      modifier=\"error\"\n      [dismissible]=\"false\"\n    >\n    </bb-alert-ui>\n    <div class=\"bb-notifications-badge-widget__all-read-button\" *ngIf=\"unreadCount > 0\">\n      <button\n        bbButton\n        data-role=\"mark-all-read-button\"\n        class=\"bb-subtitle\"\n        color=\"link-text\"\n        aria-label=\"Mark all notifcations as read\"\n        i18n-aria-label=\"Aria-label for mark all as read button@@notifications.mark-all-read.aria-label\"\n        (click)=\"hostRef.onReadAllNotifications()\"\n      >\n        <bb-icon-ui name=\"playlist-add-check\" size=\"md\" cropped=\"true\"></bb-icon-ui>\n        <span i18n=\"Label for mark all as read button@@notifications.mark-all-read.label\">Mark all as read</span>\n      </button>\n    </div>\n  </ng-container>\n\n  <ng-container *ngIf=\"!error && !updateCountersError; else errorState\">\n    <ng-container *ngIf=\"notifications?.length; else emptyState\">\n      <div data-role=\"notifications-list-inner-wrapper\" [ngClass]=\"hostRef.selectedNotification ? 'd-none' : null\">\n        <p\n          aria-live=\"polite\"\n          class=\"sr-only\"\n          i18n=\"Label for new loaded notifications available@@notifications.new-loaded-notifications-available\"\n        >\n          { notifications.length, plural, =1 {new notification of {{ totalCount }}available} other {\n          {{ notifications.length }} new notifications of {{ totalCount }}available } }\n        </p>\n        <ul\n          tabindex=\"-1\"\n          class=\"bb-notifications-badge-widget__list bb-list bb-list--flush-lg\"\n          data-role=\"notifications-list-body\"\n        >\n          <li class=\"bb-list__item\" *ngFor=\"let notification of notifications; trackBy: hostRef.trackById\">\n            <bb-notifications-list-item\n              [notification]=\"notification\"\n              class=\"bb-nt-{{ notification.id }}\"\n              (keydown.enter)=\"hostRef.selectNotification($event, notification)\"\n              (keyup.space)=\"hostRef.selectNotification($event, notification)\"\n              (click)=\"hostRef.selectNotification($event, notification)\"\n              (openDetails)=\"hostRef.selectNotification($event, notification, true)\"\n              [dateFormat]=\"dateFormat\"\n            >\n            </bb-notifications-list-item>\n          </li>\n        </ul>\n\n        <footer class=\"bb-card__footer\">\n          <ng-container *ngIf=\"totalCount > pageSize\">\n            <div\n              *ngIf=\"notifications.length < totalCount; else LoadMoreDisabled\"\n              class=\"bb-button-bar bb-button-bar--center\"\n            >\n              <bb-load-button-ui\n                i18n=\"Load more button@@notifications.notification-list.load-more\"\n                class=\"bb-button-bar__button\"\n                color=\"link\"\n                [size]=\"pageSize\"\n                [from]=\"pageFrom\"\n                [totalCount]=\"totalCount\"\n                [isLoading]=\"isLoading\"\n                [block]=\"false\"\n                (paramChange)=\"hostRef.onLoadMore(totalCount, $event)\"\n              >\n                Load More\n              </bb-load-button-ui>\n            </div>\n            <ng-template #LoadMoreDisabled>\n              <div\n                data-role=\"notification-list-load-more-disabled-text\"\n                class=\"bb-subtitle bb-text-support bb-text-align-center\"\n                i18n=\"Load more disabled text@@notifications.notification-list.load-more-disabled\"\n              >\n                You\u2019ve reached the end of the list.\n              </div>\n            </ng-template>\n          </ng-container>\n        </footer>\n      </div>\n\n      <bb-notification-details\n        *ngIf=\"hostRef.selectedNotification\"\n        [notification]=\"hostRef.selectedNotification\"\n        (navigateBack)=\"hostRef.unselectNotification()\"\n        (delete)=\"hostRef.deleteNotification()\"\n        [dateFormat]=\"dateFormat\"\n      ></bb-notification-details>\n    </ng-container>\n  </ng-container>\n\n  <ng-template #emptyState>\n    <div role=\"alert\" *ngIf=\"notifications && notifications.length === 0; else loadingState\">\n      <div class=\"bb-card__body\">\n        <bb-empty-state-ui\n          data-role=\"notifications-badge-empty-state\"\n          class=\"bb-state-container\"\n          i18n-title=\"Notifications empty state message title@@notifications.state.no-notifications.title\"\n          title=\"No Notifications\"\n          iconModifier=\"notifications-off\"\n          iconSize=\"xxl\"\n          i18n-subtitle=\"Notifications empty state message@@notifications.state.no-notifications.subtitle\"\n          subtitle=\"You don't have any notifications to be displayed\"\n        ></bb-empty-state-ui>\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #errorState>\n    <div role=\"alert\">\n      <div class=\"bb-card__body\">\n        <bb-empty-state-ui\n          data-role=\"notifications-badge-error-state\"\n          class=\"bb-state-container\"\n          iconSize=\"xxl\"\n          iconModifier=\"error-outline\"\n          title=\"Notifications couldn\u2019t load\"\n          i18n-title=\"Notifications are not loading title@@notifications.error-state.title\"\n          subtitle=\"Try to reload the page or contact the system administrator.\"\n          i18n-subtitle=\"Notifications are not loading subtitle@@notifications.error-state.subtitle\"\n        >\n        </bb-empty-state-ui>\n      </div>\n    </div>\n  </ng-template>\n\n  <ng-template #loadingState>\n    <bb-loading-indicator-ui\n      loaderSize=\"md\"\n      text=\"Loading...\"\n      i18n-test=\"Loading title@@notifications.state.loading.title\"\n    ></bb-loading-indicator-ui>\n  </ng-template>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return i8.AlertComponent; }), selector: "bb-alert-ui", inputs: ["modifier", "dismissible", "title", "message"], outputs: ["close"] }, { type: i0.forwardRef(function () { return NotificationsListItemComponent; }), selector: "bb-notifications-list-item", inputs: ["notification", "dateFormat"], outputs: ["openDetails"] }, { type: i0.forwardRef(function () { return i10.LoadButtonComponent; }), selector: "bb-load-button-ui", inputs: ["isLoading", "from", "size", "circle", "totalCount"], outputs: ["paramChange"] }, { type: i0.forwardRef(function () { return NotificationDetailsComponent; }), selector: "bb-notification-details", inputs: ["notification", "dateFormat"], outputs: ["navigateBack", "delete"] }, { type: i0.forwardRef(function () { return i12.EmptyStateComponent; }), selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }, { type: i0.forwardRef(function () { return i13.LoadingIndicatorComponent; }), selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsListCustomizableDirective; }), selector: "[bbNotificationsListCustomizable]" }, { type: i0.forwardRef(function () { return i14.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i3$1.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i0.forwardRef(function () { return i14.NgClass; }), selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i0.forwardRef(function () { return i14.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i0.forwardRef(function () { return i14.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-list',
                    templateUrl: './notifications-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: NotificationsRouterService }, { type: NotificationsPaginationService }, { type: NotificationsPollingService }, { type: NotificationsDataService }, { type: i5$2.NotificationService }, { type: i0.ElementRef }, { type: WidgetPropertiesService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }]; }, propDecorators: { navigation: [{
                type: Output
            }], preselectedNotification: [{
                type: Input
            }], dateFormat: [{
                type: Input
            }] } });
class NotificationsListCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsListCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsListCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsListCustomizableDirective, selector: "[bbNotificationsListCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsListCustomizable]',
                }]
        }] });

const BADGE_FORCE_UPDATE_DEBOUNCE_TIME = 800;
/** @dynamic */
class NotificationsBadgeWidgetComponent {
    constructor(notificationsPollingService, routerService, mediaQService, properties, pubSub, document) {
        this.notificationsPollingService = notificationsPollingService;
        this.routerService = routerService;
        this.mediaQService = mediaQService;
        this.properties = properties;
        this.pubSub = pubSub;
        this.document = document;
        this.preselectedNotification$$ = new BehaviorSubject(undefined);
        /**
         * Stream of preselected notification.
         */
        this.preselectedNotification$ = this.preselectedNotification$$.asObservable();
        /**
         * Redirect to Notification Preferences on Settings button click emitter.
         */
        this.notificationsSettingsOpened = new EventEmitter();
        /**
         * Navigation data emitter.
         */
        this.notificationRouting = new EventEmitter();
        /**
         * Unique id html property for each component instance
         */
        this.id = `bb-notifications-badge-widget-${NotificationsBadgeWidgetComponent.idCounter++}`;
        this.destroy$ = new Subject();
        /**
         * Stream with count of unread notifications.
         */
        this.unreadCount$ = this.notificationsPollingService.unreadNotificationsCount$;
        /**
         * Stream that adjusts the layout to the screen size by applying different translateX values.
         */
        this.listTransform$ = this.mediaQService.isMediaBreakpointMatches('max-width', 'sm').pipe(map(isMobileView => {
            if (isMobileView) {
                const badge = this.document.querySelector('.bb-notifications-badge-widget');
                if (badge) {
                    const { width: badgeWidth, left } = badge.getBoundingClientRect();
                    const { width: bodyWidth } = this.document.body.getBoundingClientRect();
                    return `translateX(${bodyWidth - left - badgeWidth}px)`;
                }
            }
            return undefined;
        }));
        this.origins$ = this.properties.origins$;
        this.severityLevels$ = this.properties.severityLevels$;
    }
    /**
     * Preselected notification.
     */
    set preselectedNotification(notification) {
        if (!this.popover)
            return;
        this.preselectedNotification$$.next(notification);
        if (!this.popover.isOpen() && notification) {
            this.popover.open();
        }
    }
    /**
     * Number of displayed lines in notification message.
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set notificationsMessageLineAmountValue(value) {
        if (value !== undefined) {
            this.properties.setNotificationsMessageLineAmount(value);
        }
    }
    /**
     * Display time for today relative to the current point in time (time display format).
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set displayRelativeTimeValue(value) {
        if (value !== undefined) {
            this.properties.setDisplayRelativeTime(value);
        }
    }
    /**
     * Display See More button.
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set displayShowMoreButtonInBadgeValue(value) {
        if (value !== undefined) {
            this.properties.setDisplayShowMoreButtonInBadge(value);
        }
    }
    /**
     * String of allowed routes for navigation (conversation-view, arrangement-view, transaction-view, party-view, etc.).
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set allowedRoutesValue(value) {
        if (value !== undefined) {
            this.properties.setAllowedRoutes(value);
        }
    }
    /**
     * Display Settings button (button with the Gear icon that opens Notification Preferences).
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set displaySettingsButtonValue(value) {
        if (value !== undefined) {
            this.properties.setDisplaySettingsButton(value);
        }
    }
    /**
     * Limit of notifications per paginated request.
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set pageSizeValue(value) {
        if (value !== undefined) {
            this.properties.setPageSize(value);
        }
    }
    /**
     * Comma-separated list of notifications origins to process (empty for all).
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set originsValue(value) {
        if (value !== undefined) {
            this.properties.setOrigins(value);
        }
    }
    /**
     * Comma-separated list of notifications severity levels to process (empty for all).
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set severityLevelsValue(value) {
        if (value !== undefined) {
            this.properties.setSeverityLevels(value);
        }
    }
    /**
     * Interval to poll server for unread count (in seconds).
     */
    // eslint-disable-next-line @angular-eslint/no-input-rename
    set unreadCountUpdateIntervalValue(value) {
        if (value !== undefined) {
            this.properties.setUnreadCountUpdateInterval(value);
        }
    }
    ngOnInit() {
        this.setupNavigationSubscriptions();
        this.setupBadgeUpdateSubscriptions();
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * The method to clear the preselected notification value.
     *
     * @param isOpen Is notification badge open flag
     */
    onOpenChange(isOpen) {
        if (!isOpen) {
            this.preselectedNotification$$.next(undefined);
        }
    }
    setupNavigationSubscriptions() {
        this.routerService.settingsOpenedNavigation$
            .pipe(takeUntil(this.destroy$))
            .subscribe(this.notificationsSettingsOpened);
        this.routerService.notificationRouting$.pipe(takeUntil(this.destroy$)).subscribe(this.notificationRouting);
    }
    setupBadgeUpdateSubscriptions() {
        let forceUpdateCounterHandler;
        const forceUpdateCounters$ = new Subject();
        forceUpdateCounters$
            .pipe(debounceTime(BADGE_FORCE_UPDATE_DEBOUNCE_TIME), takeUntil(this.destroy$))
            .subscribe(() => this.notificationsPollingService.forceUpdateCounters());
        combineLatest([this.origins$, this.severityLevels$])
            .pipe(first())
            .subscribe(([origins, levels]) => {
            forceUpdateCounterHandler = payload => {
                if (payload &&
                    (origins.length === 0 || (payload.origin && origins.includes(payload.origin))) &&
                    (levels.length === 0 || levels.includes(payload.level))) {
                    forceUpdateCounters$.next();
                }
            };
            this.pubSub.subscribe(NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, forceUpdateCounterHandler);
        });
        this.destroy$.subscribe(() => {
            this.pubSub.unsubscribe(NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, forceUpdateCounterHandler);
        });
    }
}
NotificationsBadgeWidgetComponent.idCounter = 0;
/** @nocollapse */ NotificationsBadgeWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetComponent, deps: [{ token: NotificationsPollingService }, { token: NotificationsRouterService }, { token: i3$2.MediaQueryService }, { token: WidgetPropertiesService }, { token: PUBSUB }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsBadgeWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsBadgeWidgetComponent, selector: "bb-notifications-badge-widget", inputs: { preselectedNotification: "preselectedNotification", notificationsMessageLineAmountValue: ["notificationsMessageLineAmount", "notificationsMessageLineAmountValue"], displayRelativeTimeValue: ["displayRelativeTime", "displayRelativeTimeValue"], displayShowMoreButtonInBadgeValue: ["displayShowMoreButtonInBadge", "displayShowMoreButtonInBadgeValue"], allowedRoutesValue: ["allowedRoutes", "allowedRoutesValue"], displaySettingsButtonValue: ["displaySettingsButton", "displaySettingsButtonValue"], pageSizeValue: ["pageSize", "pageSizeValue"], originsValue: ["origins", "originsValue"], severityLevelsValue: ["severityLevels", "severityLevelsValue"], unreadCountUpdateIntervalValue: ["unreadCountUpdateInterval", "unreadCountUpdateIntervalValue"], dateFormat: "dateFormat" }, outputs: { notificationsSettingsOpened: "notificationsSettingsOpened", notificationRouting: "notificationRouting" }, providers: [
        NotificationsPaginationService,
        NotificationsDataService,
        NotificationsPollingService,
        NotificationsRouterService,
        WidgetPropertiesService,
        NotificationsPaginationService,
    ], viewQueries: [{ propertyName: "popover", first: true, predicate: ["popover"], descendants: true }], ngImport: i0, template: "<ng-container\n  bbNotificationsBadgeCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    unreadCount: unreadCount$ | async,\n    listTransform: listTransform$ | async\n  }\"\n>\n</ng-container>\n<ng-template\n  bbNotificationsBadgeCustomizable\n  let-hostRef\n  let-unreadCount=\"context.unreadCount\"\n  let-listTransform=\"context.listTransform\"\n>\n  <div class=\"bb-notifications-badge-widget\">\n    <div #popover=\"ngbDropdown\" ngbDropdown placement=\"bottom-right\" (openChange)=\"hostRef.onOpenChange($event)\">\n      <button\n        bbButton\n        [attr.aria-labelledby]=\"'notifications-badge-label' + hostRef.id\"\n        color=\"transparent\"\n        class=\"bb-notifications-badge-widget__dropdown-button\"\n        ngbDropdownToggle\n      >\n        <bb-icon-ui name=\"notifications\" color=\"secondary\" data-role=\"notifications-icon\" size=\"lg\"></bb-icon-ui>\n        <bb-badge-counter-ui\n          class=\"bb-notifications-badge-widget__dropdown-button-counter\"\n          [count]=\"unreadCount\"\n          maxCount=\"99\"\n          color=\"danger\"\n          data-role=\"notifications-unread-count\"\n        ></bb-badge-counter-ui>\n      </button>\n      <div\n        ngbDropdownMenu\n        class=\"bb-notifications-badge-widget__dropdown-menu dropdown-menu-unstyled\"\n        data-role=\"notifications-list-wrapper\"\n      >\n        <div\n          class=\"bb-notifications-badge-widget__dropdown-menu-list\"\n          data-role=\"notifications-dropdown-menu-list\"\n          [style.transform]=\"listTransform\"\n        >\n          <div class=\"bb-card bb-notifications-badge-widget__list-wrapper\">\n            <bb-notifications-list\n              *ngIf=\"popover.isOpen()\"\n              (navigation)=\"popover.close()\"\n              [preselectedNotification]=\"hostRef.preselectedNotification$ | async\"\n              [dateFormat]=\"dateFormat\"\n            ></bb-notifications-list>\n          </div>\n        </div>\n      </div>\n      <span\n        i18n=\"Notifications badge aria label@notifications.badge.aria-label\"\n        [attr.id]=\"'notifications-badge-label' + hostRef.id\"\n        aria-live=\"polite\"\n        aria-relevant=\"text\"\n        class=\"sr-only\"\n      >\n        { unreadCount || 0, plural, =0 { no new notifications } =1 { {{ unreadCount }} new notification} other {\n        {{ unreadCount }} new notifications } }\n      </span>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2$1.IconComponent; }), selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i0.forwardRef(function () { return i6.BadgeCounterComponent; }), selector: "bb-badge-counter-ui", inputs: ["color", "count", "maxCount"] }, { type: i0.forwardRef(function () { return NotificationsListComponent; }), selector: "bb-notifications-list", inputs: ["preselectedNotification", "dateFormat"], outputs: ["navigation"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsBadgeWidgetCustomizableDirective; }), selector: "[bbNotificationsBadgeCustomizable]" }, { type: i0.forwardRef(function () { return i8$1.NgbDropdown; }), selector: "[ngbDropdown]", inputs: ["open", "placement", "container", "autoClose", "display", "dropdownClass"], outputs: ["openChange"], exportAs: ["ngbDropdown"] }, { type: i0.forwardRef(function () { return i3$1.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i0.forwardRef(function () { return i8$1.NgbDropdownToggle; }), selector: "[ngbDropdownToggle]" }, { type: i0.forwardRef(function () { return i8$1.NgbDropdownMenu; }), selector: "[ngbDropdownMenu]" }, { type: i0.forwardRef(function () { return i14.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], pipes: { "async": i0.forwardRef(function () { return i14.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-badge-widget',
                    templateUrl: './notifications-badge-widget.component.html',
                    providers: [
                        NotificationsPaginationService,
                        NotificationsDataService,
                        NotificationsPollingService,
                        NotificationsRouterService,
                        WidgetPropertiesService,
                        NotificationsPaginationService,
                    ],
                }]
        }], ctorParameters: function () { return [{ type: NotificationsPollingService }, { type: NotificationsRouterService }, { type: i3$2.MediaQueryService }, { type: WidgetPropertiesService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }, { type: Document, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { preselectedNotification: [{
                type: Input
            }], notificationsMessageLineAmountValue: [{
                type: Input,
                args: ['notificationsMessageLineAmount']
            }], displayRelativeTimeValue: [{
                type: Input,
                args: ['displayRelativeTime']
            }], displayShowMoreButtonInBadgeValue: [{
                type: Input,
                args: ['displayShowMoreButtonInBadge']
            }], allowedRoutesValue: [{
                type: Input,
                args: ['allowedRoutes']
            }], displaySettingsButtonValue: [{
                type: Input,
                args: ['displaySettingsButton']
            }], pageSizeValue: [{
                type: Input,
                args: ['pageSize']
            }], originsValue: [{
                type: Input,
                args: ['origins']
            }], severityLevelsValue: [{
                type: Input,
                args: ['severityLevels']
            }], unreadCountUpdateIntervalValue: [{
                type: Input,
                args: ['unreadCountUpdateInterval']
            }], dateFormat: [{
                type: Input
            }], notificationsSettingsOpened: [{
                type: Output
            }], notificationRouting: [{
                type: Output
            }], popover: [{
                type: ViewChild,
                args: ['popover']
            }] } });
class NotificationsBadgeWidgetCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsBadgeWidgetCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsBadgeWidgetCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsBadgeWidgetCustomizableDirective, selector: "[bbNotificationsBadgeCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsBadgeCustomizable]',
                }]
        }] });

class HumanizedDateModule {
}
/** @nocollapse */ HumanizedDateModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ HumanizedDateModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateModule, declarations: [HumanizedDateComponent, HumanizedDateCustomizableDirective], imports: [CommonModule, BbDatePipeModule], exports: [HumanizedDateComponent, HumanizedDateCustomizableDirective] });
/** @nocollapse */ HumanizedDateModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateModule, imports: [[CommonModule, BbDatePipeModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: HumanizedDateModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, BbDatePipeModule],
                    declarations: [HumanizedDateComponent, HumanizedDateCustomizableDirective],
                    exports: [HumanizedDateComponent, HumanizedDateCustomizableDirective],
                }]
        }] });

const uiModules$3 = [BbDatePipeModule, EllipsisModule];
const innerModules$3 = [HumanizedDateModule];
const components$3 = [NotificationsListItemComponent, NotificationListItemCustomizableDirective];
class NotificationsListItemModule {
}
/** @nocollapse */ NotificationsListItemModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListItemModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NotificationsListItemModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListItemModule, declarations: [NotificationsListItemComponent, NotificationListItemCustomizableDirective], imports: [CommonModule, NotificationsCommonModule, BbDatePipeModule, EllipsisModule, HumanizedDateModule], exports: [NotificationsCommonModule, BbDatePipeModule, EllipsisModule, HumanizedDateModule, NotificationsListItemComponent, NotificationListItemCustomizableDirective] });
/** @nocollapse */ NotificationsListItemModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListItemModule, imports: [[CommonModule, NotificationsCommonModule, ...uiModules$3, ...innerModules$3], NotificationsCommonModule, BbDatePipeModule, EllipsisModule, HumanizedDateModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListItemModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NotificationsCommonModule, ...uiModules$3, ...innerModules$3],
                    declarations: [...components$3],
                    exports: [NotificationsCommonModule, ...uiModules$3, ...innerModules$3, ...components$3],
                }]
        }] });

const uiModules$2 = [ButtonModule, FocusModule, EllipsisModule, TooltipModule];
const innerModules$2 = [HumanizedDateModule];
const components$2 = [
    NotificationDetailsComponent,
    NotificationDetailsCustomizableDirective,
    NotificationDetailsItemComponent,
    NotificationDetailsItemCustomizableDirective,
];
class NotificationDetailsModule {
}
/** @nocollapse */ NotificationDetailsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NotificationDetailsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsModule, declarations: [NotificationDetailsComponent,
        NotificationDetailsCustomizableDirective,
        NotificationDetailsItemComponent,
        NotificationDetailsItemCustomizableDirective], imports: [CommonModule, NotificationsCommonModule, ButtonModule, FocusModule, EllipsisModule, TooltipModule, HumanizedDateModule], exports: [NotificationsCommonModule, ButtonModule, FocusModule, EllipsisModule, TooltipModule, HumanizedDateModule, NotificationDetailsComponent,
        NotificationDetailsCustomizableDirective,
        NotificationDetailsItemComponent,
        NotificationDetailsItemCustomizableDirective] });
/** @nocollapse */ NotificationDetailsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsModule, imports: [[CommonModule, NotificationsCommonModule, ...uiModules$2, ...innerModules$2], NotificationsCommonModule, ButtonModule, FocusModule, EllipsisModule, TooltipModule, HumanizedDateModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationDetailsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NotificationsCommonModule, ...uiModules$2, ...innerModules$2],
                    declarations: [...components$2],
                    exports: [NotificationsCommonModule, ...uiModules$2, ...innerModules$2, ...components$2],
                }]
        }] });

const uiModules$1 = [
    EmptyStateModule,
    ErrorCommonStateModule,
    LoadButtonModule,
    LoadingIndicatorModule,
    ButtonModule,
    AlertModule,
];
const innerModules$1 = [NotificationsListItemModule, NotificationDetailsModule];
const components$1 = [NotificationsListComponent, NotificationsListCustomizableDirective];
class NotificationsListModule {
}
/** @nocollapse */ NotificationsListModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NotificationsListModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListModule, declarations: [NotificationsListComponent, NotificationsListCustomizableDirective], imports: [CommonModule, EmptyStateModule,
        ErrorCommonStateModule,
        LoadButtonModule,
        LoadingIndicatorModule,
        ButtonModule,
        AlertModule, NotificationsListItemModule, NotificationDetailsModule], exports: [EmptyStateModule,
        ErrorCommonStateModule,
        LoadButtonModule,
        LoadingIndicatorModule,
        ButtonModule,
        AlertModule, NotificationsListItemModule, NotificationDetailsModule, NotificationsListComponent, NotificationsListCustomizableDirective] });
/** @nocollapse */ NotificationsListModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListModule, imports: [[CommonModule, ...uiModules$1, ...innerModules$1], EmptyStateModule,
        ErrorCommonStateModule,
        LoadButtonModule,
        LoadingIndicatorModule,
        ButtonModule,
        AlertModule, NotificationsListItemModule, NotificationDetailsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsListModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, ...uiModules$1, ...innerModules$1],
                    declarations: [...components$1],
                    exports: [...uiModules$1, ...innerModules$1, ...components$1],
                }]
        }] });

const uiModules = [BadgeModule, ButtonModule, IconModule, NgbDropdownModule, BadgeCounterModule, MediaQueryModule];
const innerModules = [NotificationsListItemModule, NotificationsListModule];
const components = [NotificationsBadgeWidgetComponent, NotificationsBadgeWidgetCustomizableDirective];
class NotificationsBadgeWidgetModule {
}
/** @nocollapse */ NotificationsBadgeWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NotificationsBadgeWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetModule, declarations: [NotificationsBadgeWidgetComponent, NotificationsBadgeWidgetCustomizableDirective], imports: [CommonModule, i1.BackbaseCoreModule, BadgeModule, ButtonModule, IconModule, NgbDropdownModule, BadgeCounterModule, MediaQueryModule, NotificationsListItemModule, NotificationsListModule], exports: [BadgeModule, ButtonModule, IconModule, NgbDropdownModule, BadgeCounterModule, MediaQueryModule, NotificationsListItemModule, NotificationsListModule, NotificationsBadgeWidgetComponent, NotificationsBadgeWidgetCustomizableDirective] });
/** @nocollapse */ NotificationsBadgeWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetModule, imports: [[
            CommonModule,
            BackbaseCoreModule.withConfig({
                classMap: { NotificationsBadgeWidgetComponent },
            }),
            ...uiModules,
            ...innerModules,
        ], BadgeModule, ButtonModule, IconModule, NgbDropdownModule, BadgeCounterModule, MediaQueryModule, NotificationsListItemModule, NotificationsListModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsBadgeWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        BackbaseCoreModule.withConfig({
                            classMap: { NotificationsBadgeWidgetComponent },
                        }),
                        ...uiModules,
                        ...innerModules,
                    ],
                    declarations: [...components],
                    exports: [...uiModules, ...innerModules, ...components],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BADGE_FORCE_UPDATE_DEBOUNCE_TIME, HumanizedDateComponent, HumanizedDateCustomizableDirective, NOTIFICATIONS_BADGE_RELOAD_ON_NAVIGATE_EVENT, NotificationDetailsComponent, NotificationDetailsCustomizableDirective, NotificationDetailsItemComponent, NotificationDetailsItemCustomizableDirective, NotificationListItemCustomizableDirective, NotificationsBadgeWidgetComponent, NotificationsBadgeWidgetCustomizableDirective, NotificationsBadgeWidgetModule, NotificationsListComponent, NotificationsListCustomizableDirective, NotificationsListItemComponent, NotificationsPaginationService, NotificationsPollingService, WidgetPropertiesService, HumanizedDateModule as ӨHumanizedDateModule, NotificationDetailsModule as ӨNotificationDetailsModule, NotificationsListItemModule as ӨNotificationsListItemModule, NotificationsListModule as ӨNotificationsListModule };
//# sourceMappingURL=backbase-notifications-badge-widget-ang.js.map
