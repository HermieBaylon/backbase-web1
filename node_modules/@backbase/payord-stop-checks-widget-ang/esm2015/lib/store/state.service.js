import { Injectable } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { NavigationService } from '../services/navigation.service';
import { ActionTypes, RequestStatus, state } from './store';
import * as i0 from "@angular/core";
import * as i1 from "../services/navigation.service";
export class StateService {
    constructor(navigationService) {
        this.navigationService = navigationService;
        this.store = new BehaviorSubject(state);
        this.eventDispatcher = new Subject();
        this.eventDispatcher.subscribe((data) => {
            var _a, _b, _c;
            switch (data.type) {
                case ActionTypes.INIT_REQUEST:
                    this.store.next(state);
                    break;
                case ActionTypes.DISCARD:
                    this.store.next({
                        requestInfo: state.requestInfo,
                        status: (_a = data.payload) === null || _a === void 0 ? void 0 : _a.status,
                    });
                    break;
                case ActionTypes.REVIEW_REQUEST:
                case ActionTypes.EDIT_REQUEST:
                case ActionTypes.MARK_REQUEST_AS_SUBMITTED:
                    this.store.next({
                        requestInfo: (_b = data.payload) === null || _b === void 0 ? void 0 : _b.requestInfo,
                        status: (_c = data.payload) === null || _c === void 0 ? void 0 : _c.status,
                    });
                    break;
                default:
                    break;
            }
        });
    }
    initStopCheckRequest() {
        this.eventDispatcher.next({
            type: ActionTypes.DISCARD,
            payload: {
                status: RequestStatus.DISCARD,
            },
        });
    }
    sendStopRequestToReview(data) {
        this.eventDispatcher.next({
            type: ActionTypes.REVIEW_REQUEST,
            payload: {
                requestInfo: data,
                status: RequestStatus.REVIEW,
            },
        });
        this.navigationService.review();
    }
    markStopRequestAsSubmitted(data) {
        this.eventDispatcher.next({
            type: ActionTypes.MARK_REQUEST_AS_SUBMITTED,
            payload: {
                requestInfo: data,
                status: RequestStatus.REQUEST_IS_SUBMITTED,
            },
        });
    }
    sendStopRequestToEdit(data) {
        this.eventDispatcher.next({
            type: ActionTypes.EDIT_REQUEST,
            payload: {
                requestInfo: data,
                status: RequestStatus.EDIT_MODE,
            },
        });
        this.navigationService.form();
    }
}
/** @nocollapse */ StateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: StateService, deps: [{ token: i1.NavigationService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ StateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: StateService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: StateService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NavigationService }]; } });
//# sourceMappingURL=state.service.js.map