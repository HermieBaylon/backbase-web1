import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { catchError, map, switchMap, takeUntil, tap, withLatestFrom } from 'rxjs/operators';
import { of } from 'rxjs';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { Store } from '@ngrx/store';
import { NotificationService } from '@backbase/ui-ang/notification';
import { catchErrorWithLog } from '../../utils/operators.util';
import { fetchAmountOfLoans, fetchAmountOfLoansError, fetchAmountOfLoansSuccess, fetchLoanById, fetchLoanByIdError, fetchLoanByIdSuccess, loadLoans, loadLoansError, loadLoansSuccess, updateLoanAlias, updateLoanAliasCancel, updateLoanAliasError, updateLoanAliasSuccess, } from './actions';
import { selectLoan, selectLoansTotalCount } from './selectors';
import { ArrangementsService } from '../../services/arrangements.service';
import { LoansService } from '../../services/loans.service';
import { notificationsTitlesConfig } from '../../config/notifications.config';
import { setLoan } from '@backbase/loans-payment-config-ang';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/effects";
import * as i2 from "@ngrx/store";
import * as i3 from "../../services/loans.service";
import * as i4 from "../../services/arrangements.service";
import * as i5 from "@backbase/ui-ang/notification";
import * as i6 from "@angular/router";
export class LoansEffects {
    constructor(actions$, store, loansService, arrangementsService, notificationService, router) {
        this.actions$ = actions$;
        this.store = store;
        this.loansService = loansService;
        this.arrangementsService = arrangementsService;
        this.notificationService = notificationService;
        this.router = router;
        this.fetchLoans$ = createEffect(() => this.actions$.pipe(ofType(loadLoans), switchMap(({ page, append }) => this.loansService.getLoans(page).pipe(map((response) => loadLoansSuccess({ response, append })), catchErrorWithLog((error) => of(loadLoansError({ error: error.message || 'Loans fetch error' })))))));
        this.redirectToDetailsFromList$ = createEffect(() => this.actions$.pipe(ofType(loadLoansSuccess), tap(({ response: { totalCount, items } }) => {
            if (totalCount === 1) {
                this.router.navigateByUrl('loans/details/' + items[0].id);
            }
        })), { dispatch: false });
        this.fetchLoanById$ = createEffect(() => this.actions$.pipe(ofType(fetchLoanById), switchMap(({ id }) => this.loansService.getLoanById(id).pipe(map((loan) => {
            setLoan(loan);
            return fetchLoanByIdSuccess({ loan });
        }), catchErrorWithLog((error) => of(fetchLoanByIdError({ error: error.message || 'Loan fetch error' })))))));
        this.fetchAmountOfLoans$ = createEffect(() => this.actions$.pipe(ofType(fetchAmountOfLoans), withLatestFrom(this.store.select(selectLoansTotalCount)), switchMap(([, totalCountFromStore]) => {
            if (totalCountFromStore !== undefined) {
                return of(fetchAmountOfLoansSuccess({ totalCount: totalCountFromStore }));
            }
            return this.loansService.getLoansAmount().pipe(map((totalCount) => fetchAmountOfLoansSuccess({ totalCount })), catchError(() => this.loansService.getLoans(0).pipe(map(({ totalCount }) => fetchAmountOfLoansSuccess({ totalCount })), catchErrorWithLog(() => of(fetchAmountOfLoansError())))));
        })));
        this.updateLoanAlias$ = createEffect(() => this.actions$.pipe(ofType(updateLoanAlias), withLatestFrom(this.store.select(selectLoan)), switchMap(([{ alias }, loan]) => {
            const id = loan.id;
            return this.arrangementsService.updateUserPreferences(id, alias).pipe(map(() => updateLoanAliasSuccess({ alias, id })), catchError((error) => of(updateLoanAliasError({ error: error.message || 'Update alias error' }))), takeUntil(this.actions$.pipe(ofType(updateLoanAliasCancel))));
        })));
        this.updateLoanAfterAliasUpdate$ = createEffect(() => this.actions$.pipe(ofType(updateLoanAliasSuccess), map(({ id }) => fetchLoanById({ id }))));
        this.notifyAliasUpdateSuccess$ = createEffect(() => this.actions$.pipe(ofType(updateLoanAliasSuccess), tap(({ alias }) => this.notificationService.showNotification({
            header: alias
                ? notificationsTitlesConfig.updateAliasSuccess
                : notificationsTitlesConfig.updateAliasToDefaultSuccess,
            message: '',
            modifier: 'success',
        }))), { dispatch: false });
        this.notifyAliasUpdateError$ = createEffect(() => this.actions$.pipe(ofType(updateLoanAliasError), tap(() => this.notificationService.showNotification({
            header: notificationsTitlesConfig.updateAliasError,
            message: '',
            modifier: 'error',
        }))), { dispatch: false });
    }
}
/** @nocollapse */ LoansEffects.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LoansEffects, deps: [{ token: i1.Actions }, { token: i2.Store }, { token: i3.LoansService }, { token: i4.ArrangementsService }, { token: i5.NotificationService }, { token: i6.Router }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ LoansEffects.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LoansEffects });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LoansEffects, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Actions }, { type: i2.Store }, { type: i3.LoansService }, { type: i4.ArrangementsService }, { type: i5.NotificationService }, { type: i6.Router }]; } });
//# sourceMappingURL=effects.js.map