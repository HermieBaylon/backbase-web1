import { __awaiter } from "tslib";
import { Injectable, Optional } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { filter, first, map, switchMap } from 'rxjs/operators';
import { ɵɵOidcAuthService } from '@backbase/identity-auth';
import { ImpersonationDataService } from '../impersonation-data/impersonation-data.service';
import { impersonationCodeParam, storageKeys } from '../impersonation.model';
import * as i0 from "@angular/core";
import * as i1 from "../impersonation-data/impersonation-data.service";
import * as i2 from "@backbase/identity-auth";
export class ImpersonationService {
    /** @internal */
    constructor(dataService, oidcAuthService) {
        this.dataService = dataService;
        this.oidcAuthService = oidcAuthService;
        this.isImpersonated$$ = new BehaviorSubject(this.storedState);
        /**
         * Flag to determine if the current user is being impersonated.
         */
        this.isImpersonated$ = this.isImpersonated$$.asObservable();
        /**
         * Contacts the Identity Impersonation service to obtain an impersonation url for the
         * input user and target web app.
         * @param targetUserId the id of the user to be impersonated.
         * @param targetWebApp the url of the app to impersonate the user in.
         * @returns a url for the target app containing an impersonation code.
         */
        this.getImpersonationUrl = (targetUserId, targetWebApp) => this.oidcAuthService.accessToken$.pipe(filter((token) => !!token), first(), switchMap(({ raw }) => this.dataService.getImpersonationUrl(raw, targetUserId, targetWebApp)), map(({ ref }) => this.appendParamToUrl(targetWebApp, ref)));
        /**
         * Checks the current URL for an `impersonation_code` reference.
         * @returns a promise that resolves when the impersonation state is determined.
         */
        this.checkImpersonationStatus = () => __awaiter(this, void 0, void 0, function* () {
            const impersonationToken = this.getImpersonationCode();
            if (!impersonationToken) {
                return;
            }
            const accessTokenResponse = yield this.dataService
                .getAccessToken(impersonationToken, this.getClientId(), this.getRealm())
                .toPromise();
            this.setAccessTokenToOAuthStorage(accessTokenResponse);
            this.stripParamFromUrl();
            this.storedState = true;
            yield this.oidcAuthService.loadDiscoveryDocument();
            yield this.oidcAuthService.refresh();
        });
        if (!oidcAuthService) {
            throw new Error(`In order to use ImpersonationService, please include IdentityAuthModule to your application module`);
        }
        this.clearImpersonationStateOnLogout();
    }
    get storedState() {
        return !!this.oidcAuthService.storage.getItem(storageKeys.impersonation);
    }
    set storedState(value) {
        this.isImpersonated$$.next(value);
        if (value) {
            this.oidcAuthService.storage.setItem(storageKeys.impersonation, value.toString());
        }
        else {
            this.oidcAuthService.storage.removeItem(storageKeys.impersonation);
        }
    }
    stripParamFromUrl() {
        const url = new URL(window.location.href);
        url.searchParams.delete(impersonationCodeParam);
        window.history.replaceState(window.history.state, '', url.toString());
    }
    appendParamToUrl(targetWebAppUrl, value) {
        const url = new URL(targetWebAppUrl);
        url.searchParams.append(impersonationCodeParam, value);
        return url.toString();
    }
    setAccessTokenToOAuthStorage(response) {
        this.oidcAuthService.storage.setItem(storageKeys.accessToken, response.access_token || '');
        this.oidcAuthService.storage.setItem(storageKeys.refreshToken, response.refresh_token || '');
    }
    getClientId() {
        return this.oidcAuthService.authConfig.clientId || '';
    }
    getRealm() {
        const issuer = this.oidcAuthService.authConfig.issuer;
        if (!issuer) {
            return '';
        }
        return new URL(issuer).pathname.split('/').pop() || '';
    }
    clearImpersonationStateOnLogout() {
        this.oidcAuthService.events$
            .pipe(filter((event) => ['logout', 'session_terminated'].includes(event.type)), first())
            .subscribe({
            next: () => (this.storedState = false),
        });
    }
    getImpersonationCode() {
        return new URLSearchParams(location.search).get(impersonationCodeParam);
    }
}
/** @nocollapse */ ImpersonationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationService, deps: [{ token: i1.ImpersonationDataService }, { token: i2.ɵɵOidcAuthService, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ImpersonationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: ImpersonationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ImpersonationDataService }, { type: i2.ɵɵOidcAuthService, decorators: [{
                    type: Optional
                }] }]; } });
//# sourceMappingURL=impersonation.service.js.map