import { Injectable } from '@angular/core';
import { from, interval, of } from 'rxjs';
import { filter, first, retry, switchMap, takeUntil } from 'rxjs/operators';
import { ProgressStatus } from './helper.model';
import * as i0 from "@angular/core";
export class TransactionSigningHelperService {
    constructor() {
        this.defaultPollInterval = 1000;
        this.defaultMaxRetries = 3;
        this.defaultStatusMap = {
            success: [ProgressStatus.ACCEPTED, ProgressStatus.PROCESSED, ProgressStatus.PENDING_APPROVAL],
            rejected: [ProgressStatus.REJECTED],
            declined: [ProgressStatus.SYSTEM_DECLINED, ProgressStatus.USER_DECLINED],
            pending: [ProgressStatus.CONFIRMATION_PENDING, ProgressStatus.SENDING],
        };
    }
    /**
     * Determines if the response was returned from the Transaction Signing flow.
     * @param response the data returned after a possible transaction signing request.
     * @returns boolean
     */
    isTransactionSigningResponse(response) {
        return response && !!response['confirmation-type'];
    }
    /**
     * Polls a fetch function. Designed to run after transaction signing has occurred.
     * @param data  this is passed to the fetchFn as param.
     * @param fetchFn a function that triggers an http call.
     * @param pollOptions options to configure the polling such as pollInterval, maxRetries etc.
     * @param pendingStatuses array of statuses which determines if the polling should continue.
     * @returns an Observable that sequencially emits a value based on configured time interval.
     */
    setupPolling(data, fetchFn, pollOptions, pendingStatuses) {
        const pollUntil = pollOptions.pollUntilFn || this.defaultPollUntilFn.bind(this, pendingStatuses);
        return interval(pollOptions.pollInterval || this.defaultPollInterval).pipe(takeUntil(pollOptions.complete$), switchMap(() => from(fetchFn(data))), retry(pollOptions.maxRetries || this.defaultMaxRetries), filter((res) => pollUntil(res)), first());
    }
    /**
     * Handles scenarios after signing a transaction and triggers appropriate callbacks.
     * @param options Configuration for determining different flows of the transaction.
     */
    getTransactionInfo(options) {
        if (options.asyncPollingOptions) {
            this.handleAsyncPollingFlow(options);
        }
        else {
            this.handleGenericFlow(options);
        }
    }
    defaultPollUntilFn(pendingStatuses, status) {
        return !!status && !pendingStatuses.includes(status);
    }
    handleAsyncPollingFlow(options) {
        const { asyncPollingOptions } = options;
        const { pending } = options.statusMap || this.defaultStatusMap;
        if (options.fetchFn) {
            this.setupPolling(options.data, options.fetchFn, asyncPollingOptions, pending).subscribe((status) => {
                this.triggerTransactionCallback({ status }, options);
            }, (error) => {
                options.onError(error);
            });
        }
        else {
            console.warn('`fetchFn` is mandatory when polling options are provided');
        }
    }
    handleGenericFlow(options) {
        const item$ = options.fetchFn ? options.fetchFn(options.data) : of(options.data);
        item$.pipe(first()).subscribe((response) => {
            this.triggerTransactionCallback(response, options);
        }, (error) => {
            options.onError(error);
        });
    }
    triggerTransactionCallback(response, options) {
        const { status } = response || {};
        const { success, declined, rejected } = options.statusMap || this.defaultStatusMap;
        if (success.includes(status)) {
            options.onSuccess(response);
        }
        else if (declined.includes(status)) {
            options.onDeclined(response);
        }
        else if (rejected.includes(status)) {
            options.onRejected(response);
        }
        else {
            options.onError(response);
        }
    }
}
/** @nocollapse */ TransactionSigningHelperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningHelperService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ TransactionSigningHelperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningHelperService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: TransactionSigningHelperService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=helper.service.js.map