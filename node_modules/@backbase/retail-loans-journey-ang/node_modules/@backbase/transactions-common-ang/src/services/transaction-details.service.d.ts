import { OnDestroy } from '@angular/core';
import { TransactionClientHttpService } from '@backbase/data-ang/transactions';
import { Observable } from 'rxjs';
import { TransactionCheckImageResponse } from '../model/transactions-check-images.model';
import { TransactionsDetailsLoading } from '../model/transactions-details.model';
import { Transaction } from '../model/transaction.model';
import { MapAPILoaderService } from './map-api-loader.service';
import { PaymentsBatchService } from './payments-batch.service';
import { BatchOrder } from '../model/batch-order.model';
import * as i0 from "@angular/core";
export declare class TransactionDetailsService implements OnDestroy {
    private readonly transactionsDataHttpService;
    private readonly mapApiLoader;
    private readonly paymentsBatchService;
    /**
     * watches the transaction that is shown in the details
     */
    private readonly transactionSelection;
    /**
     * watches the configuration from CXP that can disable/enable check images
     */
    private readonly hasCheckImages;
    /**
     * general status of each feature that runs asynchronously
     */
    private readonly transactionsDetailsStatus;
    private readonly mapsApiKey;
    set enableDisputeAndInquiry(value: boolean);
    fromInquiryAndDispute(enableDisputeAndInquiry: Observable<boolean>, disputeByBillingStatus: Observable<boolean>, disputeEligibilityDays: Observable<number>, disputeTransactionTypes: Observable<Array<string>>): void;
    /**
     *
     * @param transactionId
     * triggers a new action that will cause transcations details reload and change an image
     */
    selectTransaction(transaction: Transaction): void;
    /**
     * Key-value pair that controls the loading status in transactions details
     */
    get loadingState(): Observable<TransactionsDetailsLoading>;
    /**
     *
     * @param hasCheckImages
     * Configuration for check images reactive functionality
     */
    fromCheckImages(hasCheckImages: Observable<boolean>): Observable<TransactionCheckImageResponse>;
    fromGeolocation(mapsApiKey: Observable<string>): Observable<boolean>;
    batchOrder: Observable<BatchOrder | undefined>;
    /**
     * destroy lifecycle hook that will release resources
     */
    ngOnDestroy(): void;
    /**
     *
     * @param feature
     * @param toggle
     *
     * Prevents from emiting values if the cxp configuration is set as disabled
     */
    private setCondition;
    constructor(transactionsDataHttpService: TransactionClientHttpService, mapApiLoader: MapAPILoaderService, paymentsBatchService: PaymentsBatchService);
    static ɵfac: i0.ɵɵFactoryDeclaration<TransactionDetailsService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<TransactionDetailsService>;
}
