import { animate, style, transition, trigger } from '@angular/animations';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output } from '@angular/core';
import { BarOrientation, formatLabel, PlacementTypes, ScaleType, StyleTypes, } from '@swimlane/ngx-charts';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/foundation-ang/future";
import * as i2 from "@swimlane/ngx-charts";
import * as i3 from "@angular/common";
export var D0Types;
(function (D0Types) {
    D0Types["positive"] = "positive";
    D0Types["negative"] = "negative";
})(D0Types || (D0Types = {}));
export class BbSeriesVerticalComponent {
    constructor(deprecationService) {
        this.deprecationService = deprecationService;
        /**
         * The type of the chart bars.
         */
        this.type = 'standard';
        /**
         * Enable/disable bars gradient.
         */
        this.gradient = false;
        /**
         * The active entries for the chart bars.
         */
        this.activeEntries = [];
        /**
         * Name of the chart series.
         */
        this.seriesName = '';
        /**
         * Enabel/Disable bars tooltip.
         */
        this.tooltipDisabled = false;
        /**
         * Show/Hide tooltip caret.
         */
        this.tooltipShowCaret = false;
        /**
         * Enable/disable bars rounded edges.
         */
        this.roundEdges = false;
        /**
         * Enable/disable bars animation.
         */
        this.animations = true;
        /**
         * Show/hide bars label.
         */
        this.showDataLabel = false;
        /**
         * EventEmitter for triggering a select event.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.select = new EventEmitter();
        /**
         * EventEmitter for triggering a activate event.
         */
        this.activate = new EventEmitter();
        /**
         * EventEmitter for triggering a deactivate event.
         */
        this.deactivate = new EventEmitter();
        /**
         * EventEmitter for triggering a dataLabelHeightChanged event.
         */
        this.dataLabelHeightChanged = new EventEmitter();
        this.tooltipPlacement = PlacementTypes.Top;
        this.tooltipType = StyleTypes.tooltip;
        this.orientation = BarOrientation.Vertical;
        this.barsForDataLabels = [];
    }
    getColors(value, label, offset0, offset1) {
        const bar = {};
        if (this.colors) {
            if (this.colors.scaleType === ScaleType.Ordinal) {
                bar.color = this.colors.getColor(label);
            }
            else {
                if (this.type === 'standard') {
                    bar.color = this.colors.getColor(value);
                    bar.gradientStops = this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = this.colors.getColor(offset1 || 0);
                    bar.gradientStops = this.colors.getLinearGradientStops(offset1 || 0, offset0);
                }
            }
        }
        return bar;
    }
    tooltipText(label, value) {
        return this.tooltipDisabled
            ? undefined
            : `
      <span class="tooltip-label">${label}</span>
      <span class="tooltip-val">${value}</span>
    `;
    }
    ngOnChanges() {
        if (!this.series) {
            throw new Error('[series] should be provided to the component!');
        }
        this.update(this.series);
    }
    update(series) {
        this.bars = this.formatChartData(series);
        this.barsForDataLabels = this.updatedLabels(series);
    }
    updateDataLabels(series) {
        this.deprecationService.logDeprecatedFeature('#updateDataLabels inside #BbSeriesVerticalComponent deprecated in favor of #updatedLabels, which returns the formatted object instead of assigning values within itself');
        this.barsForDataLabels = this.updatedLabels(series);
    }
    updatedBars(series) {
        var _a;
        let d0Type = D0Types.positive;
        const width = (_a = this.xScale) === null || _a === void 0 ? void 0 : _a.bandwidth();
        const yScaleMin = Math.max(this.yScale.domain()[0], 0);
        const d0 = {
            [D0Types.positive]: 0,
            [D0Types.negative]: 0,
        };
        return series.map((d, index, group) => {
            var _a, _b, _c;
            const value = d.value || 0;
            const label = d.name || '';
            const formattedLabel = formatLabel(label);
            const roundEdges = this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            const bar = {
                value,
                label,
                roundEdges,
                data: d,
                width,
                formattedLabel,
                height: 0,
                x: 0,
                y: 0,
            };
            // Use data of the group of bars for tooltips
            if (this.groupData) {
                bar.data = {
                    group: group.map((barEl) => { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                    diff: this.groupData.diff,
                    currency: this.groupData.currency,
                    value: d.value,
                    badge: this.groupData.badge,
                };
            }
            if (this.type === 'standard') {
                bar.height = Math.abs(this.yScale(value) - this.yScale(yScaleMin));
                bar.x = (_a = this.xScale) === null || _a === void 0 ? void 0 : _a.call(this, label);
                bar.y = (_b = this.yScale) === null || _b === void 0 ? void 0 : _b.call(this, Math.max(0, value));
            }
            else if (this.type === 'stacked') {
                const offset0 = d0[d0Type];
                const offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.height = Math.ceil(this.yScale(offset0) - this.yScale(offset1));
                bar.x = 0;
                bar.y = (_c = this.yScale) === null || _c === void 0 ? void 0 : _c.call(this, offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                bar.roundEdges = index === 1;
            }
            Object.assign(bar, this.getColors(value, label, bar.offset0, bar.offset1));
            let tooltipLabel = formattedLabel;
            if (this.seriesName) {
                tooltipLabel = `${this.seriesName} • ${formattedLabel}`;
                bar.data.series = this.seriesName;
            }
            bar.tooltipText = this.tooltipText(tooltipLabel, value.toLocaleString());
            return bar;
        });
    }
    updatedLabels(series) {
        return series.map((d) => {
            var _a, _b, _c;
            return ({
                name: d.name,
                series: this.seriesName ? this.seriesName : d.name,
                total: d.value,
                x: ((_a = this.xScale) === null || _a === void 0 ? void 0 : _a.call(this, d.name)) || 0,
                y: ((_b = this.yScale) === null || _b === void 0 ? void 0 : _b.call(this, 0)) || 0,
                height: this.yScale ? this.yScale(d.value) - this.yScale(0) : 0,
                width: ((_c = this.xScale) === null || _c === void 0 ? void 0 : _c.bandwidth()) || 0,
                roundEdges: this.roundEdges,
            });
        });
    }
    formatChartData(series) {
        const yScaleMin = Math.max(this.yScale.domain()[0], 0);
        const d0 = {
            [D0Types.positive]: 0,
            [D0Types.negative]: 0,
        };
        const formattedSeries = series.map((d, index, group) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const value = d.value || 0;
            const label = d.name || '';
            const d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            const formattedLabel = formatLabel(label);
            const tooltipLabel = this.seriesName ? `${this.seriesName} • ${formattedLabel}` : formattedLabel;
            const data = {
                name: this.seriesName || '',
                group: group.map((barEl) => { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                series: group.map((barEl) => { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                diff: (_a = this.groupData) === null || _a === void 0 ? void 0 : _a.diff,
                currency: (_b = this.groupData) === null || _b === void 0 ? void 0 : _b.currency,
                value: d.value,
                badge: (_c = this.groupData) === null || _c === void 0 ? void 0 : _c.badge,
            };
            const graphData = {
                name: this.seriesName || '',
                value: d.value,
            };
            const standardType = {
                height: Math.abs(this.yScale(value) - this.yScale(yScaleMin)),
                offset0: undefined,
                offset1: undefined,
                roundEdges: this.roundEdges,
                x: ((_d = this.xScale) === null || _d === void 0 ? void 0 : _d.call(this, label)) || 0,
                y: ((_e = this.yScale) === null || _e === void 0 ? void 0 : _e.call(this, Math.max(0, value))) || 0,
                width: ((_f = this.xScale) === null || _f === void 0 ? void 0 : _f.bandwidth()) || 0,
            };
            const stackedType = {
                height: Math.ceil(this.yScale(d0[d0Type]) - this.yScale(d0[d0Type] + value)),
                offset0: d0[d0Type],
                offset1: d0[d0Type] + value,
                roundEdges: index === 1,
                x: 0,
                y: ((_g = this.yScale) === null || _g === void 0 ? void 0 : _g.call(this, d0[d0Type] + value)) || 0,
                width: ((_h = this.xScale) === null || _h === void 0 ? void 0 : _h.bandwidth()) || 0,
            };
            const typeObject = this.type === 'stacked' ? stackedType : standardType;
            const returnObject = Object.assign(Object.assign(Object.assign({}, typeObject), this.getColors(value, label, typeObject.offset0, typeObject.offset1)), { data, tooltipText: this.tooltipText(tooltipLabel, value.toLocaleString()), formattedLabel,
                value,
                label, graphData: Object.assign({}, graphData) });
            return returnObject;
        });
        return formattedSeries;
    }
    updateTooltipSettings() {
        this.deprecationService.logDeprecatedFeature('Deprecated #updateTooltipSettings method inside #BbSeriesVerticalComponent in favor of assigning values during component creation');
        this.tooltipPlacement = this.tooltipDisabled ? undefined : PlacementTypes.Top;
        this.tooltipType = this.tooltipDisabled ? undefined : StyleTypes.tooltip;
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find((d) => {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    }
    onClick(data) {
        this.select.emit(data);
    }
    trackBy(index, bar) {
        return bar.label;
    }
    trackDataLabelBy(index, barLabel) {
        return `${index}#${barLabel.series}#${barLabel.total}`;
    }
}
BbSeriesVerticalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbSeriesVerticalComponent, deps: [{ token: i1.DeprecationsService }], target: i0.ɵɵFactoryTarget.Component });
BbSeriesVerticalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: { dims: "dims", type: "type", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", animations: "animations", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", groupData: "groupData" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, usesOnChanges: true, ngImport: i0, template: "<svg:g ngx-charts-bar\n  *ngFor=\"let bar of bars; trackBy: trackBy\"\n  [@animationState]=\"'active'\"\n  [@.disabled]=\"!animations\"\n  [width]=\"bar.width\"\n  [height]=\"bar.height\"\n  [x]=\"bar.x\"\n  [y]=\"bar.y\"\n  [fill]=\"bar.color\"\n  [stops]=\"bar.gradientStops\"\n  [data]=\"bar.graphData\"\n  [orientation]=\"orientation\"\n  [roundEdges]=\"bar.roundEdges\"\n  [gradient]=\"gradient\"\n  [isActive]=\"isActive(bar)\"\n  (select)=\"onClick($event)\"\n  (activate)=\"activate.emit($event)\"\n  (deactivate)=\"deactivate.emit($event)\"\n  ngx-tooltip\n  [tooltipCssClass]=\"'chart-tooltip p-0 border-0'\"\n  [tooltipShowCaret]=\"tooltipShowCaret\"\n  [tooltipDisabled]=\"tooltipDisabled\"\n  [tooltipPlacement]=\"tooltipPlacement\"\n  [tooltipType]=\"tooltipType\"\n  [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n  [tooltipTemplate]=\"tooltipTemplate\"\n  [tooltipContext]=\"bar.data\"\n  [animations]=\"animations\">\n</svg:g>\n<svg:g *ngIf=\"showDataLabel\">\n  <svg:g ngx-charts-bar-label \n    *ngFor=\"let b of barsForDataLabels; let i = index; trackBy:trackDataLabelBy\"\n    [barX]=\"b.x\"\n    [barY]=\"b.y\"\n    [barWidth]=\"b.width\"\n    [barHeight]=\"b.height\"\n    [value]=\"b.total\"\n    [valueFormatting]=\"dataLabelFormatting\"\n    [orientation]=\"orientation\"\n    (dimensionsChanged)=\"dataLabelHeightChanged.emit({size:$event, index:i})\"\n  />\n</svg:g>\n", components: [{ type: i2.BarComponent, selector: "g[ngx-charts-bar]", inputs: ["roundEdges", "gradient", "offset", "isActive", "animations", "noBarWhenZero", "fill", "data", "width", "height", "x", "y", "orientation", "stops", "ariaLabel"], outputs: ["select", "activate", "deactivate"] }, { type: i2.BarLabelComponent, selector: "g[ngx-charts-bar-label]", inputs: ["value", "valueFormatting", "barX", "barY", "barWidth", "barHeight", "orientation"], outputs: ["dimensionsChanged"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.TooltipDirective, selector: "[ngx-tooltip]", inputs: ["tooltipCssClass", "tooltipAppendToBody", "tooltipSpacing", "tooltipDisabled", "tooltipShowCaret", "tooltipPlacement", "tooltipAlignment", "tooltipType", "tooltipCloseOnClickOutside", "tooltipCloseOnMouseLeave", "tooltipHideTimeout", "tooltipShowTimeout", "tooltipShowEvent", "tooltipImmediateExit", "tooltipTitle", "tooltipTemplate", "tooltipContext"], outputs: ["show", "hide"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], animations: [
        trigger('animationState', [
            transition(':leave', [
                style({
                    opacity: 1,
                }),
                animate(500, style({ opacity: 0 })),
            ]),
        ]),
    ], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbSeriesVerticalComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'g[bb-charts-series-vertical]',
                    templateUrl: './bb-charts-series-vertical.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [
                        trigger('animationState', [
                            transition(':leave', [
                                style({
                                    opacity: 1,
                                }),
                                animate(500, style({ opacity: 0 })),
                            ]),
                        ]),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.DeprecationsService }]; }, propDecorators: { dims: [{
                type: Input
            }], type: [{
                type: Input
            }], series: [{
                type: Input
            }], xScale: [{
                type: Input
            }], yScale: [{
                type: Input
            }], colors: [{
                type: Input
            }], gradient: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], seriesName: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], tooltipShowCaret: [{
                type: Input
            }], tooltipTemplate: [{
                type: Input
            }], roundEdges: [{
                type: Input
            }], animations: [{
                type: Input
            }], showDataLabel: [{
                type: Input
            }], dataLabelFormatting: [{
                type: Input
            }], groupData: [{
                type: Input
            }], select: [{
                type: Output
            }], activate: [{
                type: Output
            }], deactivate: [{
                type: Output
            }], dataLabelHeightChanged: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmItY2hhcnRzLXNlcmllcy12ZXJ0aWNhbC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9saWJzL3R1cm5vdmVycy13aWRnZXQvc3JjL3R1cm5vdmVycy12ZXJ0aWNhbC1ncm91cGVkLWJhci1jaGFydC9iYi1jaGFydHMtc2VyaWVzLXZlcnRpY2FsLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvdHVybm92ZXJzLXdpZGdldC9zcmMvdHVybm92ZXJzLXZlcnRpY2FsLWdyb3VwZWQtYmFyLWNoYXJ0L2JiLWNoYXJ0cy1zZXJpZXMtdmVydGljYWwuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzFFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBYSxNQUFNLEVBQWUsTUFBTSxlQUFlLENBQUM7QUFFeEgsT0FBTyxFQUNMLGNBQWMsRUFHZCxXQUFXLEVBQ1gsY0FBYyxFQUNkLFNBQVMsRUFDVCxVQUFVLEdBRVgsTUFBTSxzQkFBc0IsQ0FBQzs7Ozs7QUFJOUIsTUFBTSxDQUFOLElBQVksT0FHWDtBQUhELFdBQVksT0FBTztJQUNqQixnQ0FBcUIsQ0FBQTtJQUNyQixnQ0FBcUIsQ0FBQTtBQUN2QixDQUFDLEVBSFcsT0FBTyxLQUFQLE9BQU8sUUFHbEI7QUFrQkQsTUFBTSxPQUFPLHlCQUF5QjtJQStUcEMsWUFBb0Isa0JBQXVDO1FBQXZDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBcUI7UUExVDNEOztXQUVHO1FBQ00sU0FBSSxHQUFHLFVBQVUsQ0FBQztRQWlCM0I7O1dBRUc7UUFDTSxhQUFRLEdBQVksS0FBSyxDQUFDO1FBQ25DOztXQUVHO1FBQ00sa0JBQWEsR0FBVSxFQUFFLENB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cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYW5pbWF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT3V0cHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGVwcmVjYXRpb25zU2VydmljZSB9IGZyb20gJ0BiYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9mdXR1cmUnO1xuaW1wb3J0IHtcbiAgQmFyT3JpZW50YXRpb24sXG4gIENvbG9ySGVscGVyLFxuICBEYXRhSXRlbSxcbiAgZm9ybWF0TGFiZWwsXG4gIFBsYWNlbWVudFR5cGVzLFxuICBTY2FsZVR5cGUsXG4gIFN0eWxlVHlwZXMsXG4gIFZpZXdEaW1lbnNpb25zLFxufSBmcm9tICdAc3dpbWxhbmUvbmd4LWNoYXJ0cyc7XG5pbXBvcnQgeyBTY2FsZUJhbmQsIFNjYWxlTGluZWFyIH0gZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHsgQ2hhcnRCYXJEYXRhLCBDaGFydENvbG9ycywgQ2hhcnREYXRhLCBDaGFydERhdGFMYWJlbHMsIEZvcm1hdHRlZENoYXJ0RGF0YUxhYmVscyB9IGZyb20gJy4uL21vZGVsL3R1cm5vdmVycyc7XG5cbmV4cG9ydCBlbnVtIEQwVHlwZXMge1xuICBwb3NpdGl2ZSA9ICdwb3NpdGl2ZScsXG4gIG5lZ2F0aXZlID0gJ25lZ2F0aXZlJyxcbn1cblxuQENvbXBvbmVudCh7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnZ1tiYi1jaGFydHMtc2VyaWVzLXZlcnRpY2FsXScsXG4gIHRlbXBsYXRlVXJsOiAnLi9iYi1jaGFydHMtc2VyaWVzLXZlcnRpY2FsLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdhbmltYXRpb25TdGF0ZScsIFtcbiAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgc3R5bGUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIH0pLFxuICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSxcbiAgICAgIF0pLFxuICAgIF0pLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBCYlNlcmllc1ZlcnRpY2FsQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjaGFydCBiYXJzLlxuICAgKi9cbiAgQElucHV0KCkgZGltcz86IFZpZXdEaW1lbnNpb25zO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGNoYXJ0IGJhcnMuXG4gICAqL1xuICBASW5wdXQoKSB0eXBlID0gJ3N0YW5kYXJkJztcbiAgLyoqXG4gICAqIEFycmF5IG9mIENoYXJ0IGRhdGEgb2JqZWN0cyBuZWVkZWQgZm9yIHRoZSBjaGFydCB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIEBJbnB1dCgpIHNlcmllczogQ2hhcnRCYXJEYXRhW10gfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBIb3Jpem9udGEgc2NhbGUgb2YgdGhlIGNoYXJ0IGJhcnMuXG4gICAqL1xuICBASW5wdXQoKSB4U2NhbGU/OiBTY2FsZUJhbmQ8c3RyaW5nPjtcbiAgLyoqXG4gICAqIFZlcnRpY2FsIG9mIHRoZSBjaGFydCBiYXJzLlxuICAgKi9cbiAgQElucHV0KCkgeVNjYWxlPzogU2NhbGVMaW5lYXI8bnVtYmVyLCBudW1iZXI+O1xuICAvKipcbiAgICogVGhlIGNvbG9yIHBhbGV0dGUgb2YgdGhlIGNoYXJ0IGJhcnMuXG4gICAqL1xuICBASW5wdXQoKSBjb2xvcnM/OiBDb2xvckhlbHBlcjtcbiAgLyoqXG4gICAqIEVuYWJsZS9kaXNhYmxlIGJhcnMgZ3JhZGllbnQuXG4gICAqL1xuICBASW5wdXQoKSBncmFkaWVudDogYm9vbGVhbiA9IGZhbHNlO1xuICAvKipcbiAgICogVGhlIGFjdGl2ZSBlbnRyaWVzIGZvciB0aGUgY2hhcnQgYmFycy5cbiAgICovXG4gIEBJbnB1dCgpIGFjdGl2ZUVudHJpZXM6IGFueVtdID0gW107XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjaGFydCBzZXJpZXMuXG4gICAqL1xuICBASW5wdXQoKSBzZXJpZXNOYW1lPyA9ICcnO1xuICAvKipcbiAgICogRW5hYmVsL0Rpc2FibGUgYmFycyB0b29sdGlwLlxuICAgKi9cbiAgQElucHV0KCkgdG9vbHRpcERpc2FibGVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBTaG93L0hpZGUgdG9vbHRpcCBjYXJldC5cbiAgICovXG4gIEBJbnB1dCgpIHRvb2x0aXBTaG93Q2FyZXQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRlbXBsYXRlIGZvciB0aGUgYmFyIHRvb2x0aXAuXG4gICAqL1xuICBASW5wdXQoKSB0b29sdGlwVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBiYXJzIHJvdW5kZWQgZWRnZXMuXG4gICAqL1xuICBASW5wdXQoKSByb3VuZEVkZ2VzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBiYXJzIGFuaW1hdGlvbi5cbiAgICovXG4gIEBJbnB1dCgpIGFuaW1hdGlvbnMgPSB0cnVlO1xuICAvKipcbiAgICogU2hvdy9oaWRlIGJhcnMgbGFiZWwuXG4gICAqL1xuICBASW5wdXQoKSBzaG93RGF0YUxhYmVsID0gZmFsc2U7XG4gIC8qKlxuICAgKiBGb3JtYXR0aW5nIGZvciB0aGUgYmFycyBsYWJlbHMuXG4gICAqL1xuICBASW5wdXQoKSBkYXRhTGFiZWxGb3JtYXR0aW5nOiBhbnk7XG4gIC8qKlxuICAgKiBDaGFydCBkYXRhIG9iamVjdHMgbmVlZGVkIGZvciB0aGUgY2hhcnQgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBASW5wdXQoKSBncm91cERhdGE6IENoYXJ0RGF0YSB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRXZlbnRFbWl0dGVyIGZvciB0cmlnZ2VyaW5nIGEgc2VsZWN0IGV2ZW50LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBhbmd1bGFyLWVzbGludC9uby1vdXRwdXQtbmF0aXZlXG4gIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIC8qKlxuICAgKiBFdmVudEVtaXR0ZXIgZm9yIHRyaWdnZXJpbmcgYSBhY3RpdmF0ZSBldmVudC5cbiAgICovXG4gIEBPdXRwdXQoKSBhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgLyoqXG4gICAqIEV2ZW50RW1pdHRlciBmb3IgdHJpZ2dlcmluZyBhIGRlYWN0aXZhdGUgZXZlbnQuXG4gICAqL1xuICBAT3V0cHV0KCkgZGVhY3RpdmF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgLyoqXG4gICAqIEV2ZW50RW1pdHRlciBmb3IgdHJpZ2dlcmluZyBhIGRhdGFMYWJlbEhlaWdodENoYW5nZWQgZXZlbnQuXG4gICAqL1xuICBAT3V0cHV0KCkgZGF0YUxhYmVsSGVpZ2h0Q2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICB0b29sdGlwUGxhY2VtZW50PzogUGxhY2VtZW50VHlwZXMgPSBQbGFjZW1lbnRUeXBlcy5Ub3A7XG4gIHRvb2x0aXBUeXBlPzogU3R5bGVUeXBlcyA9IFN0eWxlVHlwZXMudG9vbHRpcDtcbiAgb3JpZW50YXRpb246IEJhck9yaWVudGF0aW9uID0gQmFyT3JpZW50YXRpb24uVmVydGljYWw7XG5cbiAgYmFyczogRm9ybWF0dGVkQ2hhcnREYXRhTGFiZWxzW10gfCB1bmRlZmluZWQ7XG4gIHg6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgeTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBiYXJzRm9yRGF0YUxhYmVsczogQ2hhcnREYXRhTGFiZWxzW10gPSBbXTtcblxuICBwcml2YXRlIGdldENvbG9ycyh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBsYWJlbDogc3RyaW5nLCBvZmZzZXQwPzogc3RyaW5nIHwgbnVtYmVyLCBvZmZzZXQxPzogc3RyaW5nIHwgbnVtYmVyKSB7XG4gICAgY29uc3QgYmFyOiBDaGFydENvbG9ycyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuY29sb3JzKSB7XG4gICAgICBpZiAodGhpcy5jb2xvcnMuc2NhbGVUeXBlID09PSBTY2FsZVR5cGUuT3JkaW5hbCkge1xuICAgICAgICBiYXIuY29sb3IgPSB0aGlzLmNvbG9ycy5nZXRDb2xvcihsYWJlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnc3RhbmRhcmQnKSB7XG4gICAgICAgICAgYmFyLmNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3IodmFsdWUpO1xuICAgICAgICAgIGJhci5ncmFkaWVudFN0b3BzID0gdGhpcy5jb2xvcnMuZ2V0TGluZWFyR3JhZGllbnRTdG9wcyh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmFyLmNvbG9yID0gdGhpcy5jb2xvcnMuZ2V0Q29sb3Iob2Zmc2V0MSB8fCAwKTtcbiAgICAgICAgICBiYXIuZ3JhZGllbnRTdG9wcyA9IHRoaXMuY29sb3JzLmdldExpbmVhckdyYWRpZW50U3RvcHMob2Zmc2V0MSB8fCAwLCBvZmZzZXQwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXI7XG4gIH1cblxuICBwcml2YXRlIHRvb2x0aXBUZXh0KGxhYmVsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy50b29sdGlwRGlzYWJsZWRcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwidG9vbHRpcC1sYWJlbFwiPiR7bGFiZWx9PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ0b29sdGlwLXZhbFwiPiR7dmFsdWV9PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICBuZ09uQ2hhbmdlcygpIHtcbiAgICBpZiAoIXRoaXMuc2VyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tzZXJpZXNdIHNob3VsZCBiZSBwcm92aWRlZCB0byB0aGUgY29tcG9uZW50IScpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlKHRoaXMuc2VyaWVzKTtcbiAgfVxuXG4gIHVwZGF0ZShzZXJpZXM6IENoYXJ0QmFyRGF0YVtdKSB7XG4gICAgdGhpcy5iYXJzID0gdGhpcy5mb3JtYXRDaGFydERhdGEoc2VyaWVzKTtcbiAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gdGhpcy51cGRhdGVkTGFiZWxzKHNlcmllcyk7XG4gIH1cblxuICB1cGRhdGVEYXRhTGFiZWxzKHNlcmllczogQ2hhcnRCYXJEYXRhW10pIHtcbiAgICB0aGlzLmRlcHJlY2F0aW9uU2VydmljZS5sb2dEZXByZWNhdGVkRmVhdHVyZShcbiAgICAgICcjdXBkYXRlRGF0YUxhYmVscyBpbnNpZGUgI0JiU2VyaWVzVmVydGljYWxDb21wb25lbnQgZGVwcmVjYXRlZCBpbiBmYXZvciBvZiAjdXBkYXRlZExhYmVscywgd2hpY2ggcmV0dXJucyB0aGUgZm9ybWF0dGVkIG9iamVjdCBpbnN0ZWFkIG9mIGFzc2lnbmluZyB2YWx1ZXMgd2l0aGluIGl0c2VsZicsXG4gICAgKTtcbiAgICB0aGlzLmJhcnNGb3JEYXRhTGFiZWxzID0gdGhpcy51cGRhdGVkTGFiZWxzKHNlcmllcyk7XG4gIH1cblxuICB1cGRhdGVkQmFycyhzZXJpZXM6IENoYXJ0QmFyRGF0YVtdKTogQ2hhcnREYXRhW10ge1xuICAgIGxldCBkMFR5cGUgPSBEMFR5cGVzLnBvc2l0aXZlO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy54U2NhbGU/LmJhbmR3aWR0aCgpO1xuICAgIGNvbnN0IHlTY2FsZU1pbiA9IE1hdGgubWF4KHRoaXMueVNjYWxlIS5kb21haW4oKVswXSwgMCk7XG4gICAgY29uc3QgZDAgPSB7XG4gICAgICBbRDBUeXBlcy5wb3NpdGl2ZV06IDAsXG4gICAgICBbRDBUeXBlcy5uZWdhdGl2ZV06IDAsXG4gICAgfTtcblxuICAgIHJldHVybiBzZXJpZXMubWFwKChkLCBpbmRleCwgZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZC52YWx1ZSB8fCAwO1xuICAgICAgY29uc3QgbGFiZWwgPSBkLm5hbWUgfHwgJyc7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsKTtcbiAgICAgIGNvbnN0IHJvdW5kRWRnZXMgPSB0aGlzLnJvdW5kRWRnZXM7XG4gICAgICBkMFR5cGUgPSB2YWx1ZSA+IDAgPyBEMFR5cGVzLnBvc2l0aXZlIDogRDBUeXBlcy5uZWdhdGl2ZTtcblxuICAgICAgY29uc3QgYmFyOiBhbnkgPSB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgcm91bmRFZGdlcyxcbiAgICAgICAgZGF0YTogZCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGZvcm1hdHRlZExhYmVsLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICB9O1xuXG4gICAgICAvLyBVc2UgZGF0YSBvZiB0aGUgZ3JvdXAgb2YgYmFycyBmb3IgdG9vbHRpcHNcbiAgICAgIGlmICh0aGlzLmdyb3VwRGF0YSkge1xuICAgICAgICBiYXIuZGF0YSA9IHtcbiAgICAgICAgICBncm91cDogZ3JvdXAubWFwKChiYXJFbCkgPT4gKHsgLi4uYmFyRWwsIGNvbG9yOiB0aGlzLmNvbG9ycz8uZ2V0Q29sb3IoYmFyRWwubmFtZSB8fCAnJykgfSkpLFxuICAgICAgICAgIGRpZmY6IHRoaXMuZ3JvdXBEYXRhLmRpZmYsXG4gICAgICAgICAgY3VycmVuY3k6IHRoaXMuZ3JvdXBEYXRhLmN1cnJlbmN5LFxuICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxuICAgICAgICAgIGJhZGdlOiB0aGlzLmdyb3VwRGF0YS5iYWRnZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YW5kYXJkJykge1xuICAgICAgICBiYXIuaGVpZ2h0ID0gTWF0aC5hYnModGhpcy55U2NhbGUhKHZhbHVlKSAtIHRoaXMueVNjYWxlISh5U2NhbGVNaW4pKTtcbiAgICAgICAgYmFyLnggPSB0aGlzLnhTY2FsZT8uKGxhYmVsKTtcbiAgICAgICAgYmFyLnkgPSB0aGlzLnlTY2FsZT8uKE1hdGgubWF4KDAsIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ3N0YWNrZWQnKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldDAgPSBkMFtkMFR5cGVdO1xuICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0MCArIHZhbHVlO1xuICAgICAgICBkMFtkMFR5cGVdICs9IHZhbHVlO1xuXG4gICAgICAgIGJhci5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy55U2NhbGUhKG9mZnNldDApIC0gdGhpcy55U2NhbGUhKG9mZnNldDEpKTtcbiAgICAgICAgYmFyLnggPSAwO1xuICAgICAgICBiYXIueSA9IHRoaXMueVNjYWxlPy4ob2Zmc2V0MSk7XG4gICAgICAgIGJhci5vZmZzZXQwID0gb2Zmc2V0MDtcbiAgICAgICAgYmFyLm9mZnNldDEgPSBvZmZzZXQxO1xuICAgICAgICBiYXIucm91bmRFZGdlcyA9IGluZGV4ID09PSAxO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGJhciwgdGhpcy5nZXRDb2xvcnModmFsdWUsIGxhYmVsLCBiYXIub2Zmc2V0MCwgYmFyLm9mZnNldDEpKTtcblxuICAgICAgbGV0IHRvb2x0aXBMYWJlbCA9IGZvcm1hdHRlZExhYmVsO1xuICAgICAgaWYgKHRoaXMuc2VyaWVzTmFtZSkge1xuICAgICAgICB0b29sdGlwTGFiZWwgPSBgJHt0aGlzLnNlcmllc05hbWV9IOKAoiAke2Zvcm1hdHRlZExhYmVsfWA7XG4gICAgICAgIGJhci5kYXRhLnNlcmllcyA9IHRoaXMuc2VyaWVzTmFtZTtcbiAgICAgIH1cblxuICAgICAgYmFyLnRvb2x0aXBUZXh0ID0gdGhpcy50b29sdGlwVGV4dCh0b29sdGlwTGFiZWwsIHZhbHVlLnRvTG9jYWxlU3RyaW5nKCkpO1xuICAgICAgcmV0dXJuIGJhcjtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlZExhYmVscyhzZXJpZXM6IENoYXJ0QmFyRGF0YVtdKTogQ2hhcnREYXRhTGFiZWxzW10ge1xuICAgIHJldHVybiBzZXJpZXMubWFwKChkOiBDaGFydEJhckRhdGEpID0+ICh7XG4gICAgICBuYW1lOiBkLm5hbWUsXG4gICAgICBzZXJpZXM6IHRoaXMuc2VyaWVzTmFtZSA/IHRoaXMuc2VyaWVzTmFtZSA6IGQubmFtZSxcbiAgICAgIHRvdGFsOiBkLnZhbHVlLFxuICAgICAgeDogdGhpcy54U2NhbGU/LihkLm5hbWUpIHx8IDAsXG4gICAgICB5OiB0aGlzLnlTY2FsZT8uKDApIHx8IDAsXG4gICAgICBoZWlnaHQ6IHRoaXMueVNjYWxlID8gdGhpcy55U2NhbGUoZC52YWx1ZSkgLSB0aGlzLnlTY2FsZSgwKSA6IDAsXG4gICAgICB3aWR0aDogdGhpcy54U2NhbGU/LmJhbmR3aWR0aCgpIHx8IDAsXG4gICAgICByb3VuZEVkZ2VzOiB0aGlzLnJvdW5kRWRnZXMsXG4gICAgfSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRDaGFydERhdGEoc2VyaWVzOiBDaGFydEJhckRhdGFbXSk6IEZvcm1hdHRlZENoYXJ0RGF0YUxhYmVsc1tdIHtcbiAgICBjb25zdCB5U2NhbGVNaW4gPSBNYXRoLm1heCh0aGlzLnlTY2FsZSEuZG9tYWluKClbMF0sIDApO1xuICAgIGNvbnN0IGQwID0ge1xuICAgICAgW0QwVHlwZXMucG9zaXRpdmVdOiAwLFxuICAgICAgW0QwVHlwZXMubmVnYXRpdmVdOiAwLFxuICAgIH07XG4gICAgY29uc3QgZm9ybWF0dGVkU2VyaWVzOiBGb3JtYXR0ZWRDaGFydERhdGFMYWJlbHNbXSA9IHNlcmllcy5tYXAoKGQsIGluZGV4LCBncm91cCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBkLnZhbHVlIHx8IDA7XG4gICAgICBjb25zdCBsYWJlbCA9IGQubmFtZSB8fCAnJztcbiAgICAgIGNvbnN0IGQwVHlwZSA9IHZhbHVlID4gMCA/IEQwVHlwZXMucG9zaXRpdmUgOiBEMFR5cGVzLm5lZ2F0aXZlO1xuICAgICAgY29uc3QgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCk7XG4gICAgICBjb25zdCB0b29sdGlwTGFiZWwgPSB0aGlzLnNlcmllc05hbWUgPyBgJHt0aGlzLnNlcmllc05hbWV9IOKAoiAke2Zvcm1hdHRlZExhYmVsfWAgOiBmb3JtYXR0ZWRMYWJlbDtcblxuICAgICAgY29uc3QgZGF0YTogQ2hhcnREYXRhID0ge1xuICAgICAgICBuYW1lOiB0aGlzLnNlcmllc05hbWUgfHwgJycsXG4gICAgICAgIGdyb3VwOiBncm91cC5tYXAoKGJhckVsKSA9PiAoeyAuLi5iYXJFbCwgY29sb3I6IHRoaXMuY29sb3JzPy5nZXRDb2xvcihiYXJFbC5uYW1lIHx8ICcnKSB9KSksXG4gICAgICAgIHNlcmllczogZ3JvdXAubWFwKChiYXJFbCkgPT4gKHsgLi4uYmFyRWwsIGNvbG9yOiB0aGlzLmNvbG9ycz8uZ2V0Q29sb3IoYmFyRWwubmFtZSB8fCAnJykgfSkpLFxuICAgICAgICBkaWZmOiB0aGlzLmdyb3VwRGF0YT8uZGlmZixcbiAgICAgICAgY3VycmVuY3k6IHRoaXMuZ3JvdXBEYXRhPy5jdXJyZW5jeSxcbiAgICAgICAgdmFsdWU6IGQudmFsdWUsXG4gICAgICAgIGJhZGdlOiB0aGlzLmdyb3VwRGF0YT8uYmFkZ2UsXG4gICAgICB9O1xuICAgICAgY29uc3QgZ3JhcGhEYXRhOiBEYXRhSXRlbSA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5zZXJpZXNOYW1lIHx8ICcnLFxuICAgICAgICB2YWx1ZTogZC52YWx1ZSxcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGFuZGFyZFR5cGU6IENoYXJ0RGF0YUxhYmVscyA9IHtcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyh0aGlzLnlTY2FsZSEodmFsdWUpIC0gdGhpcy55U2NhbGUhKHlTY2FsZU1pbikpLFxuICAgICAgICBvZmZzZXQwOiB1bmRlZmluZWQsXG4gICAgICAgIG9mZnNldDE6IHVuZGVmaW5lZCxcbiAgICAgICAgcm91bmRFZGdlczogdGhpcy5yb3VuZEVkZ2VzLFxuICAgICAgICB4OiB0aGlzLnhTY2FsZT8uKGxhYmVsKSB8fCAwLFxuICAgICAgICB5OiB0aGlzLnlTY2FsZT8uKE1hdGgubWF4KDAsIHZhbHVlKSkgfHwgMCxcbiAgICAgICAgd2lkdGg6IHRoaXMueFNjYWxlPy5iYW5kd2lkdGgoKSB8fCAwLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0YWNrZWRUeXBlOiBDaGFydERhdGFMYWJlbHMgPSB7XG4gICAgICAgIGhlaWdodDogTWF0aC5jZWlsKHRoaXMueVNjYWxlIShkMFtkMFR5cGVdKSAtIHRoaXMueVNjYWxlIShkMFtkMFR5cGVdICsgdmFsdWUpKSxcbiAgICAgICAgb2Zmc2V0MDogZDBbZDBUeXBlXSxcbiAgICAgICAgb2Zmc2V0MTogZDBbZDBUeXBlXSArIHZhbHVlLFxuICAgICAgICByb3VuZEVkZ2VzOiBpbmRleCA9PT0gMSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogdGhpcy55U2NhbGU/LihkMFtkMFR5cGVdICsgdmFsdWUpIHx8IDAsXG4gICAgICAgIHdpZHRoOiB0aGlzLnhTY2FsZT8uYmFuZHdpZHRoKCkgfHwgMCxcbiAgICAgIH07XG4gICAgICBjb25zdCB0eXBlT2JqZWN0OiBDaGFydERhdGFMYWJlbHMgPSB0aGlzLnR5cGUgPT09ICdzdGFja2VkJyA/IHN0YWNrZWRUeXBlIDogc3RhbmRhcmRUeXBlO1xuXG4gICAgICBjb25zdCByZXR1cm5PYmplY3Q6IEZvcm1hdHRlZENoYXJ0RGF0YUxhYmVscyA9IHtcbiAgICAgICAgLi4udHlwZU9iamVjdCxcbiAgICAgICAgLi4udGhpcy5nZXRDb2xvcnModmFsdWUsIGxhYmVsLCB0eXBlT2JqZWN0Lm9mZnNldDAsIHR5cGVPYmplY3Qub2Zmc2V0MSksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHRvb2x0aXBUZXh0OiB0aGlzLnRvb2x0aXBUZXh0KHRvb2x0aXBMYWJlbCwgdmFsdWUudG9Mb2NhbGVTdHJpbmcoKSksXG4gICAgICAgIGZvcm1hdHRlZExhYmVsLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGdyYXBoRGF0YTogeyAuLi5ncmFwaERhdGEgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXR1cm5PYmplY3Q7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZm9ybWF0dGVkU2VyaWVzO1xuICB9XG5cbiAgdXBkYXRlVG9vbHRpcFNldHRpbmdzKCkge1xuICAgIHRoaXMuZGVwcmVjYXRpb25TZXJ2aWNlLmxvZ0RlcHJlY2F0ZWRGZWF0dXJlKFxuICAgICAgJ0RlcHJlY2F0ZWQgI3VwZGF0ZVRvb2x0aXBTZXR0aW5ncyBtZXRob2QgaW5zaWRlICNCYlNlcmllc1ZlcnRpY2FsQ29tcG9uZW50IGluIGZhdm9yIG9mIGFzc2lnbmluZyB2YWx1ZXMgZHVyaW5nIGNvbXBvbmVudCBjcmVhdGlvbicsXG4gICAgKTtcbiAgICB0aGlzLnRvb2x0aXBQbGFjZW1lbnQgPSB0aGlzLnRvb2x0aXBEaXNhYmxlZCA/IHVuZGVmaW5lZCA6IFBsYWNlbWVudFR5cGVzLlRvcDtcbiAgICB0aGlzLnRvb2x0aXBUeXBlID0gdGhpcy50b29sdGlwRGlzYWJsZWQgPyB1bmRlZmluZWQgOiBTdHlsZVR5cGVzLnRvb2x0aXA7XG4gIH1cblxuICBpc0FjdGl2ZShlbnRyeTogYW55KTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZUVudHJpZXMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5hY3RpdmVFbnRyaWVzLmZpbmQoKGQpID0+IHtcbiAgICAgIHJldHVybiBlbnRyeS5uYW1lID09PSBkLm5hbWUgJiYgZW50cnkuc2VyaWVzID09PSBkLnNlcmllcztcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlbSAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb25DbGljayhkYXRhOiBhbnkpIHtcbiAgICB0aGlzLnNlbGVjdC5lbWl0KGRhdGEpO1xuICB9XG5cbiAgdHJhY2tCeShpbmRleDogbnVtYmVyLCBiYXI6IGFueSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGJhci5sYWJlbDtcbiAgfVxuXG4gIHRyYWNrRGF0YUxhYmVsQnkoaW5kZXg6IG51bWJlciwgYmFyTGFiZWw6IGFueSkge1xuICAgIHJldHVybiBgJHtpbmRleH0jJHtiYXJMYWJlbC5zZXJpZXN9IyR7YmFyTGFiZWwudG90YWx9YDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGVwcmVjYXRpb25TZXJ2aWNlOiBEZXByZWNhdGlvbnNTZXJ2aWNlKSB7fVxufVxuIiwiPHN2ZzpnIG5neC1jaGFydHMtYmFyXG4gICpuZ0Zvcj1cImxldCBiYXIgb2YgYmFyczsgdHJhY2tCeTogdHJhY2tCeVwiXG4gIFtAYW5pbWF0aW9uU3RhdGVdPVwiJ2FjdGl2ZSdcIlxuICBbQC5kaXNhYmxlZF09XCIhYW5pbWF0aW9uc1wiXG4gIFt3aWR0aF09XCJiYXIud2lkdGhcIlxuICBbaGVpZ2h0XT1cImJhci5oZWlnaHRcIlxuICBbeF09XCJiYXIueFwiXG4gIFt5XT1cImJhci55XCJcbiAgW2ZpbGxdPVwiYmFyLmNvbG9yXCJcbiAgW3N0b3BzXT1cImJhci5ncmFkaWVudFN0b3BzXCJcbiAgW2RhdGFdPVwiYmFyLmdyYXBoRGF0YVwiXG4gIFtvcmllbnRhdGlvbl09XCJvcmllbnRhdGlvblwiXG4gIFtyb3VuZEVkZ2VzXT1cImJhci5yb3VuZEVkZ2VzXCJcbiAgW2dyYWRpZW50XT1cImdyYWRpZW50XCJcbiAgW2lzQWN0aXZlXT1cImlzQWN0aXZlKGJhcilcIlxuICAoc2VsZWN0KT1cIm9uQ2xpY2soJGV2ZW50KVwiXG4gIChhY3RpdmF0ZSk9XCJhY3RpdmF0ZS5lbWl0KCRldmVudClcIlxuICAoZGVhY3RpdmF0ZSk9XCJkZWFjdGl2YXRlLmVtaXQoJGV2ZW50KVwiXG4gIG5neC10b29sdGlwXG4gIFt0b29sdGlwQ3NzQ2xhc3NdPVwiJ2NoYXJ0LXRvb2x0aXAgcC0wIGJvcmRlci0wJ1wiXG4gIFt0b29sdGlwU2hvd0NhcmV0XT1cInRvb2x0aXBTaG93Q2FyZXRcIlxuICBbdG9vbHRpcERpc2FibGVkXT1cInRvb2x0aXBEaXNhYmxlZFwiXG4gIFt0b29sdGlwUGxhY2VtZW50XT1cInRvb2x0aXBQbGFjZW1lbnRcIlxuICBbdG9vbHRpcFR5cGVdPVwidG9vbHRpcFR5cGVcIlxuICBbdG9vbHRpcFRpdGxlXT1cInRvb2x0aXBUZW1wbGF0ZSA/IHVuZGVmaW5lZCA6IGJhci50b29sdGlwVGV4dFwiXG4gIFt0b29sdGlwVGVtcGxhdGVdPVwidG9vbHRpcFRlbXBsYXRlXCJcbiAgW3Rvb2x0aXBDb250ZXh0XT1cImJhci5kYXRhXCJcbiAgW2FuaW1hdGlvbnNdPVwiYW5pbWF0aW9uc1wiPlxuPC9zdmc6Zz5cbjxzdmc6ZyAqbmdJZj1cInNob3dEYXRhTGFiZWxcIj5cbiAgPHN2ZzpnIG5neC1jaGFydHMtYmFyLWxhYmVsIFxuICAgICpuZ0Zvcj1cImxldCBiIG9mIGJhcnNGb3JEYXRhTGFiZWxzOyBsZXQgaSA9IGluZGV4OyB0cmFja0J5OnRyYWNrRGF0YUxhYmVsQnlcIlxuICAgIFtiYXJYXT1cImIueFwiXG4gICAgW2JhclldPVwiYi55XCJcbiAgICBbYmFyV2lkdGhdPVwiYi53aWR0aFwiXG4gICAgW2JhckhlaWdodF09XCJiLmhlaWdodFwiXG4gICAgW3ZhbHVlXT1cImIudG90YWxcIlxuICAgIFt2YWx1ZUZvcm1hdHRpbmddPVwiZGF0YUxhYmVsRm9ybWF0dGluZ1wiXG4gICAgW29yaWVudGF0aW9uXT1cIm9yaWVudGF0aW9uXCJcbiAgICAoZGltZW5zaW9uc0NoYW5nZWQpPVwiZGF0YUxhYmVsSGVpZ2h0Q2hhbmdlZC5lbWl0KHtzaXplOiRldmVudCwgaW5kZXg6aX0pXCJcbiAgLz5cbjwvc3ZnOmc+XG4iXX0=