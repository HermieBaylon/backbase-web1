import * as i0 from '@angular/core';
import { EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, PLATFORM_ID, Inject, ViewChild, Directive, Injectable, Optional, NgModule } from '@angular/core';
import * as i1 from '@swimlane/ngx-charts';
import { formatLabel, BaseChartComponent, ScaleType, calculateViewDimensions, ColorHelper, PlacementTypes, StyleTypes, BarOrientation, LegendPosition, NgxChartsModule } from '@swimlane/ngx-charts';
import * as i1$1 from '@angular/common';
import { DatePipe, CommonModule, CurrencyPipe } from '@angular/common';
import { __decorate } from 'tslib';
import * as i1$2 from '@backbase/foundation-ang/future';
import * as i1$4 from '@backbase/foundation-ang/core';
import { BbTemplate, BackbaseCoreModule } from '@backbase/foundation-ang/core';
import * as i2 from '@backbase/ui-ang/css-variables-lib';
import { CssVariablesService } from '@backbase/ui-ang/css-variables-lib';
import { combineLatest, from, BehaviorSubject, of } from 'rxjs';
import { map, tap, filter, switchMap, catchError, pluck } from 'rxjs/operators';
import { trigger, transition, style, animate } from '@angular/animations';
import { scaleBand, scaleLinear } from 'd3-scale';
import * as i5 from '@backbase/ui-ang/amount';
import { FormatAmountModule } from '@backbase/ui-ang/amount';
import * as i1$3 from '@backbase/data-ang/transactions';
import * as i2$1 from '@angular/router';
import * as i5$1 from '@backbase/ui-ang/loading-indicator';
import { LoadingIndicatorModule } from '@backbase/ui-ang/loading-indicator';
import * as i6 from '@backbase/ui-ang/empty-state';
import { EmptyStateModule } from '@backbase/ui-ang/empty-state';
import * as i8 from '@backbase/ui-ang/button';
import { ButtonModule } from '@backbase/ui-ang/button';

class BbTurnoversLegendComponent {
    constructor(cd) {
        this.cd = cd;
        /**
         * The data for the chart legend.
         */
        this.data = [];
        /**
         * The active entries for the chart legend.
         */
        this.activeEntries = [];
        /**
         * EventEmitter for triggering a labelClick event.
         */
        this.labelClick = new EventEmitter();
        /**
         * EventEmitter for triggering a labelActivate event.
         */
        this.labelActivate = new EventEmitter();
        /**
         * EventEmitter for triggering a labelDeactivate event.
         */
        this.labelDeactivate = new EventEmitter();
        this.legendEntries = [];
    }
    ngOnChanges() {
        this.update();
    }
    update() {
        this.cd.markForCheck();
        this.legendEntries = this.getLegendEntries();
    }
    getLegendEntries() {
        var _a;
        const items = [];
        for (const label of this.data) {
            const formattedLabel = formatLabel(label);
            const idx = items.findIndex((i) => {
                return i.label === formattedLabel;
            });
            if (idx === -1) {
                items.push({
                    label,
                    formattedLabel,
                    color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(label),
                });
            }
        }
        return items;
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find((d) => {
            return entry.label === d.name;
        });
        return item !== undefined;
    }
    activate(item) {
        this.labelActivate.emit(item);
    }
    deactivate(item) {
        this.labelDeactivate.emit(item);
    }
    trackBy(index, item) {
        return item.label;
    }
}
BbTurnoversLegendComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbTurnoversLegendComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
BbTurnoversLegendComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbTurnoversLegendComponent, selector: "bb-charts-legend", inputs: { data: "data", title: "title", colors: "colors", height: "height", width: "width", activeEntries: "activeEntries" }, outputs: { labelClick: "labelClick", labelActivate: "labelActivate", labelDeactivate: "labelDeactivate" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"row\">\n  <header class=\"legend-title\" *ngIf=\"title?.length > 0\">\n    <span class=\"legend-title-text\">{{title}}</span>\n  </header>\n  <div class=\"legend-wrap\">\n    <ul class=\"legend-labels d-flex px-5 mb-3\"\n      [style.max-height.px]=\"height ? height - 45 : 'inherit'\">\n      <li\n        *ngFor=\"let entry of legendEntries; trackBy: trackBy\"\n        class=\"legend-label text-dark text-capitalize\">\n        <ngx-charts-legend-entry\n          [label]=\"entry.label\"\n          [formattedLabel]=\"entry.formattedLabel\"\n          [color]=\"entry.color\"\n          [isActive]=\"isActive(entry)\"\n          (select)=\"labelClick.emit($event)\"\n          (activate)=\"activate($event)\"\n          (deactivate)=\"deactivate($event)\">\n        </ngx-charts-legend-entry>\n      </li>\n    </ul>\n  </div>\n</div>\n", styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:bold}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"], components: [{ type: i1.LegendEntryComponent, selector: "ngx-charts-legend-entry", inputs: ["isActive", "color", "label", "formattedLabel"], outputs: ["select", "activate", "deactivate", "toggle"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbTurnoversLegendComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-charts-legend',
                    templateUrl: './bb-turnovers-legend.component.html',
                    styleUrls: ['./bb-turnovers-legend.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { data: [{
                type: Input
            }], title: [{
                type: Input
            }], colors: [{
                type: Input
            }], height: [{
                type: Input
            }], width: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], labelClick: [{
                type: Output
            }], labelActivate: [{
                type: Output
            }], labelDeactivate: [{
                type: Output
            }] } });

class BbGridPanelSeriesComponent {
    constructor(deprecationService) {
        this.deprecationService = deprecationService;
        this.gridPanels = [];
        /**
         * Array of Chart data objects needed for the chart to be rendered.
         */
        this.data = [];
        /**
         * Dimensions of the chart.
         */
        this.dims = {
            height: 0,
            width: 0,
        };
    }
    set orient(val) {
        this.deprecationService.logDeprecatedFeature('Removed #orient input from #BbGridPanelSeriesComponent');
        this._orient = val;
    }
    get orient() {
        return this._orient || 'vertical';
    }
    ngOnChanges() {
        this.update();
    }
    update() {
        this.gridPanels = this.getChartDataLabels();
    }
    getChartDataLabels() {
        return this.data.map((d) => {
            var _a;
            const labelName = (_a = d.name) !== null && _a !== void 0 ? _a : '';
            let width = 0;
            let xValue = 0;
            if (!!this.xScale) {
                const offset = this.xScale.bandwidth() * this.xScale.paddingInner();
                width = this.xScale.bandwidth() + offset;
                xValue = (this.xScale(labelName) || 0) - offset / 2;
            }
            return {
                name: labelName,
                class: d.badge === 'forecast' ? 'forecast' : '',
                width: width,
                height: this.dims.height,
                x: xValue,
                y: 0,
                roundEdges: false,
            };
        });
    }
    getGridPanels() {
        this.deprecationService.logDeprecatedFeature('#getGridPanels deprecation in favor of private method #getChartDataLabels from #BbGridPanelSeriesComponent');
        const localXScale = this.xScale;
        const localYScale = this.yScale;
        return this.data.map((d) => {
            let offset;
            let width;
            let height;
            let x;
            let y;
            if (this.orient === 'vertical') {
                offset = localXScale.bandwidth() * localXScale.paddingInner();
                width = localXScale.bandwidth() + offset;
                height = this.dims.height;
                x = (localXScale(d.name) || 0) - offset / 2;
                y = 0;
            }
            else if (this.orient === 'horizontal') {
                offset = localYScale.bandwidth() * localYScale.paddingInner();
                width = this.dims.width;
                height = localYScale.bandwidth() + offset;
                x = 0;
                y = localYScale(d.name) - offset / 2;
            }
            return {
                name: d.name,
                class: d.badge === 'forecast' ? 'forecast' : '',
                height,
                width,
                x,
                y,
            };
        });
    }
}
BbGridPanelSeriesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbGridPanelSeriesComponent, deps: [{ token: i1$2.DeprecationsService }], target: i0.ɵɵFactoryTarget.Component });
BbGridPanelSeriesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbGridPanelSeriesComponent, selector: "g[bb-charts-grid-panel-series]", inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale" }, usesOnChanges: true, ngImport: i0, template: "<svg:g *ngFor=\"let gridPanel of gridPanels\">\n  <svg:g ngx-charts-grid-panel\n    [height]=\"gridPanel.height\"\n    [width]=\"gridPanel.width\"\n    [x]=\"gridPanel.x\"\n    [y]=\"gridPanel.y\"\n    [class.grid-panel]=\"true\"\n    [class.forecast]=\"gridPanel.class === 'forecast'\">\n  </svg:g>\n</svg:g>\n", components: [{ type: i1.GridPanelComponent, selector: "g[ngx-charts-grid-panel]", inputs: ["width", "height", "x", "y"] }], directives: [{ type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
__decorate([
    Input()('orient')
], BbGridPanelSeriesComponent.prototype, "orient", null);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbGridPanelSeriesComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'g[bb-charts-grid-panel-series]',
                    templateUrl: './bb-grid-panel-series.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1$2.DeprecationsService }]; }, propDecorators: { data: [{
                type: Input
            }], dims: [{
                type: Input
            }], xScale: [{
                type: Input
            }], yScale: [{
                type: Input
            }] } });

const PROPERTIES = {
    FORECAST: {
        name: 'showForecast',
        value: true,
    },
};
const PERIODS = [
    {
        interval: 'MONTH',
        duration: 6,
        default: true,
    },
    {
        interval: 'MONTH',
        duration: 12,
    },
];
const INTERVAL = {
    DAY: 'DAY',
    WEEK: 'WEEK',
    MONTH: 'MONTH',
    YEAR: 'YEAR',
};
const DEFAULT_INTERVAL = INTERVAL.MONTH;
const DEFAULT_DURATION = 6;
const DEFAULT_START_DAY = 1;
const BAR_COLORS_CSS_VAR = '--chart-group-bar-color';
const CHART_COLORS = ['#004285', '#107bb5'];
const MOBILE_WIDGET_WIDTH = 688;
const filterInputParameters = (input, prop) => combineLatest([input, prop]).pipe(map(([inputVal, propVal]) => (inputVal !== undefined ? inputVal : propVal)));

class TurnoversVerticalBarChartComponent extends BaseChartComponent {
    constructor(chartElement, zone, cd, platformId) {
        super(chartElement, zone, cd, platformId);
        /**
         * Enable/Disable chart legend.
         */
        this.legend = false;
        /**
         * The title for the chart legend.
         */
        this.legendTitle = '';
        /**
         * Hide/show the horizontal axis.
         */
        this.xAxis = true;
        /**
         * Hide/show the vertical axis.
         */
        this.yAxis = true;
        /**
         * Show the horizontal axis label.
         */
        this.showXAxisLabel = true;
        /**
         * Show the vertical axis label.
         */
        this.showYAxisLabel = true;
        /**
         * The label for the horizontal axis.
         */
        this.xAxisLabel = '';
        /**
         * The label for the vertical axis.
         */
        this.yAxisLabel = '';
        /**
         * Enable/Disable chart tooltip.
         */
        this.tooltipDisabled = false;
        /**
         * Enable/Disable chart gradient.
         */
        this.gradient = false;
        /**
         * Show/hide chart grid lines.
         */
        this.showGridLines = true;
        /**
         * The active entries for the chart legend.
         */
        this.activeEntries = [];
        /**
         * Sets the scheme type of the chart.
         */
        this.schemeType = ScaleType.Ordinal;
        /**
         * Padding of the chart bars.
         */
        this.barPadding = 8;
        /**
         * Enable/Disable rounded corners.
         */
        this.roundDomains = true;
        /**
         * Enable/disable rounded edges for the bars.
         */
        this.roundEdges = false;
        /**
         * Maximum vertical chart scale.
         */
        this.yScaleMax = 0;
        /**
         * Hide/show the data labels.
         */
        this.showDataLabel = false;
        /**
         * Array of Chart data objects needed for the chart to be rendered.
         */
        this.groupsData = [];
        /**
         * The chart legend template.
         */
        this.legendTemplate = null;
        /**
         * EventEmitter for triggering a activate event.
         */
        this.activate = new EventEmitter();
        /**
         * EventEmitter for triggering a deactivate event.
         */
        this.deactivate = new EventEmitter();
        this.dims = { width: 0, height: 0, xOffset: 0 };
        this.groupDomain = [];
        this.innerDomain = [];
        this.valueDomain = [];
        this.margin = [10, 20, 10, 20];
        this.xAxisHeight = 0;
        this.yAxisWidth = 0;
        this.dataLabelMaxHeight = { negative: 0, positive: 0 };
    }
    update() {
        super.update();
        if (!this.showDataLabel) {
            this.dataLabelMaxHeight = { negative: 0, positive: 0 };
        }
        this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
        this.dims = calculateViewDimensions({
            width: this.width,
            height: this.height,
            margins: this.margin,
            showXAxis: this.xAxis,
            showYAxis: this.yAxis,
            xAxisHeight: this.xAxisHeight,
            yAxisWidth: this.yAxisWidth,
            showXLabel: this.showXAxisLabel,
            showYLabel: this.showYAxisLabel,
            showLegend: this.legend,
            legendType: this.schemeType,
        });
        if (this.showDataLabel) {
            this.dims.height -= this.dataLabelMaxHeight.negative;
        }
        this.formatDates();
        this.groupDomain = this.getGroupDomain();
        this.innerDomain = this.getInnerDomain();
        this.setColors();
        this.transform = `translate(${this.dims.xOffset} , ${this.margin[0] + this.dataLabelMaxHeight.negative})`;
    }
    getGroupDomain() {
        const domain = [];
        for (const group of this.results) {
            if (!domain.includes(group.name)) {
                domain.push(group.name);
            }
        }
        return domain;
    }
    getInnerDomain() {
        const domain = [];
        for (const group of this.results) {
            for (const d of group.series) {
                if (!domain.includes(d.name)) {
                    domain.push(d.name);
                }
            }
        }
        return domain;
    }
    getXScale() {
        const spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
        return scaleBand().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
    }
    getYScale() {
        const scale = scaleLinear().range([this.dims.height, 0]).domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    }
    onDataLabelMaxHeightChanged(event, groupIndex) {
        if (event.size.negative) {
            this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
        }
        else {
            this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
        }
        if (groupIndex === this.results.length - 1) {
            setTimeout(() => this.update());
        }
    }
    onClick(data, group) {
        if (group) {
            data.series = group.name;
        }
        this.select.emit(data);
    }
    trackBy(index, item) {
        return item.name;
    }
    setColors() {
        const domain = this.schemeType === ScaleType.Ordinal ? this.innerDomain : this.valueDomain;
        this.colors = new ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
    }
    updateYAxisWidth(axis) {
        this.yAxisWidth = axis.width;
        this.update();
    }
    updateXAxisHeight(axis) {
        this.xAxisHeight = axis.height;
        this.update();
    }
    onActivate(event, group) {
        const item = Object.assign({}, event);
        if (group) {
            item.series = group.name;
        }
        const idx = this.activeEntries.findIndex((d) => {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        if (idx > -1) {
            return;
        }
        this.activeEntries = [item, ...this.activeEntries];
        this.activate.emit({ value: item, entries: this.activeEntries });
    }
    onDeactivate(event, group) {
        const item = Object.assign({}, event);
        if (group) {
            item.series = group.name;
        }
        const idx = this.activeEntries.findIndex((d) => {
            return d.name === item.name && d.value === item.value && d.series === item.series;
        });
        this.activeEntries.splice(idx, 1);
        this.activeEntries = [...this.activeEntries]; // NOSONAR false positive - https://github.com/SonarSource/SonarTS/issues/760
        this.deactivate.emit({ value: item, entries: this.activeEntries });
    }
}
TurnoversVerticalBarChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalBarChartComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });
TurnoversVerticalBarChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalBarChartComponent, selector: "ng-component", inputs: { legend: "legend", legendTitle: "legendTitle", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", activeEntries: "activeEntries", schemeType: "schemeType", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", groupsData: "groupsData", tooltipTemplate: "tooltipTemplate", legendTemplate: "legendTemplate" }, outputs: { activate: "activate", deactivate: "deactivate" }, usesInheritance: true, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalBarChartComponent, decorators: [{
            type: Component,
            args: [{
                    template: '',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; }, propDecorators: { legend: [{
                type: Input
            }], legendTitle: [{
                type: Input
            }], xAxis: [{
                type: Input
            }], yAxis: [{
                type: Input
            }], showXAxisLabel: [{
                type: Input
            }], showYAxisLabel: [{
                type: Input
            }], xAxisLabel: [{
                type: Input
            }], yAxisLabel: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], gradient: [{
                type: Input
            }], showGridLines: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], schemeType: [{
                type: Input
            }], xAxisTickFormatting: [{
                type: Input
            }], yAxisTickFormatting: [{
                type: Input
            }], barPadding: [{
                type: Input
            }], roundDomains: [{
                type: Input
            }], roundEdges: [{
                type: Input
            }], yScaleMax: [{
                type: Input
            }], showDataLabel: [{
                type: Input
            }], dataLabelFormatting: [{
                type: Input
            }], groupsData: [{
                type: Input
            }], tooltipTemplate: [{
                type: Input
            }], legendTemplate: [{
                type: Input
            }], activate: [{
                type: Output
            }], deactivate: [{
                type: Output
            }] } });

var D0Types;
(function (D0Types) {
    D0Types["positive"] = "positive";
    D0Types["negative"] = "negative";
})(D0Types || (D0Types = {}));
class BbSeriesVerticalComponent {
    constructor(deprecationService) {
        this.deprecationService = deprecationService;
        /**
         * The type of the chart bars.
         */
        this.type = 'standard';
        /**
         * Enable/disable bars gradient.
         */
        this.gradient = false;
        /**
         * The active entries for the chart bars.
         */
        this.activeEntries = [];
        /**
         * Name of the chart series.
         */
        this.seriesName = '';
        /**
         * Enabel/Disable bars tooltip.
         */
        this.tooltipDisabled = false;
        /**
         * Show/Hide tooltip caret.
         */
        this.tooltipShowCaret = false;
        /**
         * Enable/disable bars rounded edges.
         */
        this.roundEdges = false;
        /**
         * Enable/disable bars animation.
         */
        this.animations = true;
        /**
         * Show/hide bars label.
         */
        this.showDataLabel = false;
        /**
         * EventEmitter for triggering a select event.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.select = new EventEmitter();
        /**
         * EventEmitter for triggering a activate event.
         */
        this.activate = new EventEmitter();
        /**
         * EventEmitter for triggering a deactivate event.
         */
        this.deactivate = new EventEmitter();
        /**
         * EventEmitter for triggering a dataLabelHeightChanged event.
         */
        this.dataLabelHeightChanged = new EventEmitter();
        this.tooltipPlacement = PlacementTypes.Top;
        this.tooltipType = StyleTypes.tooltip;
        this.orientation = BarOrientation.Vertical;
        this.barsForDataLabels = [];
    }
    getColors(value, label, offset0, offset1) {
        const bar = {};
        if (this.colors) {
            if (this.colors.scaleType === ScaleType.Ordinal) {
                bar.color = this.colors.getColor(label);
            }
            else {
                if (this.type === 'standard') {
                    bar.color = this.colors.getColor(value);
                    bar.gradientStops = this.colors.getLinearGradientStops(value);
                }
                else {
                    bar.color = this.colors.getColor(offset1 || 0);
                    bar.gradientStops = this.colors.getLinearGradientStops(offset1 || 0, offset0);
                }
            }
        }
        return bar;
    }
    tooltipText(label, value) {
        return this.tooltipDisabled
            ? undefined
            : `
      <span class="tooltip-label">${label}</span>
      <span class="tooltip-val">${value}</span>
    `;
    }
    ngOnChanges() {
        if (!this.series) {
            throw new Error('[series] should be provided to the component!');
        }
        this.update(this.series);
    }
    update(series) {
        this.bars = this.formatChartData(series);
        this.barsForDataLabels = this.updatedLabels(series);
    }
    updateDataLabels(series) {
        this.deprecationService.logDeprecatedFeature('#updateDataLabels inside #BbSeriesVerticalComponent deprecated in favor of #updatedLabels, which returns the formatted object instead of assigning values within itself');
        this.barsForDataLabels = this.updatedLabels(series);
    }
    updatedBars(series) {
        var _a;
        let d0Type = D0Types.positive;
        const width = (_a = this.xScale) === null || _a === void 0 ? void 0 : _a.bandwidth();
        const yScaleMin = Math.max(this.yScale.domain()[0], 0);
        const d0 = {
            [D0Types.positive]: 0,
            [D0Types.negative]: 0,
        };
        return series.map((d, index, group) => {
            var _a, _b, _c;
            const value = d.value || 0;
            const label = d.name || '';
            const formattedLabel = formatLabel(label);
            const roundEdges = this.roundEdges;
            d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            const bar = {
                value,
                label,
                roundEdges,
                data: d,
                width,
                formattedLabel,
                height: 0,
                x: 0,
                y: 0,
            };
            // Use data of the group of bars for tooltips
            if (this.groupData) {
                bar.data = {
                    group: group.map((barEl) => { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                    diff: this.groupData.diff,
                    currency: this.groupData.currency,
                    value: d.value,
                    badge: this.groupData.badge,
                };
            }
            if (this.type === 'standard') {
                bar.height = Math.abs(this.yScale(value) - this.yScale(yScaleMin));
                bar.x = (_a = this.xScale) === null || _a === void 0 ? void 0 : _a.call(this, label);
                bar.y = (_b = this.yScale) === null || _b === void 0 ? void 0 : _b.call(this, Math.max(0, value));
            }
            else if (this.type === 'stacked') {
                const offset0 = d0[d0Type];
                const offset1 = offset0 + value;
                d0[d0Type] += value;
                bar.height = Math.ceil(this.yScale(offset0) - this.yScale(offset1));
                bar.x = 0;
                bar.y = (_c = this.yScale) === null || _c === void 0 ? void 0 : _c.call(this, offset1);
                bar.offset0 = offset0;
                bar.offset1 = offset1;
                bar.roundEdges = index === 1;
            }
            Object.assign(bar, this.getColors(value, label, bar.offset0, bar.offset1));
            let tooltipLabel = formattedLabel;
            if (this.seriesName) {
                tooltipLabel = `${this.seriesName} • ${formattedLabel}`;
                bar.data.series = this.seriesName;
            }
            bar.tooltipText = this.tooltipText(tooltipLabel, value.toLocaleString());
            return bar;
        });
    }
    updatedLabels(series) {
        return series.map((d) => {
            var _a, _b, _c;
            return ({
                name: d.name,
                series: this.seriesName ? this.seriesName : d.name,
                total: d.value,
                x: ((_a = this.xScale) === null || _a === void 0 ? void 0 : _a.call(this, d.name)) || 0,
                y: ((_b = this.yScale) === null || _b === void 0 ? void 0 : _b.call(this, 0)) || 0,
                height: this.yScale ? this.yScale(d.value) - this.yScale(0) : 0,
                width: ((_c = this.xScale) === null || _c === void 0 ? void 0 : _c.bandwidth()) || 0,
                roundEdges: this.roundEdges,
            });
        });
    }
    formatChartData(series) {
        const yScaleMin = Math.max(this.yScale.domain()[0], 0);
        const d0 = {
            [D0Types.positive]: 0,
            [D0Types.negative]: 0,
        };
        const formattedSeries = series.map((d, index, group) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const value = d.value || 0;
            const label = d.name || '';
            const d0Type = value > 0 ? D0Types.positive : D0Types.negative;
            const formattedLabel = formatLabel(label);
            const tooltipLabel = this.seriesName ? `${this.seriesName} • ${formattedLabel}` : formattedLabel;
            const data = {
                name: this.seriesName || '',
                group: group.map((barEl) => { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                series: group.map((barEl) => { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                diff: (_a = this.groupData) === null || _a === void 0 ? void 0 : _a.diff,
                currency: (_b = this.groupData) === null || _b === void 0 ? void 0 : _b.currency,
                value: d.value,
                badge: (_c = this.groupData) === null || _c === void 0 ? void 0 : _c.badge,
            };
            const graphData = {
                name: this.seriesName || '',
                value: d.value,
            };
            const standardType = {
                height: Math.abs(this.yScale(value) - this.yScale(yScaleMin)),
                offset0: undefined,
                offset1: undefined,
                roundEdges: this.roundEdges,
                x: ((_d = this.xScale) === null || _d === void 0 ? void 0 : _d.call(this, label)) || 0,
                y: ((_e = this.yScale) === null || _e === void 0 ? void 0 : _e.call(this, Math.max(0, value))) || 0,
                width: ((_f = this.xScale) === null || _f === void 0 ? void 0 : _f.bandwidth()) || 0,
            };
            const stackedType = {
                height: Math.ceil(this.yScale(d0[d0Type]) - this.yScale(d0[d0Type] + value)),
                offset0: d0[d0Type],
                offset1: d0[d0Type] + value,
                roundEdges: index === 1,
                x: 0,
                y: ((_g = this.yScale) === null || _g === void 0 ? void 0 : _g.call(this, d0[d0Type] + value)) || 0,
                width: ((_h = this.xScale) === null || _h === void 0 ? void 0 : _h.bandwidth()) || 0,
            };
            const typeObject = this.type === 'stacked' ? stackedType : standardType;
            const returnObject = Object.assign(Object.assign(Object.assign({}, typeObject), this.getColors(value, label, typeObject.offset0, typeObject.offset1)), { data, tooltipText: this.tooltipText(tooltipLabel, value.toLocaleString()), formattedLabel,
                value,
                label, graphData: Object.assign({}, graphData) });
            return returnObject;
        });
        return formattedSeries;
    }
    updateTooltipSettings() {
        this.deprecationService.logDeprecatedFeature('Deprecated #updateTooltipSettings method inside #BbSeriesVerticalComponent in favor of assigning values during component creation');
        this.tooltipPlacement = this.tooltipDisabled ? undefined : PlacementTypes.Top;
        this.tooltipType = this.tooltipDisabled ? undefined : StyleTypes.tooltip;
    }
    isActive(entry) {
        if (!this.activeEntries)
            return false;
        const item = this.activeEntries.find((d) => {
            return entry.name === d.name && entry.series === d.series;
        });
        return item !== undefined;
    }
    onClick(data) {
        this.select.emit(data);
    }
    trackBy(index, bar) {
        return bar.label;
    }
    trackDataLabelBy(index, barLabel) {
        return `${index}#${barLabel.series}#${barLabel.total}`;
    }
}
BbSeriesVerticalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbSeriesVerticalComponent, deps: [{ token: i1$2.DeprecationsService }], target: i0.ɵɵFactoryTarget.Component });
BbSeriesVerticalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: { dims: "dims", type: "type", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", animations: "animations", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", groupData: "groupData" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, usesOnChanges: true, ngImport: i0, template: "<svg:g ngx-charts-bar\n  *ngFor=\"let bar of bars; trackBy: trackBy\"\n  [@animationState]=\"'active'\"\n  [@.disabled]=\"!animations\"\n  [width]=\"bar.width\"\n  [height]=\"bar.height\"\n  [x]=\"bar.x\"\n  [y]=\"bar.y\"\n  [fill]=\"bar.color\"\n  [stops]=\"bar.gradientStops\"\n  [data]=\"bar.graphData\"\n  [orientation]=\"orientation\"\n  [roundEdges]=\"bar.roundEdges\"\n  [gradient]=\"gradient\"\n  [isActive]=\"isActive(bar)\"\n  (select)=\"onClick($event)\"\n  (activate)=\"activate.emit($event)\"\n  (deactivate)=\"deactivate.emit($event)\"\n  ngx-tooltip\n  [tooltipCssClass]=\"'chart-tooltip p-0 border-0'\"\n  [tooltipShowCaret]=\"tooltipShowCaret\"\n  [tooltipDisabled]=\"tooltipDisabled\"\n  [tooltipPlacement]=\"tooltipPlacement\"\n  [tooltipType]=\"tooltipType\"\n  [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n  [tooltipTemplate]=\"tooltipTemplate\"\n  [tooltipContext]=\"bar.data\"\n  [animations]=\"animations\">\n</svg:g>\n<svg:g *ngIf=\"showDataLabel\">\n  <svg:g ngx-charts-bar-label \n    *ngFor=\"let b of barsForDataLabels; let i = index; trackBy:trackDataLabelBy\"\n    [barX]=\"b.x\"\n    [barY]=\"b.y\"\n    [barWidth]=\"b.width\"\n    [barHeight]=\"b.height\"\n    [value]=\"b.total\"\n    [valueFormatting]=\"dataLabelFormatting\"\n    [orientation]=\"orientation\"\n    (dimensionsChanged)=\"dataLabelHeightChanged.emit({size:$event, index:i})\"\n  />\n</svg:g>\n", components: [{ type: i1.BarComponent, selector: "g[ngx-charts-bar]", inputs: ["roundEdges", "gradient", "offset", "isActive", "animations", "noBarWhenZero", "fill", "data", "width", "height", "x", "y", "orientation", "stops", "ariaLabel"], outputs: ["select", "activate", "deactivate"] }, { type: i1.BarLabelComponent, selector: "g[ngx-charts-bar-label]", inputs: ["value", "valueFormatting", "barX", "barY", "barWidth", "barHeight", "orientation"], outputs: ["dimensionsChanged"] }], directives: [{ type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.TooltipDirective, selector: "[ngx-tooltip]", inputs: ["tooltipCssClass", "tooltipAppendToBody", "tooltipSpacing", "tooltipDisabled", "tooltipShowCaret", "tooltipPlacement", "tooltipAlignment", "tooltipType", "tooltipCloseOnClickOutside", "tooltipCloseOnMouseLeave", "tooltipHideTimeout", "tooltipShowTimeout", "tooltipShowEvent", "tooltipImmediateExit", "tooltipTitle", "tooltipTemplate", "tooltipContext"], outputs: ["show", "hide"] }, { type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], animations: [
        trigger('animationState', [
            transition(':leave', [
                style({
                    opacity: 1,
                }),
                animate(500, style({ opacity: 0 })),
            ]),
        ]),
    ], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: BbSeriesVerticalComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'g[bb-charts-series-vertical]',
                    templateUrl: './bb-charts-series-vertical.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [
                        trigger('animationState', [
                            transition(':leave', [
                                style({
                                    opacity: 1,
                                }),
                                animate(500, style({ opacity: 0 })),
                            ]),
                        ]),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1$2.DeprecationsService }]; }, propDecorators: { dims: [{
                type: Input
            }], type: [{
                type: Input
            }], series: [{
                type: Input
            }], xScale: [{
                type: Input
            }], yScale: [{
                type: Input
            }], colors: [{
                type: Input
            }], gradient: [{
                type: Input
            }], activeEntries: [{
                type: Input
            }], seriesName: [{
                type: Input
            }], tooltipDisabled: [{
                type: Input
            }], tooltipShowCaret: [{
                type: Input
            }], tooltipTemplate: [{
                type: Input
            }], roundEdges: [{
                type: Input
            }], animations: [{
                type: Input
            }], showDataLabel: [{
                type: Input
            }], dataLabelFormatting: [{
                type: Input
            }], groupData: [{
                type: Input
            }], select: [{
                type: Output
            }], activate: [{
                type: Output
            }], deactivate: [{
                type: Output
            }], dataLabelHeightChanged: [{
                type: Output
            }] } });

class TurnoversVerticalGroupedBarChartComponent extends TurnoversVerticalBarChartComponent {
    constructor(chartElement, zone, cd, platformId) {
        super(chartElement, zone, cd, platformId);
        /**
         * Sets the scale type of the chart.
         */
        this.scaleType = ScaleType.Ordinal;
        /**
         * Sets the group padding.
         */
        this.groupPadding = 16;
        /**
         * Array of Chart data objects needed for the chart to be rendered.
         */
        this.results = [];
        this.legendOptions = {
            colors: undefined,
            domain: [],
            scaleType: this.schemeType,
            title: '',
            position: LegendPosition.Below,
        };
    }
    update() {
        super.update();
        this.valueDomain = this.getValueDomain();
        this.groupScale = this.getGroupScale();
        this.innerScale = this.getInnerScale();
        this.valueScale = this.getValueScale();
        this.getLegendOptions();
    }
    getGroupScale() {
        const spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
        return scaleBand()
            .rangeRound([0, this.dims.width])
            .paddingInner(spacing)
            .paddingOuter(spacing / 2)
            .domain(this.groupDomain);
    }
    getInnerScale() {
        const width = this.groupScale ? this.groupScale.bandwidth() : 1;
        const spacing = this.innerDomain.length / (width / this.barPadding + 1);
        return scaleBand().rangeRound([0, width]).paddingInner(spacing).domain(this.innerDomain);
    }
    getValueScale() {
        const scale = scaleLinear().range([this.dims.height, 0]).domain(this.valueDomain);
        return this.roundDomains ? scale.nice() : scale;
    }
    getValueDomain() {
        const domain = [];
        for (const group of this.results) {
            for (const d of group.series) {
                if (!domain.includes(d.value)) {
                    domain.push(d.value);
                }
            }
        }
        const min = Math.min(0, ...domain);
        const max = this.yScaleMax ? Math.max(this.yScaleMax, ...domain) : Math.max(...domain);
        return [min, max];
    }
    groupTransform(group) {
        var _a, _b;
        const labelName = (_a = group.name) !== null && _a !== void 0 ? _a : '';
        return `translate(${(_b = this.groupScale) === null || _b === void 0 ? void 0 : _b.call(this, labelName)}, 0)`;
    }
    getLegendOptions() {
        if (!this.colors) {
            return;
        }
        if (this.legendOptions.scaleType === ScaleType.Ordinal) {
            this.legendOptions.domain = this.innerDomain;
            this.legendOptions.colors = this.colors;
            this.legendOptions.title = this.legendTitle || '';
        }
        else {
            this.legendOptions.domain = this.valueDomain;
            this.legendOptions.colors = this.colors.scale;
        }
    }
}
TurnoversVerticalGroupedBarChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalGroupedBarChartComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });
TurnoversVerticalGroupedBarChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalGroupedBarChartComponent, selector: "bb-charts-bar-vertical-2d", inputs: { scaleType: "scaleType", groupPadding: "groupPadding", results: "results" }, usesInheritance: true, ngImport: i0, template: "<ngx-charts-chart\n  [view]=\"[width, height]\"\n  [showLegend]=\"legend\"\n  [legendOptions]=\"legendOptions\"\n  [activeEntries]=\"activeEntries\"\n  [animations]=\"animations\"\n  (legendLabelActivate)=\"onActivate($event)\"\n  (legendLabelDeactivate)=\"onDeactivate($event)\"\n  (legendLabelClick)=\"onClick($event)\">\n  <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n    <svg:g bb-charts-grid-panel-series\n      [xScale]=\"groupScale\"\n      [yScale]=\"valueScale\"\n      [data]=\"groupsData\"\n      [dims]=\"dims\"\n    >\n    </svg:g>\n    <svg:g ngx-charts-x-axis\n      *ngIf=\"xAxis\"\n      [xScale]=\"groupScale\"\n      [dims]=\"dims\"\n      [showLabel]=\"showXAxisLabel\"\n      [labelText]=\"xAxisLabel\"\n      [tickFormatting]=\"xAxisTickFormatting\"\n      [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n      (dimensionsChanged)=\"updateXAxisHeight($event)\">\n    </svg:g>\n    <svg:g ngx-charts-y-axis\n      *ngIf=\"yAxis\"\n      [yScale]=\"valueScale\"\n      [dims]=\"dims\"\n      [showGridLines]=\"showGridLines\"\n      [showLabel]=\"showYAxisLabel\"\n      [labelText]=\"yAxisLabel\"\n      [tickFormatting]=\"yAxisTickFormatting\"\n      (dimensionsChanged)=\"updateYAxisWidth($event)\">\n    </svg:g>\n    <svg:g bb-charts-series-vertical\n      *ngFor=\"let group of groupsData; let index = index; trackBy:trackBy\"\n      [@animationState]=\"'active'\"\n      [attr.transform]=\"groupTransform(group)\"\n      [attr.opacity]=\"(group.badge ? 0.5 : 1)\"\n      [activeEntries]=\"activeEntries\"\n      [xScale]=\"innerScale\"\n      [yScale]=\"valueScale\"\n      [colors]=\"colors\"\n      [series]=\"group.series\"\n      [dims]=\"dims\"\n      [gradient]=\"gradient\"\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [showDataLabel]=\"showDataLabel\"\n      [dataLabelFormatting]=\"dataLabelFormatting\"\n      [seriesName]=\"group.name\"\n      [groupData]=\"group\"\n      [roundEdges]=\"roundEdges\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event, group)\"\n      (activate)=\"onActivate($event, group)\"\n      (deactivate)=\"onDeactivate($event, group)\"\n      (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n    />\n  </svg:g>\n</ngx-charts-chart>\n\n<ng-container\n  [ngTemplateOutlet]=\"legendTemplate\"\n  [ngTemplateOutletContext]=\"{\n    legendOptions: this.legendOptions,\n    activeEntries: this.activeEntries,\n    height: this.height,\n    onActivate: this.onActivate.bind(this),\n    onDeactivate: this.onDeactivate.bind(this),\n    onClick: this.onClick.bind(this)\n  }\"\n></ng-container>\n", styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .bar,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:normal}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}.gridline-path{stroke:#ccc}ngx-charts-legend{display:block;margin-top:1rem}\n"], components: [{ type: i1.ChartComponent, selector: "ngx-charts-chart", inputs: ["showLegend", "animations", "legendType", "view", "legendOptions", "activeEntries"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }, { type: BbGridPanelSeriesComponent, selector: "g[bb-charts-grid-panel-series]", inputs: ["data", "dims", "xScale", "yScale"] }, { type: i1.XAxisComponent, selector: "g[ngx-charts-x-axis]", inputs: ["rotateTicks", "showGridLines", "xOrient", "xAxisOffset", "xScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "showLabel", "labelText", "ticks", "xAxisTickCount"], outputs: ["dimensionsChanged"] }, { type: i1.YAxisComponent, selector: "g[ngx-charts-y-axis]", inputs: ["showGridLines", "yOrient", "yAxisOffset", "yScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "showLabel", "labelText", "yAxisTickCount", "referenceLines", "showRefLines", "showRefLabels"], outputs: ["dimensionsChanged"] }, { type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: ["dims", "type", "series", "xScale", "yScale", "colors", "gradient", "activeEntries", "seriesName", "tooltipDisabled", "tooltipShowCaret", "tooltipTemplate", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "groupData"], outputs: ["select", "activate", "deactivate", "dataLabelHeightChanged"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [
        trigger('animationState', [
            transition(':leave', [
                style({
                    opacity: 1,
                    transform: '*',
                }),
                animate(500, style({ opacity: 0, transform: 'scale(0)' })),
            ]),
        ]),
    ], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalGroupedBarChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-charts-bar-vertical-2d',
                    templateUrl: './turnovers-vertical-grouped-bar-chart.component.html',
                    styleUrls: ['../turnovers-vertical-stacked-bar-chart/turnovers-vertical-stacked-bar-chart.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [
                        trigger('animationState', [
                            transition(':leave', [
                                style({
                                    opacity: 1,
                                    transform: '*',
                                }),
                                animate(500, style({ opacity: 0, transform: 'scale(0)' })),
                            ]),
                        ]),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; }, propDecorators: { scaleType: [{
                type: Input
            }], groupPadding: [{
                type: Input
            }], results: [{
                type: Input
            }] } });

class TurnoversBarChartComponent {
    constructor(currencyPipe, cssVariableService) {
        this.currencyPipe = currencyPipe;
        this.cssVariableService = cssVariableService;
        /**
         * Array of Chart data objects needed for the chart to be rendered.
         */
        this.chartSeriesData = [];
        /**
         * Disable/enable the forecast option on the chart.
         */
        this.forecast = false;
        // bar chart
        // options
        this.chartOptions = from(this.cssVariableService.getCssVariable(BAR_COLORS_CSS_VAR)).pipe(map((cssVar) => ({
            colors: cssVar ? cssVar.split(',') : CHART_COLORS,
            showXAxis: true,
            showYAxis: true,
            gradient: false,
            showLegend: false,
            showXAxisLabel: true,
            showYAxisLabel: true,
        })));
    }
    yAxisTickFormatting(value) {
        const currency = this.chartSeriesData[0].currency;
        if (this.barChart2d && this.barChart2d.width < MOBILE_WIDGET_WIDTH) {
            const amountVal = value / 1000;
            if (amountVal <= 999) {
                return `${this.currencyPipe.transform(amountVal, currency, 'symbol', '1.0')}k`;
            }
            return `${this.currencyPipe.transform(amountVal / 1000, currency, 'symbol', '1.0')}m`;
        }
        return this.currencyPipe.transform(value, currency, 'symbol', '1.0');
    }
}
TurnoversBarChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversBarChartComponent, deps: [{ token: i1$1.CurrencyPipe }, { token: i2.CssVariablesService }], target: i0.ɵɵFactoryTarget.Component });
TurnoversBarChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversBarChartComponent, selector: "bb-turnovers-bar-chart", inputs: { chartSeriesData: "chartSeriesData", forecast: "forecast" }, providers: [CssVariablesService], viewQueries: [{ propertyName: "barChart2d", first: true, predicate: ["bbChartsBarVertical2d"], descendants: true }], ngImport: i0, template: "<div class=\"position-relative pb-25p pb-md-50p\">\n  <ng-container *ngIf=\"this.chartOptions | async as options\">\n    <ng-container\n      bbTurnoversVerticalGroupedBarChartCustomizable\n      [bbHostRef]=\"this\"\n      [bbTemplateContext]=\"{options: options}\"\n    ></ng-container>\n    <ng-container\n      bbTurnoversVerticalStackedBarChartCustomizable\n      [bbHostRef]=\"this\"\n      [bbTemplateContext]=\"{options: options}\"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template bbTurnoversVerticalGroupedBarChartCustomizable let-hostRef let-options=\"context.options\">\n  <div class=\"bb-turnovers-vertical-chart\">\n    <bb-charts-bar-vertical-2d\n      #bbChartsBarVertical2d\n      class=\"position-static transform-none\"\n      [scheme]=\"{ domain: options.colors }\"\n      [results]=\"hostRef.chartSeriesData\"\n      [groupsData]=\"hostRef.chartSeriesData\"\n      [xAxis]=\"options.showXAxis\"\n      [yAxis]=\"options.showYAxis\"\n      [showXAxisLabel]=\"options.showXAxisLabel\"\n      [showYAxisLabel]=\"options.showYAxisLabel\"\n      [legend]=\"options.showLegend\"\n      [gradient]=\"options.gradient\"\n      [barPadding]=\"0\"\n      [groupPadding]=\"6\"\n      [roundEdges]=\"true\"\n      [legendTemplate]=\"legendTemplate\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [yAxisTickFormatting]=\"yAxisTickFormatting.bind(this)\">\n    </bb-charts-bar-vertical-2d>\n  </div>\n</ng-template>\n\n<ng-template bbTurnoversVerticalStackedBarChartCustomizable let-hostRef let-options=\"context.options\">\n</ng-template>\n\n<ng-template bbTurnoversChartLegendCustomizable #legendTemplate\n  let-legendOptions=\"legendOptions\"\n  let-activeEntries=\"activeEntries\"\n  let-height=\"height\"\n  let-onActivate=\"onActivate\"\n  let-onDeactivate=\"onDeactivate\"\n  let-onClick=\"onClick\">\n  <bb-charts-legend\n    class=\"chart-legend\"\n    [data]=\"legendOptions.domain\"\n    [title]=\"legendOptions.title\"\n    [colors]=\"legendOptions.colors\"\n    [height]=\"height\"\n    [activeEntries]=\"activeEntries\"\n    (labelClick)=\"onClick($event)\"\n    (labelActivate)=\"onActivate($event)\"\n    (labelDeactivate)=\"onDeactivate($event)\">\n  </bb-charts-legend>\n</ng-template>\n\n<ng-template bbTurnoversChartTooltipCustomizable #tooltipTemplate let-model=\"model\">\n  <div class=\"chart-tooltip-default bb-arrow-bottom text-dark\">\n    <div\n      *ngIf=\"model.badge\"\n      class=\"pb-1 mb-2 font-weight-bold border-bottom border-dark text-capitalize text-left\">\n      {{model.badge}}\n    </div>\n    <div>\n      <div class=\"d-flex pb-1 align-items-center\" *ngFor=\"let bar of model.series; let i = index\">\n        <span [ngStyle]=\"{'color': bar.color}\" class=\"bicon bicon-circle\"></span>\n        <span class=\"text-capitalize\">{{bar.name}}</span>\n        <span class=\"ml-auto font-weight-bold\">\n          <bb-amount-ui\n            [amount]=\"i === 0 ? bar.value : (-bar.value)\"\n            [currency]=\"bar.currency\"\n            [showPlusSign]=\"i === 0 && bar.value > 0\"\n          ></bb-amount-ui>\n        </span>\n      </div>\n      <div class=\"d-flex pt-1 pl-1 align-items-center\">\n        <span i18n=\"Difference|tooltip difference label@@turnovers.tooltip.diff\">Difference</span>\n        <span class=\"ml-auto font-weight-bold\">\n          <bb-amount-ui\n            [amount]=\"model.diff\"\n            [currency]=\"model.currency\"\n            [showPlusSign]=\"model.diff !== 0\"\n          ></bb-amount-ui>\n        </span>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return TurnoversVerticalGroupedBarChartComponent; }), selector: "bb-charts-bar-vertical-2d", inputs: ["scaleType", "groupPadding", "results"] }, { type: i0.forwardRef(function () { return BbTurnoversLegendComponent; }), selector: "bb-charts-legend", inputs: ["data", "title", "colors", "height", "width", "activeEntries"], outputs: ["labelClick", "labelActivate", "labelDeactivate"] }, { type: i0.forwardRef(function () { return i5.AmountComponent; }), selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }], directives: [{ type: i0.forwardRef(function () { return i1$1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return TurnoversVerticalGroupedBarChartCustomizableDirective; }), selector: "[bbTurnoversVerticalGroupedBarChartCustomizable]" }, { type: i0.forwardRef(function () { return TurnoversVerticalStackedBarChartCustomizableDirective; }), selector: "[bbTurnoversVerticalStackedBarChartCustomizable]" }, { type: i0.forwardRef(function () { return TurnoversChartLegendCustomizableDirective; }), selector: "[bbTurnoversChartLegendCustomizable]" }, { type: i0.forwardRef(function () { return TurnoversChartTooltipCustomizableDirective; }), selector: "[bbTurnoversChartTooltipCustomizable]" }, { type: i0.forwardRef(function () { return i1$1.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i0.forwardRef(function () { return i1$1.NgStyle; }), selector: "[ngStyle]", inputs: ["ngStyle"] }], pipes: { "async": i0.forwardRef(function () { return i1$1.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversBarChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-turnovers-bar-chart',
                    templateUrl: './turnovers-bar-chart.component.html',
                    providers: [CssVariablesService],
                }]
        }], ctorParameters: function () { return [{ type: i1$1.CurrencyPipe }, { type: i2.CssVariablesService }]; }, propDecorators: { barChart2d: [{
                type: ViewChild,
                args: ['bbChartsBarVertical2d']
            }], chartSeriesData: [{
                type: Input
            }], forecast: [{
                type: Input
            }] } });
class TurnoversChartTooltipCustomizableDirective extends BbTemplate {
}
TurnoversChartTooltipCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversChartTooltipCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversChartTooltipCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversChartTooltipCustomizableDirective, selector: "[bbTurnoversChartTooltipCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversChartTooltipCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversChartTooltipCustomizable]',
                }]
        }] });
class TurnoversChartLegendCustomizableDirective extends BbTemplate {
}
TurnoversChartLegendCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversChartLegendCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversChartLegendCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversChartLegendCustomizableDirective, selector: "[bbTurnoversChartLegendCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversChartLegendCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversChartLegendCustomizable]',
                }]
        }] });
class TurnoversVerticalGroupedBarChartCustomizableDirective extends BbTemplate {
}
TurnoversVerticalGroupedBarChartCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalGroupedBarChartCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversVerticalGroupedBarChartCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalGroupedBarChartCustomizableDirective, selector: "[bbTurnoversVerticalGroupedBarChartCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalGroupedBarChartCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversVerticalGroupedBarChartCustomizable]',
                }]
        }] });
class TurnoversVerticalStackedBarChartCustomizableDirective extends BbTemplate {
}
TurnoversVerticalStackedBarChartCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalStackedBarChartCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversVerticalStackedBarChartCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalStackedBarChartCustomizableDirective, selector: "[bbTurnoversVerticalStackedBarChartCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalStackedBarChartCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversVerticalStackedBarChartCustomizable]',
                }]
        }] });

class TurnoversVerticalStackedBarChartComponent extends TurnoversVerticalBarChartComponent {
    constructor(chartElement, zone, cd, platformId) {
        super(chartElement, zone, cd, platformId);
        /**
         * An array of numbers to set the horizontal points on the chart.
         */
        this.xAxisTicks = [];
        /**
         * An array of numbers to set the vertical points on the chart.
         */
        this.yAxisTicks = [];
    }
    update() {
        super.update();
        this.valueDomain = this.getValueDomain();
        this.xScale = this.getXScale();
        this.yScale = this.getYScale();
        this.legendOptions = this.getLegendOptions();
    }
    getValueDomain() {
        const domain = [];
        let smallest = 0;
        let biggest = 0;
        for (const group of this.results) {
            let smallestSum = 0;
            let biggestSum = 0;
            for (const d of group.series) {
                if (d.value < 0) {
                    smallestSum += d.value;
                }
                else {
                    biggestSum += d.value;
                }
                smallest = d.value < smallest ? d.value : smallest;
                biggest = d.value > biggest ? d.value : biggest;
            }
            domain.push(smallestSum);
            domain.push(biggestSum);
        }
        domain.push(smallest);
        domain.push(biggest);
        const min = Math.min(0, ...domain);
        const max = this.yScaleMax ? Math.max(this.yScaleMax, ...domain) : Math.max(...domain);
        return [min, max];
    }
    groupTransform(group) {
        var _a, _b;
        const labelName = (_a = group.name) !== null && _a !== void 0 ? _a : '';
        return `translate(${(_b = this.xScale) === null || _b === void 0 ? void 0 : _b.call(this, labelName)}, 0)`;
    }
    getLegendOptions() {
        var _a;
        const opts = {
            scaleType: this.schemeType,
            colors: undefined,
            domain: [],
            title: '',
            position: LegendPosition.Below,
        };
        if (opts.scaleType === ScaleType.Ordinal) {
            opts.domain = this.innerDomain;
            opts.colors = this.colors;
            opts.title = this.legendTitle;
        }
        else {
            opts.domain = this.valueDomain;
            opts.colors = (_a = this.colors) === null || _a === void 0 ? void 0 : _a.scale;
        }
        return opts;
    }
}
TurnoversVerticalStackedBarChartComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalStackedBarChartComponent, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Component });
TurnoversVerticalStackedBarChartComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalStackedBarChartComponent, selector: "bb-charts-bar-vertical-stacked", inputs: { xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks" }, usesInheritance: true, ngImport: i0, template: "<ngx-charts-chart\n  [view]=\"[width, height]\"\n  [showLegend]=\"legend\"\n  [legendOptions]=\"legendOptions\"\n  [activeEntries]=\"activeEntries\"\n  [animations]=\"animations\"\n  (legendLabelActivate)=\"onActivate($event)\"\n  (legendLabelDeactivate)=\"onDeactivate($event)\"\n  (legendLabelClick)=\"onClick($event)\">\n  <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n    <svg:g bb-charts-grid-panel-series\n      [xScale]=\"xScale\"\n      [yScale]=\"yScale\"\n      [data]=\"groupsData\"\n      [dims]=\"dims\"\n    >\n    </svg:g>\n    <svg:g ngx-charts-x-axis\n      *ngIf=\"xAxis\"\n      [xScale]=\"xScale\"\n      [dims]=\"dims\"\n      [showLabel]=\"showXAxisLabel\"\n      [labelText]=\"xAxisLabel\"\n      [tickFormatting]=\"xAxisTickFormatting\"\n      [ticks]=\"xAxisTicks\"\n      [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n      (dimensionsChanged)=\"updateXAxisHeight($event)\">\n    </svg:g>\n    <svg:g ngx-charts-y-axis\n      *ngIf=\"yAxis\"\n      [yScale]=\"yScale\"\n      [dims]=\"dims\"\n      [showGridLines]=\"showGridLines\"\n      [showLabel]=\"showYAxisLabel\"\n      [labelText]=\"yAxisLabel\"\n      [tickFormatting]=\"yAxisTickFormatting\"\n      [ticks]=\"yAxisTicks\"\n      (dimensionsChanged)=\"updateYAxisWidth($event)\">\n    </svg:g>\n    <svg:g bb-charts-series-vertical\n      *ngFor=\"let group of results; let index = index; trackBy:trackBy\"\n      [@animationState]=\"'active'\"\n      [attr.transform]=\"groupTransform(group)\"\n      [attr.opacity]=\"(group.badge ? 0.5 : 1)\"\n      [type]=\"'stacked'\"\n      [xScale]=\"xScale\"\n      [yScale]=\"yScale\"\n      [activeEntries]=\"activeEntries\"\n      [colors]=\"colors\"\n      [series]=\"group.series\"\n      [dims]=\"dims\"\n      [roundEdges]=\"roundEdges\"\n      [gradient]=\"gradient\"\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [showDataLabel]=\"showDataLabel\"\n      [dataLabelFormatting]=\"dataLabelFormatting\"\n      [seriesName]=\"group.name\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event, group)\"\n      (activate)=\"onActivate($event, group)\"\n      (deactivate)=\"onDeactivate($event, group)\"\n      (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n    />\n  </svg:g>\n</ngx-charts-chart>\n\n<ng-container\n  [ngTemplateOutlet]=\"legendTemplate\"\n  [ngTemplateOutletContext]=\"{\n    legendOptions: this.legendOptions,\n    activeEntries: this.activeEntries,\n    height: this.height,\n    onActivate: this.onActivate.bind(this),\n    onDeactivate: this.onDeactivate.bind(this),\n    onClick: this.onClick.bind(this)\n  }\"\n></ng-container>\n", styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .bar,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:normal}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}.gridline-path{stroke:#ccc}ngx-charts-legend{display:block;margin-top:1rem}\n"], components: [{ type: i1.ChartComponent, selector: "ngx-charts-chart", inputs: ["showLegend", "animations", "legendType", "view", "legendOptions", "activeEntries"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }, { type: BbGridPanelSeriesComponent, selector: "g[bb-charts-grid-panel-series]", inputs: ["data", "dims", "xScale", "yScale"] }, { type: i1.XAxisComponent, selector: "g[ngx-charts-x-axis]", inputs: ["rotateTicks", "showGridLines", "xOrient", "xAxisOffset", "xScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "showLabel", "labelText", "ticks", "xAxisTickCount"], outputs: ["dimensionsChanged"] }, { type: i1.YAxisComponent, selector: "g[ngx-charts-y-axis]", inputs: ["showGridLines", "yOrient", "yAxisOffset", "yScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "showLabel", "labelText", "yAxisTickCount", "referenceLines", "showRefLines", "showRefLabels"], outputs: ["dimensionsChanged"] }, { type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: ["dims", "type", "series", "xScale", "yScale", "colors", "gradient", "activeEntries", "seriesName", "tooltipDisabled", "tooltipShowCaret", "tooltipTemplate", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "groupData"], outputs: ["select", "activate", "deactivate", "dataLabelHeightChanged"] }], directives: [{ type: i1$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1$1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [
        trigger('animationState', [
            transition(':leave', [
                style({
                    opacity: 1,
                    transform: '*',
                }),
                animate(500, style({ opacity: 0, transform: 'scale(0)' })),
            ]),
        ]),
    ], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversVerticalStackedBarChartComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-charts-bar-vertical-stacked',
                    templateUrl: './turnovers-vertical-stacked-bar-chart.component.html',
                    styleUrls: ['turnovers-vertical-stacked-bar-chart.component.scss'],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [
                        trigger('animationState', [
                            transition(':leave', [
                                style({
                                    opacity: 1,
                                    transform: '*',
                                }),
                                animate(500, style({ opacity: 0, transform: 'scale(0)' })),
                            ]),
                        ]),
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }]; }, propDecorators: { xAxisTicks: [{
                type: Input
            }], yAxisTicks: [{
                type: Input
            }] } });

const getMessageFromResponse = (error) => {
    const responseBody = error.error;
    if (responseBody && responseBody.errors && responseBody.errors[0] && responseBody.errors[0].message) {
        return responseBody.errors[0].message;
    }
    else {
        return undefined;
    }
};
const parseError = (error) => {
    // TODO: should have more user-friendly messages
    if (error.error instanceof ErrorEvent) {
        // Client-side or network error.
        return {
            message: 'An unexpected error occurred',
        };
    }
    else {
        // Backend returns unsuccessful response code.  In case of 400, try to get a message from the
        // response.
        switch (error.status) {
            case 400:
                return {
                    message: getMessageFromResponse(error) || 'Error 400',
                };
            case 401:
                return {
                    message: 'Error 401',
                };
            case 403:
                return {
                    message: 'Error 403',
                };
            case 404:
                return {
                    message: 'Error 404',
                };
            default:
                return {
                    message: 'An unexpected error occurred',
                };
        }
    }
};

class TurnoversWidgetHelpersService {
    constructor(datePipe) {
        this.datePipe = datePipe;
        this.extendTurnoverItem = (barData) => (Object.assign(Object.assign({}, barData), { intervalStartDate: this.datePipe.transform(barData.intervalStartDate.slice(0, 10), 'MMM') || '' }));
    }
    getChartData(turnovers, labels) {
        return (turnovers || []).map(function (barData) {
            return {
                series: [
                    {
                        name: labels.income,
                        value: Number(barData.creditAmount.amount),
                        currency: barData.creditAmount.currencyCode,
                    },
                    {
                        name: labels.spending,
                        value: Number(barData.debitAmount.amount),
                        currency: barData.debitAmount.currencyCode,
                    },
                ],
                currency: barData.balance.currencyCode,
                diff: Number(barData.balance.amount),
                badge: barData.forecast ? labels.forecast : '',
                name: barData.intervalStartDate.slice(0, 10) + (barData.forecast ? ' ' : ''),
            };
        });
    }
    periodToDate(period) {
        const date = new Date();
        // current date already covers one period
        const intervalCount = period.duration;
        switch (period.interval) {
            case 'DAY':
                date.setDate(date.getDate() - intervalCount);
                break;
            case 'WEEK':
                date.setDate(date.getDate() - intervalCount * 7);
                break;
            case 'YEAR':
                date.setFullYear(date.getFullYear() - intervalCount);
                break;
            case 'MONTH':
            default:
                date.setMonth(date.getMonth() - (intervalCount - 1));
                date.setDate(DEFAULT_START_DAY);
                break;
        }
        return date.toISOString().slice(0, 10);
    }
}
TurnoversWidgetHelpersService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetHelpersService, deps: [{ token: i1$1.DatePipe }], target: i0.ɵɵFactoryTarget.Injectable });
TurnoversWidgetHelpersService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetHelpersService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetHelpersService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.DatePipe }]; } });

class TurnoversService {
    constructor(turnoversDataHttpService) {
        this.turnoversDataHttpService = turnoversDataHttpService;
    }
    loadAnalysisData(params) {
        return this.turnoversDataHttpService.getTurnovers(params).pipe(map((body) => {
            return {
                turnovers: body.turnovers || [],
                forecast: (body.forecast || []).map((item) => (Object.assign(Object.assign({}, item), { forecast: true }))),
            };
        }), map((body) => {
            return (body.turnovers || []).concat(params.forecast && body.forecast ? body.forecast : []);
        }));
    }
}
TurnoversService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversService, deps: [{ token: i1$3.TurnoversHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
TurnoversService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$3.TurnoversHttpService }]; } });

class TurnoversComponent {
    constructor(service, route, helpers) {
        this.service = service;
        this.route = route;
        this.helpers = helpers;
        /**
         * Disable/enable the forecast option on the chart.
         */
        this.forecast = false;
        this.hostRef = this;
        this.selectedTab = PERIODS[Math.max(PERIODS.map((item) => item.default).indexOf(true), 0)];
        this.isLoading = new BehaviorSubject(false);
        this.initialDateParams = {
            periodStartDate: this.helpers.periodToDate(PERIODS[0]),
            periodEndDate: new Date().toISOString().slice(0, 10),
            intervalDuration: DEFAULT_INTERVAL,
            intervalStartDay: DEFAULT_START_DAY,
        };
        this.arrangementIds = this.getRouteParam(this.route, 'selectedAccount').pipe(map((selectedAccount) => (selectedAccount ? [selectedAccount] : [])));
        this.dateParams = new BehaviorSubject(this.initialDateParams);
        this.chartSeriesData = combineLatest(this.arrangementIds, this.dateParams.asObservable()).pipe(tap(() => (this.error = undefined)), filter(([selectedAccounts]) => !!selectedAccounts.length), map(([selectedAccounts, dateParams]) => (Object.assign(Object.assign({ arrangementIds: selectedAccounts }, dateParams), { forecast: this.forecast ? 'AVG' : undefined }))), switchMap((params) => {
            this.isLoading.next(true);
            const data = this.service.loadAnalysisData(params);
            data.subscribe({ complete: () => this.isLoading.next(false) });
            return data;
        }), map((items) => items.map(this.helpers.extendTurnoverItem)), map((items) => this.helpers.getChartData(items, this.labels)), catchError((error) => {
            this.handleError(error);
            return of([]);
        }));
        this.handleError = (error) => {
            this.error = parseError(error);
            return of([]);
        };
    }
    get labels() {
        return {
            income: this.incomeRef.nativeElement.textContent,
            spending: this.spendingRef.nativeElement.textContent,
            forecast: this.forecastRef.nativeElement.textContent,
        };
    }
    getRouteParam(route, param) {
        const paramValue = route.paramMap.pipe(pluck('params', param));
        if (!route.parent) {
            return paramValue;
        }
        // ensure that level that has actual value keeps it from being cleared
        return combineLatest(paramValue, this.getRouteParam(route.parent, param)).pipe(map((params) => params[0] || params[1]));
    }
    onTabChange(num) {
        this.selectedTab = PERIODS[Math.max(PERIODS.map((item) => item.duration).indexOf(num), 0)];
        this.dateParams.next(Object.assign(Object.assign({}, this.initialDateParams), { periodStartDate: this.helpers.periodToDate(this.selectedTab), periodEndDate: new Date().toISOString().slice(0, 10) }));
    }
}
TurnoversComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversComponent, deps: [{ token: TurnoversService }, { token: i2$1.ActivatedRoute }, { token: TurnoversWidgetHelpersService }], target: i0.ɵɵFactoryTarget.Component });
TurnoversComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversComponent, selector: "bb-turnovers", inputs: { forecast: "forecast" }, providers: [TurnoversService, DatePipe, TurnoversWidgetHelpersService], viewQueries: [{ propertyName: "incomeRef", first: true, predicate: ["incomeLabel"], descendants: true, static: true }, { propertyName: "spendingRef", first: true, predicate: ["spendingLabel"], descendants: true, static: true }, { propertyName: "forecastRef", first: true, predicate: ["forecastLabel"], descendants: true, static: true }], ngImport: i0, template: "<ng-container *ngIf=\"(arrangementIds | async)?.length; else emptyState\">\n  <ng-container *ngIf=\"chartSeriesData | async; let data; else loadingState\">\n    <div *ngIf=\"!error; else errorState\">\n      <div *ngIf=\"data.length; else emptyState\">\n        <ng-container \n          bbTurnoversItemCustomizable \n          [bbHostRef]=\"hostRef\" \n          [bbTemplateContext]=\"data\"\n        ></ng-container>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template bbTurnoversItemCustomizable let-hostRef let-chartSeriesData=\"context\">\n  <ng-container bbTurnoversControlsCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n  <bb-turnovers-bar-chart\n    *ngIf=\"(isLoading | async) === false; else loadingState\"\n    class=\"bb-turnovers-bar-chart bb-chart\"\n    [chartSeriesData]=\"chartSeriesData\"\n    [forecast]=\"forecast\">\n  </bb-turnovers-bar-chart>\n</ng-template>\n<ng-template bbTurnoversControlsCustomizable let-hostRef>\n  <div class=\"bb-turnovers-controls\">\n    <div class=\"btn-group btn-group-sm\">\n      <button\n        bbButton\n        data-role=\"6-month-btn\"\n        [value]='6'\n        (click)=\"hostRef.onTabChange(6)\"\n        [color]=\"hostRef.selectedTab.duration === 6 ? 'primary' : 'secondary'\"\n        i18n=\"Data period|Six month label@@turnovers.label.duration.month.six\"\n      >\n        6 Months\n      </button>\n      <button\n        bbButton \n        data-role=\"12-month-btn\"\n        [value]='12'\n        (click)=\"hostRef.onTabChange(12)\"\n        [color]=\"hostRef.selectedTab.duration === 12 ? 'primary' : 'secondary'\"\n        i18n=\"Data period|Twelve month label@@turnovers.label.duration.month.twelve\"\n      >\n        12 Months\n      </button>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #loadingState>\n  <bb-loading-indicator-ui\n    i18n-text=\"Loading turnovers data|Text to display while loading turnovers@@turnovers.state.loadingTurnovers\"\n    text=\"Loading transactions data...\"\n  ></bb-loading-indicator-ui>\n</ng-template>\n\n<ng-template #emptyState>\n  <ng-container bbTurnoversEmptyStateCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n</ng-template>\n\n<ng-template bbTurnoversEmptyStateCustomizable let-hostRef>\n  <ng-container bbTurnoversControlsCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n    <bb-empty-state-ui\n      i18n-title=\"No data title|Title of a message that is shown when there are no turnovers@@turnovers.state.noResultsFound.title\"\n      title=\"No data found\"\n      i18n-subtitle=\"No data subtitle|Subtitle of a message that is shown when there are no turnovers@@turnovers.state.noResultsFound.subtitle\"\n      subtitle=\"You don't have any data to be displayed. Please try selecting a different period.\"\n      iconSize=\"xxl\"\n      iconModifier=\"bar-chart\"\n    ></bb-empty-state-ui>\n</ng-template>\n\n<ng-template #errorState>\n  <bb-empty-state-ui\n    data-role=\"errorState\"\n    title=\"\"\n    [subtitle]=\"error?.message\"\n    iconModifier=\"error\"\n    iconSize=\"xxl\"\n    iconColor=\"gray\"\n    iconClasses=\"text-muted\"\n  ></bb-empty-state-ui>\n</ng-template>\n\n<span #incomeLabel class=\"ng-cloak\" i18n=\"Incoming|Label for income dataset on the chart@@turnovers.chart.income\">Incoming</span>\n<span #spendingLabel class=\"ng-cloak\" i18n=\"Outgoing|Label for spending dataset on the chart@@turnovers.chart.spending\">Outgoing</span>\n<span #forecastLabel class=\"ng-cloak\" i18n=\"forecast|Label for forecast data on the chart@@turnovers.chart.forecast\">Forecast</span>\n", components: [{ type: i0.forwardRef(function () { return TurnoversBarChartComponent; }), selector: "bb-turnovers-bar-chart", inputs: ["chartSeriesData", "forecast"] }, { type: i0.forwardRef(function () { return i5$1.LoadingIndicatorComponent; }), selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i0.forwardRef(function () { return i6.EmptyStateComponent; }), selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }], directives: [{ type: i0.forwardRef(function () { return i1$1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return TurnoversItemCustomizableDirective; }), selector: "[bbTurnoversItemCustomizable]" }, { type: i0.forwardRef(function () { return TurnoversControlsCustomizableDirective; }), selector: "[bbTurnoversControlsCustomizable]" }, { type: i0.forwardRef(function () { return i8.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i0.forwardRef(function () { return TurnoversEmptyStateCustomizableDirective; }), selector: "[bbTurnoversEmptyStateCustomizable]" }], pipes: { "async": i0.forwardRef(function () { return i1$1.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-turnovers',
                    templateUrl: './turnovers.component.html',
                    providers: [TurnoversService, DatePipe, TurnoversWidgetHelpersService],
                }]
        }], ctorParameters: function () { return [{ type: TurnoversService }, { type: i2$1.ActivatedRoute }, { type: TurnoversWidgetHelpersService }]; }, propDecorators: { forecast: [{
                type: Input
            }], incomeRef: [{
                type: ViewChild,
                args: ['incomeLabel', { static: true }]
            }], spendingRef: [{
                type: ViewChild,
                args: ['spendingLabel', { static: true }]
            }], forecastRef: [{
                type: ViewChild,
                args: ['forecastLabel', { static: true }]
            }] } });
class TurnoversItemCustomizableDirective extends BbTemplate {
}
TurnoversItemCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversItemCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversItemCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversItemCustomizableDirective, selector: "[bbTurnoversItemCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversItemCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversItemCustomizable]',
                }]
        }] });
class TurnoversControlsCustomizableDirective extends BbTemplate {
}
TurnoversControlsCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversControlsCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversControlsCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversControlsCustomizableDirective, selector: "[bbTurnoversControlsCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversControlsCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversControlsCustomizable]',
                }]
        }] });
class TurnoversEmptyStateCustomizableDirective extends BbTemplate {
}
TurnoversEmptyStateCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversEmptyStateCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
TurnoversEmptyStateCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversEmptyStateCustomizableDirective, selector: "[bbTurnoversEmptyStateCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversEmptyStateCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbTurnoversEmptyStateCustomizable]',
                }]
        }] });

class TurnoversWidgetComponent {
    constructor(itemModel) {
        this.itemModel = itemModel;
        this.forecast = this.getProperty(PROPERTIES.FORECAST).pipe(map((propertyValue) => propertyValue === true));
        this.forecastSubject = new BehaviorSubject(true);
        this.forecast$ = filterInputParameters(this.forecastSubject.asObservable(), this.forecast);
    }
    // eslint-disable-next-line
    set forecastValue(value) {
        this.forecastSubject.next(value);
    }
    getProperty(property) {
        return this.itemModel ? this.itemModel.property(property.name, property.value) : of(property.value);
    }
}
TurnoversWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetComponent, deps: [{ token: i1$4.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Component });
TurnoversWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversWidgetComponent, selector: "bb-turnovers-widget", inputs: { forecastValue: ["forecast", "forecastValue"] }, ngImport: i0, template: "<bb-turnovers\n  [forecast]=\"(forecast | async) || undefined\"\n></bb-turnovers>", components: [{ type: TurnoversComponent, selector: "bb-turnovers", inputs: ["forecast"] }], pipes: { "async": i1$1.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-turnovers-widget',
                    templateUrl: './turnovers-widget.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1$4.ItemModel, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { forecastValue: [{
                type: Input,
                args: ['forecast']
            }] } });

// General modules
const components = [
    TurnoversWidgetComponent,
    TurnoversComponent,
    TurnoversBarChartComponent,
    TurnoversVerticalBarChartComponent,
    TurnoversVerticalStackedBarChartComponent,
    TurnoversVerticalGroupedBarChartComponent,
    BbTurnoversLegendComponent,
    BbSeriesVerticalComponent,
    BbGridPanelSeriesComponent,
];
const customizables = [
    TurnoversItemCustomizableDirective,
    TurnoversControlsCustomizableDirective,
    TurnoversChartTooltipCustomizableDirective,
    TurnoversChartLegendCustomizableDirective,
    TurnoversVerticalStackedBarChartCustomizableDirective,
    TurnoversVerticalGroupedBarChartCustomizableDirective,
    TurnoversEmptyStateCustomizableDirective,
];
const modules = [FormatAmountModule, LoadingIndicatorModule, EmptyStateModule, ButtonModule];
class TurnoversWidgetModule {
}
TurnoversWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TurnoversWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetModule, declarations: [TurnoversWidgetComponent,
        TurnoversComponent,
        TurnoversBarChartComponent,
        TurnoversVerticalBarChartComponent,
        TurnoversVerticalStackedBarChartComponent,
        TurnoversVerticalGroupedBarChartComponent,
        BbTurnoversLegendComponent,
        BbSeriesVerticalComponent,
        BbGridPanelSeriesComponent, TurnoversItemCustomizableDirective,
        TurnoversControlsCustomizableDirective,
        TurnoversChartTooltipCustomizableDirective,
        TurnoversChartLegendCustomizableDirective,
        TurnoversVerticalStackedBarChartCustomizableDirective,
        TurnoversVerticalGroupedBarChartCustomizableDirective,
        TurnoversEmptyStateCustomizableDirective], imports: [CommonModule, i1$4.BackbaseCoreModule, NgxChartsModule, FormatAmountModule, LoadingIndicatorModule, EmptyStateModule, ButtonModule], exports: [TurnoversWidgetComponent,
        TurnoversComponent,
        TurnoversBarChartComponent,
        TurnoversVerticalBarChartComponent,
        TurnoversVerticalStackedBarChartComponent,
        TurnoversVerticalGroupedBarChartComponent,
        BbTurnoversLegendComponent,
        BbSeriesVerticalComponent,
        BbGridPanelSeriesComponent, TurnoversItemCustomizableDirective,
        TurnoversControlsCustomizableDirective,
        TurnoversChartTooltipCustomizableDirective,
        TurnoversChartLegendCustomizableDirective,
        TurnoversVerticalStackedBarChartCustomizableDirective,
        TurnoversVerticalGroupedBarChartCustomizableDirective,
        TurnoversEmptyStateCustomizableDirective, FormatAmountModule, LoadingIndicatorModule, EmptyStateModule, ButtonModule] });
TurnoversWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetModule, providers: [DatePipe, CurrencyPipe], imports: [[
            CommonModule,
            BackbaseCoreModule.withConfig({
                classMap: { TurnoversWidgetComponent },
            }),
            NgxChartsModule,
            ...modules,
        ], FormatAmountModule, LoadingIndicatorModule, EmptyStateModule, ButtonModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: TurnoversWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        BackbaseCoreModule.withConfig({
                            classMap: { TurnoversWidgetComponent },
                        }),
                        NgxChartsModule,
                        ...modules,
                    ],
                    providers: [DatePipe, CurrencyPipe],
                    entryComponents: [TurnoversComponent],
                    declarations: [...components, ...customizables],
                    exports: [...components, ...customizables, ...modules],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { BbGridPanelSeriesComponent, BbSeriesVerticalComponent, BbTurnoversLegendComponent, TurnoversBarChartComponent, TurnoversChartLegendCustomizableDirective, TurnoversChartTooltipCustomizableDirective, TurnoversComponent, TurnoversControlsCustomizableDirective, TurnoversEmptyStateCustomizableDirective, TurnoversItemCustomizableDirective, TurnoversVerticalBarChartComponent, TurnoversVerticalGroupedBarChartComponent, TurnoversVerticalGroupedBarChartCustomizableDirective, TurnoversVerticalStackedBarChartComponent, TurnoversVerticalStackedBarChartCustomizableDirective, TurnoversWidgetComponent, TurnoversWidgetModule };
//# sourceMappingURL=backbase-turnovers-widget-ang.js.map
