(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@swimlane/ngx-charts'), require('@angular/common'), require('@backbase/foundation-ang/future'), require('@backbase/foundation-ang/core'), require('@backbase/ui-ang/css-variables-lib'), require('rxjs'), require('rxjs/operators'), require('@angular/animations'), require('d3-scale'), require('@backbase/ui-ang/amount'), require('@backbase/data-ang/transactions'), require('@angular/router'), require('@backbase/ui-ang/loading-indicator'), require('@backbase/ui-ang/empty-state'), require('@backbase/ui-ang/button')) :
    typeof define === 'function' && define.amd ? define('@backbase/turnovers-widget-ang', ['exports', '@angular/core', '@swimlane/ngx-charts', '@angular/common', '@backbase/foundation-ang/future', '@backbase/foundation-ang/core', '@backbase/ui-ang/css-variables-lib', 'rxjs', 'rxjs/operators', '@angular/animations', 'd3-scale', '@backbase/ui-ang/amount', '@backbase/data-ang/transactions', '@angular/router', '@backbase/ui-ang/loading-indicator', '@backbase/ui-ang/empty-state', '@backbase/ui-ang/button'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.backbase = global.backbase || {}, global.backbase["turnovers-widget-ang"] = {}), global.ng.core, global.i1, global.ng.common, global.i1$2, global.i1$3, global.i2, global.rxjs, global.rxjs.operators, global.ng.animations, global.d3Scale, global.i5, global.i1$4, global.ng.router, global.i5$1, global.i6, global.i8));
})(this, (function (exports, i0, i1, i1$1, i1$2, i1$3, i2, rxjs, operators, animations, d3Scale, i5, i1$4, i2$1, i5$1, i6, i8) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i1__namespace$1 = /*#__PURE__*/_interopNamespace(i1$1);
    var i1__namespace$2 = /*#__PURE__*/_interopNamespace(i1$2);
    var i1__namespace$4 = /*#__PURE__*/_interopNamespace(i1$3);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);
    var i1__namespace$3 = /*#__PURE__*/_interopNamespace(i1$4);
    var i2__namespace$1 = /*#__PURE__*/_interopNamespace(i2$1);
    var i5__namespace$1 = /*#__PURE__*/_interopNamespace(i5$1);
    var i6__namespace = /*#__PURE__*/_interopNamespace(i6);
    var i8__namespace = /*#__PURE__*/_interopNamespace(i8);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var BbTurnoversLegendComponent = /** @class */ (function () {
        function BbTurnoversLegendComponent(cd) {
            this.cd = cd;
            /**
             * The data for the chart legend.
             */
            this.data = [];
            /**
             * The active entries for the chart legend.
             */
            this.activeEntries = [];
            /**
             * EventEmitter for triggering a labelClick event.
             */
            this.labelClick = new i0.EventEmitter();
            /**
             * EventEmitter for triggering a labelActivate event.
             */
            this.labelActivate = new i0.EventEmitter();
            /**
             * EventEmitter for triggering a labelDeactivate event.
             */
            this.labelDeactivate = new i0.EventEmitter();
            this.legendEntries = [];
        }
        BbTurnoversLegendComponent.prototype.ngOnChanges = function () {
            this.update();
        };
        BbTurnoversLegendComponent.prototype.update = function () {
            this.cd.markForCheck();
            this.legendEntries = this.getLegendEntries();
        };
        BbTurnoversLegendComponent.prototype.getLegendEntries = function () {
            var e_1, _b;
            var _a;
            var items = [];
            var _loop_1 = function (label) {
                var formattedLabel = i1.formatLabel(label);
                var idx = items.findIndex(function (i) {
                    return i.label === formattedLabel;
                });
                if (idx === -1) {
                    items.push({
                        label: label,
                        formattedLabel: formattedLabel,
                        color: (_a = this_1.colors) === null || _a === void 0 ? void 0 : _a.getColor(label),
                    });
                }
            };
            var this_1 = this;
            try {
                for (var _c = __values(this.data), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var label = _d.value;
                    _loop_1(label);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return items;
        };
        BbTurnoversLegendComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.label === d.name;
            });
            return item !== undefined;
        };
        BbTurnoversLegendComponent.prototype.activate = function (item) {
            this.labelActivate.emit(item);
        };
        BbTurnoversLegendComponent.prototype.deactivate = function (item) {
            this.labelDeactivate.emit(item);
        };
        BbTurnoversLegendComponent.prototype.trackBy = function (index, item) {
            return item.label;
        };
        return BbTurnoversLegendComponent;
    }());
    BbTurnoversLegendComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BbTurnoversLegendComponent, deps: [{ token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    BbTurnoversLegendComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbTurnoversLegendComponent, selector: "bb-charts-legend", inputs: { data: "data", title: "title", colors: "colors", height: "height", width: "width", activeEntries: "activeEntries" }, outputs: { labelClick: "labelClick", labelActivate: "labelActivate", labelDeactivate: "labelDeactivate" }, usesOnChanges: true, ngImport: i0__namespace, template: "<div class=\"row\">\n  <header class=\"legend-title\" *ngIf=\"title?.length > 0\">\n    <span class=\"legend-title-text\">{{title}}</span>\n  </header>\n  <div class=\"legend-wrap\">\n    <ul class=\"legend-labels d-flex px-5 mb-3\"\n      [style.max-height.px]=\"height ? height - 45 : 'inherit'\">\n      <li\n        *ngFor=\"let entry of legendEntries; trackBy: trackBy\"\n        class=\"legend-label text-dark text-capitalize\">\n        <ngx-charts-legend-entry\n          [label]=\"entry.label\"\n          [formattedLabel]=\"entry.formattedLabel\"\n          [color]=\"entry.color\"\n          [isActive]=\"isActive(entry)\"\n          (select)=\"labelClick.emit($event)\"\n          (activate)=\"activate($event)\"\n          (deactivate)=\"deactivate($event)\">\n        </ngx-charts-legend-entry>\n      </li>\n    </ul>\n  </div>\n</div>\n", styles: [".chart-legend{display:inline-block;padding:0;width:auto!important}.chart-legend .legend-title{white-space:nowrap;overflow:hidden;margin-left:10px;margin-bottom:5px;font-size:14px;font-weight:bold}.chart-legend ul,.chart-legend li{padding:0;margin:0;list-style:none}.chart-legend .horizontal-legend li{display:inline-block}.chart-legend .legend-wrap{width:calc(100% - 10px)}.chart-legend .legend-labels{line-height:85%;list-style:none;text-align:left;float:left;width:100%;border-radius:3px;overflow-y:auto;overflow-x:hidden;white-space:nowrap;background:rgba(0,0,0,.05)}.chart-legend .legend-label{cursor:pointer;font-size:90%;margin:8px;color:#afb7c8}.chart-legend .legend-label:hover{color:#000;transition:.2s}.chart-legend .legend-label .active .legend-label-text{color:#000}.chart-legend .legend-label-color{display:inline-block;height:15px;width:15px;margin-right:5px;color:#5b646b;border-radius:3px}.chart-legend .legend-label-text{display:inline-block;vertical-align:top;line-height:15px;font-size:12px;width:calc(100% - 20px);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.chart-legend .legend-title-text{vertical-align:bottom;display:inline-block;line-height:16px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}\n"], components: [{ type: i1__namespace.LegendEntryComponent, selector: "ngx-charts-legend-entry", inputs: ["isActive", "color", "label", "formattedLabel"], outputs: ["select", "activate", "deactivate", "toggle"] }], directives: [{ type: i1__namespace$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush, encapsulation: i0__namespace.ViewEncapsulation.None });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BbTurnoversLegendComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-charts-legend',
                        templateUrl: './bb-turnovers-legend.component.html',
                        styleUrls: ['./bb-turnovers-legend.component.scss'],
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { data: [{
                    type: i0.Input
                }], title: [{
                    type: i0.Input
                }], colors: [{
                    type: i0.Input
                }], height: [{
                    type: i0.Input
                }], width: [{
                    type: i0.Input
                }], activeEntries: [{
                    type: i0.Input
                }], labelClick: [{
                    type: i0.Output
                }], labelActivate: [{
                    type: i0.Output
                }], labelDeactivate: [{
                    type: i0.Output
                }] } });

    var BbGridPanelSeriesComponent = /** @class */ (function () {
        function BbGridPanelSeriesComponent(deprecationService) {
            this.deprecationService = deprecationService;
            this.gridPanels = [];
            /**
             * Array of Chart data objects needed for the chart to be rendered.
             */
            this.data = [];
            /**
             * Dimensions of the chart.
             */
            this.dims = {
                height: 0,
                width: 0,
            };
        }
        Object.defineProperty(BbGridPanelSeriesComponent.prototype, "orient", {
            get: function () {
                return this._orient || 'vertical';
            },
            set: function (val) {
                this.deprecationService.logDeprecatedFeature('Removed #orient input from #BbGridPanelSeriesComponent');
                this._orient = val;
            },
            enumerable: false,
            configurable: true
        });
        BbGridPanelSeriesComponent.prototype.ngOnChanges = function () {
            this.update();
        };
        BbGridPanelSeriesComponent.prototype.update = function () {
            this.gridPanels = this.getChartDataLabels();
        };
        BbGridPanelSeriesComponent.prototype.getChartDataLabels = function () {
            var _this = this;
            return this.data.map(function (d) {
                var _a;
                var labelName = (_a = d.name) !== null && _a !== void 0 ? _a : '';
                var width = 0;
                var xValue = 0;
                if (!!_this.xScale) {
                    var offset = _this.xScale.bandwidth() * _this.xScale.paddingInner();
                    width = _this.xScale.bandwidth() + offset;
                    xValue = (_this.xScale(labelName) || 0) - offset / 2;
                }
                return {
                    name: labelName,
                    class: d.badge === 'forecast' ? 'forecast' : '',
                    width: width,
                    height: _this.dims.height,
                    x: xValue,
                    y: 0,
                    roundEdges: false,
                };
            });
        };
        BbGridPanelSeriesComponent.prototype.getGridPanels = function () {
            var _this = this;
            this.deprecationService.logDeprecatedFeature('#getGridPanels deprecation in favor of private method #getChartDataLabels from #BbGridPanelSeriesComponent');
            var localXScale = this.xScale;
            var localYScale = this.yScale;
            return this.data.map(function (d) {
                var offset;
                var width;
                var height;
                var x;
                var y;
                if (_this.orient === 'vertical') {
                    offset = localXScale.bandwidth() * localXScale.paddingInner();
                    width = localXScale.bandwidth() + offset;
                    height = _this.dims.height;
                    x = (localXScale(d.name) || 0) - offset / 2;
                    y = 0;
                }
                else if (_this.orient === 'horizontal') {
                    offset = localYScale.bandwidth() * localYScale.paddingInner();
                    width = _this.dims.width;
                    height = localYScale.bandwidth() + offset;
                    x = 0;
                    y = localYScale(d.name) - offset / 2;
                }
                return {
                    name: d.name,
                    class: d.badge === 'forecast' ? 'forecast' : '',
                    height: height,
                    width: width,
                    x: x,
                    y: y,
                };
            });
        };
        return BbGridPanelSeriesComponent;
    }());
    BbGridPanelSeriesComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BbGridPanelSeriesComponent, deps: [{ token: i1__namespace$2.DeprecationsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    BbGridPanelSeriesComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbGridPanelSeriesComponent, selector: "g[bb-charts-grid-panel-series]", inputs: { data: "data", dims: "dims", xScale: "xScale", yScale: "yScale" }, usesOnChanges: true, ngImport: i0__namespace, template: "<svg:g *ngFor=\"let gridPanel of gridPanels\">\n  <svg:g ngx-charts-grid-panel\n    [height]=\"gridPanel.height\"\n    [width]=\"gridPanel.width\"\n    [x]=\"gridPanel.x\"\n    [y]=\"gridPanel.y\"\n    [class.grid-panel]=\"true\"\n    [class.forecast]=\"gridPanel.class === 'forecast'\">\n  </svg:g>\n</svg:g>\n", components: [{ type: i1__namespace.GridPanelComponent, selector: "g[ngx-charts-grid-panel]", inputs: ["width", "height", "x", "y"] }], directives: [{ type: i1__namespace$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    __decorate([
        i0.Input()('orient')
    ], BbGridPanelSeriesComponent.prototype, "orient", null);
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BbGridPanelSeriesComponent, decorators: [{
                type: i0.Component,
                args: [{
                        // eslint-disable-next-line @angular-eslint/component-selector
                        selector: 'g[bb-charts-grid-panel-series]',
                        templateUrl: './bb-grid-panel-series.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.DeprecationsService }]; }, propDecorators: { data: [{
                    type: i0.Input
                }], dims: [{
                    type: i0.Input
                }], xScale: [{
                    type: i0.Input
                }], yScale: [{
                    type: i0.Input
                }] } });

    var PROPERTIES = {
        FORECAST: {
            name: 'showForecast',
            value: true,
        },
    };
    var PERIODS = [
        {
            interval: 'MONTH',
            duration: 6,
            default: true,
        },
        {
            interval: 'MONTH',
            duration: 12,
        },
    ];
    var INTERVAL = {
        DAY: 'DAY',
        WEEK: 'WEEK',
        MONTH: 'MONTH',
        YEAR: 'YEAR',
    };
    var DEFAULT_INTERVAL = INTERVAL.MONTH;
    var DEFAULT_DURATION = 6;
    var DEFAULT_START_DAY = 1;
    var BAR_COLORS_CSS_VAR = '--chart-group-bar-color';
    var CHART_COLORS = ['#004285', '#107bb5'];
    var MOBILE_WIDGET_WIDTH = 688;
    var filterInputParameters = function (input, prop) { return rxjs.combineLatest([input, prop]).pipe(operators.map(function (_a) {
        var _b = __read(_a, 2), inputVal = _b[0], propVal = _b[1];
        return (inputVal !== undefined ? inputVal : propVal);
    })); };

    var TurnoversVerticalBarChartComponent = /** @class */ (function (_super) {
        __extends(TurnoversVerticalBarChartComponent, _super);
        function TurnoversVerticalBarChartComponent(chartElement, zone, cd, platformId) {
            var _this = _super.call(this, chartElement, zone, cd, platformId) || this;
            /**
             * Enable/Disable chart legend.
             */
            _this.legend = false;
            /**
             * The title for the chart legend.
             */
            _this.legendTitle = '';
            /**
             * Hide/show the horizontal axis.
             */
            _this.xAxis = true;
            /**
             * Hide/show the vertical axis.
             */
            _this.yAxis = true;
            /**
             * Show the horizontal axis label.
             */
            _this.showXAxisLabel = true;
            /**
             * Show the vertical axis label.
             */
            _this.showYAxisLabel = true;
            /**
             * The label for the horizontal axis.
             */
            _this.xAxisLabel = '';
            /**
             * The label for the vertical axis.
             */
            _this.yAxisLabel = '';
            /**
             * Enable/Disable chart tooltip.
             */
            _this.tooltipDisabled = false;
            /**
             * Enable/Disable chart gradient.
             */
            _this.gradient = false;
            /**
             * Show/hide chart grid lines.
             */
            _this.showGridLines = true;
            /**
             * The active entries for the chart legend.
             */
            _this.activeEntries = [];
            /**
             * Sets the scheme type of the chart.
             */
            _this.schemeType = i1.ScaleType.Ordinal;
            /**
             * Padding of the chart bars.
             */
            _this.barPadding = 8;
            /**
             * Enable/Disable rounded corners.
             */
            _this.roundDomains = true;
            /**
             * Enable/disable rounded edges for the bars.
             */
            _this.roundEdges = false;
            /**
             * Maximum vertical chart scale.
             */
            _this.yScaleMax = 0;
            /**
             * Hide/show the data labels.
             */
            _this.showDataLabel = false;
            /**
             * Array of Chart data objects needed for the chart to be rendered.
             */
            _this.groupsData = [];
            /**
             * The chart legend template.
             */
            _this.legendTemplate = null;
            /**
             * EventEmitter for triggering a activate event.
             */
            _this.activate = new i0.EventEmitter();
            /**
             * EventEmitter for triggering a deactivate event.
             */
            _this.deactivate = new i0.EventEmitter();
            _this.dims = { width: 0, height: 0, xOffset: 0 };
            _this.groupDomain = [];
            _this.innerDomain = [];
            _this.valueDomain = [];
            _this.margin = [10, 20, 10, 20];
            _this.xAxisHeight = 0;
            _this.yAxisWidth = 0;
            _this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            return _this;
        }
        TurnoversVerticalBarChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            if (!this.showDataLabel) {
                this.dataLabelMaxHeight = { negative: 0, positive: 0 };
            }
            this.margin = [10 + this.dataLabelMaxHeight.positive, 20, 10 + this.dataLabelMaxHeight.negative, 20];
            this.dims = i1.calculateViewDimensions({
                width: this.width,
                height: this.height,
                margins: this.margin,
                showXAxis: this.xAxis,
                showYAxis: this.yAxis,
                xAxisHeight: this.xAxisHeight,
                yAxisWidth: this.yAxisWidth,
                showXLabel: this.showXAxisLabel,
                showYLabel: this.showYAxisLabel,
                showLegend: this.legend,
                legendType: this.schemeType,
            });
            if (this.showDataLabel) {
                this.dims.height -= this.dataLabelMaxHeight.negative;
            }
            this.formatDates();
            this.groupDomain = this.getGroupDomain();
            this.innerDomain = this.getInnerDomain();
            this.setColors();
            this.transform = "translate(" + this.dims.xOffset + " , " + (this.margin[0] + this.dataLabelMaxHeight.negative) + ")";
        };
        TurnoversVerticalBarChartComponent.prototype.getGroupDomain = function () {
            var e_1, _a;
            var domain = [];
            try {
                for (var _b = __values(this.results), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var group = _c.value;
                    if (!domain.includes(group.name)) {
                        domain.push(group.name);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return domain;
        };
        TurnoversVerticalBarChartComponent.prototype.getInnerDomain = function () {
            var e_2, _a, e_3, _b;
            var domain = [];
            try {
                for (var _c = __values(this.results), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var group = _d.value;
                    try {
                        for (var _e = (e_3 = void 0, __values(group.series)), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var d = _f.value;
                            if (!domain.includes(d.name)) {
                                domain.push(d.name);
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return domain;
        };
        TurnoversVerticalBarChartComponent.prototype.getXScale = function () {
            var spacing = this.groupDomain.length / (this.dims.width / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, this.dims.width]).paddingInner(spacing).domain(this.groupDomain);
        };
        TurnoversVerticalBarChartComponent.prototype.getYScale = function () {
            var scale = d3Scale.scaleLinear().range([this.dims.height, 0]).domain(this.valueDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        TurnoversVerticalBarChartComponent.prototype.onDataLabelMaxHeightChanged = function (event, groupIndex) {
            var _this = this;
            if (event.size.negative) {
                this.dataLabelMaxHeight.negative = Math.max(this.dataLabelMaxHeight.negative, event.size.height);
            }
            else {
                this.dataLabelMaxHeight.positive = Math.max(this.dataLabelMaxHeight.positive, event.size.height);
            }
            if (groupIndex === this.results.length - 1) {
                setTimeout(function () { return _this.update(); });
            }
        };
        TurnoversVerticalBarChartComponent.prototype.onClick = function (data, group) {
            if (group) {
                data.series = group.name;
            }
            this.select.emit(data);
        };
        TurnoversVerticalBarChartComponent.prototype.trackBy = function (index, item) {
            return item.name;
        };
        TurnoversVerticalBarChartComponent.prototype.setColors = function () {
            var domain = this.schemeType === i1.ScaleType.Ordinal ? this.innerDomain : this.valueDomain;
            this.colors = new i1.ColorHelper(this.scheme, this.schemeType, domain, this.customColors);
        };
        TurnoversVerticalBarChartComponent.prototype.updateYAxisWidth = function (axis) {
            this.yAxisWidth = axis.width;
            this.update();
        };
        TurnoversVerticalBarChartComponent.prototype.updateXAxisHeight = function (axis) {
            this.xAxisHeight = axis.height;
            this.update();
        };
        TurnoversVerticalBarChartComponent.prototype.onActivate = function (event, group) {
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            if (idx > -1) {
                return;
            }
            this.activeEntries = __spreadArray([item], __read(this.activeEntries));
            this.activate.emit({ value: item, entries: this.activeEntries });
        };
        TurnoversVerticalBarChartComponent.prototype.onDeactivate = function (event, group) {
            var item = Object.assign({}, event);
            if (group) {
                item.series = group.name;
            }
            var idx = this.activeEntries.findIndex(function (d) {
                return d.name === item.name && d.value === item.value && d.series === item.series;
            });
            this.activeEntries.splice(idx, 1);
            this.activeEntries = __spreadArray([], __read(this.activeEntries)); // NOSONAR false positive - https://github.com/SonarSource/SonarTS/issues/760
            this.deactivate.emit({ value: item, entries: this.activeEntries });
        };
        return TurnoversVerticalBarChartComponent;
    }(i1.BaseChartComponent));
    TurnoversVerticalBarChartComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalBarChartComponent, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TurnoversVerticalBarChartComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalBarChartComponent, selector: "ng-component", inputs: { legend: "legend", legendTitle: "legendTitle", xAxis: "xAxis", yAxis: "yAxis", showXAxisLabel: "showXAxisLabel", showYAxisLabel: "showYAxisLabel", xAxisLabel: "xAxisLabel", yAxisLabel: "yAxisLabel", tooltipDisabled: "tooltipDisabled", gradient: "gradient", showGridLines: "showGridLines", activeEntries: "activeEntries", schemeType: "schemeType", xAxisTickFormatting: "xAxisTickFormatting", yAxisTickFormatting: "yAxisTickFormatting", barPadding: "barPadding", roundDomains: "roundDomains", roundEdges: "roundEdges", yScaleMax: "yScaleMax", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", groupsData: "groupsData", tooltipTemplate: "tooltipTemplate", legendTemplate: "legendTemplate" }, outputs: { activate: "activate", deactivate: "deactivate" }, usesInheritance: true, ngImport: i0__namespace, template: '', isInline: true });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalBarChartComponent, decorators: [{
                type: i0.Component,
                args: [{
                        template: '',
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        }, propDecorators: { legend: [{
                    type: i0.Input
                }], legendTitle: [{
                    type: i0.Input
                }], xAxis: [{
                    type: i0.Input
                }], yAxis: [{
                    type: i0.Input
                }], showXAxisLabel: [{
                    type: i0.Input
                }], showYAxisLabel: [{
                    type: i0.Input
                }], xAxisLabel: [{
                    type: i0.Input
                }], yAxisLabel: [{
                    type: i0.Input
                }], tooltipDisabled: [{
                    type: i0.Input
                }], gradient: [{
                    type: i0.Input
                }], showGridLines: [{
                    type: i0.Input
                }], activeEntries: [{
                    type: i0.Input
                }], schemeType: [{
                    type: i0.Input
                }], xAxisTickFormatting: [{
                    type: i0.Input
                }], yAxisTickFormatting: [{
                    type: i0.Input
                }], barPadding: [{
                    type: i0.Input
                }], roundDomains: [{
                    type: i0.Input
                }], roundEdges: [{
                    type: i0.Input
                }], yScaleMax: [{
                    type: i0.Input
                }], showDataLabel: [{
                    type: i0.Input
                }], dataLabelFormatting: [{
                    type: i0.Input
                }], groupsData: [{
                    type: i0.Input
                }], tooltipTemplate: [{
                    type: i0.Input
                }], legendTemplate: [{
                    type: i0.Input
                }], activate: [{
                    type: i0.Output
                }], deactivate: [{
                    type: i0.Output
                }] } });

    var D0Types;
    (function (D0Types) {
        D0Types["positive"] = "positive";
        D0Types["negative"] = "negative";
    })(D0Types || (D0Types = {}));
    var BbSeriesVerticalComponent = /** @class */ (function () {
        function BbSeriesVerticalComponent(deprecationService) {
            this.deprecationService = deprecationService;
            /**
             * The type of the chart bars.
             */
            this.type = 'standard';
            /**
             * Enable/disable bars gradient.
             */
            this.gradient = false;
            /**
             * The active entries for the chart bars.
             */
            this.activeEntries = [];
            /**
             * Name of the chart series.
             */
            this.seriesName = '';
            /**
             * Enabel/Disable bars tooltip.
             */
            this.tooltipDisabled = false;
            /**
             * Show/Hide tooltip caret.
             */
            this.tooltipShowCaret = false;
            /**
             * Enable/disable bars rounded edges.
             */
            this.roundEdges = false;
            /**
             * Enable/disable bars animation.
             */
            this.animations = true;
            /**
             * Show/hide bars label.
             */
            this.showDataLabel = false;
            /**
             * EventEmitter for triggering a select event.
             */
            // eslint-disable-next-line @angular-eslint/no-output-native
            this.select = new i0.EventEmitter();
            /**
             * EventEmitter for triggering a activate event.
             */
            this.activate = new i0.EventEmitter();
            /**
             * EventEmitter for triggering a deactivate event.
             */
            this.deactivate = new i0.EventEmitter();
            /**
             * EventEmitter for triggering a dataLabelHeightChanged event.
             */
            this.dataLabelHeightChanged = new i0.EventEmitter();
            this.tooltipPlacement = i1.PlacementTypes.Top;
            this.tooltipType = i1.StyleTypes.tooltip;
            this.orientation = i1.BarOrientation.Vertical;
            this.barsForDataLabels = [];
        }
        BbSeriesVerticalComponent.prototype.getColors = function (value, label, offset0, offset1) {
            var bar = {};
            if (this.colors) {
                if (this.colors.scaleType === i1.ScaleType.Ordinal) {
                    bar.color = this.colors.getColor(label);
                }
                else {
                    if (this.type === 'standard') {
                        bar.color = this.colors.getColor(value);
                        bar.gradientStops = this.colors.getLinearGradientStops(value);
                    }
                    else {
                        bar.color = this.colors.getColor(offset1 || 0);
                        bar.gradientStops = this.colors.getLinearGradientStops(offset1 || 0, offset0);
                    }
                }
            }
            return bar;
        };
        BbSeriesVerticalComponent.prototype.tooltipText = function (label, value) {
            return this.tooltipDisabled
                ? undefined
                : "\n      <span class=\"tooltip-label\">" + label + "</span>\n      <span class=\"tooltip-val\">" + value + "</span>\n    ";
        };
        BbSeriesVerticalComponent.prototype.ngOnChanges = function () {
            if (!this.series) {
                throw new Error('[series] should be provided to the component!');
            }
            this.update(this.series);
        };
        BbSeriesVerticalComponent.prototype.update = function (series) {
            this.bars = this.formatChartData(series);
            this.barsForDataLabels = this.updatedLabels(series);
        };
        BbSeriesVerticalComponent.prototype.updateDataLabels = function (series) {
            this.deprecationService.logDeprecatedFeature('#updateDataLabels inside #BbSeriesVerticalComponent deprecated in favor of #updatedLabels, which returns the formatted object instead of assigning values within itself');
            this.barsForDataLabels = this.updatedLabels(series);
        };
        BbSeriesVerticalComponent.prototype.updatedBars = function (series) {
            var _j;
            var _this = this;
            var _a;
            var d0Type = D0Types.positive;
            var width = (_a = this.xScale) === null || _a === void 0 ? void 0 : _a.bandwidth();
            var yScaleMin = Math.max(this.yScale.domain()[0], 0);
            var d0 = (_j = {},
                _j[D0Types.positive] = 0,
                _j[D0Types.negative] = 0,
                _j);
            return series.map(function (d, index, group) {
                var _a, _b, _c;
                var value = d.value || 0;
                var label = d.name || '';
                var formattedLabel = i1.formatLabel(label);
                var roundEdges = _this.roundEdges;
                d0Type = value > 0 ? D0Types.positive : D0Types.negative;
                var bar = {
                    value: value,
                    label: label,
                    roundEdges: roundEdges,
                    data: d,
                    width: width,
                    formattedLabel: formattedLabel,
                    height: 0,
                    x: 0,
                    y: 0,
                };
                // Use data of the group of bars for tooltips
                if (_this.groupData) {
                    bar.data = {
                        group: group.map(function (barEl) { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = _this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                        diff: _this.groupData.diff,
                        currency: _this.groupData.currency,
                        value: d.value,
                        badge: _this.groupData.badge,
                    };
                }
                if (_this.type === 'standard') {
                    bar.height = Math.abs(_this.yScale(value) - _this.yScale(yScaleMin));
                    bar.x = (_a = _this.xScale) === null || _a === void 0 ? void 0 : _a.call(_this, label);
                    bar.y = (_b = _this.yScale) === null || _b === void 0 ? void 0 : _b.call(_this, Math.max(0, value));
                }
                else if (_this.type === 'stacked') {
                    var offset0 = d0[d0Type];
                    var offset1 = offset0 + value;
                    d0[d0Type] += value;
                    bar.height = Math.ceil(_this.yScale(offset0) - _this.yScale(offset1));
                    bar.x = 0;
                    bar.y = (_c = _this.yScale) === null || _c === void 0 ? void 0 : _c.call(_this, offset1);
                    bar.offset0 = offset0;
                    bar.offset1 = offset1;
                    bar.roundEdges = index === 1;
                }
                Object.assign(bar, _this.getColors(value, label, bar.offset0, bar.offset1));
                var tooltipLabel = formattedLabel;
                if (_this.seriesName) {
                    tooltipLabel = _this.seriesName + " \u2022 " + formattedLabel;
                    bar.data.series = _this.seriesName;
                }
                bar.tooltipText = _this.tooltipText(tooltipLabel, value.toLocaleString());
                return bar;
            });
        };
        BbSeriesVerticalComponent.prototype.updatedLabels = function (series) {
            var _this = this;
            return series.map(function (d) {
                var _a, _b, _c;
                return ({
                    name: d.name,
                    series: _this.seriesName ? _this.seriesName : d.name,
                    total: d.value,
                    x: ((_a = _this.xScale) === null || _a === void 0 ? void 0 : _a.call(_this, d.name)) || 0,
                    y: ((_b = _this.yScale) === null || _b === void 0 ? void 0 : _b.call(_this, 0)) || 0,
                    height: _this.yScale ? _this.yScale(d.value) - _this.yScale(0) : 0,
                    width: ((_c = _this.xScale) === null || _c === void 0 ? void 0 : _c.bandwidth()) || 0,
                    roundEdges: _this.roundEdges,
                });
            });
        };
        BbSeriesVerticalComponent.prototype.formatChartData = function (series) {
            var _j;
            var _this = this;
            var yScaleMin = Math.max(this.yScale.domain()[0], 0);
            var d0 = (_j = {},
                _j[D0Types.positive] = 0,
                _j[D0Types.negative] = 0,
                _j);
            var formattedSeries = series.map(function (d, index, group) {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                var value = d.value || 0;
                var label = d.name || '';
                var d0Type = value > 0 ? D0Types.positive : D0Types.negative;
                var formattedLabel = i1.formatLabel(label);
                var tooltipLabel = _this.seriesName ? _this.seriesName + " \u2022 " + formattedLabel : formattedLabel;
                var data = {
                    name: _this.seriesName || '',
                    group: group.map(function (barEl) { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = _this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                    series: group.map(function (barEl) { var _a; return (Object.assign(Object.assign({}, barEl), { color: (_a = _this.colors) === null || _a === void 0 ? void 0 : _a.getColor(barEl.name || '') })); }),
                    diff: (_a = _this.groupData) === null || _a === void 0 ? void 0 : _a.diff,
                    currency: (_b = _this.groupData) === null || _b === void 0 ? void 0 : _b.currency,
                    value: d.value,
                    badge: (_c = _this.groupData) === null || _c === void 0 ? void 0 : _c.badge,
                };
                var graphData = {
                    name: _this.seriesName || '',
                    value: d.value,
                };
                var standardType = {
                    height: Math.abs(_this.yScale(value) - _this.yScale(yScaleMin)),
                    offset0: undefined,
                    offset1: undefined,
                    roundEdges: _this.roundEdges,
                    x: ((_d = _this.xScale) === null || _d === void 0 ? void 0 : _d.call(_this, label)) || 0,
                    y: ((_e = _this.yScale) === null || _e === void 0 ? void 0 : _e.call(_this, Math.max(0, value))) || 0,
                    width: ((_f = _this.xScale) === null || _f === void 0 ? void 0 : _f.bandwidth()) || 0,
                };
                var stackedType = {
                    height: Math.ceil(_this.yScale(d0[d0Type]) - _this.yScale(d0[d0Type] + value)),
                    offset0: d0[d0Type],
                    offset1: d0[d0Type] + value,
                    roundEdges: index === 1,
                    x: 0,
                    y: ((_g = _this.yScale) === null || _g === void 0 ? void 0 : _g.call(_this, d0[d0Type] + value)) || 0,
                    width: ((_h = _this.xScale) === null || _h === void 0 ? void 0 : _h.bandwidth()) || 0,
                };
                var typeObject = _this.type === 'stacked' ? stackedType : standardType;
                var returnObject = Object.assign(Object.assign(Object.assign({}, typeObject), _this.getColors(value, label, typeObject.offset0, typeObject.offset1)), { data: data, tooltipText: _this.tooltipText(tooltipLabel, value.toLocaleString()), formattedLabel: formattedLabel, value: value, label: label, graphData: Object.assign({}, graphData) });
                return returnObject;
            });
            return formattedSeries;
        };
        BbSeriesVerticalComponent.prototype.updateTooltipSettings = function () {
            this.deprecationService.logDeprecatedFeature('Deprecated #updateTooltipSettings method inside #BbSeriesVerticalComponent in favor of assigning values during component creation');
            this.tooltipPlacement = this.tooltipDisabled ? undefined : i1.PlacementTypes.Top;
            this.tooltipType = this.tooltipDisabled ? undefined : i1.StyleTypes.tooltip;
        };
        BbSeriesVerticalComponent.prototype.isActive = function (entry) {
            if (!this.activeEntries)
                return false;
            var item = this.activeEntries.find(function (d) {
                return entry.name === d.name && entry.series === d.series;
            });
            return item !== undefined;
        };
        BbSeriesVerticalComponent.prototype.onClick = function (data) {
            this.select.emit(data);
        };
        BbSeriesVerticalComponent.prototype.trackBy = function (index, bar) {
            return bar.label;
        };
        BbSeriesVerticalComponent.prototype.trackDataLabelBy = function (index, barLabel) {
            return index + "#" + barLabel.series + "#" + barLabel.total;
        };
        return BbSeriesVerticalComponent;
    }());
    BbSeriesVerticalComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BbSeriesVerticalComponent, deps: [{ token: i1__namespace$2.DeprecationsService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    BbSeriesVerticalComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: { dims: "dims", type: "type", series: "series", xScale: "xScale", yScale: "yScale", colors: "colors", gradient: "gradient", activeEntries: "activeEntries", seriesName: "seriesName", tooltipDisabled: "tooltipDisabled", tooltipShowCaret: "tooltipShowCaret", tooltipTemplate: "tooltipTemplate", roundEdges: "roundEdges", animations: "animations", showDataLabel: "showDataLabel", dataLabelFormatting: "dataLabelFormatting", groupData: "groupData" }, outputs: { select: "select", activate: "activate", deactivate: "deactivate", dataLabelHeightChanged: "dataLabelHeightChanged" }, usesOnChanges: true, ngImport: i0__namespace, template: "<svg:g ngx-charts-bar\n  *ngFor=\"let bar of bars; trackBy: trackBy\"\n  [@animationState]=\"'active'\"\n  [@.disabled]=\"!animations\"\n  [width]=\"bar.width\"\n  [height]=\"bar.height\"\n  [x]=\"bar.x\"\n  [y]=\"bar.y\"\n  [fill]=\"bar.color\"\n  [stops]=\"bar.gradientStops\"\n  [data]=\"bar.graphData\"\n  [orientation]=\"orientation\"\n  [roundEdges]=\"bar.roundEdges\"\n  [gradient]=\"gradient\"\n  [isActive]=\"isActive(bar)\"\n  (select)=\"onClick($event)\"\n  (activate)=\"activate.emit($event)\"\n  (deactivate)=\"deactivate.emit($event)\"\n  ngx-tooltip\n  [tooltipCssClass]=\"'chart-tooltip p-0 border-0'\"\n  [tooltipShowCaret]=\"tooltipShowCaret\"\n  [tooltipDisabled]=\"tooltipDisabled\"\n  [tooltipPlacement]=\"tooltipPlacement\"\n  [tooltipType]=\"tooltipType\"\n  [tooltipTitle]=\"tooltipTemplate ? undefined : bar.tooltipText\"\n  [tooltipTemplate]=\"tooltipTemplate\"\n  [tooltipContext]=\"bar.data\"\n  [animations]=\"animations\">\n</svg:g>\n<svg:g *ngIf=\"showDataLabel\">\n  <svg:g ngx-charts-bar-label \n    *ngFor=\"let b of barsForDataLabels; let i = index; trackBy:trackDataLabelBy\"\n    [barX]=\"b.x\"\n    [barY]=\"b.y\"\n    [barWidth]=\"b.width\"\n    [barHeight]=\"b.height\"\n    [value]=\"b.total\"\n    [valueFormatting]=\"dataLabelFormatting\"\n    [orientation]=\"orientation\"\n    (dimensionsChanged)=\"dataLabelHeightChanged.emit({size:$event, index:i})\"\n  />\n</svg:g>\n", components: [{ type: i1__namespace.BarComponent, selector: "g[ngx-charts-bar]", inputs: ["roundEdges", "gradient", "offset", "isActive", "animations", "noBarWhenZero", "fill", "data", "width", "height", "x", "y", "orientation", "stops", "ariaLabel"], outputs: ["select", "activate", "deactivate"] }, { type: i1__namespace.BarLabelComponent, selector: "g[ngx-charts-bar-label]", inputs: ["value", "valueFormatting", "barX", "barY", "barWidth", "barHeight", "orientation"], outputs: ["dimensionsChanged"] }], directives: [{ type: i1__namespace$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace.TooltipDirective, selector: "[ngx-tooltip]", inputs: ["tooltipCssClass", "tooltipAppendToBody", "tooltipSpacing", "tooltipDisabled", "tooltipShowCaret", "tooltipPlacement", "tooltipAlignment", "tooltipType", "tooltipCloseOnClickOutside", "tooltipCloseOnMouseLeave", "tooltipHideTimeout", "tooltipShowTimeout", "tooltipShowEvent", "tooltipImmediateExit", "tooltipTitle", "tooltipTemplate", "tooltipContext"], outputs: ["show", "hide"] }, { type: i1__namespace$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], animations: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                    }),
                    animations.animate(500, animations.style({ opacity: 0 })),
                ]),
            ]),
        ], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: BbSeriesVerticalComponent, decorators: [{
                type: i0.Component,
                args: [{
                        // eslint-disable-next-line @angular-eslint/component-selector
                        selector: 'g[bb-charts-series-vertical]',
                        templateUrl: './bb-charts-series-vertical.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('animationState', [
                                animations.transition(':leave', [
                                    animations.style({
                                        opacity: 1,
                                    }),
                                    animations.animate(500, animations.style({ opacity: 0 })),
                                ]),
                            ]),
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$2.DeprecationsService }]; }, propDecorators: { dims: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], series: [{
                    type: i0.Input
                }], xScale: [{
                    type: i0.Input
                }], yScale: [{
                    type: i0.Input
                }], colors: [{
                    type: i0.Input
                }], gradient: [{
                    type: i0.Input
                }], activeEntries: [{
                    type: i0.Input
                }], seriesName: [{
                    type: i0.Input
                }], tooltipDisabled: [{
                    type: i0.Input
                }], tooltipShowCaret: [{
                    type: i0.Input
                }], tooltipTemplate: [{
                    type: i0.Input
                }], roundEdges: [{
                    type: i0.Input
                }], animations: [{
                    type: i0.Input
                }], showDataLabel: [{
                    type: i0.Input
                }], dataLabelFormatting: [{
                    type: i0.Input
                }], groupData: [{
                    type: i0.Input
                }], select: [{
                    type: i0.Output
                }], activate: [{
                    type: i0.Output
                }], deactivate: [{
                    type: i0.Output
                }], dataLabelHeightChanged: [{
                    type: i0.Output
                }] } });

    var TurnoversVerticalGroupedBarChartComponent = /** @class */ (function (_super) {
        __extends(TurnoversVerticalGroupedBarChartComponent, _super);
        function TurnoversVerticalGroupedBarChartComponent(chartElement, zone, cd, platformId) {
            var _this = _super.call(this, chartElement, zone, cd, platformId) || this;
            /**
             * Sets the scale type of the chart.
             */
            _this.scaleType = i1.ScaleType.Ordinal;
            /**
             * Sets the group padding.
             */
            _this.groupPadding = 16;
            /**
             * Array of Chart data objects needed for the chart to be rendered.
             */
            _this.results = [];
            _this.legendOptions = {
                colors: undefined,
                domain: [],
                scaleType: _this.schemeType,
                title: '',
                position: i1.LegendPosition.Below,
            };
            return _this;
        }
        TurnoversVerticalGroupedBarChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.valueDomain = this.getValueDomain();
            this.groupScale = this.getGroupScale();
            this.innerScale = this.getInnerScale();
            this.valueScale = this.getValueScale();
            this.getLegendOptions();
        };
        TurnoversVerticalGroupedBarChartComponent.prototype.getGroupScale = function () {
            var spacing = this.groupDomain.length / (this.dims.height / this.groupPadding + 1);
            return d3Scale.scaleBand()
                .rangeRound([0, this.dims.width])
                .paddingInner(spacing)
                .paddingOuter(spacing / 2)
                .domain(this.groupDomain);
        };
        TurnoversVerticalGroupedBarChartComponent.prototype.getInnerScale = function () {
            var width = this.groupScale ? this.groupScale.bandwidth() : 1;
            var spacing = this.innerDomain.length / (width / this.barPadding + 1);
            return d3Scale.scaleBand().rangeRound([0, width]).paddingInner(spacing).domain(this.innerDomain);
        };
        TurnoversVerticalGroupedBarChartComponent.prototype.getValueScale = function () {
            var scale = d3Scale.scaleLinear().range([this.dims.height, 0]).domain(this.valueDomain);
            return this.roundDomains ? scale.nice() : scale;
        };
        TurnoversVerticalGroupedBarChartComponent.prototype.getValueDomain = function () {
            var e_1, _c, e_2, _d;
            var domain = [];
            try {
                for (var _e = __values(this.results), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var group = _f.value;
                    try {
                        for (var _g = (e_2 = void 0, __values(group.series)), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var d = _h.value;
                            if (!domain.includes(d.value)) {
                                domain.push(d.value);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var min = Math.min.apply(Math, __spreadArray([0], __read(domain)));
            var max = this.yScaleMax ? Math.max.apply(Math, __spreadArray([this.yScaleMax], __read(domain))) : Math.max.apply(Math, __spreadArray([], __read(domain)));
            return [min, max];
        };
        TurnoversVerticalGroupedBarChartComponent.prototype.groupTransform = function (group) {
            var _a, _b;
            var labelName = (_a = group.name) !== null && _a !== void 0 ? _a : '';
            return "translate(" + ((_b = this.groupScale) === null || _b === void 0 ? void 0 : _b.call(this, labelName)) + ", 0)";
        };
        TurnoversVerticalGroupedBarChartComponent.prototype.getLegendOptions = function () {
            if (!this.colors) {
                return;
            }
            if (this.legendOptions.scaleType === i1.ScaleType.Ordinal) {
                this.legendOptions.domain = this.innerDomain;
                this.legendOptions.colors = this.colors;
                this.legendOptions.title = this.legendTitle || '';
            }
            else {
                this.legendOptions.domain = this.valueDomain;
                this.legendOptions.colors = this.colors.scale;
            }
        };
        return TurnoversVerticalGroupedBarChartComponent;
    }(TurnoversVerticalBarChartComponent));
    TurnoversVerticalGroupedBarChartComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalGroupedBarChartComponent, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TurnoversVerticalGroupedBarChartComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalGroupedBarChartComponent, selector: "bb-charts-bar-vertical-2d", inputs: { scaleType: "scaleType", groupPadding: "groupPadding", results: "results" }, usesInheritance: true, ngImport: i0__namespace, template: "<ngx-charts-chart\n  [view]=\"[width, height]\"\n  [showLegend]=\"legend\"\n  [legendOptions]=\"legendOptions\"\n  [activeEntries]=\"activeEntries\"\n  [animations]=\"animations\"\n  (legendLabelActivate)=\"onActivate($event)\"\n  (legendLabelDeactivate)=\"onDeactivate($event)\"\n  (legendLabelClick)=\"onClick($event)\">\n  <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n    <svg:g bb-charts-grid-panel-series\n      [xScale]=\"groupScale\"\n      [yScale]=\"valueScale\"\n      [data]=\"groupsData\"\n      [dims]=\"dims\"\n    >\n    </svg:g>\n    <svg:g ngx-charts-x-axis\n      *ngIf=\"xAxis\"\n      [xScale]=\"groupScale\"\n      [dims]=\"dims\"\n      [showLabel]=\"showXAxisLabel\"\n      [labelText]=\"xAxisLabel\"\n      [tickFormatting]=\"xAxisTickFormatting\"\n      [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n      (dimensionsChanged)=\"updateXAxisHeight($event)\">\n    </svg:g>\n    <svg:g ngx-charts-y-axis\n      *ngIf=\"yAxis\"\n      [yScale]=\"valueScale\"\n      [dims]=\"dims\"\n      [showGridLines]=\"showGridLines\"\n      [showLabel]=\"showYAxisLabel\"\n      [labelText]=\"yAxisLabel\"\n      [tickFormatting]=\"yAxisTickFormatting\"\n      (dimensionsChanged)=\"updateYAxisWidth($event)\">\n    </svg:g>\n    <svg:g bb-charts-series-vertical\n      *ngFor=\"let group of groupsData; let index = index; trackBy:trackBy\"\n      [@animationState]=\"'active'\"\n      [attr.transform]=\"groupTransform(group)\"\n      [attr.opacity]=\"(group.badge ? 0.5 : 1)\"\n      [activeEntries]=\"activeEntries\"\n      [xScale]=\"innerScale\"\n      [yScale]=\"valueScale\"\n      [colors]=\"colors\"\n      [series]=\"group.series\"\n      [dims]=\"dims\"\n      [gradient]=\"gradient\"\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [showDataLabel]=\"showDataLabel\"\n      [dataLabelFormatting]=\"dataLabelFormatting\"\n      [seriesName]=\"group.name\"\n      [groupData]=\"group\"\n      [roundEdges]=\"roundEdges\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event, group)\"\n      (activate)=\"onActivate($event, group)\"\n      (deactivate)=\"onDeactivate($event, group)\"\n      (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n    />\n  </svg:g>\n</ngx-charts-chart>\n\n<ng-container\n  [ngTemplateOutlet]=\"legendTemplate\"\n  [ngTemplateOutletContext]=\"{\n    legendOptions: this.legendOptions,\n    activeEntries: this.activeEntries,\n    height: this.height,\n    onActivate: this.onActivate.bind(this),\n    onDeactivate: this.onDeactivate.bind(this),\n    onClick: this.onClick.bind(this)\n  }\"\n></ng-container>\n", styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .bar,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:normal}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}.gridline-path{stroke:#ccc}ngx-charts-legend{display:block;margin-top:1rem}\n"], components: [{ type: i1__namespace.ChartComponent, selector: "ngx-charts-chart", inputs: ["showLegend", "animations", "legendType", "view", "legendOptions", "activeEntries"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }, { type: BbGridPanelSeriesComponent, selector: "g[bb-charts-grid-panel-series]", inputs: ["data", "dims", "xScale", "yScale"] }, { type: i1__namespace.XAxisComponent, selector: "g[ngx-charts-x-axis]", inputs: ["rotateTicks", "showGridLines", "xOrient", "xAxisOffset", "xScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "showLabel", "labelText", "ticks", "xAxisTickCount"], outputs: ["dimensionsChanged"] }, { type: i1__namespace.YAxisComponent, selector: "g[ngx-charts-y-axis]", inputs: ["showGridLines", "yOrient", "yAxisOffset", "yScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "showLabel", "labelText", "yAxisTickCount", "referenceLines", "showRefLines", "showRefLabels"], outputs: ["dimensionsChanged"] }, { type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: ["dims", "type", "series", "xScale", "yScale", "colors", "gradient", "activeEntries", "seriesName", "tooltipDisabled", "tooltipShowCaret", "tooltipTemplate", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "groupData"], outputs: ["select", "activate", "deactivate", "dataLabelHeightChanged"] }], directives: [{ type: i1__namespace$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*',
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' })),
                ]),
            ]),
        ], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush, encapsulation: i0__namespace.ViewEncapsulation.None });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalGroupedBarChartComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-charts-bar-vertical-2d',
                        templateUrl: './turnovers-vertical-grouped-bar-chart.component.html',
                        styleUrls: ['../turnovers-vertical-stacked-bar-chart/turnovers-vertical-stacked-bar-chart.component.scss'],
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('animationState', [
                                animations.transition(':leave', [
                                    animations.style({
                                        opacity: 1,
                                        transform: '*',
                                    }),
                                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' })),
                                ]),
                            ]),
                        ],
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        }, propDecorators: { scaleType: [{
                    type: i0.Input
                }], groupPadding: [{
                    type: i0.Input
                }], results: [{
                    type: i0.Input
                }] } });

    var TurnoversBarChartComponent = /** @class */ (function () {
        function TurnoversBarChartComponent(currencyPipe, cssVariableService) {
            this.currencyPipe = currencyPipe;
            this.cssVariableService = cssVariableService;
            /**
             * Array of Chart data objects needed for the chart to be rendered.
             */
            this.chartSeriesData = [];
            /**
             * Disable/enable the forecast option on the chart.
             */
            this.forecast = false;
            // bar chart
            // options
            this.chartOptions = rxjs.from(this.cssVariableService.getCssVariable(BAR_COLORS_CSS_VAR)).pipe(operators.map(function (cssVar) { return ({
                colors: cssVar ? cssVar.split(',') : CHART_COLORS,
                showXAxis: true,
                showYAxis: true,
                gradient: false,
                showLegend: false,
                showXAxisLabel: true,
                showYAxisLabel: true,
            }); }));
        }
        TurnoversBarChartComponent.prototype.yAxisTickFormatting = function (value) {
            var currency = this.chartSeriesData[0].currency;
            if (this.barChart2d && this.barChart2d.width < MOBILE_WIDGET_WIDTH) {
                var amountVal = value / 1000;
                if (amountVal <= 999) {
                    return this.currencyPipe.transform(amountVal, currency, 'symbol', '1.0') + "k";
                }
                return this.currencyPipe.transform(amountVal / 1000, currency, 'symbol', '1.0') + "m";
            }
            return this.currencyPipe.transform(value, currency, 'symbol', '1.0');
        };
        return TurnoversBarChartComponent;
    }());
    TurnoversBarChartComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversBarChartComponent, deps: [{ token: i1__namespace$1.CurrencyPipe }, { token: i2__namespace.CssVariablesService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TurnoversBarChartComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversBarChartComponent, selector: "bb-turnovers-bar-chart", inputs: { chartSeriesData: "chartSeriesData", forecast: "forecast" }, providers: [i2.CssVariablesService], viewQueries: [{ propertyName: "barChart2d", first: true, predicate: ["bbChartsBarVertical2d"], descendants: true }], ngImport: i0__namespace, template: "<div class=\"position-relative pb-25p pb-md-50p\">\n  <ng-container *ngIf=\"this.chartOptions | async as options\">\n    <ng-container\n      bbTurnoversVerticalGroupedBarChartCustomizable\n      [bbHostRef]=\"this\"\n      [bbTemplateContext]=\"{options: options}\"\n    ></ng-container>\n    <ng-container\n      bbTurnoversVerticalStackedBarChartCustomizable\n      [bbHostRef]=\"this\"\n      [bbTemplateContext]=\"{options: options}\"\n    ></ng-container>\n  </ng-container>\n</div>\n\n<ng-template bbTurnoversVerticalGroupedBarChartCustomizable let-hostRef let-options=\"context.options\">\n  <div class=\"bb-turnovers-vertical-chart\">\n    <bb-charts-bar-vertical-2d\n      #bbChartsBarVertical2d\n      class=\"position-static transform-none\"\n      [scheme]=\"{ domain: options.colors }\"\n      [results]=\"hostRef.chartSeriesData\"\n      [groupsData]=\"hostRef.chartSeriesData\"\n      [xAxis]=\"options.showXAxis\"\n      [yAxis]=\"options.showYAxis\"\n      [showXAxisLabel]=\"options.showXAxisLabel\"\n      [showYAxisLabel]=\"options.showYAxisLabel\"\n      [legend]=\"options.showLegend\"\n      [gradient]=\"options.gradient\"\n      [barPadding]=\"0\"\n      [groupPadding]=\"6\"\n      [roundEdges]=\"true\"\n      [legendTemplate]=\"legendTemplate\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [yAxisTickFormatting]=\"yAxisTickFormatting.bind(this)\">\n    </bb-charts-bar-vertical-2d>\n  </div>\n</ng-template>\n\n<ng-template bbTurnoversVerticalStackedBarChartCustomizable let-hostRef let-options=\"context.options\">\n</ng-template>\n\n<ng-template bbTurnoversChartLegendCustomizable #legendTemplate\n  let-legendOptions=\"legendOptions\"\n  let-activeEntries=\"activeEntries\"\n  let-height=\"height\"\n  let-onActivate=\"onActivate\"\n  let-onDeactivate=\"onDeactivate\"\n  let-onClick=\"onClick\">\n  <bb-charts-legend\n    class=\"chart-legend\"\n    [data]=\"legendOptions.domain\"\n    [title]=\"legendOptions.title\"\n    [colors]=\"legendOptions.colors\"\n    [height]=\"height\"\n    [activeEntries]=\"activeEntries\"\n    (labelClick)=\"onClick($event)\"\n    (labelActivate)=\"onActivate($event)\"\n    (labelDeactivate)=\"onDeactivate($event)\">\n  </bb-charts-legend>\n</ng-template>\n\n<ng-template bbTurnoversChartTooltipCustomizable #tooltipTemplate let-model=\"model\">\n  <div class=\"chart-tooltip-default bb-arrow-bottom text-dark\">\n    <div\n      *ngIf=\"model.badge\"\n      class=\"pb-1 mb-2 font-weight-bold border-bottom border-dark text-capitalize text-left\">\n      {{model.badge}}\n    </div>\n    <div>\n      <div class=\"d-flex pb-1 align-items-center\" *ngFor=\"let bar of model.series; let i = index\">\n        <span [ngStyle]=\"{'color': bar.color}\" class=\"bicon bicon-circle\"></span>\n        <span class=\"text-capitalize\">{{bar.name}}</span>\n        <span class=\"ml-auto font-weight-bold\">\n          <bb-amount-ui\n            [amount]=\"i === 0 ? bar.value : (-bar.value)\"\n            [currency]=\"bar.currency\"\n            [showPlusSign]=\"i === 0 && bar.value > 0\"\n          ></bb-amount-ui>\n        </span>\n      </div>\n      <div class=\"d-flex pt-1 pl-1 align-items-center\">\n        <span i18n=\"Difference|tooltip difference label@@turnovers.tooltip.diff\">Difference</span>\n        <span class=\"ml-auto font-weight-bold\">\n          <bb-amount-ui\n            [amount]=\"model.diff\"\n            [currency]=\"model.currency\"\n            [showPlusSign]=\"model.diff !== 0\"\n          ></bb-amount-ui>\n        </span>\n      </div>\n    </div>\n  </div>\n</ng-template>\n", components: [{ type: i0__namespace.forwardRef(function () { return TurnoversVerticalGroupedBarChartComponent; }), selector: "bb-charts-bar-vertical-2d", inputs: ["scaleType", "groupPadding", "results"] }, { type: i0__namespace.forwardRef(function () { return BbTurnoversLegendComponent; }), selector: "bb-charts-legend", inputs: ["data", "title", "colors", "height", "width", "activeEntries"], outputs: ["labelClick", "labelActivate", "labelDeactivate"] }, { type: i0__namespace.forwardRef(function () { return i5__namespace.AmountComponent; }), selector: "bb-amount-ui", inputs: ["currency", "showPlusSign", "mapCurrency", "showPercent", "abbreviate", "decimalPlaces", "trailingZeroes", "amount"] }], directives: [{ type: i0__namespace.forwardRef(function () { return i1__namespace$1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0__namespace.forwardRef(function () { return TurnoversVerticalGroupedBarChartCustomizableDirective; }), selector: "[bbTurnoversVerticalGroupedBarChartCustomizable]" }, { type: i0__namespace.forwardRef(function () { return TurnoversVerticalStackedBarChartCustomizableDirective; }), selector: "[bbTurnoversVerticalStackedBarChartCustomizable]" }, { type: i0__namespace.forwardRef(function () { return TurnoversChartLegendCustomizableDirective; }), selector: "[bbTurnoversChartLegendCustomizable]" }, { type: i0__namespace.forwardRef(function () { return TurnoversChartTooltipCustomizableDirective; }), selector: "[bbTurnoversChartTooltipCustomizable]" }, { type: i0__namespace.forwardRef(function () { return i1__namespace$1.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i0__namespace.forwardRef(function () { return i1__namespace$1.NgStyle; }), selector: "[ngStyle]", inputs: ["ngStyle"] }], pipes: { "async": i0__namespace.forwardRef(function () { return i1__namespace$1.AsyncPipe; }) } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversBarChartComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-turnovers-bar-chart',
                        templateUrl: './turnovers-bar-chart.component.html',
                        providers: [i2.CssVariablesService],
                    }]
            }], ctorParameters: function () { return [{ type: i1__namespace$1.CurrencyPipe }, { type: i2__namespace.CssVariablesService }]; }, propDecorators: { barChart2d: [{
                    type: i0.ViewChild,
                    args: ['bbChartsBarVertical2d']
                }], chartSeriesData: [{
                    type: i0.Input
                }], forecast: [{
                    type: i0.Input
                }] } });
    var TurnoversChartTooltipCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversChartTooltipCustomizableDirective, _super);
        function TurnoversChartTooltipCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversChartTooltipCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversChartTooltipCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversChartTooltipCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversChartTooltipCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversChartTooltipCustomizableDirective, selector: "[bbTurnoversChartTooltipCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversChartTooltipCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversChartTooltipCustomizable]',
                    }]
            }] });
    var TurnoversChartLegendCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversChartLegendCustomizableDirective, _super);
        function TurnoversChartLegendCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversChartLegendCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversChartLegendCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversChartLegendCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversChartLegendCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversChartLegendCustomizableDirective, selector: "[bbTurnoversChartLegendCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversChartLegendCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversChartLegendCustomizable]',
                    }]
            }] });
    var TurnoversVerticalGroupedBarChartCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversVerticalGroupedBarChartCustomizableDirective, _super);
        function TurnoversVerticalGroupedBarChartCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversVerticalGroupedBarChartCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversVerticalGroupedBarChartCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalGroupedBarChartCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversVerticalGroupedBarChartCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalGroupedBarChartCustomizableDirective, selector: "[bbTurnoversVerticalGroupedBarChartCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalGroupedBarChartCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversVerticalGroupedBarChartCustomizable]',
                    }]
            }] });
    var TurnoversVerticalStackedBarChartCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversVerticalStackedBarChartCustomizableDirective, _super);
        function TurnoversVerticalStackedBarChartCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversVerticalStackedBarChartCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversVerticalStackedBarChartCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalStackedBarChartCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversVerticalStackedBarChartCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalStackedBarChartCustomizableDirective, selector: "[bbTurnoversVerticalStackedBarChartCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalStackedBarChartCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversVerticalStackedBarChartCustomizable]',
                    }]
            }] });

    var TurnoversVerticalStackedBarChartComponent = /** @class */ (function (_super) {
        __extends(TurnoversVerticalStackedBarChartComponent, _super);
        function TurnoversVerticalStackedBarChartComponent(chartElement, zone, cd, platformId) {
            var _this = _super.call(this, chartElement, zone, cd, platformId) || this;
            /**
             * An array of numbers to set the horizontal points on the chart.
             */
            _this.xAxisTicks = [];
            /**
             * An array of numbers to set the vertical points on the chart.
             */
            _this.yAxisTicks = [];
            return _this;
        }
        TurnoversVerticalStackedBarChartComponent.prototype.update = function () {
            _super.prototype.update.call(this);
            this.valueDomain = this.getValueDomain();
            this.xScale = this.getXScale();
            this.yScale = this.getYScale();
            this.legendOptions = this.getLegendOptions();
        };
        TurnoversVerticalStackedBarChartComponent.prototype.getValueDomain = function () {
            var e_1, _c, e_2, _d;
            var domain = [];
            var smallest = 0;
            var biggest = 0;
            try {
                for (var _e = __values(this.results), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var group = _f.value;
                    var smallestSum = 0;
                    var biggestSum = 0;
                    try {
                        for (var _g = (e_2 = void 0, __values(group.series)), _h = _g.next(); !_h.done; _h = _g.next()) {
                            var d = _h.value;
                            if (d.value < 0) {
                                smallestSum += d.value;
                            }
                            else {
                                biggestSum += d.value;
                            }
                            smallest = d.value < smallest ? d.value : smallest;
                            biggest = d.value > biggest ? d.value : biggest;
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    domain.push(smallestSum);
                    domain.push(biggestSum);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            domain.push(smallest);
            domain.push(biggest);
            var min = Math.min.apply(Math, __spreadArray([0], __read(domain)));
            var max = this.yScaleMax ? Math.max.apply(Math, __spreadArray([this.yScaleMax], __read(domain))) : Math.max.apply(Math, __spreadArray([], __read(domain)));
            return [min, max];
        };
        TurnoversVerticalStackedBarChartComponent.prototype.groupTransform = function (group) {
            var _a, _b;
            var labelName = (_a = group.name) !== null && _a !== void 0 ? _a : '';
            return "translate(" + ((_b = this.xScale) === null || _b === void 0 ? void 0 : _b.call(this, labelName)) + ", 0)";
        };
        TurnoversVerticalStackedBarChartComponent.prototype.getLegendOptions = function () {
            var _a;
            var opts = {
                scaleType: this.schemeType,
                colors: undefined,
                domain: [],
                title: '',
                position: i1.LegendPosition.Below,
            };
            if (opts.scaleType === i1.ScaleType.Ordinal) {
                opts.domain = this.innerDomain;
                opts.colors = this.colors;
                opts.title = this.legendTitle;
            }
            else {
                opts.domain = this.valueDomain;
                opts.colors = (_a = this.colors) === null || _a === void 0 ? void 0 : _a.scale;
            }
            return opts;
        };
        return TurnoversVerticalStackedBarChartComponent;
    }(TurnoversVerticalBarChartComponent));
    TurnoversVerticalStackedBarChartComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalStackedBarChartComponent, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.NgZone }, { token: i0__namespace.ChangeDetectorRef }, { token: i0.PLATFORM_ID }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TurnoversVerticalStackedBarChartComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversVerticalStackedBarChartComponent, selector: "bb-charts-bar-vertical-stacked", inputs: { xAxisTicks: "xAxisTicks", yAxisTicks: "yAxisTicks" }, usesInheritance: true, ngImport: i0__namespace, template: "<ngx-charts-chart\n  [view]=\"[width, height]\"\n  [showLegend]=\"legend\"\n  [legendOptions]=\"legendOptions\"\n  [activeEntries]=\"activeEntries\"\n  [animations]=\"animations\"\n  (legendLabelActivate)=\"onActivate($event)\"\n  (legendLabelDeactivate)=\"onDeactivate($event)\"\n  (legendLabelClick)=\"onClick($event)\">\n  <svg:g [attr.transform]=\"transform\" class=\"bar-chart chart\">\n    <svg:g bb-charts-grid-panel-series\n      [xScale]=\"xScale\"\n      [yScale]=\"yScale\"\n      [data]=\"groupsData\"\n      [dims]=\"dims\"\n    >\n    </svg:g>\n    <svg:g ngx-charts-x-axis\n      *ngIf=\"xAxis\"\n      [xScale]=\"xScale\"\n      [dims]=\"dims\"\n      [showLabel]=\"showXAxisLabel\"\n      [labelText]=\"xAxisLabel\"\n      [tickFormatting]=\"xAxisTickFormatting\"\n      [ticks]=\"xAxisTicks\"\n      [xAxisOffset]=\"dataLabelMaxHeight.negative\"\n      (dimensionsChanged)=\"updateXAxisHeight($event)\">\n    </svg:g>\n    <svg:g ngx-charts-y-axis\n      *ngIf=\"yAxis\"\n      [yScale]=\"yScale\"\n      [dims]=\"dims\"\n      [showGridLines]=\"showGridLines\"\n      [showLabel]=\"showYAxisLabel\"\n      [labelText]=\"yAxisLabel\"\n      [tickFormatting]=\"yAxisTickFormatting\"\n      [ticks]=\"yAxisTicks\"\n      (dimensionsChanged)=\"updateYAxisWidth($event)\">\n    </svg:g>\n    <svg:g bb-charts-series-vertical\n      *ngFor=\"let group of results; let index = index; trackBy:trackBy\"\n      [@animationState]=\"'active'\"\n      [attr.transform]=\"groupTransform(group)\"\n      [attr.opacity]=\"(group.badge ? 0.5 : 1)\"\n      [type]=\"'stacked'\"\n      [xScale]=\"xScale\"\n      [yScale]=\"yScale\"\n      [activeEntries]=\"activeEntries\"\n      [colors]=\"colors\"\n      [series]=\"group.series\"\n      [dims]=\"dims\"\n      [roundEdges]=\"roundEdges\"\n      [gradient]=\"gradient\"\n      [tooltipDisabled]=\"tooltipDisabled\"\n      [tooltipTemplate]=\"tooltipTemplate\"\n      [showDataLabel]=\"showDataLabel\"\n      [dataLabelFormatting]=\"dataLabelFormatting\"\n      [seriesName]=\"group.name\"\n      [animations]=\"animations\"\n      (select)=\"onClick($event, group)\"\n      (activate)=\"onActivate($event, group)\"\n      (deactivate)=\"onDeactivate($event, group)\"\n      (dataLabelHeightChanged)=\"onDataLabelMaxHeightChanged($event, index)\"\n    />\n  </svg:g>\n</ngx-charts-chart>\n\n<ng-container\n  [ngTemplateOutlet]=\"legendTemplate\"\n  [ngTemplateOutletContext]=\"{\n    legendOptions: this.legendOptions,\n    activeEntries: this.activeEntries,\n    height: this.height,\n    onActivate: this.onActivate.bind(this),\n    onDeactivate: this.onDeactivate.bind(this),\n    onClick: this.onClick.bind(this)\n  }\"\n></ng-container>\n", styles: [".ngx-charts{float:left;overflow:visible}.ngx-charts .circle,.ngx-charts .bar,.ngx-charts .arc{cursor:pointer}.ngx-charts .bar.active,.ngx-charts .bar:hover,.ngx-charts .cell.active,.ngx-charts .cell:hover,.ngx-charts .arc.active,.ngx-charts .arc:hover,.ngx-charts .card.active,.ngx-charts .card:hover{opacity:.8;transition:opacity .1s ease-in-out}.ngx-charts .bar:focus,.ngx-charts .cell:focus,.ngx-charts .arc:focus,.ngx-charts .card:focus{outline:none}.ngx-charts .bar.hidden,.ngx-charts .cell.hidden,.ngx-charts .arc.hidden,.ngx-charts .card.hidden{display:none}.ngx-charts g:focus{outline:none}.ngx-charts .line-series.inactive,.ngx-charts .line-series-range.inactive,.ngx-charts .polar-series-path.inactive,.ngx-charts .polar-series-area.inactive,.ngx-charts .area-series.inactive{transition:opacity .1s ease-in-out;opacity:.2}.ngx-charts .line-highlight{display:none}.ngx-charts .line-highlight.active{display:block}.ngx-charts .area{opacity:.6}.ngx-charts .circle:hover{cursor:pointer}.ngx-charts .label{font-size:12px;font-weight:normal}.ngx-charts .tooltip-anchor{fill:#000}.ngx-charts .gridline-path{stroke:#ddd;stroke-width:1;fill:none}.ngx-charts .refline-path{stroke:#a8b2c7;stroke-width:1;stroke-dasharray:5;stroke-dashoffset:5}.ngx-charts .refline-label{font-size:9px}.ngx-charts .reference-area{fill-opacity:.05;fill:#000}.ngx-charts .gridline-path-dotted{stroke:#ddd;stroke-width:1;fill:none;stroke-dasharray:1,20;stroke-dashoffset:3}.ngx-charts .grid-panel rect{fill:none}.ngx-charts .grid-panel.odd rect{fill:#0000000d}.gridline-path{stroke:#ccc}ngx-charts-legend{display:block;margin-top:1rem}\n"], components: [{ type: i1__namespace.ChartComponent, selector: "ngx-charts-chart", inputs: ["showLegend", "animations", "legendType", "view", "legendOptions", "activeEntries"], outputs: ["legendLabelClick", "legendLabelActivate", "legendLabelDeactivate"] }, { type: BbGridPanelSeriesComponent, selector: "g[bb-charts-grid-panel-series]", inputs: ["data", "dims", "xScale", "yScale"] }, { type: i1__namespace.XAxisComponent, selector: "g[ngx-charts-x-axis]", inputs: ["rotateTicks", "showGridLines", "xOrient", "xAxisOffset", "xScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "showLabel", "labelText", "ticks", "xAxisTickCount"], outputs: ["dimensionsChanged"] }, { type: i1__namespace.YAxisComponent, selector: "g[ngx-charts-y-axis]", inputs: ["showGridLines", "yOrient", "yAxisOffset", "yScale", "dims", "trimTicks", "maxTickLength", "tickFormatting", "ticks", "showLabel", "labelText", "yAxisTickCount", "referenceLines", "showRefLines", "showRefLabels"], outputs: ["dimensionsChanged"] }, { type: BbSeriesVerticalComponent, selector: "g[bb-charts-series-vertical]", inputs: ["dims", "type", "series", "xScale", "yScale", "colors", "gradient", "activeEntries", "seriesName", "tooltipDisabled", "tooltipShowCaret", "tooltipTemplate", "roundEdges", "animations", "showDataLabel", "dataLabelFormatting", "groupData"], outputs: ["select", "activate", "deactivate", "dataLabelHeightChanged"] }], directives: [{ type: i1__namespace$1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1__namespace$1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1__namespace$1.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [
            animations.trigger('animationState', [
                animations.transition(':leave', [
                    animations.style({
                        opacity: 1,
                        transform: '*',
                    }),
                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' })),
                ]),
            ]),
        ], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush, encapsulation: i0__namespace.ViewEncapsulation.None });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversVerticalStackedBarChartComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-charts-bar-vertical-stacked',
                        templateUrl: './turnovers-vertical-stacked-bar-chart.component.html',
                        styleUrls: ['turnovers-vertical-stacked-bar-chart.component.scss'],
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('animationState', [
                                animations.transition(':leave', [
                                    animations.style({
                                        opacity: 1,
                                        transform: '*',
                                    }),
                                    animations.animate(500, animations.style({ opacity: 0, transform: 'scale(0)' })),
                                ]),
                            ]),
                        ],
                    }]
            }], ctorParameters: function () {
            return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.NgZone }, { type: i0__namespace.ChangeDetectorRef }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [i0.PLATFORM_ID]
                        }] }];
        }, propDecorators: { xAxisTicks: [{
                    type: i0.Input
                }], yAxisTicks: [{
                    type: i0.Input
                }] } });

    var getMessageFromResponse = function (error) {
        var responseBody = error.error;
        if (responseBody && responseBody.errors && responseBody.errors[0] && responseBody.errors[0].message) {
            return responseBody.errors[0].message;
        }
        else {
            return undefined;
        }
    };
    var parseError = function (error) {
        // TODO: should have more user-friendly messages
        if (error.error instanceof ErrorEvent) {
            // Client-side or network error.
            return {
                message: 'An unexpected error occurred',
            };
        }
        else {
            // Backend returns unsuccessful response code.  In case of 400, try to get a message from the
            // response.
            switch (error.status) {
                case 400:
                    return {
                        message: getMessageFromResponse(error) || 'Error 400',
                    };
                case 401:
                    return {
                        message: 'Error 401',
                    };
                case 403:
                    return {
                        message: 'Error 403',
                    };
                case 404:
                    return {
                        message: 'Error 404',
                    };
                default:
                    return {
                        message: 'An unexpected error occurred',
                    };
            }
        }
    };

    var TurnoversWidgetHelpersService = /** @class */ (function () {
        function TurnoversWidgetHelpersService(datePipe) {
            var _this = this;
            this.datePipe = datePipe;
            this.extendTurnoverItem = function (barData) { return (Object.assign(Object.assign({}, barData), { intervalStartDate: _this.datePipe.transform(barData.intervalStartDate.slice(0, 10), 'MMM') || '' })); };
        }
        TurnoversWidgetHelpersService.prototype.getChartData = function (turnovers, labels) {
            return (turnovers || []).map(function (barData) {
                return {
                    series: [
                        {
                            name: labels.income,
                            value: Number(barData.creditAmount.amount),
                            currency: barData.creditAmount.currencyCode,
                        },
                        {
                            name: labels.spending,
                            value: Number(barData.debitAmount.amount),
                            currency: barData.debitAmount.currencyCode,
                        },
                    ],
                    currency: barData.balance.currencyCode,
                    diff: Number(barData.balance.amount),
                    badge: barData.forecast ? labels.forecast : '',
                    name: barData.intervalStartDate.slice(0, 10) + (barData.forecast ? ' ' : ''),
                };
            });
        };
        TurnoversWidgetHelpersService.prototype.periodToDate = function (period) {
            var date = new Date();
            // current date already covers one period
            var intervalCount = period.duration;
            switch (period.interval) {
                case 'DAY':
                    date.setDate(date.getDate() - intervalCount);
                    break;
                case 'WEEK':
                    date.setDate(date.getDate() - intervalCount * 7);
                    break;
                case 'YEAR':
                    date.setFullYear(date.getFullYear() - intervalCount);
                    break;
                case 'MONTH':
                default:
                    date.setMonth(date.getMonth() - (intervalCount - 1));
                    date.setDate(DEFAULT_START_DAY);
                    break;
            }
            return date.toISOString().slice(0, 10);
        };
        return TurnoversWidgetHelpersService;
    }());
    TurnoversWidgetHelpersService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetHelpersService, deps: [{ token: i1__namespace$1.DatePipe }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TurnoversWidgetHelpersService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetHelpersService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetHelpersService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$1.DatePipe }]; } });

    var TurnoversService = /** @class */ (function () {
        function TurnoversService(turnoversDataHttpService) {
            this.turnoversDataHttpService = turnoversDataHttpService;
        }
        TurnoversService.prototype.loadAnalysisData = function (params) {
            return this.turnoversDataHttpService.getTurnovers(params).pipe(operators.map(function (body) {
                return {
                    turnovers: body.turnovers || [],
                    forecast: (body.forecast || []).map(function (item) { return (Object.assign(Object.assign({}, item), { forecast: true })); }),
                };
            }), operators.map(function (body) {
                return (body.turnovers || []).concat(params.forecast && body.forecast ? body.forecast : []);
            }));
        };
        return TurnoversService;
    }());
    TurnoversService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversService, deps: [{ token: i1__namespace$3.TurnoversHttpService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    TurnoversService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$3.TurnoversHttpService }]; } });

    var TurnoversComponent = /** @class */ (function () {
        function TurnoversComponent(service, route, helpers) {
            var _this = this;
            this.service = service;
            this.route = route;
            this.helpers = helpers;
            /**
             * Disable/enable the forecast option on the chart.
             */
            this.forecast = false;
            this.hostRef = this;
            this.selectedTab = PERIODS[Math.max(PERIODS.map(function (item) { return item.default; }).indexOf(true), 0)];
            this.isLoading = new rxjs.BehaviorSubject(false);
            this.initialDateParams = {
                periodStartDate: this.helpers.periodToDate(PERIODS[0]),
                periodEndDate: new Date().toISOString().slice(0, 10),
                intervalDuration: DEFAULT_INTERVAL,
                intervalStartDay: DEFAULT_START_DAY,
            };
            this.arrangementIds = this.getRouteParam(this.route, 'selectedAccount').pipe(operators.map(function (selectedAccount) { return (selectedAccount ? [selectedAccount] : []); }));
            this.dateParams = new rxjs.BehaviorSubject(this.initialDateParams);
            this.chartSeriesData = rxjs.combineLatest(this.arrangementIds, this.dateParams.asObservable()).pipe(operators.tap(function () { return (_this.error = undefined); }), operators.filter(function (_a) {
                var _b = __read(_a, 1), selectedAccounts = _b[0];
                return !!selectedAccounts.length;
            }), operators.map(function (_a) {
                var _b = __read(_a, 2), selectedAccounts = _b[0], dateParams = _b[1];
                return (Object.assign(Object.assign({ arrangementIds: selectedAccounts }, dateParams), { forecast: _this.forecast ? 'AVG' : undefined }));
            }), operators.switchMap(function (params) {
                _this.isLoading.next(true);
                var data = _this.service.loadAnalysisData(params);
                data.subscribe({ complete: function () { return _this.isLoading.next(false); } });
                return data;
            }), operators.map(function (items) { return items.map(_this.helpers.extendTurnoverItem); }), operators.map(function (items) { return _this.helpers.getChartData(items, _this.labels); }), operators.catchError(function (error) {
                _this.handleError(error);
                return rxjs.of([]);
            }));
            this.handleError = function (error) {
                _this.error = parseError(error);
                return rxjs.of([]);
            };
        }
        Object.defineProperty(TurnoversComponent.prototype, "labels", {
            get: function () {
                return {
                    income: this.incomeRef.nativeElement.textContent,
                    spending: this.spendingRef.nativeElement.textContent,
                    forecast: this.forecastRef.nativeElement.textContent,
                };
            },
            enumerable: false,
            configurable: true
        });
        TurnoversComponent.prototype.getRouteParam = function (route, param) {
            var paramValue = route.paramMap.pipe(operators.pluck('params', param));
            if (!route.parent) {
                return paramValue;
            }
            // ensure that level that has actual value keeps it from being cleared
            return rxjs.combineLatest(paramValue, this.getRouteParam(route.parent, param)).pipe(operators.map(function (params) { return params[0] || params[1]; }));
        };
        TurnoversComponent.prototype.onTabChange = function (num) {
            this.selectedTab = PERIODS[Math.max(PERIODS.map(function (item) { return item.duration; }).indexOf(num), 0)];
            this.dateParams.next(Object.assign(Object.assign({}, this.initialDateParams), { periodStartDate: this.helpers.periodToDate(this.selectedTab), periodEndDate: new Date().toISOString().slice(0, 10) }));
        };
        return TurnoversComponent;
    }());
    TurnoversComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversComponent, deps: [{ token: TurnoversService }, { token: i2__namespace$1.ActivatedRoute }, { token: TurnoversWidgetHelpersService }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TurnoversComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversComponent, selector: "bb-turnovers", inputs: { forecast: "forecast" }, providers: [TurnoversService, i1$1.DatePipe, TurnoversWidgetHelpersService], viewQueries: [{ propertyName: "incomeRef", first: true, predicate: ["incomeLabel"], descendants: true, static: true }, { propertyName: "spendingRef", first: true, predicate: ["spendingLabel"], descendants: true, static: true }, { propertyName: "forecastRef", first: true, predicate: ["forecastLabel"], descendants: true, static: true }], ngImport: i0__namespace, template: "<ng-container *ngIf=\"(arrangementIds | async)?.length; else emptyState\">\n  <ng-container *ngIf=\"chartSeriesData | async; let data; else loadingState\">\n    <div *ngIf=\"!error; else errorState\">\n      <div *ngIf=\"data.length; else emptyState\">\n        <ng-container \n          bbTurnoversItemCustomizable \n          [bbHostRef]=\"hostRef\" \n          [bbTemplateContext]=\"data\"\n        ></ng-container>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n\n<ng-template bbTurnoversItemCustomizable let-hostRef let-chartSeriesData=\"context\">\n  <ng-container bbTurnoversControlsCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n  <bb-turnovers-bar-chart\n    *ngIf=\"(isLoading | async) === false; else loadingState\"\n    class=\"bb-turnovers-bar-chart bb-chart\"\n    [chartSeriesData]=\"chartSeriesData\"\n    [forecast]=\"forecast\">\n  </bb-turnovers-bar-chart>\n</ng-template>\n<ng-template bbTurnoversControlsCustomizable let-hostRef>\n  <div class=\"bb-turnovers-controls\">\n    <div class=\"btn-group btn-group-sm\">\n      <button\n        bbButton\n        data-role=\"6-month-btn\"\n        [value]='6'\n        (click)=\"hostRef.onTabChange(6)\"\n        [color]=\"hostRef.selectedTab.duration === 6 ? 'primary' : 'secondary'\"\n        i18n=\"Data period|Six month label@@turnovers.label.duration.month.six\"\n      >\n        6 Months\n      </button>\n      <button\n        bbButton \n        data-role=\"12-month-btn\"\n        [value]='12'\n        (click)=\"hostRef.onTabChange(12)\"\n        [color]=\"hostRef.selectedTab.duration === 12 ? 'primary' : 'secondary'\"\n        i18n=\"Data period|Twelve month label@@turnovers.label.duration.month.twelve\"\n      >\n        12 Months\n      </button>\n    </div>\n  </div>\n</ng-template>\n\n<ng-template #loadingState>\n  <bb-loading-indicator-ui\n    i18n-text=\"Loading turnovers data|Text to display while loading turnovers@@turnovers.state.loadingTurnovers\"\n    text=\"Loading transactions data...\"\n  ></bb-loading-indicator-ui>\n</ng-template>\n\n<ng-template #emptyState>\n  <ng-container bbTurnoversEmptyStateCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n</ng-template>\n\n<ng-template bbTurnoversEmptyStateCustomizable let-hostRef>\n  <ng-container bbTurnoversControlsCustomizable [bbHostRef]=\"hostRef\"></ng-container>\n    <bb-empty-state-ui\n      i18n-title=\"No data title|Title of a message that is shown when there are no turnovers@@turnovers.state.noResultsFound.title\"\n      title=\"No data found\"\n      i18n-subtitle=\"No data subtitle|Subtitle of a message that is shown when there are no turnovers@@turnovers.state.noResultsFound.subtitle\"\n      subtitle=\"You don't have any data to be displayed. Please try selecting a different period.\"\n      iconSize=\"xxl\"\n      iconModifier=\"bar-chart\"\n    ></bb-empty-state-ui>\n</ng-template>\n\n<ng-template #errorState>\n  <bb-empty-state-ui\n    data-role=\"errorState\"\n    title=\"\"\n    [subtitle]=\"error?.message\"\n    iconModifier=\"error\"\n    iconSize=\"xxl\"\n    iconColor=\"gray\"\n    iconClasses=\"text-muted\"\n  ></bb-empty-state-ui>\n</ng-template>\n\n<span #incomeLabel class=\"ng-cloak\" i18n=\"Incoming|Label for income dataset on the chart@@turnovers.chart.income\">Incoming</span>\n<span #spendingLabel class=\"ng-cloak\" i18n=\"Outgoing|Label for spending dataset on the chart@@turnovers.chart.spending\">Outgoing</span>\n<span #forecastLabel class=\"ng-cloak\" i18n=\"forecast|Label for forecast data on the chart@@turnovers.chart.forecast\">Forecast</span>\n", components: [{ type: i0__namespace.forwardRef(function () { return TurnoversBarChartComponent; }), selector: "bb-turnovers-bar-chart", inputs: ["chartSeriesData", "forecast"] }, { type: i0__namespace.forwardRef(function () { return i5__namespace$1.LoadingIndicatorComponent; }), selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i0__namespace.forwardRef(function () { return i6__namespace.EmptyStateComponent; }), selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }], directives: [{ type: i0__namespace.forwardRef(function () { return i1__namespace$1.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0__namespace.forwardRef(function () { return TurnoversItemCustomizableDirective; }), selector: "[bbTurnoversItemCustomizable]" }, { type: i0__namespace.forwardRef(function () { return TurnoversControlsCustomizableDirective; }), selector: "[bbTurnoversControlsCustomizable]" }, { type: i0__namespace.forwardRef(function () { return i8__namespace.ButtonDirective; }), selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i0__namespace.forwardRef(function () { return TurnoversEmptyStateCustomizableDirective; }), selector: "[bbTurnoversEmptyStateCustomizable]" }], pipes: { "async": i0__namespace.forwardRef(function () { return i1__namespace$1.AsyncPipe; }) } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-turnovers',
                        templateUrl: './turnovers.component.html',
                        providers: [TurnoversService, i1$1.DatePipe, TurnoversWidgetHelpersService],
                    }]
            }], ctorParameters: function () { return [{ type: TurnoversService }, { type: i2__namespace$1.ActivatedRoute }, { type: TurnoversWidgetHelpersService }]; }, propDecorators: { forecast: [{
                    type: i0.Input
                }], incomeRef: [{
                    type: i0.ViewChild,
                    args: ['incomeLabel', { static: true }]
                }], spendingRef: [{
                    type: i0.ViewChild,
                    args: ['spendingLabel', { static: true }]
                }], forecastRef: [{
                    type: i0.ViewChild,
                    args: ['forecastLabel', { static: true }]
                }] } });
    var TurnoversItemCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversItemCustomizableDirective, _super);
        function TurnoversItemCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversItemCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversItemCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversItemCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversItemCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversItemCustomizableDirective, selector: "[bbTurnoversItemCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversItemCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversItemCustomizable]',
                    }]
            }] });
    var TurnoversControlsCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversControlsCustomizableDirective, _super);
        function TurnoversControlsCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversControlsCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversControlsCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversControlsCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversControlsCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversControlsCustomizableDirective, selector: "[bbTurnoversControlsCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversControlsCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversControlsCustomizable]',
                    }]
            }] });
    var TurnoversEmptyStateCustomizableDirective = /** @class */ (function (_super) {
        __extends(TurnoversEmptyStateCustomizableDirective, _super);
        function TurnoversEmptyStateCustomizableDirective() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TurnoversEmptyStateCustomizableDirective;
    }(i1$3.BbTemplate));
    TurnoversEmptyStateCustomizableDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversEmptyStateCustomizableDirective, deps: null, target: i0__namespace.ɵɵFactoryTarget.Directive });
    TurnoversEmptyStateCustomizableDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversEmptyStateCustomizableDirective, selector: "[bbTurnoversEmptyStateCustomizable]", usesInheritance: true, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversEmptyStateCustomizableDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[bbTurnoversEmptyStateCustomizable]',
                    }]
            }] });

    var TurnoversWidgetComponent = /** @class */ (function () {
        function TurnoversWidgetComponent(itemModel) {
            this.itemModel = itemModel;
            this.forecast = this.getProperty(PROPERTIES.FORECAST).pipe(operators.map(function (propertyValue) { return propertyValue === true; }));
            this.forecastSubject = new rxjs.BehaviorSubject(true);
            this.forecast$ = filterInputParameters(this.forecastSubject.asObservable(), this.forecast);
        }
        Object.defineProperty(TurnoversWidgetComponent.prototype, "forecastValue", {
            // eslint-disable-next-line
            set: function (value) {
                this.forecastSubject.next(value);
            },
            enumerable: false,
            configurable: true
        });
        TurnoversWidgetComponent.prototype.getProperty = function (property) {
            return this.itemModel ? this.itemModel.property(property.name, property.value) : rxjs.of(property.value);
        };
        return TurnoversWidgetComponent;
    }());
    TurnoversWidgetComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetComponent, deps: [{ token: i1__namespace$4.ItemModel, optional: true }], target: i0__namespace.ɵɵFactoryTarget.Component });
    TurnoversWidgetComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: TurnoversWidgetComponent, selector: "bb-turnovers-widget", inputs: { forecastValue: ["forecast", "forecastValue"] }, ngImport: i0__namespace, template: "<bb-turnovers\n  [forecast]=\"(forecast | async) || undefined\"\n></bb-turnovers>", components: [{ type: TurnoversComponent, selector: "bb-turnovers", inputs: ["forecast"] }], pipes: { "async": i1__namespace$1.AsyncPipe } });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'bb-turnovers-widget',
                        templateUrl: './turnovers-widget.component.html',
                    }]
            }], ctorParameters: function () {
            return [{ type: i1__namespace$4.ItemModel, decorators: [{
                            type: i0.Optional
                        }] }];
        }, propDecorators: { forecastValue: [{
                    type: i0.Input,
                    args: ['forecast']
                }] } });

    var components = [
        TurnoversWidgetComponent,
        TurnoversComponent,
        TurnoversBarChartComponent,
        TurnoversVerticalBarChartComponent,
        TurnoversVerticalStackedBarChartComponent,
        TurnoversVerticalGroupedBarChartComponent,
        BbTurnoversLegendComponent,
        BbSeriesVerticalComponent,
        BbGridPanelSeriesComponent,
    ];
    var customizables = [
        TurnoversItemCustomizableDirective,
        TurnoversControlsCustomizableDirective,
        TurnoversChartTooltipCustomizableDirective,
        TurnoversChartLegendCustomizableDirective,
        TurnoversVerticalStackedBarChartCustomizableDirective,
        TurnoversVerticalGroupedBarChartCustomizableDirective,
        TurnoversEmptyStateCustomizableDirective,
    ];
    var modules = [i5.FormatAmountModule, i5$1.LoadingIndicatorModule, i6.EmptyStateModule, i8.ButtonModule];
    var TurnoversWidgetModule = /** @class */ (function () {
        function TurnoversWidgetModule() {
        }
        return TurnoversWidgetModule;
    }());
    TurnoversWidgetModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    TurnoversWidgetModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetModule, declarations: [TurnoversWidgetComponent,
            TurnoversComponent,
            TurnoversBarChartComponent,
            TurnoversVerticalBarChartComponent,
            TurnoversVerticalStackedBarChartComponent,
            TurnoversVerticalGroupedBarChartComponent,
            BbTurnoversLegendComponent,
            BbSeriesVerticalComponent,
            BbGridPanelSeriesComponent, TurnoversItemCustomizableDirective,
            TurnoversControlsCustomizableDirective,
            TurnoversChartTooltipCustomizableDirective,
            TurnoversChartLegendCustomizableDirective,
            TurnoversVerticalStackedBarChartCustomizableDirective,
            TurnoversVerticalGroupedBarChartCustomizableDirective,
            TurnoversEmptyStateCustomizableDirective], imports: [i1$1.CommonModule, i1__namespace$4.BackbaseCoreModule, i1.NgxChartsModule, i5.FormatAmountModule, i5$1.LoadingIndicatorModule, i6.EmptyStateModule, i8.ButtonModule], exports: [TurnoversWidgetComponent,
            TurnoversComponent,
            TurnoversBarChartComponent,
            TurnoversVerticalBarChartComponent,
            TurnoversVerticalStackedBarChartComponent,
            TurnoversVerticalGroupedBarChartComponent,
            BbTurnoversLegendComponent,
            BbSeriesVerticalComponent,
            BbGridPanelSeriesComponent, TurnoversItemCustomizableDirective,
            TurnoversControlsCustomizableDirective,
            TurnoversChartTooltipCustomizableDirective,
            TurnoversChartLegendCustomizableDirective,
            TurnoversVerticalStackedBarChartCustomizableDirective,
            TurnoversVerticalGroupedBarChartCustomizableDirective,
            TurnoversEmptyStateCustomizableDirective, i5.FormatAmountModule, i5$1.LoadingIndicatorModule, i6.EmptyStateModule, i8.ButtonModule] });
    TurnoversWidgetModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetModule, providers: [i1$1.DatePipe, i1$1.CurrencyPipe], imports: [__spreadArray([
                i1$1.CommonModule,
                i1$3.BackbaseCoreModule.withConfig({
                    classMap: { TurnoversWidgetComponent: TurnoversWidgetComponent },
                }),
                i1.NgxChartsModule
            ], __read(modules)), i5.FormatAmountModule, i5$1.LoadingIndicatorModule, i6.EmptyStateModule, i8.ButtonModule] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: TurnoversWidgetModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: __spreadArray([
                            i1$1.CommonModule,
                            i1$3.BackbaseCoreModule.withConfig({
                                classMap: { TurnoversWidgetComponent: TurnoversWidgetComponent },
                            }),
                            i1.NgxChartsModule
                        ], __read(modules)),
                        providers: [i1$1.DatePipe, i1$1.CurrencyPipe],
                        entryComponents: [TurnoversComponent],
                        declarations: __spreadArray(__spreadArray([], __read(components)), __read(customizables)),
                        exports: __spreadArray(__spreadArray(__spreadArray([], __read(components)), __read(customizables)), __read(modules)),
                    }]
            }] });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.BbGridPanelSeriesComponent = BbGridPanelSeriesComponent;
    exports.BbSeriesVerticalComponent = BbSeriesVerticalComponent;
    exports.BbTurnoversLegendComponent = BbTurnoversLegendComponent;
    exports.TurnoversBarChartComponent = TurnoversBarChartComponent;
    exports.TurnoversChartLegendCustomizableDirective = TurnoversChartLegendCustomizableDirective;
    exports.TurnoversChartTooltipCustomizableDirective = TurnoversChartTooltipCustomizableDirective;
    exports.TurnoversComponent = TurnoversComponent;
    exports.TurnoversControlsCustomizableDirective = TurnoversControlsCustomizableDirective;
    exports.TurnoversEmptyStateCustomizableDirective = TurnoversEmptyStateCustomizableDirective;
    exports.TurnoversItemCustomizableDirective = TurnoversItemCustomizableDirective;
    exports.TurnoversVerticalBarChartComponent = TurnoversVerticalBarChartComponent;
    exports.TurnoversVerticalGroupedBarChartComponent = TurnoversVerticalGroupedBarChartComponent;
    exports.TurnoversVerticalGroupedBarChartCustomizableDirective = TurnoversVerticalGroupedBarChartCustomizableDirective;
    exports.TurnoversVerticalStackedBarChartComponent = TurnoversVerticalStackedBarChartComponent;
    exports.TurnoversVerticalStackedBarChartCustomizableDirective = TurnoversVerticalStackedBarChartCustomizableDirective;
    exports.TurnoversWidgetComponent = TurnoversWidgetComponent;
    exports.TurnoversWidgetModule = TurnoversWidgetModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=backbase-turnovers-widget-ang.umd.js.map
