import { __rest } from "tslib";
import { Injectable } from '@angular/core';
import { ContactsHttpService } from '@backbase/data-ang/contact-manager';
import { BehaviorSubject, combineLatest, merge, of, ReplaySubject, Subject } from 'rxjs';
import { catchError, distinctUntilChanged, map, mapTo, scan, shareReplay, switchMap } from 'rxjs/operators';
import { ContactActions, LoadMoreMethod, } from '@backbase/contact-common-ang';
import { AccountCreateType } from '../models/types';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/contact-manager";
export var ModalOptions;
(function (ModalOptions) {
    ModalOptions[ModalOptions["Cancel"] = 0] = "Cancel";
    ModalOptions[ModalOptions["Success"] = 1] = "Success";
})(ModalOptions || (ModalOptions = {}));
const defaultListParams = {
    pagination: {
        from: 0,
        size: 4,
        query: '',
    },
    paginationType: LoadMoreMethod.PAGINATION,
};
/**
 *
 * This service calls the api calls from data-ang
 *
 * @see ContactManagerWidgetModule
 * @usageNotes
 *
 * ### Ensure the ContactManagerWidgetModule is imported to your component module
 *
 * ```ts
 * @NgModule({
 *   ...
 *   imports: [
 *     ...
 *     ContactManagerWidgetModule,
 *   ],
 * })
 * export class ContactManagerWidgetModule {}
 * ```
 *
 * ### Inject this service into your provider
 *
 * ```ts
 * @Component({
 *   ...
 *   providers: [ContactsService]
 * })
 *  export class ContactManagerWidgetModule {
 * ```
 */
export class ContactsService {
    constructor(dataService) {
        this.dataService = dataService;
        // "Events" - Subjects that are used to trigger actions
        this.saveComplete = new Subject();
        this.listParams = new BehaviorSubject(defaultListParams);
        this.selectedItemId = new ReplaySubject(1);
        this.lastSelectedItemId = new BehaviorSubject(undefined);
        this.actions$ = merge(this.listParams.pipe(map(({ pagination, paginationType, method }) => ({
            action: ContactActions.Load,
            params: pagination,
            paginationType,
            method: method,
        }))), this.saveComplete.pipe(mapTo({ action: ContactActions.Refresh })));
        // The params to use for a list request
        this.items = this.actions$.pipe(scan((state, action) => (Object.assign(Object.assign({}, state), action))), map(({ action, params, paginationType, method }) => {
            const isLoadMoreRefresh = action === ContactActions.Refresh && paginationType === LoadMoreMethod.LOAD_MORE;
            return {
                action,
                paginationType,
                params: Object.assign(Object.assign({}, params), (isLoadMoreRefresh ? { from: 0, size: (params.from + 1) * params.size } : {})),
                method,
            };
        }), switchMap((_a) => {
            var { params, method } = _a, state = __rest(_a, ["params", "method"]);
            return this.dataService.getContacts(this.toHttpParams(params), 'response').pipe(map(listFromData), map((response) => (Object.assign(Object.assign(Object.assign(Object.assign({}, response), { params }), state), { method }))));
        }), scan((acc, curr) => {
            const { count, action, paginationType, method } = curr;
            let contacts;
            if (curr.params.from > 0 &&
                acc.params.query === curr.params.query &&
                action !== ContactActions.Refresh &&
                paginationType === LoadMoreMethod.LOAD_MORE &&
                method !== 'search') {
                contacts = [...acc.contacts, ...curr.contacts];
            }
            else {
                contacts = [...curr.contacts];
            }
            return {
                count,
                contacts,
                params: curr.params,
            };
        }), shareReplay());
        this.currentlySelectedItemId = combineLatest([
            this.selectedItemId,
            this.lastSelectedItemId,
            this.items,
        ]).pipe(map(([id, lastItemId, items]) => {
            var _a, _b, _c;
            return (_c = (_a = id !== null && id !== void 0 ? id : lastItemId) !== null && _a !== void 0 ? _a : (_b = items.contacts[0]) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : null;
        }));
        this.item = combineLatest([
            this.currentlySelectedItemId.pipe(distinctUntilChanged()),
            this.items,
        ]).pipe(switchMap(([id, items]) => {
            var _a;
            if (id === '0') {
                return of(undefined);
            }
            let contact = this.getContactsItem((_a = id !== null && id !== void 0 ? id : this.lastSelectedItemId.value) !== null && _a !== void 0 ? _a : undefined, items);
            const firstContact = this.getContactsItem(this.firstContact(items.contacts), items);
            if (!contact && this.lastSelectedItemId.value) {
                const contactId = this.lastSelectedItemId.value;
                return this.dataService.getContact({ contactId }).pipe(catchError(() => of(firstContact)));
            }
            if (contact) {
                this.lastSelectedItemId.next(contact.id);
            }
            return of(contact || firstContact);
        }), shareReplay());
        this.deleteSuccess = new Subject();
        this.deleteError = new Subject();
    }
    /**
     * Updates the selected contact.
     *
     * @param {Observable<ItemId | null>} ids contact Id
     */
    getItemFrom(ids) {
        ids.subscribe((id) => this.selectedItemId.next(id));
    }
    firstContact(contacts) {
        return contacts && contacts.length > 0 ? contacts[0].id : undefined;
    }
    /**
     * Gets the contact in the given list by id.
     *
     * @param {string | undefined} id contact ID
     * @param {ContactList} items all contacts in an array form.
     * @returns {ContactItem | undefined} contact item from list or undefined
     */
    getContactsItem(id, items) {
        if (!(items && items.contacts && items.contacts.length))
            return;
        let item;
        if (id === '0') {
            return undefined;
        }
        else {
            item = items.contacts.find((v) => v.id === id);
        }
        return item;
    }
    toHttpParams(params) {
        return {
            from: Math.floor(params.from),
            size: Math.floor(params.size),
            query: params.query || undefined,
        };
    }
    /**
     * Update the list of Parameters when changed.
     *
     * @param {?string} query search query
     * @param {?number} page current Page of contact lists
     * @param {?number} size no of records to be shown on one page
     * @param {?string} paginationType type of pagination `load-more` or `pagination`
     * @param {?string} method enumerated value
     */
    updateItemList(query, page, size, paginationType, method) {
        this.listParams.next({
            pagination: {
                query: query || '',
                from: page || 0,
                size: size || 5,
            },
            paginationType: paginationType || LoadMoreMethod.PAGINATION,
            method,
        });
    }
    /**
     * Gets the account Type for the contacts.
     *
     * @returns {Observable<string>} Observable of a string with accountType
     */
    getAccountType() {
        return this.item.pipe(map((contactItem) => (contactItem ? this.checkaccountType(contactItem) : AccountCreateType.IBAN)));
    }
    /**
     * Calls the update API for contacts when updated.
     *
     * @param {ContactItem} item - Updated contact.
     * @returns {Observable<string | undefined>} the observable of updated ID of contact.
     */
    save(item) {
        if (isNew(item)) {
            const postItem = item;
            return this.dataService
                .postContacts({ contactsPostRequestBody: postItem }, 'response')
                .pipe(map((res) => this.saveSuccess(res)));
        }
        else {
            return this.dataService
                .putContact({ contactId: item.id, contactPutRequestBody: item }, 'response')
                .pipe(map((res) => this.editSuccess(res, item.id)));
        }
    }
    /**
     * Returns the contact Id when updated.
     *
     * @param {HttpResponse<Id>} res save response
     * @returns {string | undefined} contact ID.
     */
    saveSuccess(res) {
        if (res.body && res.body.id) {
            this.saveComplete.next();
            return res.body.id;
        }
        else {
            // error state
            return undefined;
        }
    }
    /**
     * Returns the ID of the contact when edit is successful
     *
     * @param {HttpResponse<ContactUpdateDeleteResponse>} res response of editing a contact.
     * @param {string} id Contact ID.
     * @returns {string | undefined} the ID of contact when edit is successful.
     */
    editSuccess(res, id) {
        if (res.body) {
            this.saveComplete.next();
            return id;
        }
        else {
            // error state
            return undefined;
        }
    }
    /**
     * Calls the deletion API.
     *
     * @param {string} contactId - Contact ID for selected contact.
     * @returns {Subscription} Subscription of deletion api.
     */
    delete(contactId) {
        return this.dataService.deleteContact({ contactId }).subscribe(() => {
            this.deleteSuccess.next();
            this.saveComplete.next();
        }, (error) => this.deleteError.next(error));
    }
    /**
     * Returns the account Type for the given contact
     *
     * @param {ContactItem} item contact object.
     * @returns {string} type of account for one contact.
     */
    checkaccountType(item) {
        if (item) {
            return ((Object.entries(item === null || item === void 0 ? void 0 : item.accounts[0]).find(([key, value]) => Object.values(AccountCreateType).includes(key) && value) || [])[0] || AccountCreateType.IBAN);
        }
        return AccountCreateType.IBAN;
    }
}
/** @nocollapse */ ContactsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ContactsService, deps: [{ token: i1.ContactsHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ContactsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ContactsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ContactsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.ContactsHttpService }]; } });
/**
 * Returns if the contact is new or is being edited.
 *
 * @param {ContactItem} item contact object
 * @returns {boolean} whether the item is new or existing
 */
function isNew(item) {
    return item.id === undefined || item.id === '';
}
/**
 * Returns the contact list in a format.
 *
 * @param {HttpResponse<Contacts>} response http response with data
 * @returns {ContactList} contacts list with total count.
 */
function listFromData(response) {
    if (response.body === null) {
        throw new Error('Response body not set');
    }
    const headers = response.headers;
    const totalCount = headers.get('X-Total-Count');
    return {
        count: totalCount ? +totalCount : null,
        contacts: response.body,
    };
}
//# sourceMappingURL=contacts.service.js.map