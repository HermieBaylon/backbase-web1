import { Injectable } from '@angular/core';
import { combineLatest, forkJoin } from 'rxjs';
import { map } from 'rxjs/operators';
import { LimitsHttpService, } from '@backbase/data-ang/limits';
import { prepareLimitObj } from '../../helpers/limits-helpers';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/limits";
export class LimitsService {
    constructor(limitsService) {
        this.limitsService = limitsService;
        this.getLimitsPeriods$ = this.limitsService.getSupportedPeriods();
    }
    getLimitsConsumptionsRecord(currentLimitsConsumptionsRetrievalPostRequestBody) {
        return this.limitsService.postCurrentLimitsConsumptionsRetrieval({
            currentLimitsConsumptionsRetrievalPostRequestBody,
        });
    }
    getLimitsRetrievalRecord(limitsRetrievalPostRequestBody) {
        return this.limitsService.postLimitsRetrieval({
            limitsRetrievalPostRequestBody,
        });
    }
    createNewLimit(createLimitRequestBody) {
        return this.limitsService.postLimits({
            createLimitRequestBody,
        });
    }
    updateLimit(uuid, updateLimitRequestBody) {
        return this.limitsService.putLimitByUuid({
            uuid,
            updateLimitRequestBody,
        });
    }
    /**
     * Return grouped object by type of response
     * @param data: any - object for grouping
     * @param groupByEref: string - type of gentry point
     * @param dataType: string - type of grouped data
     */
    groupedFunc(data, groupByEref, dataType) {
        switch (dataType) {
            case 'consumption':
                return data.reduce((h, obj) => Object.assign(h, {
                    [this.getUniqueKeyConsumption(groupByEref, obj)]: (h[this.getUniqueKeyConsumption(groupByEref, obj)] || []).concat(obj),
                }), {});
            case 'lookUp':
                return data.reduce((h, obj) => Object.assign(h, {
                    [this.getUniqueKeyLookUpKey(groupByEref, obj)]: (h[this.getUniqueKeyLookUpKey(groupByEref, obj)] || []).concat(obj),
                }), {});
            default:
                return data.reduce((h, obj) => Object.assign(h, {
                    [this.getUniqueKeyRetrival(groupByEref, obj)]: (h[this.getUniqueKeyRetrival(groupByEref, obj)] || []).concat(obj),
                }), {});
        }
    }
    /**
     * Return unique key for grouping consumption limit response
     * @param type: string - type of entry point
     * @param obj: any - response object for consumption limit
     */
    getUniqueKeyConsumption(type, obj) {
        switch (type) {
            case 'user':
                return obj.limit['user-BBID'];
            case 'perm':
                let unitPermKey = '';
                if (obj.limit.entities) {
                    for (let i = 0; i < obj.limit.entities.length; i++) {
                        if (obj.limit.entities[i].etype === 'PRV' || obj.limit.entities[i].etype === 'FUN') {
                            unitPermKey = unitPermKey + obj.limit.entities[i].eref;
                        }
                    }
                }
                return unitPermKey;
            case 'func':
                let unitFuncKey = '';
                if (obj.limit.entities) {
                    for (let i = 0; i < obj.limit.entities.length; i++) {
                        if (obj.limit.entities[i].etype === 'PRV' ||
                            obj.limit.entities[i].etype === 'FUN' ||
                            obj.limit.entities[i].etype === 'FAG') {
                            unitFuncKey = unitFuncKey + obj.limit.entities[i].eref;
                        }
                    }
                }
                return unitFuncKey;
            default:
                return obj.limit.entities[0].eref;
        }
    }
    /**
     * Return unique key for grouping lookUp key from request
     * @param type: string - type of entry point
     * @param obj: any - lookUp key from request
     */
    getUniqueKeyLookUpKey(type, obj) {
        switch (type) {
            case 'user':
                return obj['user-BBID'];
            case 'perm':
                let unitPermKey = '';
                for (let i = 0; i < obj.lookupKeys.length; i++) {
                    if (obj.lookupKeys[i].etype === 'PRV' || obj.lookupKeys[i].etype === 'FUN') {
                        unitPermKey = unitPermKey + obj.lookupKeys[i].eref;
                    }
                }
                return unitPermKey;
            case 'func':
                let unitFuncKey = '';
                for (let i = 0; i < obj.lookupKeys.length; i++) {
                    if (obj.lookupKeys[i].etype === 'PRV' ||
                        obj.lookupKeys[i].etype === 'FUN' ||
                        obj.lookupKeys[i].etype === 'FAG') {
                        unitFuncKey = unitFuncKey + obj.lookupKeys[i].eref;
                    }
                }
                return unitFuncKey;
            default:
                return obj.lookupKeys[0].eref;
        }
    }
    /**
     * Return unique key for grouping retrival limit response
     * @param type: string - type of entry point
     * @param obj: any - response object for retrival limit
     */
    getUniqueKeyRetrival(type, obj) {
        switch (type) {
            case 'user':
                return obj['user-BBID'];
            case 'perm':
                let unitPermKey = '';
                for (let i = 0; i < obj.entities.length; i++) {
                    if (obj.entities[i].etype === 'PRV' || obj.entities[i].etype === 'FUN') {
                        unitPermKey = unitPermKey + obj.entities[i].eref;
                    }
                }
                return unitPermKey;
            case 'func':
                let unitFuncKey = '';
                for (let i = 0; i < obj.entities.length; i++) {
                    if (obj.entities[i].etype === 'PRV' || obj.entities[i].etype === 'FUN' || obj.entities[i].etype === 'FAG') {
                        unitFuncKey = unitFuncKey + obj.entities[i].eref;
                    }
                }
                return unitFuncKey;
            default:
                return obj.entities[0].eref;
        }
    }
    /**
     * Return stream of limitsData
     * @param limitsRetrievalOptions
     * @param groupByEref
     * @param itemsPerRequest - number of items per request (by default 100)
     */
    getLimitsData(limitsRetrievalOptions, groupByEref = '', itemsPerRequest = 100) {
        if (limitsRetrievalOptions.length > itemsPerRequest) {
            const limitsRetrievalOptionsArray = this.chunk(limitsRetrievalOptions, itemsPerRequest || 0);
            return forkJoin(limitsRetrievalOptionsArray.map(limitsRetrievalOption => this._getLimitsData(limitsRetrievalOption, groupByEref))).pipe(map(limitsDataChunks => {
                const limitsData = {};
                limitsDataChunks.map(limitsDataChunk => Object.assign(limitsData, limitsDataChunk));
                return limitsData;
            }));
        }
        return this._getLimitsData(limitsRetrievalOptions, groupByEref);
    }
    _getLimitsData(limitsRetrievalOptions, groupByEref = '') {
        return combineLatest([
            this.getLimitsPeriods$,
            this.getLimitsRetrievalRecord({ limitsRetrievalOptions: limitsRetrievalOptions }),
            this.getLimitsConsumptionsRecord({ limitsRetrievalOptions: limitsRetrievalOptions }),
        ]).pipe(map(([periods, limitRetrievalsData, limitConsumptionsData]) => {
            const limitData = {};
            const groupedLimit = this.groupedFunc(limitConsumptionsData, groupByEref, 'consumption');
            const groupedRetrivalLimit = this.groupedFunc(limitRetrievalsData, groupByEref, '');
            const groupedLookUpKey = this.groupedFunc(limitsRetrievalOptions, groupByEref, 'lookUp');
            for (const key in groupedLookUpKey) {
                if (groupedLookUpKey.hasOwnProperty(key)) {
                    limitData[key] = prepareLimitObj(groupedLimit[key], periods, groupedRetrivalLimit[key]);
                }
            }
            return limitData;
        }));
    }
    /**
     * Util function to divide array into array of arrays of given size
     * @param arr - original array
     * @param len - small arrays length
     */
    chunk(arr, len) {
        const chunks = [];
        const n = arr.length;
        let i = 0;
        while (i < n) {
            chunks.push(arr.slice(i, (i += len)));
        }
        return chunks;
    }
}
/** @nocollapse */ LimitsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LimitsService, deps: [{ token: i1.LimitsHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ LimitsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LimitsService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: LimitsService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.LimitsHttpService }]; } });
//# sourceMappingURL=limits.service.js.map