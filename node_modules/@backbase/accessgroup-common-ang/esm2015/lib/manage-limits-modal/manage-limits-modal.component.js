import { Component, Directive, EventEmitter, Input, Output, ViewChild, } from '@angular/core';
import { FormControl } from '@angular/forms';
import { forkJoin, Subject, of, BehaviorSubject } from 'rxjs';
import { finalize, takeUntil, catchError, distinctUntilChanged } from 'rxjs/operators';
import { BbTemplate } from '@backbase/foundation-ang/core';
import { NotificationService } from '@backbase/ui-ang/notification';
import { AMOUNT_DELIMETER_REG_EXP } from '../constants/amount-delimeter-remover';
import { LimitsService } from './services/limits.service';
import { PERIODIC_LIMITS_BOUNDS, TRANSACTIONAL_LIMITS_BOUNDS } from './models/limits-bound-types.model';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/ui-ang/notification";
import * as i2 from "./services/limits.service";
import * as i3 from "@backbase/ui-ang/modal";
import * as i4 from "./manage-limits-modal-header/manage-limits-modal-header.component";
import * as i5 from "./manage-limits-modal-view-body/manage-limits-modal-view-body.component";
import * as i6 from "./edit-limit/edit-limit.component";
import * as i7 from "@angular/common";
const PENDING_APPROVAL_STATUS = 'PENDING';
export class ManageLimitsModalComponent {
    constructor(notificationService, limitsService) {
        this.notificationService = notificationService;
        this.limitsService = limitsService;
        /**
         * Success both limits template reference
         */
        this.successBothLimitTemplate = '';
        /**
         * Success Regular limits create template reference
         */
        this.successRegularLimitCreateTemplate = '';
        /**
         * Success Regular limits update template reference
         */
        this.successRegularLimitUpdateTemplate = '';
        /**
         * Success Shadow limits create template reference
         */
        this.successShadowLimitCreateTemplate = '';
        /**
         * Success shadow limit update template reference
         */
        this.successShadowLimitUpdateTemplate = '';
        /**
         * Fail both limits template reference
         */
        this.failBothLimitTemplate = '';
        /**
         * Fail regular limit create template reference
         */
        this.failRegularLimitCreateTemplate = '';
        /**
         * Fail regular limit update template reference
         */
        this.failRegularLimitUpdateTemplate = '';
        /**
         * Fail shadow limit create template reference
         */
        this.failShadowLimitCreateTemplate = '';
        /**
         * Fail shadow limit update template reference
         */
        this.failShadowLimitUpdateTemplate = '';
        /**
         * Limits pending notification template reference
         */
        this.limitsPendingNotificationTemplate = '';
        /**
         * Shadow Limits pending notification template reference
         */
        this.shadowLimitsPendingNotificationTemplate = '';
        /**
         * Flag for show/hide regular limit column.
         */
        this.showRegularLimit = false;
        /**
         * Flag for show/hide shadow limit column.
         */
        this.showShadowLimit = false;
        /**
         * Notification dismiss time in milliseconds (defaults to 3000)
         * @default 3000
         */
        this.notificationDismissTime = 3000;
        /**
         * Close modal window event.
         * Propagate event when modal window should be closed.
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
        this.pendingSubmitSubject = new Subject();
        /**
         * Stream of pending submit flag value
         */
        this.pendingSubmit$ = this.pendingSubmitSubject.pipe(distinctUntilChanged());
        this.errorsBESubject = new Subject();
        /**
         * Stream of BE errors
         */
        this.errorsBE$ = this.errorsBESubject.pipe(distinctUntilChanged());
        this.disableRegularSubject = new BehaviorSubject(false);
        /**
         * Stream of Disable regular limits flag
         */
        this.disableRegular$ = this.disableRegularSubject.pipe(distinctUntilChanged());
        this.disableShadowSubject = new BehaviorSubject(false);
        /**
         * Stream of Disable shadow limits flag
         */
        this.disableShadow$ = this.disableShadowSubject.pipe(distinctUntilChanged());
        /**
         * Currency form control
         */
        this.currencyControl = new FormControl();
        /**
         * Show notification stream
         */
        this.showNotification$ = new Subject();
        /**
         * Unsubscribe stream
         */
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        this.showNotification$.pipe(takeUntil(this.destroy$)).subscribe(({ header, modifier }) => {
            this.notificationService.showNotification({
                modifier,
                header,
                message: '',
                dismissible: true,
                ttl: this.notificationDismissTime,
            });
        });
    }
    /**
     * Function for calling create/update limits API calls
     * @param event - any
     */
    submitLimits(event) {
        this.pendingSubmitSubject.next(true);
        this.errorsBESubject.next();
        let requestData;
        const requestDataList = [];
        const requests = [];
        if (this.showRegularLimit && !this.disableRegularSubject.value && event.isRegularChanged) {
            requestData = this.generateManageLimitRequestData(event.limitValue, false);
            requestDataList.push(requestData);
            requests.push(requestData.uuid
                ? this.limitsService
                    .updateLimit(requestData.uuid, this.generateManageLimitRequestUpdateData(event.limitValue, false))
                    .pipe(catchError(err => of(Object.assign({ isError: true }, err))))
                : this.limitsService.createNewLimit(requestData).pipe(catchError(err => of(Object.assign({ isError: true }, err)))));
        }
        if (this.showShadowLimit && !this.disableShadowSubject.value && event.isShadowChanged) {
            requestData = this.generateManageLimitRequestData(event.limitValue, true);
            requestDataList.push(requestData);
            requests.push(requestData.uuid
                ? this.limitsService
                    .updateLimit(requestData.uuid, this.generateManageLimitRequestUpdateData(event.limitValue, true))
                    .pipe(catchError(err => of(Object.assign({ isError: true }, err))))
                : this.limitsService.createNewLimit(requestData).pipe(catchError(err => of(Object.assign({ isError: true }, err)))));
        }
        forkJoin(requests)
            .pipe(finalize(() => this.pendingSubmitSubject.next(false)), takeUntil(this.destroy$))
            .subscribe(resp => this.parseSubmitLimitsResponse(resp, requestDataList));
    }
    /**
     * Parse response of manage limits API
     * @param response - any
     * @param requests - any[]
     */
    parseSubmitLimitsResponse(response, requests) {
        const errors = response.filter((item) => item.isError);
        if (!errors.length) {
            if (response.filter((item) => item.approvalStatus === PENDING_APPROVAL_STATUS).length) {
                this.showAllIsPendingNotification(requests);
            }
            else {
                this.showNotification(this.successBothLimitTemplate);
            }
            this.close.emit();
        }
        else if (errors.length === response.length) {
            this.showNotification(this.failBothLimitTemplate, 'error');
        }
        else {
            response.forEach((item, index) => {
                if (item.approvalStatus === PENDING_APPROVAL_STATUS) {
                    this.showPendingLimitNotification(requests[index]);
                }
                else {
                    this.showLimitNotification(requests[index], item.isError);
                }
            });
            if (!this.currency) {
                this.currency = this.currencyControl.value;
            }
        }
        this.generateBEErrors(errors);
    }
    /**
     * Generate list of BE errors
     * @param errors - any[]
     */
    generateBEErrors(errors) {
        if (!errors.length) {
            return;
        }
        const errorsBE = [];
        errors.forEach((errorItem) => {
            const error = errorItem.error;
            if (error) {
                if (error.errorDetails) {
                    errorsBE.push(...this.parseErrorDetails(error.errorDetails));
                }
                else if (error.message) {
                    errorsBE.push({ message: error.message });
                }
            }
            else if (errorItem.message) {
                errorsBE.push({ message: errorItem.message });
            }
        });
        this.errorsBESubject.next(errorsBE);
    }
    /**
     * Parse errorDetails object and return array of error
     * @param errorDetails - any
     * @return any[]
     */
    parseErrorDetails(errorDetails) {
        const errorsBE = [];
        if (errorDetails && errorDetails.errorFields) {
            errorsBE.push(...errorDetails.errorFields);
        }
        else if (errorDetails.message) {
            errorsBE.push({ message: errorDetails.message });
        }
        return errorsBE;
    }
    /**
     * Show appropriate notification after create/update limits
     * @param request - any
     * @param isError - boolean
     */
    showLimitNotification(request, isError) {
        if (isError) {
            this.showErrorLimitNotification(request);
        }
        else {
            this.showSuccessLimitNotification(request);
        }
    }
    /**
     * Show error notification for limit request
     * @param request - any
     */
    showErrorLimitNotification(request) {
        if (request.shadow) {
            this.showNotification(request.uuid ? this.failShadowLimitUpdateTemplate : this.failShadowLimitCreateTemplate, 'error');
        }
        else {
            this.showNotification(request.uuid ? this.failRegularLimitUpdateTemplate : this.failRegularLimitCreateTemplate, 'error');
        }
    }
    /**
     * Show success notification for limit request
     * @param request - any
     */
    showSuccessLimitNotification(request) {
        if (!request.shadow) {
            this.showNotification(request.uuid ? this.successRegularLimitUpdateTemplate : this.successRegularLimitCreateTemplate);
            this.disableRegularSubject.next(true);
        }
        else {
            this.showNotification(request.uuid ? this.successShadowLimitUpdateTemplate : this.successShadowLimitCreateTemplate);
            this.disableShadowSubject.next(true);
        }
    }
    /**
     * Show success pending notification for limit requests
     * @param requests - any[]
     */
    showAllIsPendingNotification(requests) {
        if (requests.length === 1 && requests[0].shadow) {
            this.showNotification(this.shadowLimitsPendingNotificationTemplate, 'success');
        }
        else {
            this.showNotification(this.limitsPendingNotificationTemplate, 'success');
        }
    }
    /**
     * Show pending notification which happened with another failed request
     * @param request - any
     */
    showPendingLimitNotification(request) {
        if (request.shadow) {
            this.showNotification(this.shadowLimitsPendingNotificationTemplate, 'success');
            this.disableShadowSubject.next(true);
        }
        else {
            this.showNotification(this.limitsPendingNotificationTemplate, 'success');
            this.disableRegularSubject.next(true);
        }
    }
    /**
     * Show notification
     * @param messageRef - TemplateRef<any> | string
     * @param type - any
     */
    showNotification(messageRef, type = 'success') {
        this.showNotification$.next({
            modifier: type,
            header: messageRef,
        });
    }
    /**
     * Mapper for converting limits form value into request body for manage limits API
     * @param limitValue - any
     * @param isShadow - boolean
     */
    generateManageLimitRequestData(limitValue, isShadow) {
        const limitType = isShadow ? 'shadow' : 'regular';
        const requestData = {
            'user-BBID': this.limitKey['user-BBID'],
            entities: this.limitKey.lookupKeys,
            shadow: isShadow,
            currency: this.currency || this.currencyControl.value,
        };
        requestData[PERIODIC_LIMITS_BOUNDS] = {
            customPeriods: [],
        };
        if (this.limitIds && this.limitIds[limitType]) {
            requestData.uuid = this.limitIds[limitType];
        }
        this.limitBounds.forEach((limitBound, index) => {
            var _a;
            const amount = (_a = limitValue[limitType][index]) === null || _a === void 0 ? void 0 : _a.amount.replace(AMOUNT_DELIMETER_REG_EXP, '');
            switch (limitBound.period) {
                case TRANSACTIONAL_LIMITS_BOUNDS:
                    requestData[TRANSACTIONAL_LIMITS_BOUNDS] = {
                        amount,
                    };
                    break;
                case 'daily':
                case 'weekly':
                case 'monthly':
                case 'quarterly':
                case 'yearly':
                    requestData[PERIODIC_LIMITS_BOUNDS][limitBound.period] = amount;
                    break;
                default:
                    requestData[PERIODIC_LIMITS_BOUNDS].customPeriods.push({
                        period: limitBound.period,
                        amount,
                    });
                    break;
            }
        });
        return requestData;
    }
    generateManageLimitRequestUpdateData(limitValue, isShadow) {
        const requestData = {};
        const limitType = isShadow ? 'shadow' : 'regular';
        requestData[PERIODIC_LIMITS_BOUNDS] = {
            customPeriods: [],
        };
        this.limitBounds.forEach((limitBound, index) => {
            var _a;
            const amount = (_a = limitValue[limitType][index]) === null || _a === void 0 ? void 0 : _a.amount;
            switch (limitBound.period) {
                case TRANSACTIONAL_LIMITS_BOUNDS:
                    requestData[TRANSACTIONAL_LIMITS_BOUNDS] = {
                        amount,
                    };
                    break;
                case 'daily':
                case 'weekly':
                case 'monthly':
                case 'quarterly':
                case 'yearly':
                    requestData[PERIODIC_LIMITS_BOUNDS][limitBound.period] = amount;
                    break;
                default:
                    requestData[PERIODIC_LIMITS_BOUNDS].customPeriods.push({
                        period: limitBound.period,
                        amount,
                    });
                    break;
            }
        });
        return requestData;
    }
    /**
     * Limit currency getter
     */
    get getCurrency() {
        return this.currency || this.currencyControl.value;
    }
    /**
     * OpenChange modal window event handler.
     * @param isOpen - boolean
     */
    onOpenChange(isOpen) {
        if (!isOpen) {
            this.close.emit();
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
}
/** @nocollapse */ ManageLimitsModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageLimitsModalComponent, deps: [{ token: i1.NotificationService }, { token: i2.LimitsService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ ManageLimitsModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: ManageLimitsModalComponent, selector: "bb-manage-limits-modal", inputs: { view: "view", limitBounds: "limitBounds", showRegularLimit: "showRegularLimit", showShadowLimit: "showShadowLimit", currency: "currency", limitKey: "limitKey", limitIds: "limitIds", pending: "pending", headerTitle: "headerTitle", serviceAgreementId: "serviceAgreementId", legalEntityId: "legalEntityId", headerSubTitleUserName: "headerSubTitleUserName", headerSubTitleJRName: "headerSubTitleJRName", headerSubTitleLEName: "headerSubTitleLEName", headerSubTitleSAName: "headerSubTitleSAName", notificationDismissTime: "notificationDismissTime" }, outputs: { close: "close" }, viewQueries: [{ propertyName: "successBothLimitTemplate", first: true, predicate: ["successBothLimit"], descendants: true }, { propertyName: "successRegularLimitCreateTemplate", first: true, predicate: ["successRegularLimitCreate"], descendants: true }, { propertyName: "successRegularLimitUpdateTemplate", first: true, predicate: ["successRegularLimitUpdate"], descendants: true }, { propertyName: "successShadowLimitCreateTemplate", first: true, predicate: ["successShadowLimitCreate"], descendants: true }, { propertyName: "successShadowLimitUpdateTemplate", first: true, predicate: ["successShadowLimitUpdate"], descendants: true }, { propertyName: "failBothLimitTemplate", first: true, predicate: ["failBothLimit"], descendants: true }, { propertyName: "failRegularLimitCreateTemplate", first: true, predicate: ["failRegularLimitCreate"], descendants: true }, { propertyName: "failRegularLimitUpdateTemplate", first: true, predicate: ["failRegularLimitUpdate"], descendants: true }, { propertyName: "failShadowLimitCreateTemplate", first: true, predicate: ["failShadowLimitCreate"], descendants: true }, { propertyName: "failShadowLimitUpdateTemplate", first: true, predicate: ["failShadowLimitUpdate"], descendants: true }, { propertyName: "limitsPendingNotificationTemplate", first: true, predicate: ["limitsPendingNotificationTemplate"], descendants: true }, { propertyName: "shadowLimitsPendingNotificationTemplate", first: true, predicate: ["shadowLimitsPendingNotificationTemplate"], descendants: true }], ngImport: i0, template: "<ng-container\n  bbManageLimitsModalCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    pendingSubmit: pendingSubmit$ | async,\n    errorsBE: errorsBE$ | async,\n    disableRegular: disableRegular$ | async,\n    disableShadow: disableShadow$ | async\n  }\"></ng-container>\n\n<ng-template\n  bbManageLimitsModalCustomizable\n  let-hostRef\n  let-pendingSubmit=\"context.pendingSubmit\"\n  let-errorsBE=\"context.errorsBE\"\n  let-disableRegular=\"context.disableRegular\"\n  let-disableShadow=\"context.disableShadow\">\n  <bb-modal-ui\n    data-role=\"bb-manage-limits-modal-container\"\n    [isOpen]=\"true\"\n    [modalOptions]=\"{\n      backdrop: 'static',\n      centered: true,\n      keyboard: true,\n      size: 'md'\n    }\"\n    (isOpenChange)=\"hostRef.onOpenChange($event)\">\n    <bb-modal-header-ui>\n      <ng-template bbCustomModalHeader>\n        <bb-manage-limits-modal-header\n          class=\"bb-stack__item bb-stack__item--fill\"\n          [currency]=\"hostRef.currency\"\n          [currencyControl]=\"hostRef.currencyControl\"\n          [title]=\"hostRef.headerTitle\"\n          [serviceAgreementId]=\"hostRef.serviceAgreementId\"\n          [legalEntityId]=\"hostRef.legalEntityId\"\n          [subTitleUserName]=\"hostRef.headerSubTitleUserName\"\n          [subTitleJRName]=\"hostRef.headerSubTitleJRName\"\n          [subTitleLEName]=\"hostRef.headerSubTitleLEName\"\n          [subTitleSAName]=\"hostRef.headerSubTitleSAName\"\n          [notificationDismissTime]=\"hostRef._notificationDismissTime\"\n          (close)=\"hostRef.onOpenChange(false)\"\n          defaultTitle=\"Limits\"\n          i18n-defaultTitle=\"Limits modal header title@@manage-limits-modal.header.title\"\n          data-role=\"manage-limits-modal-header\"></bb-manage-limits-modal-header>\n      </ng-template>\n    </bb-modal-header-ui>\n\n    <!-- NOTE: View and Edit template should define it's own header, footer, and body templates here -->\n    <ng-container *ngIf=\"hostRef.getCurrency\" [ngSwitch]=\"hostRef.view\">\n      <ng-container *ngSwitchCase=\"'view'\">\n        <bb-manage-limits-modal-view-body\n          [limitBounds]=\"hostRef.limitBounds\"\n          [showRegularLimit]=\"hostRef.showRegularLimit\"\n          [showShadowLimit]=\"hostRef.showShadowLimit\"\n          [pending]=\"hostRef.pending\"\n          [currency]=\"hostRef.currency\"\n          (cancel)=\"hostRef.onOpenChange(false)\"\n          data-role=\"bb-manage-limits-modal-view\"></bb-manage-limits-modal-view-body>\n      </ng-container>\n      <ng-container *ngSwitchCase=\"'edit'\">\n        <bb-edit-limit\n          [limitBounds]=\"hostRef.limitBounds\"\n          [showRegularLimit]=\"hostRef.showRegularLimit\"\n          [showShadowLimit]=\"hostRef.showShadowLimit\"\n          [disableRegular]=\"disableRegular\"\n          [disableShadow]=\"disableShadow\"\n          [currency]=\"hostRef.getCurrency\"\n          [showLoadingSubmitBtn]=\"pendingSubmit\"\n          [errors]=\"errorsBE\"\n          (submit)=\"hostRef.submitLimits($event)\"\n          (close)=\"hostRef.onOpenChange(false)\"\n          data-role=\"bb-manage-limits-modal-edit\"></bb-edit-limit>\n      </ng-container>\n    </ng-container>\n  </bb-modal-ui>\n</ng-template>\n\n<ng-template #successBothLimit>\n  <span i18n=\"Both limits is successfully saved@@manage-limits-modal.notification.save.success\">\n    Limits successfully saved\n  </span>\n</ng-template>\n<ng-template #successRegularLimitCreate>\n  <span i18n=\"Regular limits is successfully added@@manage-limits-modal.notification.create.success.regular\">\n    Regular limits successfully added\n  </span>\n</ng-template>\n<ng-template #successRegularLimitUpdate>\n  <span i18n=\"Regular limits is successfully updated@@manage-limits-modal.notification.update.success.regular\">\n    Regular limits successfully updated\n  </span>\n</ng-template>\n<ng-template #successShadowLimitCreate>\n  <span i18n=\"Shadow limits is successfully added@@manage-limits-modal.notification.create.success.shadow\">\n    Shadow limits successfully added\n  </span>\n</ng-template>\n<ng-template #successShadowLimitUpdate>\n  <span i18n=\"Shadow limits is successfully updated@@manage-limits-modal.notification.update.success.shadow\">\n    Shadow limits successfully updated\n  </span>\n</ng-template>\n<ng-template #failBothLimit>\n  <span i18n=\"Both limits are failed to saved@@manage-limits-modal.notification.save.error\">\n    Limits failed to save\n  </span>\n</ng-template>\n<ng-template #failRegularLimitCreate>\n  <span i18n=\"Regular limits are failed to create@@manage-limits-modal.notification.create.error.regular\">\n    Regular limits failed to add\n  </span>\n</ng-template>\n<ng-template #failRegularLimitUpdate>\n  <span i18n=\"Regular limits are failed to update@@manage-limits-modal.notification.update.error.regular\">\n    Regular limits failed to update\n  </span>\n</ng-template>\n<ng-template #failShadowLimitCreate>\n  <span i18n=\"Shadow limits are failed to create@@manage-limits-modal.notification.create.error.shadow\">\n    Shadow limits failed to add\n  </span>\n</ng-template>\n<ng-template #failShadowLimitUpdate>\n  <span i18n=\"Shadow limits are failed to update@@manage-limits-modal.notification.update.error.shadow\">\n    Shadow limits failed to update\n  </span>\n</ng-template>\n<ng-template #limitsPendingNotificationTemplate>\n  <span\n    i18n=\"\n      Success notification when limits changed but changes are in pending\n      state@@manage-limits-modal.notification.pending.limit\">\n    The limits are in pending state, and will be active once they are approved\n  </span>\n</ng-template>\n\n<ng-template #shadowLimitsPendingNotificationTemplate>\n  <span\n    i18n=\"\n      Success notification when shadow limits changed but changes are in pending\n      state@@manage-limits-modal.notification.pending.shadow-limit\">\n    The shadow limits are in pending state, and will be active once they are approved\n  </span>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i3.ModalComponent; }), selector: "bb-modal-ui", inputs: ["isOpen", "aria-labelledby", "aria-describedby", "modalOptions"], outputs: ["confirm", "cancel", "isOpenChange"] }, { type: i0.forwardRef(function () { return i3.ModalHeaderComponent; }), selector: "bb-modal-header-ui", inputs: ["title"], outputs: ["close"] }, { type: i0.forwardRef(function () { return i4.ManageLimitsModalHeaderComponent; }), selector: "bb-manage-limits-modal-header", inputs: ["currency", "currencyControl", "defaultTitle", "title", "serviceAgreementId", "legalEntityId", "subTitleUserName", "subTitleJRName", "subTitleLEName", "subTitleSAName", "notificationDismissTime"], outputs: ["close"] }, { type: i0.forwardRef(function () { return i5.ManageLimitsModalViewBodyComponent; }), selector: "bb-manage-limits-modal-view-body", inputs: ["showRegularLimit", "showShadowLimit", "pending", "currency", "limitBounds"], outputs: ["cancel"] }, { type: i0.forwardRef(function () { return i6.EditLimitComponent; }), selector: "bb-edit-limit", inputs: ["showRegularLimit", "showShadowLimit", "limitBounds", "currency", "showLoadingSubmitBtn", "errors", "disableRegular", "disableShadow"], outputs: ["submit", "close"] }], directives: [{ type: i0.forwardRef(function () { return ManageLimitsModalCustomizableDirective; }), selector: "[bbManageLimitsModalCustomizable]" }, { type: i0.forwardRef(function () { return i3.CustomModalHeaderDirective; }), selector: "ng-template[bbCustomModalHeader]" }, { type: i0.forwardRef(function () { return i7.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i7.NgSwitch; }), selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i0.forwardRef(function () { return i7.NgSwitchCase; }), selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }], pipes: { "async": i0.forwardRef(function () { return i7.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageLimitsModalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-manage-limits-modal',
                    templateUrl: 'manage-limits-modal.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.NotificationService }, { type: i2.LimitsService }]; }, propDecorators: { successBothLimitTemplate: [{
                type: ViewChild,
                args: ['successBothLimit']
            }], successRegularLimitCreateTemplate: [{
                type: ViewChild,
                args: ['successRegularLimitCreate']
            }], successRegularLimitUpdateTemplate: [{
                type: ViewChild,
                args: ['successRegularLimitUpdate']
            }], successShadowLimitCreateTemplate: [{
                type: ViewChild,
                args: ['successShadowLimitCreate']
            }], successShadowLimitUpdateTemplate: [{
                type: ViewChild,
                args: ['successShadowLimitUpdate']
            }], failBothLimitTemplate: [{
                type: ViewChild,
                args: ['failBothLimit']
            }], failRegularLimitCreateTemplate: [{
                type: ViewChild,
                args: ['failRegularLimitCreate']
            }], failRegularLimitUpdateTemplate: [{
                type: ViewChild,
                args: ['failRegularLimitUpdate']
            }], failShadowLimitCreateTemplate: [{
                type: ViewChild,
                args: ['failShadowLimitCreate']
            }], failShadowLimitUpdateTemplate: [{
                type: ViewChild,
                args: ['failShadowLimitUpdate']
            }], limitsPendingNotificationTemplate: [{
                type: ViewChild,
                args: ['limitsPendingNotificationTemplate']
            }], shadowLimitsPendingNotificationTemplate: [{
                type: ViewChild,
                args: ['shadowLimitsPendingNotificationTemplate']
            }], view: [{
                type: Input
            }], limitBounds: [{
                type: Input
            }], showRegularLimit: [{
                type: Input
            }], showShadowLimit: [{
                type: Input
            }], currency: [{
                type: Input
            }], limitKey: [{
                type: Input
            }], limitIds: [{
                type: Input
            }], pending: [{
                type: Input
            }], headerTitle: [{
                type: Input
            }], serviceAgreementId: [{
                type: Input
            }], legalEntityId: [{
                type: Input
            }], headerSubTitleUserName: [{
                type: Input
            }], headerSubTitleJRName: [{
                type: Input
            }], headerSubTitleLEName: [{
                type: Input
            }], headerSubTitleSAName: [{
                type: Input
            }], notificationDismissTime: [{
                type: Input
            }], close: [{
                type: Output
            }] } });
export class ManageLimitsModalCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ ManageLimitsModalCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageLimitsModalCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ ManageLimitsModalCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: ManageLimitsModalCustomizableDirective, selector: "[bbManageLimitsModalCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ManageLimitsModalCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbManageLimitsModalCustomizable]',
                }]
        }] });
//# sourceMappingURL=manage-limits-modal.component.js.map