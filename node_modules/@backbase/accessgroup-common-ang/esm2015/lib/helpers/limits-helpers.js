import { BOUNDTS_TYPE, TRANSACTIONAL_LIMITS_BOUNDS, PERIODIC_LIMITS_BOUNDS, } from '../manage-limits-modal/models/limits-bound-types.model';
/**
 * Parse response from consumption API into separate regular/shadow limits and regular/shadow consumption
 */
const getLimitsAndConsumptionItem = (limitData) => {
    let regularLimit, regularConsumptions, shadowLimit, shadowConsumptions;
    limitData.forEach((limit) => {
        if (limit.limit && !limit.limit.shadow) {
            regularLimit = limit.limit;
            regularConsumptions = limit.consumptions;
        }
        else if (limit.limit && limit.limit.shadow) {
            shadowLimit = limit.limit;
            shadowConsumptions = limit.consumptions;
        }
    });
    return { regularLimit, regularConsumptions, shadowLimit, shadowConsumptions };
};
/**
 * Get transactional limit amount
 */
const getTransactionalLimit = (limitItem) => {
    const limit = limitItem && limitItem[TRANSACTIONAL_LIMITS_BOUNDS];
    return { amount: limit && limit.amount };
};
/**
 * Get periodical limit amount
 */
const getPeriodicalLimit = (limitItem, key, isCustom) => {
    const periodicLimits = limitItem && limitItem[PERIODIC_LIMITS_BOUNDS];
    let limitAmount;
    if (periodicLimits) {
        if (isCustom) {
            const customLimit = periodicLimits.customPeriods && periodicLimits.customPeriods.find((item) => item.period === key);
            limitAmount = customLimit && customLimit.amount;
        }
        else {
            limitAmount = periodicLimits[key];
        }
    }
    return { amount: limitAmount };
};
/**
 * Get consumption amount by periodic key
 */
const getConsumptionAmount = (consumptions, key, isCustom) => {
    let consumptionAmount;
    if (consumptions) {
        if (isCustom) {
            const customLimit = consumptions.customPeriods && consumptions.customPeriods.find((item) => item.period === key);
            consumptionAmount = customLimit && customLimit.amount;
        }
        else {
            consumptionAmount = consumptions[key];
        }
    }
    return consumptionAmount;
};
/**
 * Get if limit included any shadow limit amount
 */
export const getIfLimitHasShadow = (limits) => {
    for (let i = 0; i < limits.length; i++) {
        if (limits[i].shadow && limits[i].shadow.amount) {
            return true;
        }
    }
    return false;
};
/**
 * Get limit is unlimited
 */
export const getLimitUnlimited = (limits) => {
    for (let i = 0; i < limits.length; i++) {
        if ((limits[i].shadow && limits[i].shadow.amount) || (limits[i].regular && limits[i].regular.amount)) {
            return false;
        }
    }
    return true;
};
/**
 * Map period keys into limit bound keys
 */
const getLimitsPeriodsKey = (key) => {
    return BOUNDTS_TYPE[key] ? { key: BOUNDTS_TYPE[key], isCustom: false } : { key, isCustom: true };
};
/**
 * Get limit currency
 */
const getLimitCurrency = (limitData) => {
    if (limitData && limitData.length) {
        const limitItem = limitData[0];
        return limitItem.limit && limitItem.limit.currency;
    }
    return undefined;
};
/**
 * Get regular/shadow limit ids
 */
const getLimitsIds = (limitData) => {
    let regular, shadow;
    limitData.forEach((limit) => {
        if (limit.limit && !limit.limit.shadow) {
            regular = limit.limit.uuid;
        }
        else if (limit.limit && limit.limit.shadow) {
            shadow = limit.limit.uuid;
        }
    });
    return { regular, shadow };
};
/**
 * Mapper for converting periods list and limit data into object with array of LimitBound
 */
export const periodLimitsConsumptionMapper = (periods, limitConsumptionsData) => {
    const limitBounds = [];
    const { regularLimit, regularConsumptions, shadowLimit, shadowConsumptions } = getLimitsAndConsumptionItem(limitConsumptionsData);
    limitBounds.push({
        period: TRANSACTIONAL_LIMITS_BOUNDS,
        custom: false,
        regular: getTransactionalLimit(regularLimit),
        shadow: getTransactionalLimit(shadowLimit),
    });
    periods.forEach(period => {
        const { key, isCustom } = getLimitsPeriodsKey(period.name);
        const regularLimitItem = getPeriodicalLimit(regularLimit, key, isCustom);
        const shadowLimitItem = getPeriodicalLimit(shadowLimit, key, isCustom);
        const regularConsumptionItem = getConsumptionAmount(regularConsumptions, key, isCustom);
        const shadowConsumptionItem = getConsumptionAmount(shadowConsumptions, key, isCustom);
        limitBounds.push({
            period: key,
            custom: isCustom,
            regular: regularLimitItem,
            shadow: shadowLimitItem,
            regularConsumption: regularConsumptionItem,
            shadowConsumption: shadowConsumptionItem,
        });
    });
    return {
        uuid: getLimitsIds(limitConsumptionsData),
        currency: getLimitCurrency(limitConsumptionsData),
        limitBounds,
    };
};
export const lookUpObject = (entity, id) => {
    return {
        lookupKeys: [
            {
                eref: id,
                etype: entity,
            },
        ],
    };
};
export const checkPermission = (permission) => {
    return (permission.regularLimit.edit ||
        permission.regularLimit.view ||
        permission.regularLimit.create ||
        permission.shadowLimit.edit ||
        permission.shadowLimit.view ||
        permission.shadowLimit.create);
};
export const prepareLimitObj = (groupedLimit, periods, groupedRetrivalLimit) => {
    let limit;
    if (groupedLimit) {
        limit = Object.assign(Object.assign({}, periodLimitsConsumptionMapper(periods, groupedLimit)), { created: true });
        limit.isHasShadow = getIfLimitHasShadow(limit.limitBounds);
        limit.isUnlimited = getLimitUnlimited(limit.limitBounds);
    }
    else {
        limit = Object.assign(Object.assign({}, periodLimitsConsumptionMapper(periods, [])), { created: false });
    }
    if (groupedRetrivalLimit) {
        groupedRetrivalLimit.forEach((item) => {
            if (item.approvalId) {
                limit.pending = true;
            }
        });
    }
    return limit;
};
//# sourceMappingURL=limits-helpers.js.map