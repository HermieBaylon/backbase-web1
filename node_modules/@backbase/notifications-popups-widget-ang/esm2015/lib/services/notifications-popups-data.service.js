import { Inject, Injectable, NgZone } from '@angular/core';
import { NotificationsHttpService } from '@backbase/data-ang/notifications';
import { shareReplayOnce } from '@backbase/notifications-common-ang';
import { delay, delayWhen, first, map, observeOn, switchMap, take, tap } from 'rxjs/operators';
import { asyncScheduler, combineLatest, merge, of, Subject } from 'rxjs';
import { enterZone, leaveZone, NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, NOTIFICATIONS_CREATE_LOCAL_EVENT, } from '@backbase/notifications-common-ang';
import { fromHttpResponse, notificationsStreamToPopups, notificationsStreamToSticky, notificationLocalToStreamItem, } from '../helpers/mappers';
import { PUBSUB } from '@backbase/foundation-ang/web-sdk';
import { NOTIFICATION_LOCAL } from '../constants/notification-local';
import { WidgetPropertiesService } from './widget-properties.service';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/notifications";
import * as i2 from "./widget-properties.service";
export const DEFAULT_POLLING_INTERVAL = 15;
export class NotificationsPopupsDataService {
    constructor(dataHttpService, ngZone, properties, pubSub) {
        this.dataHttpService = dataHttpService;
        this.ngZone = ngZone;
        this.properties = properties;
        this.pubSub = pubSub;
        /**
         * Mark notification as read stream
         */
        this.markNotificationAsRead$ = new Subject();
        this.notificationsStreamForceUpdate$ = new Subject();
        this.polling$ = new Subject();
        this.notificationsLocalStickySource = new Map();
        this.origins$ = this.properties.origins$;
        this.severityLevels$ = this.properties.severityLevels$;
        this.pollingInterval$ = this.properties.pollingInterval$;
        this.notificationsStream$ = this.initializeNotificationsStreamPolling();
        this.stickyNotificationsStream$ = this.notificationsStream$.pipe(map(notificationsStreamToSticky));
        this.popupsNotificationsStream$ = this.notificationsStream$.pipe(map(notificationsStreamToPopups));
        this.markNotificationAsRead$.subscribe((payload) => {
            this.pubSub.publish(NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, typeof payload === 'object'
                ? {
                    origin: payload.origin,
                    level: payload.level,
                }
                : undefined);
        });
        this.pubSub.subscribe(NOTIFICATIONS_CREATE_LOCAL_EVENT, (notification) => {
            const parsedNotification = notificationLocalToStreamItem(notification);
            if (notification.sticky) {
                this.notificationsLocalStickySource.set(parsedNotification.id, parsedNotification);
            }
            this.notificationsStream$
                .pipe(switchMap(stream => {
                const popup = (!notification.sticky && [parsedNotification]) || [];
                const stickies = this.notificationsLocalSticky;
                return of([...stream, ...stickies, ...popup]);
            }), map(concatenatedStream => Array.from(new Map(concatenatedStream.map(item => [item.id, item])).values())), take(1))
                .subscribe(notificationsStream => this.notificationsStreamForceUpdate$.next(notificationsStream));
        });
    }
    get notificationsLocalSticky() {
        return Array.from(this.notificationsLocalStickySource.values());
    }
    /**
     * Mark notification as read
     *
     * @param notification Notification data
     */
    markNotificationAsRead(notification) {
        const id = typeof notification === 'string' ? notification : notification.id;
        if (id.match(NOTIFICATION_LOCAL)) {
            this.removeNotificationItemFromStream(id);
            this.notificationsLocalStickySource.delete(id);
        }
        else {
            this.dataHttpService.putMarkAsRead({ id, markAsReadPutRequestBody: { read: true } }).subscribe(() => {
                this.removeNotificationItemFromStream(id);
                this.markNotificationAsRead$.next(notification);
            });
        }
    }
    requestNotificationsStream() {
        return combineLatest([this.pollingInterval$, this.origins$, this.severityLevels$]).pipe(first(), switchMap(([interval, origins, levels]) => this.dataHttpService.getNotificationsStream(Object.assign(Object.assign({ interval }, (origins.length && { origins })), (levels && { levels: levels.join(', ') })), 'response')), map(fromHttpResponse));
    }
    removeNotificationItemFromStream(notificationId) {
        this.notificationsStream$
            .pipe(first(), map(notificationsStream => notificationsStream.filter(({ id }) => id !== notificationId)))
            .subscribe(notificationsStream => this.notificationsStreamForceUpdate$.next(notificationsStream));
    }
    initializeNotificationsStreamPolling() {
        const pollAndRequest$ = of(undefined).pipe(tap(() => this.polling$.next()), switchMap(() => this.requestNotificationsStream()));
        const pollingNotificationsStream$ = this.polling$.pipe(switchMap(() => this.pollingInterval$), delayWhen(pollingInterval => of().pipe(delay(pollingInterval, leaveZone(this.ngZone, asyncScheduler)))), switchMap(() => pollAndRequest$), observeOn(enterZone(this.ngZone, asyncScheduler)));
        return merge(this.notificationsStreamForceUpdate$, pollingNotificationsStream$.pipe(switchMap(stream => of([...stream, ...this.notificationsLocalSticky]))), pollAndRequest$.pipe(switchMap(stream => of([...stream, ...this.notificationsLocalSticky])))).pipe(shareReplayOnce());
    }
}
/** @nocollapse */ NotificationsPopupsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsDataService, deps: [{ token: i1.NotificationsHttpService }, { token: i0.NgZone }, { token: i2.WidgetPropertiesService }, { token: PUBSUB }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPopupsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsDataService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsDataService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.NotificationsHttpService }, { type: i0.NgZone }, { type: i2.WidgetPropertiesService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }]; } });
//# sourceMappingURL=notifications-popups-data.service.js.map