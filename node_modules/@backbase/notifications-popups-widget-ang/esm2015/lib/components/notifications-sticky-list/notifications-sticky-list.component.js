import { Component, Directive, ElementRef } from '@angular/core';
import { BbTemplate } from '@backbase/foundation-ang/core';
import { NotificationsPopupsDataService } from '../../services/notifications-popups-data.service';
import { first, map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../services/notifications-popups-data.service";
import * as i2 from "../notifications-sticky-list-item/notifications-sticky-list-item.component";
import * as i3 from "@angular/common";
export class NotificationsStickyListComponent {
    constructor(dataService, elem) {
        this.dataService = dataService;
        this.elem = elem;
        /**
         * Notification sticky stream data
         */
        this.notifications$ = this.dataService.stickyNotificationsStream$;
    }
    /**
     * Method to call mark notification as read request by id
     *
     * @param notification Notification data
     */
    onReadNotification(notification) {
        this.dataService.markNotificationAsRead(notification);
        const notifications = this.elem.nativeElement.querySelectorAll('bb-notifications-sticky-list-item');
        const deletedNotificationIndex$ = this.notifications$.pipe(map((notificationElements) => notificationElements.findIndex(item => typeof notification === 'string' ? notification === item.id : notification.id === item.id)));
        deletedNotificationIndex$.pipe(first()).subscribe(index => {
            if (notifications[index + 1]) {
                notifications[index + 1].getElementsByTagName('button')[0].focus();
            }
            else if (notifications[index - 1]) {
                notifications[index - 1].getElementsByTagName('button')[0].focus();
            }
            else if (this.previousFocusedElement) {
                this.previousFocusedElement.focus();
            }
        });
    }
    /**
     * Method to differentiate notifications by IDs.
     *
     * @param _index List item index
     * @param notification Notification list item
     * @returns Notification id
     */
    trackById(_index, notification) {
        return notification.id;
    }
    /**
     * Method to change focus.
     *
     * @param event Focus event
     */
    onFocus(event) {
        if (!this.previousFocusedElement) {
            this.previousFocusedElement = event.relatedTarget;
        }
    }
}
/** @nocollapse */ NotificationsStickyListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListComponent, deps: [{ token: i1.NotificationsPopupsDataService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsStickyListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsStickyListComponent, selector: "bb-notifications-sticky-list", ngImport: i0, template: "<ng-container\n  bbNotificationsStickyListCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    notifications: notifications$ | async\n  }\"\n></ng-container>\n\n<ng-template bbNotificationsStickyListCustomizable let-host let-notifications=\"context.notifications\">\n  <bb-notifications-sticky-list-item\n    (focusin)=\"host.onFocus($event)\"\n    *ngFor=\"let item of notifications; trackBy: host.trackById\"\n    [notification]=\"item\"\n    (close)=\"host.onReadNotification($event)\"\n  ></bb-notifications-sticky-list-item>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i2.NotificationsStickyListItemComponent; }), selector: "bb-notifications-sticky-list-item", inputs: ["notification"], outputs: ["close"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsStickyListCustomizableDirective; }), selector: "[bbNotificationsStickyListCustomizable]" }, { type: i0.forwardRef(function () { return i3.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i0.forwardRef(function () { return i3.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-sticky-list',
                    templateUrl: './notifications-sticky-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.NotificationsPopupsDataService }, { type: i0.ElementRef }]; } });
export class NotificationsStickyListCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsStickyListCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsStickyListCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsStickyListCustomizableDirective, selector: "[bbNotificationsStickyListCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsStickyListCustomizable]',
                }]
        }] });
//# sourceMappingURL=notifications-sticky-list.component.js.map