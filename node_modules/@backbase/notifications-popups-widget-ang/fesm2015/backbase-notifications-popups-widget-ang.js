import * as i0 from '@angular/core';
import { Injectable, Optional, Inject, EventEmitter, Component, Input, Output, Directive, ViewChild, NgModule } from '@angular/core';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1 from '@backbase/foundation-ang/core';
import { BbTemplate, BackbaseCoreModule } from '@backbase/foundation-ang/core';
import * as i1$1 from '@backbase/data-ang/notifications';
import * as i5 from '@backbase/notifications-common-ang';
import { BaseWidgetPropertiesService, getPropertyValue, modelItemToBoolean, shareReplayOnce, secondsToMilliseconds as secondsToMilliseconds$1, NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, NOTIFICATIONS_CREATE_LOCAL_EVENT, leaveZone, enterZone, NotificationsCommonModule } from '@backbase/notifications-common-ang';
import { map, first, switchMap, take, tap, delayWhen, delay, observeOn, takeUntil } from 'rxjs/operators';
import { BehaviorSubject, Subject, of, combineLatest, asyncScheduler, merge } from 'rxjs';
import { PUBSUB } from '@backbase/foundation-ang/web-sdk';
import * as i1$2 from '@backbase/ui-ang/alert';
import { AlertModule } from '@backbase/ui-ang/alert';
import { BbTemplate as BbTemplate$1 } from '@backbase/foundation-ang/core/';
import * as i1$3 from '@backbase/ui-ang/notification';
import * as i6 from '@backbase/ui-ang/ellipsis';
import { EllipsisModule } from '@backbase/ui-ang/ellipsis';

const NOTIFICATION_LOCAL = 'NOTIFICATION_LOCAL';

const secondsToMilliseconds = (seconds) => seconds * 1000;
const fromHttpResponse = (response) => {
    if (response.body === null) {
        throw new Error('Response body not set');
    }
    return response.body;
};
const notificationsStreamToSticky = (notificationsStream) => notificationsStream.filter(item => !!item.expiresOn);
const notificationsStreamToPopups = (notificationsStream) => notificationsStream.filter(item => !item.expiresOn);
// eslint-disable-next-line arrow-body-style
const parseNotificationSeverityLevel = (level) => {
    return level === 'ALERT' ? 'error' : level.toLowerCase();
};
// eslint-disable-next-line arrow-body-style
const severityTypeToSeverityLevel = (type) => {
    return type === 'error' ? 'ALERT' : type.toUpperCase();
};
const notificationLocalToStreamItem = (notification) => {
    const timestamp = Date.now();
    const date = new Date(timestamp).toISOString();
    return Object.assign({ id: `${NOTIFICATION_LOCAL}_${timestamp + Math.floor(Math.random() * 1000)}`, createdOn: date, title: notification.title, message: notification.message, level: severityTypeToSeverityLevel(notification.level) }, (notification.sticky && { expiresOn: date }));
};

const DefaultWidgetProperties = {
    allowedRoutes: [],
    autofocus: true,
    popupMessageLineAmount: 2,
    displayShowMoreButtonInPopup: false,
    origins: [],
    severityLevels: [],
    pollingInterval: 15,
};
class WidgetPropertiesService extends BaseWidgetPropertiesService {
    constructor(itemModel) {
        super(itemModel);
        this.itemModel = itemModel;
        this.autofocus$$ = new BehaviorSubject(undefined);
        this.popupMessageLineAmount$$ = new BehaviorSubject(undefined);
        this.displayShowMoreButtonInPopup$$ = new BehaviorSubject(undefined);
        this.pollingInterval$$ = new BehaviorSubject(undefined);
        this.autofocus$ = getPropertyValue(this.autofocus$$, this.autofocus);
        this.popupMessageLineAmount$ = getPropertyValue(this.popupMessageLineAmount$$, this.popupMessageLineAmount);
        this.displayShowMoreButtonInPopup$ = getPropertyValue(this.displayShowMoreButtonInPopup$$, this.displayShowMoreButtonInPopup);
        this.pollingInterval$ = getPropertyValue(this.pollingInterval$$, this.pollingInterval);
    }
    get autofocus() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.autofocus);
        }
        return this.itemModel
            .property('autofocus', DefaultWidgetProperties.autofocus)
            .pipe(map(modelItemToBoolean), first());
    }
    get popupMessageLineAmount() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.popupMessageLineAmount);
        }
        return this.itemModel.property('popupMessageLineAmount', '').pipe(map(Number), first());
    }
    get displayShowMoreButtonInPopup() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.displayShowMoreButtonInPopup);
        }
        return this.itemModel
            .property('displayShowMoreButtonInPopup', DefaultWidgetProperties.displayShowMoreButtonInPopup)
            .pipe(map(modelItemToBoolean), first());
    }
    get pollingInterval() {
        if (!this.itemModel) {
            return this.defaultModelObservable(DefaultWidgetProperties.pollingInterval * 1000);
        }
        return this.itemModel.property('pollingInterval', DefaultWidgetProperties.pollingInterval).pipe(map(Number), map(n => n * 1000), shareReplayOnce());
    }
    setAutofocus(value) {
        this.autofocus$$.next(modelItemToBoolean(value));
    }
    setPopupMessageLineAmount(value) {
        this.popupMessageLineAmount$$.next(Number(value));
    }
    setDisplayShowMoreButtonInPopup(value) {
        this.displayShowMoreButtonInPopup$$.next(modelItemToBoolean(value));
    }
    setPollingInterval(value) {
        const pollingInterval = Number(value);
        if (!isNaN(pollingInterval) && pollingInterval > 0) {
            this.pollingInterval$$.next(secondsToMilliseconds$1(pollingInterval));
        }
    }
}
/** @nocollapse */ WidgetPropertiesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService, deps: [{ token: i1.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ WidgetPropertiesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WidgetPropertiesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.ItemModel, decorators: [{
                    type: Optional
                }] }]; } });

const DEFAULT_POLLING_INTERVAL = 15;
class NotificationsPopupsDataService {
    constructor(dataHttpService, ngZone, properties, pubSub) {
        this.dataHttpService = dataHttpService;
        this.ngZone = ngZone;
        this.properties = properties;
        this.pubSub = pubSub;
        /**
         * Mark notification as read stream
         */
        this.markNotificationAsRead$ = new Subject();
        this.notificationsStreamForceUpdate$ = new Subject();
        this.polling$ = new Subject();
        this.notificationsLocalStickySource = new Map();
        this.origins$ = this.properties.origins$;
        this.severityLevels$ = this.properties.severityLevels$;
        this.pollingInterval$ = this.properties.pollingInterval$;
        this.notificationsStream$ = this.initializeNotificationsStreamPolling();
        this.stickyNotificationsStream$ = this.notificationsStream$.pipe(map(notificationsStreamToSticky));
        this.popupsNotificationsStream$ = this.notificationsStream$.pipe(map(notificationsStreamToPopups));
        this.markNotificationAsRead$.subscribe((payload) => {
            this.pubSub.publish(NOTIFICATIONS_BADGE_FORCE_UPDATE_EVENT, typeof payload === 'object'
                ? {
                    origin: payload.origin,
                    level: payload.level,
                }
                : undefined);
        });
        this.pubSub.subscribe(NOTIFICATIONS_CREATE_LOCAL_EVENT, (notification) => {
            const parsedNotification = notificationLocalToStreamItem(notification);
            if (notification.sticky) {
                this.notificationsLocalStickySource.set(parsedNotification.id, parsedNotification);
            }
            this.notificationsStream$
                .pipe(switchMap(stream => {
                const popup = (!notification.sticky && [parsedNotification]) || [];
                const stickies = this.notificationsLocalSticky;
                return of([...stream, ...stickies, ...popup]);
            }), map(concatenatedStream => Array.from(new Map(concatenatedStream.map(item => [item.id, item])).values())), take(1))
                .subscribe(notificationsStream => this.notificationsStreamForceUpdate$.next(notificationsStream));
        });
    }
    get notificationsLocalSticky() {
        return Array.from(this.notificationsLocalStickySource.values());
    }
    /**
     * Mark notification as read
     *
     * @param notification Notification data
     */
    markNotificationAsRead(notification) {
        const id = typeof notification === 'string' ? notification : notification.id;
        if (id.match(NOTIFICATION_LOCAL)) {
            this.removeNotificationItemFromStream(id);
            this.notificationsLocalStickySource.delete(id);
        }
        else {
            this.dataHttpService.putMarkAsRead({ id, markAsReadPutRequestBody: { read: true } }).subscribe(() => {
                this.removeNotificationItemFromStream(id);
                this.markNotificationAsRead$.next(notification);
            });
        }
    }
    requestNotificationsStream() {
        return combineLatest([this.pollingInterval$, this.origins$, this.severityLevels$]).pipe(first(), switchMap(([interval, origins, levels]) => this.dataHttpService.getNotificationsStream(Object.assign(Object.assign({ interval }, (origins.length && { origins })), (levels && { levels: levels.join(', ') })), 'response')), map(fromHttpResponse));
    }
    removeNotificationItemFromStream(notificationId) {
        this.notificationsStream$
            .pipe(first(), map(notificationsStream => notificationsStream.filter(({ id }) => id !== notificationId)))
            .subscribe(notificationsStream => this.notificationsStreamForceUpdate$.next(notificationsStream));
    }
    initializeNotificationsStreamPolling() {
        const pollAndRequest$ = of(undefined).pipe(tap(() => this.polling$.next()), switchMap(() => this.requestNotificationsStream()));
        const pollingNotificationsStream$ = this.polling$.pipe(switchMap(() => this.pollingInterval$), delayWhen(pollingInterval => of().pipe(delay(pollingInterval, leaveZone(this.ngZone, asyncScheduler)))), switchMap(() => pollAndRequest$), observeOn(enterZone(this.ngZone, asyncScheduler)));
        return merge(this.notificationsStreamForceUpdate$, pollingNotificationsStream$.pipe(switchMap(stream => of([...stream, ...this.notificationsLocalSticky]))), pollAndRequest$.pipe(switchMap(stream => of([...stream, ...this.notificationsLocalSticky])))).pipe(shareReplayOnce());
    }
}
/** @nocollapse */ NotificationsPopupsDataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsDataService, deps: [{ token: i1$1.NotificationsHttpService }, { token: i0.NgZone }, { token: WidgetPropertiesService }, { token: PUBSUB }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPopupsDataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsDataService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsDataService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.NotificationsHttpService }, { type: i0.NgZone }, { type: WidgetPropertiesService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PUBSUB]
                }] }]; } });

class NotificationsPopupsRouterService {
    constructor() {
        this.popupsRoutingSubject = new Subject();
        /**
         * Popups notification routing stream
         */
        this.popupsRouting$ = this.popupsRoutingSubject.asObservable();
    }
    /**
     * Emit popups routing
     *
     * @param routing Notification routing data
     */
    emitPopupsRouting(routing) {
        this.popupsRoutingSubject.next(routing);
    }
}
/** @nocollapse */ NotificationsPopupsRouterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsRouterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NotificationsPopupsRouterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsRouterService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsRouterService, decorators: [{
            type: Injectable
        }] });

class NotificationsStickyListItemComponent {
    constructor() {
        /**
         * Notification stream item close event
         * Emits notification stream item id
         */
        // eslint-disable-next-line @angular-eslint/no-output-native
        this.close = new EventEmitter();
    }
    /**
     * Method to handle close event from alert component
     *
     * @param notification Notification data
     */
    onClose(notification) {
        this.close.emit(notification);
    }
    /**
     * Method to parse severity level into alert modifier
     *
     * @param level Severity level
     * @returns Notification severity level type
     */
    parseNotificationSeverityLevel(level) {
        return parseNotificationSeverityLevel(level);
    }
}
/** @nocollapse */ NotificationsStickyListItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListItemComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsStickyListItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsStickyListItemComponent, selector: "bb-notifications-sticky-list-item", inputs: { notification: "notification" }, outputs: { close: "close" }, ngImport: i0, template: "<ng-container\n  bbNotificationsStickyListItemCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"notification\"\n></ng-container>\n\n<ng-template bbNotificationsStickyListItemCustomizable let-host let-notification=\"context\">\n  <bb-alert-ui\n    [dismissible]=\"true\"\n    [modifier]=\"host.parseNotificationSeverityLevel(notification?.level)\"\n    [title]=\"notification?.title || ''\"\n    (close)=\"host.onClose(notification)\"\n  >\n    <div\n      class=\"bb-subtitle\"\n      data-role=\"notification-sticky-message\"\n      [innerHTML]=\"notification?.message | interpolateLink: notification:true:'alert-link'\"\n    ></div>\n  </bb-alert-ui>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i1$2.AlertComponent; }), selector: "bb-alert-ui", inputs: ["modifier", "dismissible", "title", "message"], outputs: ["close"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsStickyListItemCustomizableDirective; }), selector: "[bbNotificationsStickyListItemCustomizable]" }], pipes: { "interpolateLink": i0.forwardRef(function () { return i5.ӨInterpolateLinkPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-sticky-list-item',
                    templateUrl: './notifications-sticky-list-item.component.html',
                }]
        }], propDecorators: { notification: [{
                type: Input
            }], close: [{
                type: Output
            }] } });
class NotificationsStickyListItemCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsStickyListItemCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListItemCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsStickyListItemCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsStickyListItemCustomizableDirective, selector: "[bbNotificationsStickyListItemCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListItemCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsStickyListItemCustomizable]',
                }]
        }] });

class NotificationsStickyListComponent {
    constructor(dataService, elem) {
        this.dataService = dataService;
        this.elem = elem;
        /**
         * Notification sticky stream data
         */
        this.notifications$ = this.dataService.stickyNotificationsStream$;
    }
    /**
     * Method to call mark notification as read request by id
     *
     * @param notification Notification data
     */
    onReadNotification(notification) {
        this.dataService.markNotificationAsRead(notification);
        const notifications = this.elem.nativeElement.querySelectorAll('bb-notifications-sticky-list-item');
        const deletedNotificationIndex$ = this.notifications$.pipe(map((notificationElements) => notificationElements.findIndex(item => typeof notification === 'string' ? notification === item.id : notification.id === item.id)));
        deletedNotificationIndex$.pipe(first()).subscribe(index => {
            if (notifications[index + 1]) {
                notifications[index + 1].getElementsByTagName('button')[0].focus();
            }
            else if (notifications[index - 1]) {
                notifications[index - 1].getElementsByTagName('button')[0].focus();
            }
            else if (this.previousFocusedElement) {
                this.previousFocusedElement.focus();
            }
        });
    }
    /**
     * Method to differentiate notifications by IDs.
     *
     * @param _index List item index
     * @param notification Notification list item
     * @returns Notification id
     */
    trackById(_index, notification) {
        return notification.id;
    }
    /**
     * Method to change focus.
     *
     * @param event Focus event
     */
    onFocus(event) {
        if (!this.previousFocusedElement) {
            this.previousFocusedElement = event.relatedTarget;
        }
    }
}
/** @nocollapse */ NotificationsStickyListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListComponent, deps: [{ token: NotificationsPopupsDataService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsStickyListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsStickyListComponent, selector: "bb-notifications-sticky-list", ngImport: i0, template: "<ng-container\n  bbNotificationsStickyListCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"{\n    notifications: notifications$ | async\n  }\"\n></ng-container>\n\n<ng-template bbNotificationsStickyListCustomizable let-host let-notifications=\"context.notifications\">\n  <bb-notifications-sticky-list-item\n    (focusin)=\"host.onFocus($event)\"\n    *ngFor=\"let item of notifications; trackBy: host.trackById\"\n    [notification]=\"item\"\n    (close)=\"host.onReadNotification($event)\"\n  ></bb-notifications-sticky-list-item>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return NotificationsStickyListItemComponent; }), selector: "bb-notifications-sticky-list-item", inputs: ["notification"], outputs: ["close"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsStickyListCustomizableDirective; }), selector: "[bbNotificationsStickyListCustomizable]" }, { type: i0.forwardRef(function () { return i3.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i0.forwardRef(function () { return i3.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-sticky-list',
                    templateUrl: './notifications-sticky-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: NotificationsPopupsDataService }, { type: i0.ElementRef }]; } });
class NotificationsStickyListCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsStickyListCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsStickyListCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsStickyListCustomizableDirective, selector: "[bbNotificationsStickyListCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsStickyListCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsStickyListCustomizable]',
                }]
        }] });

/** @dynamic */
class NotificationsPopupsItemComponent {
    constructor(notificationService, dataService, routerService, properties) {
        this.notificationService = notificationService;
        this.dataService = dataService;
        this.routerService = routerService;
        this.properties = properties;
        /**
         * Notification close delay timeout
         */
        this.notificationTimeout = 0;
        /**
         * Routes available for navigation.
         */
        this.allowedRoutes$ = this.properties.allowedRoutes$;
        /**
         * Stream of widget property with a flag that defines if notification popup should be auto-focused.
         */
        this.autofocus$ = this.properties.autofocus$;
        /**
         * Stream of widget property with a flag that defines if we should display Show More button.
         */
        this.displayShowMoreButtonInPopup$ = this.properties.displayShowMoreButtonInPopup$;
        /**
         * Stream of widget property with the number of lines to show as a notification message.
         */
        this.popupMessageLineAmount$ = this.properties.popupMessageLineAmount$;
        /**
         * The boolean flag that shows if the notification message text exceeds the number of visible lines and is truncated.
         */
        this.isMessageTruncated = false;
        /**
         * destroy$ should emit only when component is destroyed to
         * signal subscriptions to unsubscribe.
         */
        this.destroy$ = new Subject();
    }
    ngAfterViewInit() {
        if (this.notification) {
            combineLatest([this.allowedRoutes$, this.displayShowMoreButtonInPopup$, this.autofocus$])
                .pipe(map(([routes, isShowMoreButtonEnabled, autofocus]) => [
                this.hasRouting(routes),
                isShowMoreButtonEnabled,
                autofocus,
            ]), takeUntil(this.destroy$))
                .subscribe((preferences) => {
                this.createNotificationPopup(preferences);
            });
        }
    }
    /**
     * Open notification details in external widget
     *
     * @param event Click event
     */
    openNotificationDetails(event) {
        event.stopPropagation();
        const routing = {
            ['where-to']: 'notification-details',
            data: this.notification,
        };
        this.readNotification(this.notification);
        this.routerService.emitPopupsRouting(routing);
        this.hideNotification();
    }
    /**
     * Set truncation status of notification message
     *
     * @param isMessageTruncated Is message truncated flag
     */
    setIsContentTruncated(isMessageTruncated) {
        this.isMessageTruncated = isMessageTruncated;
    }
    createNotificationPopup([hasRouting, isShowMoreButtonEnabled, autofocus]) {
        this.hideNotification = this.notificationService.showNotification(Object.assign(Object.assign(Object.assign({ modifier: parseNotificationSeverityLevel(this.notification.level), header: this.popupHeaderTemplate, message: this.popupMessageTemplate, ttl: secondsToMilliseconds(this.notificationTimeout), closeAction: this.readNotification.bind(this, this.notification) }, (hasRouting && {
            hostAction: this.navigateFromPopup.bind(this),
        })), (!hasRouting &&
            isShowMoreButtonEnabled && {
            hostAction: this.openNotificationDetails.bind(this),
        })), { autofocus }));
    }
    readNotification(notification) {
        this.dataService.markNotificationAsRead(notification);
    }
    hasRouting(routes) {
        const route = this.notification.routing && this.notification.routing['where-to'];
        return Boolean(this.notification.routing) && routes.some(allowedRoute => route === allowedRoute);
    }
    navigateFromPopup() {
        this.readNotification(this.notification);
        if (this.notification.routing) {
            this.routerService.emitPopupsRouting(this.notification.routing);
        }
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
/** @nocollapse */ NotificationsPopupsItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsItemComponent, deps: [{ token: i1$3.NotificationService }, { token: NotificationsPopupsDataService }, { token: NotificationsPopupsRouterService }, { token: WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsPopupsItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsPopupsItemComponent, selector: "bb-notifications-popups-item", inputs: { notification: "notification", notificationTimeout: "notificationTimeout" }, viewQueries: [{ propertyName: "popupHeaderTemplate", first: true, predicate: ["popupHeader"], descendants: true }, { propertyName: "popupMessageTemplate", first: true, predicate: ["popupMessage"], descendants: true }], ngImport: i0, template: "<ng-template #popupHeader>\n  <ng-container\n    bbNotificationsPopupsItemHeaderCustomizable\n    [bbHostRef]=\"this\"\n    [bbTemplateContext]=\"notification\"\n  ></ng-container>\n</ng-template>\n\n<ng-template #popupMessage>\n  <ng-container bbNotificationsPopupsItemMessageCustomizable [bbHostRef]=\"this\" [bbTemplateContext]=\"notification\">\n  </ng-container>\n</ng-template>\n\n<ng-template bbNotificationsPopupsItemHeaderCustomizable let-hostRef let-notification=\"context\">\n  <span class=\"sr-only\"> {{ notification?.level || '' }}, </span>\n  <span [innerHTML]=\"notification | notificationLocalization: 'title'\"></span>\n</ng-template>\n\n<ng-template bbNotificationsPopupsItemMessageCustomizable let-hostRef let-notification=\"context\">\n  <ng-container\n    *ngTemplateOutlet=\"(hostRef.popupMessageLineAmount$ | async) ? truncatedMessageContent : messageContent\"\n  ></ng-container>\n  <bb-notifications-capability-icon [origin]=\"notification?.origin\"></bb-notifications-capability-icon>\n  <button\n    type=\"button\"\n    *ngIf=\"hostRef.isMessageTruncated && (hostRef.displayShowMoreButtonInPopup$ | async)\"\n    class=\"btn-link-text bb-text-bold bb-notification__details-button\"\n    (click)=\"hostRef.openNotificationDetails($event)\"\n    aria-label=\"See more notification details\"\n    i18n=\"Notification pop-up See more button@notification.popup.see-more.button\"\n    i18n-aria-label=\"Aria-label for See more button@@notification.popup.see-more.button.aria-label\"\n  >\n    <span>See more</span>\n  </button>\n\n  <ng-template #messageContent>\n    <div class=\"bb-block\" bbIsElementContentTruncated [hostRef]=\"hostRef\">\n      <div\n        [innerHTML]=\"\n          notification\n            | notificationLocalization: 'message'\n            | interpolateLink: notification:true:'bb-notification__message-link'\n        \"\n      ></div>\n    </div>\n  </ng-template>\n\n  <ng-template #truncatedMessageContent>\n    <bb-ellipsis-ui [tooltipTriggers]=\"''\" [lineClamp]=\"hostRef.popupMessageLineAmount$ | async\">\n      <ng-container *ngTemplateOutlet=\"messageContent\"></ng-container>\n    </bb-ellipsis-ui>\n  </ng-template>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return i5.NotificationsCapabilityIconComponent; }), selector: "bb-notifications-capability-icon", inputs: ["origin"] }, { type: i0.forwardRef(function () { return i6.EllipsisComponent; }), selector: "bb-ellipsis-ui", inputs: ["text", "tooltipTriggers", "lineClamp"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsPopupsItemHeaderCustomizableDirective; }), selector: "[bbNotificationsPopupsItemHeaderCustomizable]" }, { type: i0.forwardRef(function () { return NotificationsPopupsItemMessageCustomizableDirective; }), selector: "[bbNotificationsPopupsItemMessageCustomizable]" }, { type: i0.forwardRef(function () { return i3.NgTemplateOutlet; }), selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i0.forwardRef(function () { return i3.NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i0.forwardRef(function () { return i5.ӨIsElementContentTruncatedDirective; }), selector: "[bbIsElementContentTruncated]", inputs: ["hostRef"] }], pipes: { "notificationLocalization": i0.forwardRef(function () { return i5.ӨNotificationLocalizationPipe; }), "async": i0.forwardRef(function () { return i3.AsyncPipe; }), "interpolateLink": i0.forwardRef(function () { return i5.ӨInterpolateLinkPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-popups-item',
                    templateUrl: './notifications-popups-item.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.NotificationService }, { type: NotificationsPopupsDataService }, { type: NotificationsPopupsRouterService }, { type: WidgetPropertiesService }]; }, propDecorators: { notification: [{
                type: Input
            }], notificationTimeout: [{
                type: Input
            }], popupHeaderTemplate: [{
                type: ViewChild,
                args: ['popupHeader']
            }], popupMessageTemplate: [{
                type: ViewChild,
                args: ['popupMessage']
            }] } });
class NotificationsPopupsItemHeaderCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsPopupsItemHeaderCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsItemHeaderCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsPopupsItemHeaderCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsPopupsItemHeaderCustomizableDirective, selector: "[bbNotificationsPopupsItemHeaderCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsItemHeaderCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsPopupsItemHeaderCustomizable]',
                }]
        }] });
class NotificationsPopupsItemMessageCustomizableDirective extends BbTemplate {
}
/** @nocollapse */ NotificationsPopupsItemMessageCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsItemMessageCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsPopupsItemMessageCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsPopupsItemMessageCustomizableDirective, selector: "[bbNotificationsPopupsItemMessageCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsItemMessageCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsPopupsItemMessageCustomizable]',
                }]
        }] });

const DEFAULT_NOTIFICATION_TIMEOUT = 5;
class NotificationsPopupsListComponent {
    constructor(dataService) {
        this.dataService = dataService;
        /**
         * Notification popups stream data in reversed order
         */
        this.popups$ = this.dataService.popupsNotificationsStream$.pipe(map(this.parsePopupsData));
    }
    /**
     * Method to parse popups stream data in reversed order
     * for correct rendering by show notificaton service
     */
    parsePopupsData(array) {
        return array.reverse();
    }
    /**
     * Method to get close notification timeout value for each popup
     *
     * @param index List item index
     * @param length List length
     * @returns Number of seconds before notification popup close
     */
    getNotificationTimeoutByIndex(index, length) {
        return DEFAULT_NOTIFICATION_TIMEOUT + length - index - 1;
    }
}
/** @nocollapse */ NotificationsPopupsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsListComponent, deps: [{ token: NotificationsPopupsDataService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsPopupsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsPopupsListComponent, selector: "bb-notifications-popups-list", ngImport: i0, template: "<ng-container\n  bbNotificationsPopupsListCustomizable\n  [bbHostRef]=\"this\"\n  [bbTemplateContext]=\"popups$ | async\"\n></ng-container>\n\n<ng-template bbNotificationsPopupsListCustomizable let-hostRef let-notifications=\"context\">\n  <bb-notifications-popups-item\n    *ngFor=\"let notification of notifications; index as i\"\n    [notification]=\"notification\"\n    [notificationTimeout]=\"hostRef.getNotificationTimeoutByIndex(i, notifications.length)\"\n  >\n  </bb-notifications-popups-item>\n</ng-template>\n", components: [{ type: i0.forwardRef(function () { return NotificationsPopupsItemComponent; }), selector: "bb-notifications-popups-item", inputs: ["notification", "notificationTimeout"] }], directives: [{ type: i0.forwardRef(function () { return NotificationsPopupsListCustomizableDirective; }), selector: "[bbNotificationsPopupsListCustomizable]" }, { type: i0.forwardRef(function () { return i3.NgForOf; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "async": i0.forwardRef(function () { return i3.AsyncPipe; }) } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-popups-list',
                    templateUrl: './notifications-popups-list.component.html',
                }]
        }], ctorParameters: function () { return [{ type: NotificationsPopupsDataService }]; } });
class NotificationsPopupsListCustomizableDirective extends BbTemplate$1 {
}
/** @nocollapse */ NotificationsPopupsListCustomizableDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsListCustomizableDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ NotificationsPopupsListCustomizableDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsPopupsListCustomizableDirective, selector: "[bbNotificationsPopupsListCustomizable]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsListCustomizableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbNotificationsPopupsListCustomizable]',
                }]
        }] });

/* eslint-disable @angular-eslint/no-input-rename */
class NotificationsPopupsWidgetComponent {
    constructor(routerService, properties) {
        this.routerService = routerService;
        this.properties = properties;
        /**
         * Navigation Data emitter.
         */
        this.notificationRouting = new EventEmitter();
        this.destroy$ = new Subject();
    }
    /**
     * Comma-separated list of notifications origins to process (empty for all).
     */
    set originsValue(value) {
        if (value !== undefined) {
            this.properties.setOrigins(value);
        }
    }
    /**
     * Comma-separated list of notifications severity levels to process (empty for all).
     */
    set severityLevelsValue(value) {
        if (value !== undefined) {
            this.properties.setSeverityLevels(value);
        }
    }
    /**
     * Polling interval (in seconds).
     */
    set pollingIntervalValue(value) {
        if (value !== undefined) {
            this.properties.setPollingInterval(value);
        }
    }
    /**
     * String of allowed routes for navigation (conversation-view, arrangement-view, transaction-view, party-view, etc.).
     */
    set allowedRoutesValue(value) {
        if (value !== undefined) {
            this.properties.setAllowedRoutes(value);
        }
    }
    /**
     * Auto-focus.
     */
    set autofocusValue(value) {
        if (value !== undefined) {
            this.properties.setAutofocus(value);
        }
    }
    /**
     * Display See More button.
     */
    set displayShowMoreButtonInPopupValue(value) {
        if (value !== undefined) {
            this.properties.setDisplayShowMoreButtonInPopup(value);
        }
    }
    /**
     * Number of displayed lines in notification message emitter.
     */
    set popupMessageLineAmountValue(value) {
        if (value !== undefined) {
            this.properties.setPopupMessageLineAmount(value);
        }
    }
    ngOnInit() {
        this.routerService.popupsRouting$.pipe(takeUntil(this.destroy$)).subscribe(this.notificationRouting);
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
}
/** @nocollapse */ NotificationsPopupsWidgetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsWidgetComponent, deps: [{ token: NotificationsPopupsRouterService }, { token: WidgetPropertiesService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ NotificationsPopupsWidgetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NotificationsPopupsWidgetComponent, selector: "bb-notifications-popups-widget", inputs: { originsValue: ["origins", "originsValue"], severityLevelsValue: ["severityLevels", "severityLevelsValue"], pollingIntervalValue: ["pollingInterval", "pollingIntervalValue"], allowedRoutesValue: ["allowedRoutes", "allowedRoutesValue"], autofocusValue: ["autofocus", "autofocusValue"], displayShowMoreButtonInPopupValue: ["displayShowMoreButtonInPopup", "displayShowMoreButtonInPopupValue"], popupMessageLineAmountValue: ["popupMessageLineAmount", "popupMessageLineAmountValue"] }, outputs: { notificationRouting: "notificationRouting" }, providers: [NotificationsPopupsDataService, NotificationsPopupsRouterService, WidgetPropertiesService], ngImport: i0, template: `
    <bb-notifications-sticky-list></bb-notifications-sticky-list>
    <bb-notifications-popups-list></bb-notifications-popups-list>
  `, isInline: true, components: [{ type: NotificationsStickyListComponent, selector: "bb-notifications-sticky-list" }, { type: NotificationsPopupsListComponent, selector: "bb-notifications-popups-list" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsWidgetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-notifications-popups-widget',
                    template: `
    <bb-notifications-sticky-list></bb-notifications-sticky-list>
    <bb-notifications-popups-list></bb-notifications-popups-list>
  `,
                    providers: [NotificationsPopupsDataService, NotificationsPopupsRouterService, WidgetPropertiesService],
                }]
        }], ctorParameters: function () { return [{ type: NotificationsPopupsRouterService }, { type: WidgetPropertiesService }]; }, propDecorators: { originsValue: [{
                type: Input,
                args: ['origins']
            }], severityLevelsValue: [{
                type: Input,
                args: ['severityLevels']
            }], pollingIntervalValue: [{
                type: Input,
                args: ['pollingInterval']
            }], allowedRoutesValue: [{
                type: Input,
                args: ['allowedRoutes']
            }], autofocusValue: [{
                type: Input,
                args: ['autofocus']
            }], displayShowMoreButtonInPopupValue: [{
                type: Input,
                args: ['displayShowMoreButtonInPopup']
            }], popupMessageLineAmountValue: [{
                type: Input,
                args: ['popupMessageLineAmount']
            }], notificationRouting: [{
                type: Output
            }] } });

const components = [
    NotificationsPopupsWidgetComponent,
    NotificationsStickyListComponent,
    NotificationsStickyListItemComponent,
    NotificationsPopupsListComponent,
    NotificationsPopupsItemComponent,
];
const directives = [
    NotificationsStickyListCustomizableDirective,
    NotificationsStickyListItemCustomizableDirective,
    NotificationsPopupsItemHeaderCustomizableDirective,
    NotificationsPopupsItemMessageCustomizableDirective,
    NotificationsPopupsListCustomizableDirective,
];
const uiModules = [AlertModule, EllipsisModule];
class NotificationsPopupsWidgetModule {
}
/** @nocollapse */ NotificationsPopupsWidgetModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsWidgetModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ NotificationsPopupsWidgetModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsWidgetModule, declarations: [NotificationsPopupsWidgetComponent,
        NotificationsStickyListComponent,
        NotificationsStickyListItemComponent,
        NotificationsPopupsListComponent,
        NotificationsPopupsItemComponent, NotificationsStickyListCustomizableDirective,
        NotificationsStickyListItemCustomizableDirective,
        NotificationsPopupsItemHeaderCustomizableDirective,
        NotificationsPopupsItemMessageCustomizableDirective,
        NotificationsPopupsListCustomizableDirective], imports: [CommonModule,
        NotificationsCommonModule, i1.BackbaseCoreModule, AlertModule, EllipsisModule], exports: [NotificationsCommonModule, NotificationsPopupsWidgetComponent,
        NotificationsStickyListComponent,
        NotificationsStickyListItemComponent,
        NotificationsPopupsListComponent,
        NotificationsPopupsItemComponent, NotificationsStickyListCustomizableDirective,
        NotificationsStickyListItemCustomizableDirective,
        NotificationsPopupsItemHeaderCustomizableDirective,
        NotificationsPopupsItemMessageCustomizableDirective,
        NotificationsPopupsListCustomizableDirective, AlertModule, EllipsisModule] });
/** @nocollapse */ NotificationsPopupsWidgetModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsWidgetModule, imports: [[
            CommonModule,
            NotificationsCommonModule,
            BackbaseCoreModule.withConfig({
                classMap: { NotificationsPopupsWidgetComponent },
            }),
            ...uiModules,
        ], NotificationsCommonModule, AlertModule, EllipsisModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NotificationsPopupsWidgetModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [...components, ...directives],
                    imports: [
                        CommonModule,
                        NotificationsCommonModule,
                        BackbaseCoreModule.withConfig({
                            classMap: { NotificationsPopupsWidgetComponent },
                        }),
                        ...uiModules,
                    ],
                    exports: [NotificationsCommonModule, ...components, ...directives, ...uiModules],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NotificationsPopupsWidgetComponent, NotificationsPopupsWidgetModule, WidgetPropertiesService, NotificationsPopupsItemComponent as ӨNotificationsPopupsItemComponent, NotificationsPopupsItemHeaderCustomizableDirective as ӨNotificationsPopupsItemHeaderCustomizableDirective, NotificationsPopupsItemMessageCustomizableDirective as ӨNotificationsPopupsItemMessageCustomizableDirective, NotificationsPopupsListComponent as ӨNotificationsPopupsListComponent, NotificationsPopupsListCustomizableDirective as ӨNotificationsPopupsListCustomizableDirective, NotificationsStickyListComponent as ӨNotificationsStickyListComponent, NotificationsStickyListCustomizableDirective as ӨNotificationsStickyListCustomizableDirective, NotificationsStickyListItemComponent as ӨNotificationsStickyListItemComponent, NotificationsStickyListItemCustomizableDirective as ӨNotificationsStickyListItemCustomizableDirective };
//# sourceMappingURL=backbase-notifications-popups-widget-ang.js.map
