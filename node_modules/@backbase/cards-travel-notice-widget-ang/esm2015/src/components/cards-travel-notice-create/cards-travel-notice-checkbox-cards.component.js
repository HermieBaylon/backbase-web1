import { Component, forwardRef, Input } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "@backbase/ui-ang/input-checkbox";
import * as i3 from "../cards-travel-notice-payment-card/cards-travel-notice-payment-card.component";
import * as i4 from "@angular/common";
export class CardsTravelNoticeCheckboxCardsComponent {
    constructor(fb) {
        this.fb = fb;
        this.indeterminate = false;
        this.onChange = () => { };
        this.onTouched = () => { };
        this.isIndeterminate = () => {
            if (this.checkBoxCardsForm) {
                const cardsIdsControl = this.checkBoxCardsForm.controls['cardIds'].controls;
                const elements = Object.keys(cardsIdsControl);
                const actives = elements.reduce((previous, item) => (cardsIdsControl[item].value ? previous + 1 : previous), 0);
                return actives !== 0 && actives < elements.length;
            }
            return false;
        };
        this.parentChange = (value) => {
            if (this.checkBoxCardsForm) {
                const cardsIdsControl = this.checkBoxCardsForm.controls['cardIds'];
                const newValue = this.createCardsObjectWithDefaultValue(Object.keys(cardsIdsControl.controls), (item) => item, value);
                cardsIdsControl.setValue(newValue);
            }
        };
        this.childChange = (cardIds) => {
            this.indeterminate = this.isIndeterminate();
            const result = Object.keys(cardIds || {}).filter((item) => cardIds[item] === true);
            this.onChange(result.map((item) => this.paymentCards && this.paymentCards.find((card) => card.id === item)));
        };
    }
    createCardsObjectWithDefaultValue(group = [], keyFinder, defaultValue) {
        return group.reduce((acc, cur) => (Object.assign(Object.assign({}, acc), { [keyFinder(cur)]: defaultValue })), {});
    }
    hasCardsSelected(control) {
        const cards = Object.keys(control.controls).find((item) => control.controls[item].value === true);
        // eslint-disable-next-line no-null/no-null
        return cards ? null : { empty: true };
    }
    createForm() {
        const cardsFormGroup = this.createCardsObjectWithDefaultValue(this.paymentCards, (card) => card.id, [
            false,
        ]);
        this.checkBoxCardsForm = this.fb.group({
            parent: [false],
            cardIds: this.fb.group(cardsFormGroup),
        });
        this.checkBoxCardsForm.controls['cardIds'].setValidators(this.hasCardsSelected);
    }
    writeValue(cards) {
        if (this.checkBoxCardsForm && cards && !!this.paymentCards) {
            const cardIds = this.checkBoxCardsForm.controls['cardIds'];
            cards.forEach((item) => cardIds.controls[item.id].setValue(true));
            if (cards.length === this.paymentCards.length) {
                this.checkBoxCardsForm.patchValue({ parent: true });
            }
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    ngOnInit() {
        this.createForm();
        if (this.checkBoxCardsForm) {
            const parentGroup = this.checkBoxCardsForm.controls['parent'];
            const childrenGroup = this.checkBoxCardsForm.controls['cardIds'];
            this.parentSubscription = parentGroup.valueChanges.subscribe(this.parentChange);
            this.childrenSubscription = childrenGroup.valueChanges.subscribe(this.childChange);
        }
    }
    ngOnDestroy() {
        if (this.parentSubscription) {
            this.parentSubscription.unsubscribe();
        }
        if (this.childrenSubscription) {
            this.childrenSubscription.unsubscribe();
        }
    }
}
CardsTravelNoticeCheckboxCardsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CardsTravelNoticeCheckboxCardsComponent, deps: [{ token: i1.FormBuilder }], target: i0.ɵɵFactoryTarget.Component });
CardsTravelNoticeCheckboxCardsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.15", type: CardsTravelNoticeCheckboxCardsComponent, selector: "bb-cards-travel-notice-checkbox-cards", inputs: { paymentCards: "paymentCards" }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            // eslint-disable-next-line @angular-eslint/no-forward-ref
            useExisting: forwardRef(() => CardsTravelNoticeCheckboxCardsComponent),
            multi: true,
        },
    ], ngImport: i0, template: "<form [formGroup]=\"checkBoxCardsForm!\">\n  <ul class=\"list-unstyled\">\n    <li>\n      <div class=\"bb-block bb-block--xl\">\n        <bb-input-checkbox-ui \n          formControlName=\"parent\" \n          label=\"Select all cards\"\n          i18n-label=\"Select all cards@@cards.create.travel.notice.checkbox.label\"\n          i18n=\"Select all cards@@cards.create.travel.notice.checkbox.child\"\n          [indeterminate]=\"indeterminate\"\n        >\n          label=\"Select all cards\"\n        </bb-input-checkbox-ui>\n      </div>\n      <!--card -->\n      <div class=\"row bb-create-travel-notice-card-group\" formGroupName=\"cardIds\">\n        <ng-container *ngFor=\"let paymentCard of paymentCards\">\n          <div class=\"col-lg-6\">\n            <div class=\"bb-block bb-block--xl\">\n              <div class=\"bb-stack\">\n                <div class=\"bb-stack__item\">\n                  <bb-input-checkbox-ui [formControlName]=\"paymentCard.id\">\n                    <div class=\"bb-create-travel-notice-card-group__payment-card\">\n                      <bb-cards-travel-notice-payment-card [paymentCard]=\"paymentCard\"></bb-cards-travel-notice-payment-card>\n                    </div>\n                  </bb-input-checkbox-ui>\n                </div>\n              </div>\n            </div>\n          </div>\n        </ng-container>\n      </div>\n      <!-- end card -->\n    </li>\n  </ul>\n</form>", components: [{ type: i2.InputCheckboxComponent, selector: "bb-input-checkbox-ui", inputs: ["indeterminate"], outputs: ["indeterminateChange"] }, { type: i3.CardsTravelNoticePaymentCardComponent, selector: "bb-cards-travel-notice-payment-card", inputs: ["paymentCard"] }], directives: [{ type: i1.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i1.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i1.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i1.FormControlName, selector: "[formControlName]", inputs: ["disabled", "formControlName", "ngModel"], outputs: ["ngModelChange"] }, { type: i1.FormGroupName, selector: "[formGroupName]", inputs: ["formGroupName"] }, { type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.15", ngImport: i0, type: CardsTravelNoticeCheckboxCardsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-cards-travel-notice-checkbox-cards',
                    templateUrl: 'cards-travel-notice-checkbox-cards.component.html',
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            // eslint-disable-next-line @angular-eslint/no-forward-ref
                            useExisting: forwardRef(() => CardsTravelNoticeCheckboxCardsComponent),
                            multi: true,
                        },
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i1.FormBuilder }]; }, propDecorators: { paymentCards: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZHMtdHJhdmVsLW5vdGljZS1jaGVja2JveC1jYXJkcy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9saWJzL2NhcmRzLXRyYXZlbC1ub3RpY2Utd2lkZ2V0LWFuZy9zcmMvY29tcG9uZW50cy9jYXJkcy10cmF2ZWwtbm90aWNlLWNyZWF0ZS9jYXJkcy10cmF2ZWwtbm90aWNlLWNoZWNrYm94LWNhcmRzLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvY2FyZHMtdHJhdmVsLW5vdGljZS13aWRnZXQtYW5nL3NyYy9jb21wb25lbnRzL2NhcmRzLXRyYXZlbC1ub3RpY2UtY3JlYXRlL2NhcmRzLXRyYXZlbC1ub3RpY2UtY2hlY2tib3gtY2FyZHMuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFxQixNQUFNLGVBQWUsQ0FBQztBQUNoRixPQUFPLEVBQWdELGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7OztBQWdCakcsTUFBTSxPQUFPLHVDQUF1QztJQXNIbEQsWUFBNkIsRUFBZTtRQUFmLE9BQUUsR0FBRixFQUFFLENBQWE7UUEvRzVDLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBa0J0QixhQUFRLEdBQW9ELEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztRQUVyRSxjQUFTLEdBQWUsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDO1FBRWpDLG9CQUFlLEdBQUcsR0FBRyxFQUFFO1lBQ3JCLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO2dCQUMxQixNQUFNLGVBQWUsR0FBSSxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBZSxDQUFDLFFBQVEsQ0FBQztnQkFDM0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENB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IHsgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQnVpbGRlciwgRm9ybUdyb3VwLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFBheW1lbnRDYXJkIH0gZnJvbSAnQGJhY2tiYXNlL2NhcmRzLWNvbW1vbi1hbmcnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2JiLWNhcmRzLXRyYXZlbC1ub3RpY2UtY2hlY2tib3gtY2FyZHMnLFxuICB0ZW1wbGF0ZVVybDogJ2NhcmRzLXRyYXZlbC1ub3RpY2UtY2hlY2tib3gtY2FyZHMuY29tcG9uZW50Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvbm8tZm9yd2FyZC1yZWZcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENhcmRzVHJhdmVsTm90aWNlQ2hlY2tib3hDYXJkc0NvbXBvbmVudCksXG4gICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9LFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDYXJkc1RyYXZlbE5vdGljZUNoZWNrYm94Q2FyZHNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAvKipcbiAgICogUGF5bWVudCBjYXJkIHRvIGJlIGRpc3BsYXllZC5cbiAgICovXG4gIEBJbnB1dCgpIHBheW1lbnRDYXJkczogUGF5bWVudENhcmRbXSB8IHVuZGVmaW5lZDtcblxuICBjaGVja0JveENhcmRzRm9ybTogRm9ybUdyb3VwIHwgdW5kZWZpbmVkO1xuICBpbmRldGVybWluYXRlID0gZmFsc2U7XG4gIHByaXZhdGUgcGFyZW50U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgY2hpbGRyZW5TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGNyZWF0ZUNhcmRzT2JqZWN0V2l0aERlZmF1bHRWYWx1ZShcbiAgICBncm91cDogQXJyYXk8YW55PiA9IFtdLFxuICAgIGtleUZpbmRlcjogKGl0ZW06IGFueSkgPT4gc3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogYW55LFxuICApOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICByZXR1cm4gZ3JvdXAucmVkdWNlKFxuICAgICAgKGFjYywgY3VyKSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIFtrZXlGaW5kZXIoY3VyKV06IGRlZmF1bHRWYWx1ZSxcbiAgICAgIH0pLFxuICAgICAge30sXG4gICAgKTtcbiAgfVxuXG4gIG9uQ2hhbmdlOiAobmV3VmFsdWU6IE9iamVjdCB8IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gIG9uVG91Y2hlZDogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gIGlzSW5kZXRlcm1pbmF0ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5jaGVja0JveENhcmRzRm9ybSkge1xuICAgICAgY29uc3QgY2FyZHNJZHNDb250cm9sID0gKHRoaXMuY2hlY2tCb3hDYXJkc0Zvcm0uY29udHJvbHNbJ2NhcmRJZHMnXSBhcyBGb3JtR3JvdXApLmNvbnRyb2xzO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBPYmplY3Qua2V5cyhjYXJkc0lkc0NvbnRyb2wpO1xuICAgICAgY29uc3QgYWN0aXZlcyA9IGVsZW1lbnRzLnJlZHVjZSgocHJldmlvdXMsIGl0ZW0pID0+IChjYXJkc0lkc0NvbnRyb2xbaXRlbV0udmFsdWUgPyBwcmV2aW91cyArIDEgOiBwcmV2aW91cyksIDApO1xuXG4gICAgICByZXR1cm4gYWN0aXZlcyAhPT0gMCAmJiBhY3RpdmVzIDwgZWxlbWVudHMubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHBhcmVudENoYW5nZSA9ICh2YWx1ZTogYW55KSA9PiB7XG4gICAgaWYgKHRoaXMuY2hlY2tCb3hDYXJkc0Zvcm0pIHtcbiAgICAgIGNvbnN0IGNhcmRzSWRzQ29udHJvbCA9IHRoaXMuY2hlY2tCb3hDYXJkc0Zvcm0uY29udHJvbHNbJ2NhcmRJZHMnXSBhcyBGb3JtR3JvdXA7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuY3JlYXRlQ2FyZHNPYmplY3RXaXRoRGVmYXVsdFZhbHVlKFxuICAgICAgICBPYmplY3Qua2V5cyhjYXJkc0lkc0NvbnRyb2wuY29udHJvbHMpLFxuICAgICAgICAoaXRlbTogc3RyaW5nKSA9PiBpdGVtLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICk7XG4gICAgICBjYXJkc0lkc0NvbnRyb2wuc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGNoaWxkQ2hhbmdlID0gKGNhcmRJZHM6IGFueSkgPT4ge1xuICAgIHRoaXMuaW5kZXRlcm1pbmF0ZSA9IHRoaXMuaXNJbmRldGVybWluYXRlKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXMoY2FyZElkcyB8fCB7fSkuZmlsdGVyKChpdGVtOiBhbnkpID0+IGNhcmRJZHNbaXRlbV0gPT09IHRydWUpO1xuICAgIHRoaXMub25DaGFuZ2UocmVzdWx0Lm1hcCgoaXRlbSkgPT4gdGhpcy5wYXltZW50Q2FyZHMgJiYgdGhpcy5wYXltZW50Q2FyZHMuZmluZCgoY2FyZCkgPT4gY2FyZC5pZCA9PT0gaXRlbSkpKTtcbiAgfTtcblxuICBwcml2YXRlIGhhc0NhcmRzU2VsZWN0ZWQoY29udHJvbDogYW55KSB7XG4gICAgY29uc3QgY2FyZHMgPSBPYmplY3Qua2V5cyhjb250cm9sLmNvbnRyb2xzKS5maW5kKChpdGVtOiBhbnkpID0+IGNvbnRyb2wuY29udHJvbHNbaXRlbV0udmFsdWUgPT09IHRydWUpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW51bGwvbm8tbnVsbFxuICAgIHJldHVybiBjYXJkcyA/IG51bGwgOiB7IGVtcHR5OiB0cnVlIH07XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZUZvcm0oKSB7XG4gICAgY29uc3QgY2FyZHNGb3JtR3JvdXAgPSB0aGlzLmNyZWF0ZUNhcmRzT2JqZWN0V2l0aERlZmF1bHRWYWx1ZSh0aGlzLnBheW1lbnRDYXJkcywgKGNhcmQ6IFBheW1lbnRDYXJkKSA9PiBjYXJkLmlkLCBbXG4gICAgICBmYWxzZSxcbiAgICBdKTtcblxuICAgIHRoaXMuY2hlY2tCb3hDYXJkc0Zvcm0gPSB0aGlzLmZiLmdyb3VwKHtcbiAgICAgIHBhcmVudDogW2ZhbHNlXSxcbiAgICAgIGNhcmRJZHM6IHRoaXMuZmIuZ3JvdXAoY2FyZHNGb3JtR3JvdXApLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jaGVja0JveENhcmRzRm9ybS5jb250cm9sc1snY2FyZElkcyddLnNldFZhbGlkYXRvcnModGhpcy5oYXNDYXJkc1NlbGVjdGVkKTtcbiAgfVxuXG4gIHdyaXRlVmFsdWUoY2FyZHM6IFBheW1lbnRDYXJkW10pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jaGVja0JveENhcmRzRm9ybSAmJiBjYXJkcyAmJiAhIXRoaXMucGF5bWVudENhcmRzKSB7XG4gICAgICBjb25zdCBjYXJkSWRzID0gdGhpcy5jaGVja0JveENhcmRzRm9ybS5jb250cm9sc1snY2FyZElkcyddIGFzIEZvcm1Hcm91cDtcbiAgICAgIGNhcmRzLmZvckVhY2goKGl0ZW0pID0+IGNhcmRJZHMuY29udHJvbHNbaXRlbS5pZF0uc2V0VmFsdWUodHJ1ZSkpO1xuICAgICAgaWYgKGNhcmRzLmxlbmd0aCA9PT0gdGhpcy5wYXltZW50Q2FyZHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tCb3hDYXJkc0Zvcm0ucGF0Y2hWYWx1ZSh7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5jcmVhdGVGb3JtKCk7XG5cbiAgICBpZiAodGhpcy5jaGVja0JveENhcmRzRm9ybSkge1xuICAgICAgY29uc3QgcGFyZW50R3JvdXAgPSB0aGlzLmNoZWNrQm94Q2FyZHNGb3JtLmNvbnRyb2xzWydwYXJlbnQnXTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuR3JvdXAgPSB0aGlzLmNoZWNrQm94Q2FyZHNGb3JtLmNvbnRyb2xzWydjYXJkSWRzJ107XG4gICAgICB0aGlzLnBhcmVudFN1YnNjcmlwdGlvbiA9IHBhcmVudEdyb3VwLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUodGhpcy5wYXJlbnRDaGFuZ2UpO1xuICAgICAgdGhpcy5jaGlsZHJlblN1YnNjcmlwdGlvbiA9IGNoaWxkcmVuR3JvdXAudmFsdWVDaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmNoaWxkQ2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnRTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMucGFyZW50U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW5TdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2hpbGRyZW5TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZiOiBGb3JtQnVpbGRlcikge31cbn1cbiIsIjxmb3JtIFtmb3JtR3JvdXBdPVwiY2hlY2tCb3hDYXJkc0Zvcm0hXCI+XG4gIDx1bCBjbGFzcz1cImxpc3QtdW5zdHlsZWRcIj5cbiAgICA8bGk+XG4gICAgICA8ZGl2IGNsYXNzPVwiYmItYmxvY2sgYmItYmxvY2stLXhsXCI+XG4gICAgICAgIDxiYi1pbnB1dC1jaGVja2JveC11aSBcbiAgICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJwYXJlbnRcIiBcbiAgICAgICAgICBsYWJlbD1cIlNlbGVjdCBhbGwgY2FyZHNcIlxuICAgICAgICAgIGkxOG4tbGFiZWw9XCJTZWxlY3QgYWxsIGNhcmRzQEBjYXJkcy5jcmVhdGUudHJhdmVsLm5vdGljZS5jaGVja2JveC5sYWJlbFwiXG4gICAgICAgICAgaTE4bj1cIlNlbGVjdCBhbGwgY2FyZHNAQGNhcmRzLmNyZWF0ZS50cmF2ZWwubm90aWNlLmNoZWNrYm94LmNoaWxkXCJcbiAgICAgICAgICBbaW5kZXRlcm1pbmF0ZV09XCJpbmRldGVybWluYXRlXCJcbiAgICAgICAgPlxuICAgICAgICAgIGxhYmVsPVwiU2VsZWN0IGFsbCBjYXJkc1wiXG4gICAgICAgIDwvYmItaW5wdXQtY2hlY2tib3gtdWk+XG4gICAgICA8L2Rpdj5cbiAgICAgIDwhLS1jYXJkIC0tPlxuICAgICAgPGRpdiBjbGFzcz1cInJvdyBiYi1jcmVhdGUtdHJhdmVsLW5vdGljZS1jYXJkLWdyb3VwXCIgZm9ybUdyb3VwTmFtZT1cImNhcmRJZHNcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcGF5bWVudENhcmQgb2YgcGF5bWVudENhcmRzXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbC1sZy02XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYmItYmxvY2sgYmItYmxvY2stLXhsXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJiYi1zdGFja1wiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJiYi1zdGFja19faXRlbVwiPlxuICAgICAgICAgICAgICAgICAgPGJiLWlucHV0LWNoZWNrYm94LXVpIFtmb3JtQ29udHJvbE5hbWVdPVwicGF5bWVudENhcmQuaWRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImJiLWNyZWF0ZS10cmF2ZWwtbm90aWNlLWNhcmQtZ3JvdXBfX3BheW1lbnQtY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxiYi1jYXJkcy10cmF2ZWwtbm90aWNlLXBheW1lbnQtY2FyZCBbcGF5bWVudENhcmRdPVwicGF5bWVudENhcmRcIj48L2JiLWNhcmRzLXRyYXZlbC1ub3RpY2UtcGF5bWVudC1jYXJkPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvYmItaW5wdXQtY2hlY2tib3gtdWk+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC9kaXY+XG4gICAgICA8IS0tIGVuZCBjYXJkIC0tPlxuICAgIDwvbGk+XG4gIDwvdWw+XG48L2Zvcm0+Il19