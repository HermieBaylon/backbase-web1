import { Subject, combineLatest } from 'rxjs';
import { takeUntil, pluck, distinctUntilChanged, startWith, skip, filter, } from 'rxjs/operators';
import { ProductKinds, } from '../models/form-items.model';
import { CounterPartyFields, HiddenFields, PaymentBaseFields, RemittanceInfoFields, ScheduleFields, } from '../models/form-item-names.model';
import { getEndDate } from '../../ui/helpers/date-helpers';
import { Frequencies, ScheduleEndType } from '../../ui/constants/constants';
export function scheduleEndTypeToggleDependants(value) {
    switch (value) {
        case ScheduleEndType.ON:
            return [ScheduleFields.endDate];
        case ScheduleEndType.AFTER:
            return [ScheduleFields.repeat];
        default:
            return;
    }
}
export function scheduleFrequencyToggleDependants(value) {
    return value !== Frequencies.ONCE ? [ScheduleFields.endType] : undefined;
}
let onDestroyStartDate$;
let onDestroyEndDate$;
const getNgbTime = (date) => new Date(date.year, date.month - 1, date.day).getTime();
const oneDay = 24 * 60 * 60 * 1000;
export function scheduleStartDateOnDestroyHook() {
    if (onDestroyStartDate$) {
        onDestroyStartDate$.next();
        onDestroyStartDate$.complete();
    }
    if (onDestroyEndDate$) {
        onDestroyEndDate$.next();
        onDestroyEndDate$.complete();
    }
}
export function scheduleStartDateOnInitHook({ control, group, component, }) {
    onDestroyStartDate$ = new Subject();
    if (group) {
        group.valueChanges
            .pipe(takeUntil(onDestroyStartDate$), pluck(ScheduleFields.frequency), distinctUntilChanged())
            .subscribe((value) => {
            if (value === Frequencies.ONCE) {
                component.options.label = 'Execution date';
            }
            else {
                component.options.label = 'Start on';
            }
            component.options.markDisabled = (date) => getNgbTime(date) < new Date().getTime() - oneDay;
        });
    }
}
export function scheduleEndDateOnInitHook({ control, group, component, }) {
    onDestroyEndDate$ = new Subject();
    const startDate = group && group.get(ScheduleFields.startDate);
    const frequency = group && group.get(ScheduleFields.frequency);
    const endType = group && group.get(ScheduleFields.endType);
    if (startDate && !startDate.pristine && frequency && control.pristine) {
        control.patchValue(getEndDate(frequency.value, startDate.value));
    }
    if (startDate && frequency && endType) {
        combineLatest([
            startDate.valueChanges.pipe(startWith(startDate.value), distinctUntilChanged()),
            frequency.valueChanges.pipe(startWith(frequency.value), distinctUntilChanged()),
            endType.valueChanges.pipe(startWith(endType.value), distinctUntilChanged()),
        ])
            .pipe(takeUntil(onDestroyEndDate$), skip(1))
            .subscribe(() => {
            if (control) {
                const endDate = getEndDate(frequency.value, startDate.value);
                control.patchValue(endDate);
                component.options.markDisabled = (date) => getNgbTime(date) < new Date(endDate || '').getTime();
            }
        });
    }
}
export function toggleForAmountOptions(_, control, amountOptions) {
    var _a, _b, _c, _d;
    const selectedAccKind = control && control.parent ? (_a = control.parent.value) === null || _a === void 0 ? void 0 : _a.productKindName : null;
    const product = control && control.parent
        ? (_c = (_b = control.parent.value) === null || _b === void 0 ? void 0 : _b.accountData) === null || _c === void 0 ? void 0 : _c.defaultRecord
        : null;
    const isAmountOptionsZero = (_d = amountOptions === null || amountOptions === void 0 ? void 0 : amountOptions.creditCard) === null || _d === void 0 ? void 0 : _d.every((option) => (option === null || option === void 0 ? void 0 : option.amountApiField)
        ? Number(product === null || product === void 0 ? void 0 : product[option.amountApiField]) === 0
        : true);
    if (selectedAccKind === ProductKinds.creditCard ||
        selectedAccKind === ProductKinds.loanAccount) {
        const items = [RemittanceInfoFields.amountOptions];
        if (selectedAccKind === ProductKinds.creditCard && isAmountOptionsZero) {
            items.push(RemittanceInfoFields.amountCurrencyGroup);
        }
        return [
            {
                parent: PaymentBaseFields.remittanceInfo,
                items,
            },
        ];
    }
    return [
        {
            parent: PaymentBaseFields.remittanceInfo,
            items: [
                RemittanceInfoFields.description,
                RemittanceInfoFields.amountCurrencyGroup,
            ],
        },
    ];
}
// Internal transfer onInit-onDestroy hooks
let internalTransferDestroy$;
export function internalTransferScheduleFreqOnInitHook({ control, group, component, }) {
    var _a, _b, _c, _d;
    internalTransferDestroy$ = new Subject();
    const initialOptions = component.options.options;
    const frequencyCtrl = (_b = (_a = group.parent) === null || _a === void 0 ? void 0 : _a.get(PaymentBaseFields.remittanceInfo)) === null || _b === void 0 ? void 0 : _b.get('scheduleFrequency');
    const paymentType$ = (_d = (_c = group.parent) === null || _c === void 0 ? void 0 : _c.get('paymentType')) === null || _d === void 0 ? void 0 : _d.valueChanges;
    paymentType$ === null || paymentType$ === void 0 ? void 0 : paymentType$.pipe(takeUntil(internalTransferDestroy$)).subscribe((paymentType) => {
        if (paymentType === 'EXTERNAL_A2A') {
            const optionsWithoutDaily = initialOptions.filter((opt) => opt.value !== Frequencies.DAILY);
            component.options.options = optionsWithoutDaily;
        }
        else {
            component.options.options = initialOptions;
        }
        component.toggleDependants();
    });
    frequencyCtrl === null || frequencyCtrl === void 0 ? void 0 : frequencyCtrl.valueChanges.pipe(takeUntil(internalTransferDestroy$), startWith(frequencyCtrl.value)).subscribe((scheduleFrequency) => {
        const scheduleOptions = scheduleFrequency || initialOptions;
        component.options.options = scheduleOptions;
        const isFreqExistInOptions = scheduleOptions.find(({ value }) => value === control.value);
        // Check whether previously selected frequency is in options
        if (!isFreqExistInOptions) {
            control.setValue(component.options.defaultValue);
            component.toggleDependants();
        }
    });
}
export function internalTransferOnDestroyHook() {
    if (internalTransferDestroy$) {
        internalTransferDestroy$.next();
        internalTransferDestroy$.complete();
    }
}
export function internalTransferScheduleAlertOnInitHook({ group, component, }) {
    var _a, _b;
    internalTransferDestroy$ = new Subject();
    const { config, options } = component;
    (_b = (_a = group === null || group === void 0 ? void 0 : group.parent) === null || _a === void 0 ? void 0 : _a.get(PaymentBaseFields.counterparty)) === null || _b === void 0 ? void 0 : _b.valueChanges.pipe(filter((account) => {
        const isCreditCardOrLoan = [
            ProductKinds.creditCard,
            ProductKinds.loanAccount,
        ].includes(account === null || account === void 0 ? void 0 : account.productKindName);
        config.hidden = !isCreditCardOrLoan;
        return isCreditCardOrLoan;
    }), takeUntil(internalTransferDestroy$)).subscribe((account) => {
        var _a, _b, _c, _d, _e;
        const dueDate = new Date((_b = (_a = account === null || account === void 0 ? void 0 : account.accountData) === null || _a === void 0 ? void 0 : _a.defaultRecord) === null || _b === void 0 ? void 0 : _b.minimumPaymentDueDate);
        if (dueDate) {
            const fullMonth = dueDate.toLocaleDateString('default', {
                month: 'long',
            });
            const formattedDueDate = `${fullMonth} ${dueDate.getDate()}, ${dueDate.getFullYear()}`;
            const alert = new Date().getTime() >= dueDate.getTime()
                ? (_c = options.alerts) === null || _c === void 0 ? void 0 : _c.overdue
                : (_d = options.alerts) === null || _d === void 0 ? void 0 : _d.undue;
            if (alert) {
                alert.description = (_e = alert.description) === null || _e === void 0 ? void 0 : _e.replace('@@date', formattedDueDate);
            }
            component.options = Object.assign(Object.assign({}, options), (alert ? alert : {}));
        }
    });
}
export function internalTransAmountOptToggleDependants(_, control) {
    var _a;
    const showFreqSwitch = control && control.parent
        ? (_a = control.parent.get('showFrequencySwitch')) === null || _a === void 0 ? void 0 : _a.value
        : null;
    const items = showFreqSwitch
        ? [ScheduleFields.frequencySwitch]
        : [ScheduleFields.frequency];
    return [
        {
            parent: PaymentBaseFields.schedule,
            items,
        },
    ];
}
export function internalTransScheduleStartDateOnInitHook({ control, group, component, }) {
    var _a, _b, _c;
    scheduleStartDateOnInitHook({ control, group, component });
    internalTransferDestroy$ = new Subject();
    const { options } = component;
    const defaultDescription = options.description;
    component.options = Object.assign(Object.assign({}, options), { description: '' }); // No description until an account is selected
    const date$ = control === null || control === void 0 ? void 0 : control.valueChanges.pipe(startWith(control.value));
    const account$ = (_b = (_a = group === null || group === void 0 ? void 0 : group.parent) === null || _a === void 0 ? void 0 : _a.get(PaymentBaseFields.counterparty)) === null || _b === void 0 ? void 0 : _b.valueChanges.pipe(startWith((_c = group.parent.get(PaymentBaseFields.counterparty)) === null || _c === void 0 ? void 0 : _c.value), filter((account) => [ProductKinds.creditCard, ProductKinds.loanAccount].includes(account === null || account === void 0 ? void 0 : account.productKindName)));
    combineLatest([account$, date$])
        .pipe(takeUntil(internalTransferDestroy$))
        .subscribe(([account, date]) => {
        var _a, _b;
        const dueDate = new Date((_b = (_a = account === null || account === void 0 ? void 0 : account.accountData) === null || _a === void 0 ? void 0 : _a.defaultRecord) === null || _b === void 0 ? void 0 : _b.minimumPaymentDueDate).getTime();
        const executeDate = new Date(date).getTime();
        if (dueDate && executeDate) {
            component.options.description =
                executeDate >= dueDate && dueDate >= new Date().getTime()
                    ? defaultDescription
                    : '';
        }
    });
}
export function intrabankCheckboxOnInitHook({ control, group, component, }) {
    var _a, _b, _c;
    internalTransferDestroy$ = new Subject();
    const contactNameCtrl = (_a = group.parent) === null || _a === void 0 ? void 0 : _a.get(`${PaymentBaseFields.counterparty}.${CounterPartyFields.name}`);
    const contactNumberCtrl = (_b = group.parent) === null || _b === void 0 ? void 0 : _b.get(`${PaymentBaseFields.counterparty}.${CounterPartyFields.accountNumber}`);
    const selectedContact = (_c = group.parent) === null || _c === void 0 ? void 0 : _c.get(`${PaymentBaseFields.counterparty}.${HiddenFields.selectedBeneficiary}`);
    combineLatest([
        contactNameCtrl === null || contactNameCtrl === void 0 ? void 0 : contactNameCtrl.valueChanges,
        contactNumberCtrl === null || contactNumberCtrl === void 0 ? void 0 : contactNumberCtrl.valueChanges,
        selectedContact === null || selectedContact === void 0 ? void 0 : selectedContact.valueChanges,
    ])
        .pipe(takeUntil(internalTransferDestroy$))
        .subscribe(([typedName, typedAccountNumber, { name, accounts }]) => {
        const { accountNumber, email, phoneNumber } = accounts[0];
        const isFormValuesEqualToSavedContact = typedName === name &&
            [accountNumber, email, phoneNumber].includes(typedAccountNumber);
        component.options.disabled = isFormValuesEqualToSavedContact;
        if (isFormValuesEqualToSavedContact) {
            control.reset();
        }
    });
}
export function internalTransferEndTypeOnInitHook({ group, component, }) {
    var _a, _b;
    internalTransferDestroy$ = new Subject();
    const initialOptions = component.options.options;
    const initialCssClasses = component.options.cssClasses;
    const paymentType$ = (_b = (_a = group.parent) === null || _a === void 0 ? void 0 : _a.get('paymentType')) === null || _b === void 0 ? void 0 : _b.valueChanges;
    paymentType$ === null || paymentType$ === void 0 ? void 0 : paymentType$.pipe(takeUntil(internalTransferDestroy$)).subscribe((paymentType) => {
        if (paymentType === 'EXTERNAL_A2A') {
            component.options.options = initialOptions.filter((opt) => opt.value !== ScheduleEndType.ON);
            component.options.cssClasses = initialCssClasses.filter((i) => i !== 'bb-schedule__end-type');
        }
        else {
            component.options.options = initialOptions;
            component.options.cssClasses = initialCssClasses;
        }
    });
}
export function internalTransferRepeatOnInitHook({ group, component, }) {
    var _a, _b;
    internalTransferDestroy$ = new Subject();
    const initialCssClasses = component.options.cssClasses;
    const paymentType$ = (_b = (_a = group.parent) === null || _a === void 0 ? void 0 : _a.get('paymentType')) === null || _b === void 0 ? void 0 : _b.valueChanges;
    paymentType$ === null || paymentType$ === void 0 ? void 0 : paymentType$.pipe(takeUntil(internalTransferDestroy$)).subscribe((paymentType) => {
        component.options.cssClasses = [
            ...initialCssClasses,
            ...(paymentType === 'EXTERNAL_A2A'
                ? ['bb-schedule__repeat--two-option']
                : []),
        ];
    });
}
//# sourceMappingURL=schedule-config-helpers.js.map