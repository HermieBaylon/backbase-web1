import { Inject, Injectable, Optional } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { BB_PAYMENT_CONFIG, BB_REGISTERED_PAYMENT_CONFIGS } from '../constants';
import { normalizePaymentType } from '../../ui/helpers/payment-config-helpers';
import * as i0 from "@angular/core";
const DEFAULT_KEY = 'DEFAULT';
export class PaymentConfigService {
    constructor(configs, registeredPaymentConfigs) {
        this.paymentConfigRegistry = new BehaviorSubject(new Map(configs
            ? configs.reduce((acc, { paymentType, businessFunction }) => {
                const paymentConfig = Object.assign(paymentType, {
                    businessFunction,
                });
                return [...acc, [paymentConfig.paymentType, paymentConfig]];
            }, [])
            : undefined));
        this.classIdRegistry = new BehaviorSubject(new Map(configs
            ? configs.reduce((acc, { classId, paymentType }) => [
                ...acc,
                [classId || DEFAULT_KEY, paymentType.paymentType],
            ], [])
            : undefined));
        this.configRegistry = new BehaviorSubject(new Map(configs
            ? configs.reduce((acc, config) => [
                ...acc,
                [config.classId || DEFAULT_KEY, config],
            ], [])
            : undefined));
        if (registeredPaymentConfigs && registeredPaymentConfigs.length) {
            registeredPaymentConfigs
                .reduce((acc, val) => acc.concat(val), [])
                .forEach((config) => this.setPaymentConfigByType(config));
        }
    }
    has(paymentType) {
        return this.paymentConfigRegistry.value.has(paymentType);
    }
    hasClassId(classId) {
        return this.classIdRegistry.value.has(classId);
    }
    getPaymentConfigByClassId(classId) {
        const paymentConfigType = this.getBaseConfigByClassId(classId);
        return paymentConfigType && paymentConfigType.paymentType;
    }
    getPaymentConfigByType(paymentType) {
        return this.paymentConfigRegistry.value.get(paymentType);
    }
    mapPaymentType(item) {
        var _a;
        const paymentType = typeof item === 'string'
            ? item
            : item.details.paymentType;
        const _paymentType = normalizePaymentType(paymentType);
        return _paymentType
            ? (_a = this.getPaymentConfigByType(_paymentType)) === null || _a === void 0 ? void 0 : _a.name
            : undefined;
    }
    getBaseConfigByClassId(classId) {
        return (this.configRegistry.value.get(classId) ||
            this.configRegistry.value.get(DEFAULT_KEY));
    }
    setPaymentConfigByType(config) {
        const _value = this.paymentConfigRegistry.value;
        _value.set(config.paymentType, config);
        this.paymentConfigRegistry.next(_value);
    }
}
/** @nocollapse */ PaymentConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentConfigService, deps: [{ token: BB_PAYMENT_CONFIG, optional: true }, { token: BB_REGISTERED_PAYMENT_CONFIGS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ PaymentConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentConfigService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentConfigService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: Array, decorators: [{
                    type: Inject,
                    args: [BB_PAYMENT_CONFIG]
                }, {
                    type: Optional
                }] }, { type: Array, decorators: [{
                    type: Inject,
                    args: [BB_REGISTERED_PAYMENT_CONFIGS]
                }, {
                    type: Optional
                }] }]; } });
//# sourceMappingURL=payment-config.service.js.map