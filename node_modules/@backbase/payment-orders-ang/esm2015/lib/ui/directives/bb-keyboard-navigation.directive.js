import { ContentChild, ContentChildren, Directive, ElementRef, forwardRef, Inject, QueryList, } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import * as i0 from "@angular/core";
export class KeyboardNavigationDirectiveBase {
}
export class KeyboardNavigationItemDirective {
    constructor(navigator, elementRef) {
        this.navigator = navigator;
        this.elementRef = elementRef;
    }
}
/** @nocollapse */ KeyboardNavigationItemDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationItemDirective, deps: [{ token: forwardRef(() => KeyboardNavigationDirective) }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ KeyboardNavigationItemDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: KeyboardNavigationItemDirective, selector: "[bbKeyboardNavigationItem]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbKeyboardNavigationItem]',
                }]
        }], ctorParameters: function () { return [{ type: KeyboardNavigationDirectiveBase, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => KeyboardNavigationDirective)]
                }] }, { type: i0.ElementRef }]; } });
export class KeyboardNavigationAnchorDirective {
    constructor(navigator, elementRef) {
        this.navigator = navigator;
        this.elementRef = elementRef;
        this.nativeElement = this.elementRef.nativeElement;
    }
}
/** @nocollapse */ KeyboardNavigationAnchorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationAnchorDirective, deps: [{ token: forwardRef(() => KeyboardNavigationDirective) }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ KeyboardNavigationAnchorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: KeyboardNavigationAnchorDirective, selector: "[bbKeyboardNavigationAnchor]", host: { listeners: { "keydown.ArrowLeft": "navigator.onKeyDown($event)", "keydown.ArrowRight": "navigator.onKeyDown($event)", "keydown.ArrowDown": "navigator.onKeyDown($event)", "keydown.Tab": "navigator.onKeyDown($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationAnchorDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbKeyboardNavigationAnchor]',
                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                    host: {
                        '(keydown.ArrowLeft)': 'navigator.onKeyDown($event)',
                        '(keydown.ArrowRight)': 'navigator.onKeyDown($event)',
                        '(keydown.ArrowDown)': 'navigator.onKeyDown($event)',
                        '(keydown.Tab)': 'navigator.onKeyDown($event)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: KeyboardNavigationDirectiveBase, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => KeyboardNavigationDirective)]
                }] }, { type: i0.ElementRef }]; } });
export class KeyboardNavigationListDirective {
    constructor(navigator, elementRef) {
        this.navigator = navigator;
        this.elementRef = elementRef;
        this.nativeElement = this.elementRef.nativeElement;
    }
}
/** @nocollapse */ KeyboardNavigationListDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationListDirective, deps: [{ token: forwardRef(() => KeyboardNavigationDirective) }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ KeyboardNavigationListDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: KeyboardNavigationListDirective, selector: "[bbKeyboardNavigationList]", host: { listeners: { "keydown.ArrowUp": "navigator.onKeyDown($event)", "keydown.ArrowDown": "navigator.onKeyDown($event)", "keydown.Shift": "navigator.onKeyDown($event)", "keydown.Tab": "navigator.onKeyDown($event)", "keydown.Shift.Tab": "navigator.onKeyDown($event)", "keydown.Space": "navigator.onKeyDown($event)", "keydown.Enter": "navigator.onKeyDown($event)" } }, queries: [{ propertyName: "items", predicate: KeyboardNavigationItemDirective, descendants: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationListDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbKeyboardNavigationList]',
                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property
                    host: {
                        '(keydown.ArrowUp)': 'navigator.onKeyDown($event)',
                        '(keydown.ArrowDown)': 'navigator.onKeyDown($event)',
                        '(keydown.Shift)': 'navigator.onKeyDown($event)',
                        '(keydown.Tab)': 'navigator.onKeyDown($event)',
                        '(keydown.Shift.Tab)': 'navigator.onKeyDown($event)',
                        '(keydown.Space)': 'navigator.onKeyDown($event)',
                        '(keydown.Enter)': 'navigator.onKeyDown($event)',
                    },
                }]
        }], ctorParameters: function () { return [{ type: KeyboardNavigationDirectiveBase, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => KeyboardNavigationDirective)]
                }] }, { type: i0.ElementRef }]; }, propDecorators: { items: [{
                type: ContentChildren,
                args: [KeyboardNavigationItemDirective, { descendants: true }]
            }] } });
export class KeyboardNavigationDirective {
    constructor(document) {
        this.document = document;
        this._document = this.document;
    }
    static resetItem(position, itemElements) {
        if (position === -1) {
            return;
        }
        itemElements[position].removeAttribute('tabindex');
    }
    static resetTabItem(position, itemElements) {
        itemElements[position].setAttribute('tabindex', '-1');
    }
    static setItemActive(position, itemElements) {
        itemElements[position].setAttribute('tabindex', '0');
        itemElements[position].focus();
    }
    static setPositionUp(position) {
        return Math.max(position - 1, 0);
    }
    static setPositionDown(position, itemsLength) {
        return Math.min(position + 1, itemsLength - 1);
    }
    isEventFromAnchor($event) {
        var _a;
        return !!((_a = this.anchorList) === null || _a === void 0 ? void 0 : _a.find((el) => el.nativeElement.contains($event.target)));
    }
    getListElements() {
        var _a;
        return (_a = this.list) === null || _a === void 0 ? void 0 : _a.items.map((item) => item.elementRef.nativeElement);
    }
    getListAnchor() {
        var _a;
        return (_a = this.anchorList) === null || _a === void 0 ? void 0 : _a.map((item) => item.elementRef.nativeElement);
    }
    onKeyDown(event) {
        const code = event.code;
        const itemElements = this.getListElements();
        const anchorElements = this.getListAnchor();
        const isEventFromAnchor = this.isEventFromAnchor(event);
        const horizontalNav = new Set(['ArrowRight', 'ArrowLeft']);
        const selectedEvents = new Set(['Space', 'Enter']);
        let itemPosition = -1;
        let anchorPosition = 0;
        let itemElement = null;
        if (code === 'ArrowDown' || code === 'Tab') {
            if (isEventFromAnchor && (itemElements === null || itemElements === void 0 ? void 0 : itemElements.length)) {
                KeyboardNavigationDirective.setItemActive(0, itemElements);
                event.preventDefault();
            }
            if (code === 'Tab') {
                return;
            }
        }
        if (!isEventFromAnchor && (itemElements === null || itemElements === void 0 ? void 0 : itemElements.length)) {
            itemElements.forEach((item, index) => {
                if (item.contains(event.target)) {
                    itemElement = item;
                }
                if (item === this._document.activeElement) {
                    itemPosition = index;
                }
            });
        }
        if (selectedEvents.has(code) && !isEventFromAnchor && itemElement) {
            event.preventDefault();
            itemElement.click();
            return;
        }
        if (isEventFromAnchor &&
            anchorElements.length > 1 &&
            horizontalNav.has(code)) {
            anchorElements.forEach((item, index) => {
                if (item === this._document.activeElement) {
                    anchorPosition = index;
                }
            });
            switch (code) {
                case 'ArrowRight':
                    KeyboardNavigationDirective.resetTabItem(anchorPosition, anchorElements);
                    anchorPosition = KeyboardNavigationDirective.setPositionDown(anchorPosition, anchorElements.length);
                    break;
                case 'ArrowLeft':
                    KeyboardNavigationDirective.resetTabItem(anchorPosition, anchorElements);
                    anchorPosition =
                        KeyboardNavigationDirective.setPositionUp(anchorPosition);
                    break;
            }
            KeyboardNavigationDirective.setItemActive(anchorPosition, anchorElements);
            return;
        }
        if (!isEventFromAnchor && itemElement) {
            switch (code) {
                case 'ArrowDown':
                    KeyboardNavigationDirective.resetItem(itemPosition, itemElements);
                    itemPosition = KeyboardNavigationDirective.setPositionDown(itemPosition, itemElements.length);
                    break;
                case 'ArrowUp':
                    KeyboardNavigationDirective.resetItem(itemPosition, itemElements);
                    itemPosition =
                        KeyboardNavigationDirective.setPositionUp(itemPosition);
                    break;
            }
            KeyboardNavigationDirective.setItemActive(itemPosition, itemElements);
            event.preventDefault();
        }
    }
}
/** @nocollapse */ KeyboardNavigationDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationDirective, deps: [{ token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ KeyboardNavigationDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: KeyboardNavigationDirective, selector: "[bbKeyboardNavigation]", queries: [{ propertyName: "list", first: true, predicate: KeyboardNavigationListDirective, descendants: true }, { propertyName: "anchorList", predicate: KeyboardNavigationAnchorDirective, descendants: true }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardNavigationDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbKeyboardNavigation]',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }]; }, propDecorators: { list: [{
                type: ContentChild,
                args: [KeyboardNavigationListDirective, { static: false }]
            }], anchorList: [{
                type: ContentChildren,
                args: [KeyboardNavigationAnchorDirective, { descendants: true }]
            }] } });
//# sourceMappingURL=bb-keyboard-navigation.directive.js.map