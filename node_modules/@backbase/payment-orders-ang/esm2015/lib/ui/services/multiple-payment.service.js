import { Injectable } from '@angular/core';
import { catchError, map, switchMap, take, debounce, distinctUntilChanged, } from 'rxjs/operators';
import { BatchOrdersHttpService, } from '@backbase/data-ang/payment-batch';
import { BatchTemplatesHttpService, } from '@backbase/data-ang/payment-batch-template';
import { BehaviorSubject, EMPTY, throwError, timer } from 'rxjs';
import { ProductSummaryHttpService, } from '@backbase/data-ang/arrangements';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/data-ang/payment-batch";
import * as i2 from "@backbase/data-ang/payment-batch-template";
import * as i3 from "@backbase/data-ang/arrangements";
export class MultiplePaymentService {
    constructor(batchOrderService, batchTemplateService, productSummaryService) {
        this.batchOrderService = batchOrderService;
        this.batchTemplateService = batchTemplateService;
        this.productSummaryService = productSummaryService;
        this.submitting = false;
    }
    createFetchAccountsFactory(config) {
        return this._fetchAccountsFactory.bind(this, config);
    }
    saveBatchOrder(data, batchOrderID, dryRun) {
        this.submitting = true;
        const param = {
            batchOrdersPostRequest: data,
        };
        if (batchOrderID === '') {
            return this.batchOrderService
                .postBatchOrders(param)
                .pipe(catchError(this.catchResponseError));
        }
        else {
            return this.updateBatchOrder(data, batchOrderID, dryRun);
        }
    }
    updateBatchOrder(event, batchOrderID, dryRun, intendedCreditTransactionsCount, intendedCreditAmount) {
        return this.batchOrderService
            .updateBatchOrderById({
            batchOrderId: batchOrderID,
            dryRun,
            batchOrderPutRequest: event,
            intendedCreditAmount,
            intendedCreditTransactionsCount,
        })
            .pipe(catchError(this.catchResponseError));
    }
    cancelDraftOrder(batchOrderId) {
        this.batchOrderService
            .deleteBatchOrderIdByBatchOrderId({ batchOrderId })
            .pipe(take(1))
            .subscribe();
    }
    saveDraftPayment(data, batchOrderID) {
        return this.batchOrderService
            .postBatchPayments({
            batchOrderId: batchOrderID,
            batchPaymentsPostRequest: data,
        })
            .pipe(catchError(this.catchResponseError));
    }
    updatePayment(batchOrderID, paymentID, data) {
        return this.batchOrderService
            .putBatchPaymentById({
            batchOrderId: batchOrderID,
            batchPaymentId: paymentID,
            batchPaymentsPutRequest: data,
        })
            .pipe(catchError(this.catchResponseError));
    }
    deletePayment(batchOrderId, batchPaymentId) {
        return this.batchOrderService
            .deleteBatchPaymentById({ batchOrderId, batchPaymentId })
            .pipe(catchError(this.catchResponseError));
    }
    saveAsTemplate(batchOrderId, name) {
        const parameter = {
            batchTemplatesPostRequest: { batchOrderId, name },
        };
        return this.batchTemplateService
            .postBatchTemplates(parameter)
            .pipe(catchError(this.catchResponseError))
            .toPromise();
    }
    getPayments(batchOrderId, options = { from: 0, size: 1000 }) {
        return this.batchOrderService
            .getBatchPaymentsById(Object.assign({ batchOrderId }, options))
            .pipe(catchError(this.catchResponseError))
            .toPromise();
    }
    catchResponseError(response) {
        switch (response.status) {
            case 400:
                return throwError(response.error || {
                    message: 'Unknown error',
                    errors: [{ message: 'Unknown error' }],
                });
            case 401:
                return throwError({
                    type: 'TIMEOUT',
                    message: 'Session Timeout',
                    subMessage: 'Please login again.',
                });
            default:
                return throwError({
                    type: 'GENERIC',
                    message: 'Unknown Error',
                    subMessage: 'Try to reload the page or contact system administrator.',
                });
        }
    }
    _fetchAccountsFactory(config) {
        const search$ = new BehaviorSubject('');
        const items$ = search$.pipe(distinctUntilChanged(), debounce((searchTerm) => searchTerm ? timer(config.debounceTime || 0) : EMPTY), switchMap((searchTerm) => {
            const params = Object.assign(Object.assign({}, config), (searchTerm ? { searchTerm } : {}));
            return this.productSummaryService
                .getArrangementsByBusinessFunction(params)
                .pipe(map((arrangements) => arrangements.map((arrangement) => ({
                id: arrangement.id,
                name: arrangement.name || '',
                alias: (arrangement.userPreferences || {}).alias ||
                    arrangement.bankAlias,
                balance: arrangement.availableBalance || arrangement.bookedBalance,
                bookedBalance: arrangement.bookedBalance,
                availableBalance: arrangement.availableBalance,
                creditLimit: arrangement.creditLimit,
                currency: arrangement.currency || '',
                IBAN: arrangement.IBAN || arrangement.number,
                BBAN: arrangement.BBAN,
                accountNumber: arrangement.BBAN || arrangement.IBAN || '',
                number: arrangement.BBAN || '',
                bankBranchCode: arrangement.bankBranchCode,
                externalTransferAllowed: arrangement.externalTransferAllowed,
                urgentTransferAllowed: arrangement.urgentTransferAllowed,
                additions: arrangement.additions,
                productKindName: arrangement.productKindName,
                originalArrangement: arrangement,
            }))));
        }));
        return {
            search$,
            items$,
        };
    }
}
/** @nocollapse */ MultiplePaymentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MultiplePaymentService, deps: [{ token: i1.BatchOrdersHttpService }, { token: i2.BatchTemplatesHttpService }, { token: i3.ProductSummaryHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ MultiplePaymentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MultiplePaymentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MultiplePaymentService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.BatchOrdersHttpService }, { type: i2.BatchTemplatesHttpService }, { type: i3.ProductSummaryHttpService }]; } });
//# sourceMappingURL=multiple-payment.service.js.map