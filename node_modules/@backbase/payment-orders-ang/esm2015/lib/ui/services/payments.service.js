import { __rest } from "tslib";
import { Inject, Injectable, Optional, } from '@angular/core';
import { ItemModel } from '@backbase/foundation-ang/core';
import { BehaviorSubject, merge, of, ReplaySubject, Subject, } from 'rxjs';
import { distinctUntilChanged, filter, finalize, map, mapTo, scan, shareReplay, switchMap, takeUntil, tap, withLatestFrom, } from 'rxjs/operators';
import { datePart } from '../helpers/date-helpers';
import { PaymentActionsTypes } from '../models/payment-actions-types';
import { PaymentOrdersHttpService } from './payment-orders-http.service';
import { DEFAULT_PAYMENT_PARAMS } from './tokens';
import * as i0 from "@angular/core";
import * as i1 from "./payment-orders-http.service";
import * as i2 from "@backbase/foundation-ang/core";
export class PaymentService {
    constructor(paymentOrdersService, model, defaultPaymentsParams) {
        var _a;
        this.paymentOrdersService = paymentOrdersService;
        this.model = model;
        this.defaultPaymentsParams = defaultPaymentsParams;
        this.destroy$ = new Subject();
        this.selectedAccount$ = new Subject();
        this.search$ = new Subject();
        this.changePage$ = new Subject();
        this.loadMore$ = new Subject();
        this.loadPayments$ = new ReplaySubject(1);
        this.refreshPayments$ = new Subject();
        this.sortPayments$ = new Subject();
        this.loadingSub$ = new ReplaySubject(1);
        this.actingSub$ = new ReplaySubject(1);
        this.pageSizeIM$ = ((_a = this.model) === null || _a === void 0 ? void 0 : _a.property('pageSize')) || of(null);
        this.loading$ = this.loadingSub$.pipe(distinctUntilChanged());
        this.acting$ = this.actingSub$.pipe(distinctUntilChanged());
        this.pageSizeSub$ = new BehaviorSubject(undefined);
        this.debitMode$ = new BehaviorSubject(undefined);
        this.pageSize$ = this.pageSizeSub$.asObservable().pipe(withLatestFrom(this.pageSizeIM$), map(([pageSize, pageSizeIM]) => 
        //TODO: remove it when migration on journeys for payments will be done
        pageSize === undefined
            ? pageSizeIM || this.defaultPaymentsParams.size
            : pageSize));
        this.loadingCalls = 0;
        this.actingCalls = 0;
        this.paymentsActions$ = merge(this.loadPayments$.pipe(map((paymentMode) => ({
            type: PaymentActionsTypes.LoadPayments,
            paymentMode,
        }))), this.refreshPayments$.pipe(mapTo({ type: PaymentActionsTypes.RefreshPayments })), this.changePage$.pipe(map((from) => ({ type: PaymentActionsTypes.ChangePage, from }))), this.loadMore$.pipe(map((from) => ({ type: PaymentActionsTypes.LoadMore, from }))), this.selectedAccount$.pipe(map((query) => ({ type: PaymentActionsTypes.SelectAccount, query }))), this.sortPayments$.pipe(map((sortParams) => (Object.assign({ type: PaymentActionsTypes.SelectAccount }, sortParams)))), this.search$.pipe(map((params) => (Object.assign({ type: PaymentActionsTypes.Search }, params)))));
        this.paymentState$ = this.paymentsActions$.pipe(withLatestFrom(this.pageSize$, this.debitMode$), map(([state, pageSize, isDebitMode]) => (Object.assign(Object.assign({}, state), { pageSize,
            isDebitMode }))), //TODO: remove it when migration on journeys for payments will be done
        scan((state, action) => (Object.assign(Object.assign({}, state), action))), map((state) => (Object.assign(Object.assign({}, this.defaultPaymentsParams), state))), map((_a) => {
            var { pageSize, isDebitMode } = _a, state = __rest(_a, ["pageSize", "isDebitMode"]);
            const isRefresh = state.type === 'RefreshPayments';
            const size = pageSize || 50;
            const from = state.from || 0;
            return Object.assign(Object.assign(Object.assign({}, state), { size: isRefresh ? size * (from + 1) : size, from: isRefresh ? 0 : from }), (isDebitMode ? { paymentTypeGroup: 'Debit' } : null));
        }), filter((action) => action.type !== undefined), shareReplay(1));
        this.paymentsEffect$ = this.paymentState$.pipe(switchMap((_a) => {
            var { type } = _a, params = __rest(_a, ["type"]);
            const isActing = type === PaymentActionsTypes.SelectAccount;
            const isLoadMore = type === PaymentActionsTypes.LoadMore;
            isActing ? (this.acting = true) : (this.loading = true);
            return this.paymentOrdersService.loadPayments(params).pipe(map((response) => (Object.assign(Object.assign({}, response), { isLoadMore }))), finalize(() => isActing ? (this.acting = false) : (this.loading = false)));
        }), takeUntil(this.destroy$), shareReplay(1));
        this.paymentsStateSource$ = new BehaviorSubject(undefined);
        this.paymentsEffect$.subscribe((payload) => this.handlePaymentSuccess(payload), (error) => this.paymentsStateSource$.error(error));
    }
    set loading(val) {
        val ? this.loadingCalls++ : this.loadingCalls--;
        this.loadingSub$.next(this.loadingCalls > 0);
    }
    set acting(val) {
        val ? this.actingCalls++ : this.actingCalls--;
        this.actingSub$.next(this.actingCalls > 0);
    }
    get payments$() {
        return this.paymentsStateSource$.asObservable();
    }
    handlePaymentSuccess(payload) {
        const orders = [];
        if (payload.isLoadMore) {
            orders.push(...this.handleLoadMore());
        }
        this.paymentsStateSource$.next({
            items: [...orders, ...payload.items],
            totalCount: payload.totalCount || payload.items.length,
        });
    }
    handleLoadMore() {
        const existingPayments = this.paymentsStateSource$.getValue();
        return existingPayments ? existingPayments.items : [];
    }
    loadPayments(paymentMode) {
        this.loadPayments$.next(paymentMode);
    }
    refreshPayments() {
        this.refreshPayments$.next();
    }
    loadMore(from) {
        this.loadMore$.next(from);
    }
    changePage(from) {
        this.changePage$.next(from);
    }
    sortPayments(orderBy, direction) {
        this.sortPayments$.next({ orderBy, direction });
    }
    setPageSize(value) {
        this.pageSizeSub$.next(value);
    }
    setDebitMode(value) {
        this.debitMode$.next(value);
    }
    cancelPayment(paymentOrderId, version) {
        this.acting = true;
        return this.paymentOrdersService
            .cancelPayment(paymentOrderId, version)
            .pipe(finalize(() => (this.acting = false)), tap(() => {
            this.handleCancelPaymentSuccess(paymentOrderId);
        }));
    }
    handleCancelPaymentSuccess(paymentOrderId) {
        const payments = this.paymentsStateSource$.getValue();
        if (payments) {
            const newItems = payments.items.filter((item) => item.id !== paymentOrderId);
            this.paymentsStateSource$.next({
                items: newItems,
                totalCount: payments.totalCount,
            });
        }
    }
    getCurrencyExchangeRate(currencyFrom = 'EUR', currencyTo = 'USD') {
        return this.paymentOrdersService.getCurrencyExchangeRate(currencyFrom, currencyTo);
    }
    getPaymentOrders(params) {
        return this.paymentOrdersService.getPaymentOrders(params);
    }
    getPaymentDetails(paymentId, params) {
        return this.paymentOrdersService.getPayment(paymentId, params);
    }
    approvePayment(paymentId, comment) {
        return this.paymentOrdersService.approvePayment(paymentId, comment);
    }
    bulkApprovePayments(paymentIds, comment) {
        return this.paymentOrdersService.bulkApprovePayments(paymentIds, comment);
    }
    rejectPayment(paymentId, comment) {
        return this.paymentOrdersService.rejectPayment(paymentId, comment);
    }
    bulkRejectPayments(paymentIds, comment) {
        return this.paymentOrdersService.bulkRejectPayments(paymentIds, comment);
    }
    searchPayments(query) {
        this.search$.next({ query, from: 0 });
    }
    applyFilter(_a) {
        var { amount, executionDate } = _a, rest = __rest(_a, ["amount", "executionDate"]);
        const retVal = Object.assign(Object.assign({}, rest), { from: 0 });
        if (!retVal.status) {
            retVal.status = [];
        }
        retVal.amountFrom = amount.from || '';
        retVal.amountTo = amount.to || '';
        retVal.executionDateFrom =
            executionDate && executionDate.from ? datePart(executionDate.from) : '';
        retVal.executionDateTo =
            executionDate && executionDate.to ? datePart(executionDate.to) : '';
        this.search$.next(retVal);
    }
    postCancelPayment(paymentOrderId, version) {
        this.acting = true;
        return this.paymentOrdersService
            .postPaymentCancel(paymentOrderId, version)
            .pipe(finalize(() => (this.acting = false)), tap(() => {
            this.handleCancelPaymentSuccess(paymentOrderId);
        }));
    }
    validatePayment(payment) {
        return this.paymentOrdersService.validatePayment(payment);
    }
    ngOnDestroy() {
        // clean up our subjects
        this.destroy$.complete();
        this.loadMore$.complete();
        this.changePage$.complete();
        this.selectedAccount$.complete();
        this.search$.complete();
        this.loadPayments$.complete();
        this.refreshPayments$.complete();
    }
}
/** @nocollapse */ PaymentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService, deps: [{ token: i1.PaymentOrdersHttpService }, { token: i2.ItemModel, optional: true }, { token: DEFAULT_PAYMENT_PARAMS }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ PaymentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PaymentService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.PaymentOrdersHttpService }, { type: i2.ItemModel, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DEFAULT_PAYMENT_PARAMS]
                }] }]; } });
export const providePaymentServices = [
    { provide: PaymentOrdersHttpService, useClass: PaymentOrdersHttpService },
    {
        provide: PaymentService,
        useClass: PaymentService,
        deps: [PaymentOrdersHttpService, ItemModel, DEFAULT_PAYMENT_PARAMS],
    },
];
//# sourceMappingURL=payments.service.js.map