import { AbstractControl, AsyncValidatorFn, FormArray, FormGroup, ValidatorFn } from '@angular/forms';
import { InputFormField } from '@backbase/data-ang/payment-order-options';
import { Address, ArrangementItem, ContactItem, PaymentDetails, PaymentFormFieldConfig, PaymentFormGroup, PaymentTypeConfig } from '@backbase/payment-orders-ang';
/**
 * Registers a FormControl in the provided FormGroup
 *
 * @param group
 * @param formControlName
 * @param [validators]
 * @param [asyncValidators]
 * @param [initialValue='']
 * @returns
 */
export declare function registerFormControl(group: FormGroup, formControlName: string, validators?: Array<ValidatorFn>, asyncValidators?: Array<AsyncValidatorFn>, initialValue?: any, config?: PaymentFormFieldConfig): AbstractControl;
/**
 * Converts the nested form array into a flat map. It is used to lookup any fields easily
 */
export declare const createControlsMap: (controls: Array<PaymentFormFieldConfig | PaymentFormGroup>, controlsMap?: {
    [key: string]: PaymentFormFieldConfig | PaymentFormGroup;
}) => {
    [key: string]: PaymentFormFieldConfig | PaymentFormGroup;
};
export declare function registerFormGroup(group: FormGroup, formGroupName: string, formGroupConfig: {
    [key: string]: any[];
}, validators?: Array<ValidatorFn>, asyncValidators?: Array<AsyncValidatorFn>): AbstractControl | null;
export declare function getParentForm(control: AbstractControl): FormGroup;
export declare function getFormFieldData({ formControlPath, form, config, }: {
    formControlPath: string;
    form: FormGroup;
    config: PaymentTypeConfig;
}): {
    control: AbstractControl | null;
    fieldConfig: PaymentFormFieldConfig | PaymentFormGroup | undefined;
} | undefined;
export declare function applyInputFormSettingForCountry({ inputFormSetting, form, config, }: {
    inputFormSetting: InputFormField | any;
    form: FormGroup;
    config: PaymentTypeConfig;
}): void;
export declare function setAdditionalBankDetails(form: FormGroup, config: PaymentTypeConfig): void;
export declare function createValidatorFromRegex(pattern: string): ValidatorFn;
export declare function isControlFilled(control: AbstractControl): boolean;
export declare function isClosedPaymentValidator(control: AbstractControl): {
    hasOnlyClosedPaymentPermission: boolean;
} | null;
export declare function getCounterpartyFormGroupDetails(form: FormGroup): Partial<ArrangementItem>;
export declare function resetValidators(formControl: AbstractControl, validators?: Array<ValidatorFn>, asyncValidators?: Array<AsyncValidatorFn>, config?: PaymentFormFieldConfig): void;
export declare function addAddressFields(formGroup: FormGroup): void;
export declare function registerFormArray(group: FormGroup, formArrayName: string, validators?: Array<ValidatorFn>, asyncValidators?: Array<AsyncValidatorFn>): FormArray;
export declare function addControlToFormArray(array: FormArray, formGroupConfig: any[], validators?: Array<ValidatorFn>, asyncValidators?: Array<AsyncValidatorFn>, initialValue?: any): FormArray;
export declare function isEditFormDirty(formValue: PaymentDetails, initialFormValue?: PaymentDetails): boolean;
export declare function isTemplateFormDirty(formValue: PaymentDetails, initialFormValue: PaymentDetails): boolean;
export declare function applyPurposeOfPaymentSettings({ form, config, }: {
    form: FormGroup;
    config: PaymentTypeConfig | any;
}): void;
export declare function getBeneficiaryDetails(beneficiary?: ContactItem | ArrangementItem): Partial<ArrangementItem & {
    address: Address;
    bankAddress: Address;
}>;
export declare function revertBeneficiaryChanges(form: FormGroup): void;
