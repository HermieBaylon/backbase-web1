import { AfterViewInit, ElementRef, EventEmitter, OnDestroy, OnInit } from '@angular/core';
import { AbstractControl, FormGroup } from '@angular/forms';
import { FetchPaymentOptionsListenerFn, PaymentFormFieldConfig, PaymentFormGroup, PaymentFormItem, PaymentOption, PaymentState, PaymentTypeConfig } from '@backbase/payment-orders-ang';
import { BehaviorSubject, Observable, Subject } from 'rxjs';
import { PaymentOption as PaymentOptionResponse } from '@backbase/data-ang/payment-order-options';
import * as i0 from "@angular/core";
export declare class AdaptiveFormComponent implements OnInit, AfterViewInit, OnDestroy {
    private readonly formEl;
    /**
     * The actual formgroup item.
     */
    formItem: FormGroup;
    /**
     * The initial set of fields rendered on the form.
     * These fields are static for all payment types.
     */
    baseFields: Array<PaymentFormFieldConfig | PaymentFormGroup>;
    /**
     * Array of payment configs that are needs to be supported by the wizard.
     */
    paymentTypes: Array<PaymentTypeConfig>;
    /**
     * The current state of the payment. Defaults to INITIAL
     */
    paymentState: PaymentState;
    /**
     * The flag to denote if it is a debit payment.
     */
    isDebitPayment: boolean;
    /**
     * The current selected payment config
     */
    selectedPaymentConfig?: PaymentTypeConfig;
    /**
     * The current selected payment option
     */
    selectedPaymentOption?: PaymentOption;
    /**
     * Flag to display when not payment option is avaialble
     */
    paymentOptionsError: boolean;
    /**
     * Flag to check closed payment access
     */
    checkClosedPaymentsAccess: boolean;
    /**
     * An Observable containing the list of payment options
     */
    paymentOptions$: Observable<Array<PaymentOptionResponse>>;
    /**
     * Apply a payment template event emitter
     */
    applyPaymentTemplate: EventEmitter<FormGroup>;
    /**
     * A subject that emit s a flag to denote if we are in the process of fetching the payment options
     */
    set fetchingOptions(isFetchingOptions: boolean);
    /**
     * An optional listener that can be used be trigger the payment options api.
     * This will replace call to listenCriticalFieldChanges function.
     */
    fetchPaymentOptionsListener?: FetchPaymentOptionsListenerFn;
    /**
     * Flag that denotes if form is being submitted
     */
    set submitting(isSubmitting: boolean);
    /**
     * A subject that emits when payment options has to be fetched
     */
    fetchOptions$: Subject<FormGroup>;
    /**
     * Flag that indicates wether should apply a template
     * Default value is `false`
     */
    shouldApplyTemplate: boolean;
    /**
     * The flag to denote if the widget is rendered inside a modal.
     */
    isModalView: boolean;
    /**
     * Event emitted when the form is submitted.
     */
    submitted: EventEmitter<any>;
    /**
     *  Event emitted when a payment option is selected
     */
    selectPaymentOption: EventEmitter<any>;
    /**
     * Event emitted when the form is reset.
     */
    clear: EventEmitter<any>;
    /**
     * Event emitted when a payment config is selected based on the form details.
     */
    selectConfig: EventEmitter<any>;
    isSubmitting$: BehaviorSubject<boolean>;
    fetchingOptions$: BehaviorSubject<boolean>;
    gc$: Subject<unknown>;
    currentControls: Array<PaymentFormFieldConfig | PaymentFormGroup>;
    form: FormGroup;
    shouldResetPaymentOptions: boolean;
    currentDebitAccount?: string;
    debounceInput: import("rxjs").UnaryFunction<Observable<unknown>, Observable<unknown>>;
    controls$: BehaviorSubject<any[]>;
    paymentOptionControls$: BehaviorSubject<PaymentFormFieldConfig[] | undefined>;
    paymentOptionsSubject$: BehaviorSubject<(PaymentOption & {
        name: string;
    })[][] | undefined>;
    paymentTypeControl: AbstractControl;
    selectPaymentOptionControl: AbstractControl;
    inputFormSettingControl: AbstractControl;
    chargeBearerControl: AbstractControl;
    chargeBearerOptionsControl: AbstractControl;
    transferFeeControl: AbstractControl;
    baseControls$: BehaviorSubject<any[]>;
    taggedBaseFields: Array<PaymentFormFieldConfig | PaymentFormGroup>;
    listenChanges: Function;
    retainableFields: string[];
    buttonGroupConfig: PaymentFormFieldConfig;
    constructor(formEl: ElementRef);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    private getButtonGroupConfig;
    registerPaymentOptionControls(): void;
    registerPostalAddressFormGroups(): void;
    /**
     * Renders the provided payment config
     */
    renderPaymentConfig(paymentConfig: PaymentTypeConfig): void;
    /**
     * The activate depandants feature is based on groups so we need to group delta fields in order to toggle dependatants.
     * This function is used to group sibling delta fields into groups, so that the toggle dependatants feature is retained.
     */
    groupDeltaFields(currentControls: Array<PaymentFormItem>, delta: Array<PaymentFormItem>): (PaymentFormGroup | (PaymentFormFieldConfig & {
        parent?: string | undefined;
    }))[];
    /**
     * This function is fetches the grouped delta fields and encloses them with their appropriate parent group config.
     * Doing so ensures the toggle dependants feature works as expected
     */
    mapGroupedFields(groupedFields: Array<PaymentFormItem>, currentControls: Array<PaymentFormItem>): (PaymentFormGroup | (PaymentFormFieldConfig & {
        parent?: string | undefined;
    }))[];
    /**
     * This function encloses the non counterparty and non schedule delta fields inside payment information group.
     */
    organiseConfigs(configs: Array<PaymentFormItem>): (PaymentFormGroup | (PaymentFormFieldConfig & {
        parent?: string | undefined;
    }))[];
    /**
     * Renders the provided array of fields in the form
     */
    renderFields(fields: Array<PaymentFormFieldConfig | PaymentFormGroup>, flatArray: Array<PaymentFormFieldConfig | PaymentFormGroup>): void;
    /**
     * Deletes form controls in current array that are absent in the new array and returns the delta fields
     */
    deleteControls(currentControls: Array<PaymentFormFieldConfig | PaymentFormGroup>, newControls: Array<PaymentFormFieldConfig | PaymentFormGroup>): (PaymentFormFieldConfig | PaymentFormGroup)[];
    /**
     * Listens to the form for changes in debit account number, credit account number, amount and currency
     */
    private listenCriticalFieldChanges;
    /**
     * Listen to the select payment option component and render the fields fo the selected payment type.
     */
    private listenPaymentTypeChanges;
    /**
     * Listens to changes to the payment type in the form
     */
    private listenPaymentType;
    private getPaymentConfigByType;
    private listenPaymentOptionsChange;
    private listenFormSettingChange;
    private applyCountrySpecificSettings;
    private renderPaymentOptionControls;
    /**
     * Resets the existing payment options
     */
    resetPaymentOptions(paymentOptions: Array<PaymentOptionResponse>): void;
    private shouldResetSelectedPaymentOption;
    /**
     * Callback triggered when the payment type changes
     */
    private onPaymentOptionsChange;
    /**
     * Fetches the payment options for provided payment details
     */
    fetchPaymentOptions(form: FormGroup, fetchOptions$: Subject<FormGroup>): void;
    /**
     * Returns the form group for the provided form field config
     */
    getFormGroup(field: PaymentFormItem): FormGroup;
    /**
     * Submits the payment form
     */
    onSubmit(): void;
    /**
     * Resets the payment form
     */
    resetForm(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<AdaptiveFormComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<AdaptiveFormComponent, "bb-adaptive-form", never, { "formItem": "formItem"; "baseFields": "baseFields"; "paymentTypes": "paymentTypes"; "paymentState": "paymentState"; "isDebitPayment": "isDebitPayment"; "selectedPaymentConfig": "selectedPaymentConfig"; "selectedPaymentOption": "selectedPaymentOption"; "paymentOptionsError": "paymentOptionsError"; "checkClosedPaymentsAccess": "checkClosedPaymentsAccess"; "paymentOptions$": "paymentOptions$"; "fetchingOptions": "fetchingOptions"; "fetchPaymentOptionsListener": "fetchPaymentOptionsListener"; "submitting": "submitting"; "fetchOptions$": "fetchOptions$"; "shouldApplyTemplate": "shouldApplyTemplate"; "isModalView": "isModalView"; }, { "applyPaymentTemplate": "applyPaymentTemplate"; "submitted": "submitted"; "selectPaymentOption": "selectPaymentOption"; "clear": "clear"; "selectConfig": "selectConfig"; }, never, never>;
}
