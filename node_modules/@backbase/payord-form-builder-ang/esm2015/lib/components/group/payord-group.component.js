import { Component, Input, EventEmitter, } from '@angular/core';
import { VisibilityService } from '../../services/visibility.service';
import { takeUntil, map } from 'rxjs/operators';
import { FormGroup, Validators, } from '@angular/forms';
import { mapDependentItems } from '../../helpers/generic-utils';
import * as i0 from "@angular/core";
import * as i1 from "../../services/visibility.service";
import * as i2 from "@backbase/ui-ang/fieldset";
import * as i3 from "@backbase/payment-orders-ang";
import * as i4 from "@backbase/ui-ang/collapsible";
import * as i5 from "@backbase/ui-ang/icon";
import * as i6 from "@angular/common";
import * as i7 from "@backbase/ui-ang/button";
export class PayordGroupComponent {
    constructor(visibilityService) {
        this.visibilityService = visibilityService;
        this.gc$ = new EventEmitter();
    }
    ngOnInit() {
        this.eventName = this.config.parent
            ? `${this.config.parent}.${this.config.name}`
            : this.config.name;
        this.visibilityService.show$
            .pipe(map(({ name, items }) => mapDependentItems(items, name).find((dep) => dep.parent === this.eventName)), takeUntil(this.gc$))
            .subscribe((data) => {
            var _a;
            if ((_a = data === null || data === void 0 ? void 0 : data.items) === null || _a === void 0 ? void 0 : _a.length) {
                this.showFields(data.items);
            }
        });
        this.visibilityService.hide$
            .pipe(map(({ name, items }) => mapDependentItems(items, name).find((dep) => dep.parent === this.eventName)), takeUntil(this.gc$))
            .subscribe((data) => {
            var _a;
            if ((_a = data === null || data === void 0 ? void 0 : data.items) === null || _a === void 0 ? void 0 : _a.length) {
                this.hideFields(data.items);
            }
        });
    }
    scanHideableItems(items) {
        const hideableFields = {};
        items.forEach((itemName) => {
            hideableFields[itemName] = true;
        });
        return hideableFields;
    }
    showFields(fieldsNames) {
        const hideableFields = this.scanHideableItems(fieldsNames);
        let control;
        this.config.fields.forEach((field) => {
            var _a;
            if (hideableFields[field.name]) {
                field.hidden = false;
                control = this.group.get(`${this.config.name}.${field.name}`);
                if (control && ((_a = field === null || field === void 0 ? void 0 : field.options) === null || _a === void 0 ? void 0 : _a.isConditionalMandatory)) {
                    control.setValidators([
                        Validators.required,
                        ...(field.options.validators || []),
                    ]);
                    control.setAsyncValidators([
                        ...(field.options.asyncValidators || []),
                    ]);
                    control.updateValueAndValidity();
                }
            }
        });
    }
    hideFields(fieldsNames) {
        const hideableFields = this.scanHideableItems(fieldsNames);
        let control;
        this.config.fields.forEach((field) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (hideableFields[field.name]) {
                field.hidden = true;
                control = ((_a = field === null || field === void 0 ? void 0 : field.options) === null || _a === void 0 ? void 0 : _a.mapToField)
                    ? this.getMappedField(field.name, field.options.mapToField)
                    : this.group.get(`${this.config.name}.${field.name}`);
                if (control && !((_b = field === null || field === void 0 ? void 0 : field.options) === null || _b === void 0 ? void 0 : _b.keepValueOnHidden)) {
                    if ((_c = field === null || field === void 0 ? void 0 : field.options) === null || _c === void 0 ? void 0 : _c.isConditionalMandatory) {
                        control.setValidators(null);
                        control.setAsyncValidators(null);
                        control.updateValueAndValidity();
                    }
                    control.reset();
                    if ((_d = field === null || field === void 0 ? void 0 : field.options) === null || _d === void 0 ? void 0 : _d.defaultValue) {
                        control.patchValue(field.options.defaultValue);
                    }
                }
                this.hideNestedField(field);
                if ((_f = (_e = field) === null || _e === void 0 ? void 0 : _e.fields) === null || _f === void 0 ? void 0 : _f.length) {
                    (_h = (_g = field) === null || _g === void 0 ? void 0 : _g.fields) === null || _h === void 0 ? void 0 : _h.forEach((nestedField) => this.hideNestedField(nestedField));
                }
            }
        });
    }
    hideNestedField(field) {
        var _a, _b;
        if (((_a = field === null || field === void 0 ? void 0 : field.options) === null || _a === void 0 ? void 0 : _a.dependants) && !((_b = field === null || field === void 0 ? void 0 : field.options) === null || _b === void 0 ? void 0 : _b.keepDependantsOnHide)) {
            mapDependentItems(field.options.dependants, field.parent).forEach(({ parent, items }) => {
                this.visibilityService.hideItems(parent, items);
            });
        }
    }
    getMappedField(fieldName, mapToField) {
        let parent = this.group;
        let control;
        while (parent) {
            control = parent.get(`${mapToField}.${fieldName}`);
            if (control) {
                return control;
            }
            parent = parent.parent;
        }
        return null;
    }
    ngOnDestroy() {
        this.gc$.next();
        this.gc$.complete();
    }
}
/** @nocollapse */ PayordGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PayordGroupComponent, deps: [{ token: i1.VisibilityService }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ PayordGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PayordGroupComponent, selector: "bb-payord-group", inputs: { config: "config", group: "group" }, ngImport: i0, template: "<ng-container *ngIf=\"!config?.hidden\">\n  <div\n    *ngIf=\"config?.cssClasses?.length; else defaultTmpl\"\n    [ngClass]=\"config?.cssClasses\"\n  >\n    <ng-container *ngTemplateOutlet=\"defaultTmpl\"></ng-container>\n  </div>\n</ng-container>\n\n<ng-template #defaultTmpl>\n  <ng-container *ngIf=\"!config.collapsible; else collapsibleTmpl\">\n    <bb-fieldset-ui\n      *ngIf=\"config?.title; else subGroup\"\n      [heading]=\"config?.title\"\n    >\n      <div *ngIf=\"config.subTitle\" class=\"bb-fieldset\">\n        {{ config?.subTitle }}\n      </div>\n      <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n    </bb-fieldset-ui>\n    <ng-container *ngIf=\"config?.separator\">\n      <bb-separator\n        [options]=\"config.separator\"\n        class=\"d-block mt-5\"\n      ></bb-separator>\n    </ng-container>\n  </ng-container>\n</ng-template>\n\n<ng-template #subGroup>\n  <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</ng-template>\n\n<ng-template #collapsibleTmpl>\n  <fieldset class=\"bb-fieldset\">\n    <bb-collapsible-ui data-role=\"schedule-toggle\" #collapse>\n      <ng-template bbCollapsibleHeader let-toggle=\"toggle\" let-isOpen=\"isOpen\">\n        <div\n          (click)=\"collapse.toggle()\"\n          [attr.aria-expanded]=\"isOpen\"\n          class=\"bb-stack justify-content-between col-12\"\n        >\n          <legend>\n            <span class=\"bb-label\">{{ config?.title }}</span>\n          </legend>\n          <button\n            bbButton\n            color=\"outline\"\n            [attr.aria-label]=\"config?.title\"\n            [attr.aria-expanded]=\"isOpen\"\n            (click)=\"collapse.toggle(); $event.stopPropagation()\"\n          >\n            <bb-icon-ui\n              [name]=\"isOpen ? 'toggle-up' : 'toggle-down'\"\n            ></bb-icon-ui>\n          </button>\n        </div>\n        <hr class=\"mt-0 mx-3\" />\n      </ng-template>\n      <ng-template bbCollapsibleBody>\n        <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n      </ng-template>\n    </bb-collapsible-ui>\n  </fieldset>\n</ng-template>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n", components: [{ type: i2.FieldsetComponent, selector: "bb-fieldset-ui", inputs: ["heading", "disabled"] }, { type: i3.ӨSeparatorComponent, selector: "bb-separator", inputs: ["options"] }, { type: i4.CollapsibleComponent, selector: "bb-collapsible-ui", inputs: ["recreateBodyContent", "hasChevron", "isOpen"], outputs: ["isOpenChange"] }, { type: i5.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }], directives: [{ type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i6.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i4.CollapsibleHeaderDirective, selector: "ng-template[bbCollapsibleHeader]" }, { type: i7.ButtonDirective, selector: "button[bbButton]", inputs: ["type", "color", "buttonSize", "block", "circle"] }, { type: i4.CollapsibleBodyDirective, selector: "ng-template[bbCollapsibleBody]" }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PayordGroupComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-payord-group',
                    templateUrl: './payord-group.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i1.VisibilityService }]; }, propDecorators: { config: [{
                type: Input
            }], group: [{
                type: Input
            }] } });
//# sourceMappingURL=payord-group.component.js.map