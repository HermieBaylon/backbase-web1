import { FormArray, FormControl, FormGroup, Validators, } from '@angular/forms';
import { amountValidator, CounterPartyFields, currencyValidatorFactory, datePart, getAccountHolderAddress, getConfig, getContactBankAddress, HiddenFields, ibanCountryValidator, isCounterpartyObjectEquals, isObjectTruthy, isSelectedBeneficiaryModified, objectEquals, PaymentBaseFields, PaymentTemplateFields, RemittanceInfoFields, resetBeneficiaryDetails, } from '@backbase/payment-orders-ang';
import { getPurposeOfPaymentInfo } from './generic-utils';
/**
 * Registers a FormControl in the provided FormGroup
 *
 * @param group
 * @param formControlName
 * @param [validators]
 * @param [asyncValidators]
 * @param [initialValue='']
 * @returns
 */
export function registerFormControl(group, formControlName, validators, asyncValidators, initialValue = '', config) {
    let formControl;
    formControl = group.controls[formControlName];
    group.addControl(formControlName, new FormControl(initialValue, validators || [], asyncValidators || []));
    if (formControl) {
        resetValidators(formControl, validators, asyncValidators, config);
    }
    else {
        group.addControl(formControlName, new FormControl(initialValue, validators || [], asyncValidators || []));
        formControl = group.controls[formControlName];
    }
    return formControl;
}
/**
 * Converts the nested form array into a flat map. It is used to lookup any fields easily
 */
export const createControlsMap = (controls, controlsMap = {}) => {
    let path;
    return controls.reduce((acc, control) => {
        path = control.parent
            ? `${control.parent}.${control.name}`
            : control.name;
        if (control.fields) {
            acc = Object.assign(Object.assign({}, acc), createControlsMap(control.fields, acc));
        }
        else {
            acc[path] = control;
        }
        return acc;
    }, controlsMap);
};
export function registerFormGroup(group, formGroupName, formGroupConfig, validators, asyncValidators) {
    const subGroup = group.get(formGroupName) ||
        new FormGroup({}, validators || [], asyncValidators || []);
    for (const key in formGroupConfig) {
        if (formGroupConfig.hasOwnProperty(key)) {
            subGroup.registerControl(key, new FormControl(formGroupConfig[key].shift(), formGroupConfig[key].shift() || []));
        }
    }
    group.addControl(formGroupName, subGroup);
    return group.get(formGroupName);
}
export function getParentForm(control) {
    let ancestor = control;
    while (ancestor && ancestor.parent) {
        ancestor = ancestor.parent;
    }
    return ancestor;
}
export function getFormFieldData({ formControlPath, form, config, }) {
    const apiFieldMap = {
        'transferTransactionInformation.counterpartyAccount.identification.identification': {
            name: CounterPartyFields.accountNumber,
            path: `${PaymentBaseFields.counterparty}.${CounterPartyFields.accountNumber}`,
        },
        'transferTransactionInformation.counterpartyBank.bankBranchCode': {
            name: CounterPartyFields.bankBranchCode,
            path: `${PaymentBaseFields.counterparty}.${CounterPartyFields.creditorBank}.${CounterPartyFields.bankBranchCode}`,
        },
        'transferTransactionInformation.instructedAmount.currencyCode': {
            name: RemittanceInfoFields.amountCurrencyGroup,
            path: `${PaymentBaseFields.remittanceInfo}.${RemittanceInfoFields.amountCurrencyGroup}`,
        },
    };
    const fieldData = apiFieldMap[formControlPath] || null;
    if (fieldData) {
        const control = form.get(fieldData.path);
        const fieldConfig = getConfig(fieldData.name, config);
        return { control, fieldConfig };
    }
    return;
}
export function applyInputFormSettingForCountry({ inputFormSetting, form, config, }) {
    var _a;
    const counterpartyGroup = form.get(PaymentBaseFields.counterparty);
    const isClosedPaymentControl = (form.get(HiddenFields.isClosedPayment));
    const hasArrangementIdControl = (counterpartyGroup.get(CounterPartyFields.id));
    const schemeControl = counterpartyGroup.get(CounterPartyFields.schemeName) ||
        registerFormControl(counterpartyGroup, CounterPartyFields.schemeName);
    if (inputFormSetting.apiField) {
        const { control = null, fieldConfig = null } = getFormFieldData({
            formControlPath: inputFormSetting.apiField,
            form,
            config,
        }) || {};
        let validators = [];
        if (inputFormSetting.mandatory) {
            // For currency input we need amountValidator instead of Validators.required
            if (inputFormSetting.key === 'currency') {
                validators.push(amountValidator);
            }
            else {
                validators.push(Validators.required);
            }
        }
        if (inputFormSetting.regex) {
            validators.push(createValidatorFromRegex(inputFormSetting.regex));
        }
        if (inputFormSetting.key === 'currency' && inputFormSetting.values.length) {
            validators.push(currencyValidatorFactory(inputFormSetting.values));
        }
        if (inputFormSetting.key === 'account-number') {
            schemeControl.setValue(inputFormSetting.format);
            if (inputFormSetting.format === 'IBAN') {
                validators.push(ibanCountryValidator());
            }
        }
        if (control && fieldConfig) {
            const labelData = inputFormSetting.label || {};
            const labelKey = Object.keys(labelData)[0];
            const label = labelData[labelKey]; // need  to implement i18n for this
            fieldConfig.options = fieldConfig.options || {};
            if (label) {
                if (!fieldConfig.options.defaultLabel) {
                    fieldConfig.options.defaultLabel =
                        getLabelFromInputSetting((_a = form.get('defaultBankCodeSetting')) === null || _a === void 0 ? void 0 : _a.value) || fieldConfig.options.label;
                }
                fieldConfig.options.label = label;
            }
            else if (fieldConfig.options.defaultLabel &&
                fieldConfig.options.defaultLabel !== fieldConfig.options.label) {
                // reset to default label if the inputform setting doesn't contain label.
                fieldConfig.options.label = fieldConfig.options.defaultLabel;
            }
            const shouldEnableControls = !((isClosedPaymentControl === null || isClosedPaymentControl === void 0 ? void 0 : isClosedPaymentControl.value) || (hasArrangementIdControl === null || hasArrangementIdControl === void 0 ? void 0 : hasArrangementIdControl.value));
            if (inputFormSetting.notApplicable) {
                control.reset();
                validators = null;
                control.disable();
            }
            else if (control.disabled && shouldEnableControls) {
                control.enable();
            }
            if (isControlFilled(control)) {
                control.markAsTouched();
            }
            control.setValidators(validators);
            control.updateValueAndValidity();
        }
    }
}
export function setAdditionalBankDetails(form, config) {
    var _a;
    const setting = (_a = form.get('defaultBankCodeSetting')) === null || _a === void 0 ? void 0 : _a.value;
    if (!setting)
        return;
    const label = getLabelFromInputSetting(setting);
    const regex = setting.regex;
    if (label) {
        setAdditionalBankLabel(CounterPartyFields.correspondentBank, label, config);
        setAdditionalBankLabel(CounterPartyFields.intermediaryBank, label, config);
    }
    if (regex) {
        appendBankCodePatternValidator(CounterPartyFields.correspondentBank, regex, config);
        appendBankCodePatternValidator(CounterPartyFields.intermediaryBank, regex, config);
    }
}
export function createValidatorFromRegex(pattern) {
    if (pattern.startsWith('/') && pattern.endsWith('/')) {
        pattern = pattern.slice(1, -1);
    }
    return Validators.pattern(new RegExp(pattern));
}
function appendBankCodePatternValidator(controlName, regex, config) {
    const additionalBankConfig = getConfig(controlName, config);
    if (!additionalBankConfig)
        return;
    const bankCodeConfig = getConfig(CounterPartyFields.bankBranchCode, additionalBankConfig);
    if (bankCodeConfig) {
        if (!(bankCodeConfig === null || bankCodeConfig === void 0 ? void 0 : bankCodeConfig.options)) {
            bankCodeConfig.options = {};
        }
        bankCodeConfig.options.validators = [createValidatorFromRegex(regex)];
    }
}
function getLabelFromInputSetting(setting) {
    return Object.values((setting === null || setting === void 0 ? void 0 : setting.label) || {})[0];
}
function setAdditionalBankLabel(additionalBankType, label, config) {
    var _a;
    const additionalBankConfig = getConfig(additionalBankType, config);
    if (additionalBankConfig) {
        const bankCodeConfig = getConfig(CounterPartyFields.bankBranchCode, additionalBankConfig);
        const selectAdditionalBankCodeTypeConfig = getConfig('selectAdditionalBankCodeType', additionalBankConfig);
        const selectAdditionalBankCodeTypeOptions = (_a = selectAdditionalBankCodeTypeConfig === null || selectAdditionalBankCodeTypeConfig === void 0 ? void 0 : selectAdditionalBankCodeTypeConfig.options) === null || _a === void 0 ? void 0 : _a.options;
        if (bankCodeConfig === null || bankCodeConfig === void 0 ? void 0 : bankCodeConfig.options) {
            bankCodeConfig.options.label = label;
        }
        if (selectAdditionalBankCodeTypeOptions === null || selectAdditionalBankCodeTypeOptions === void 0 ? void 0 : selectAdditionalBankCodeTypeOptions.length) {
            selectAdditionalBankCodeTypeOptions.forEach((option) => {
                if (option.value === 'BRANCH_CODE') {
                    option.label = label;
                }
            });
        }
    }
}
export function isControlFilled(control) {
    var _a;
    const isAmountControl = ((control === null || control === void 0 ? void 0 : control.value) || {}).hasOwnProperty('currency') &&
        ((control === null || control === void 0 ? void 0 : control.value) || {}).hasOwnProperty('amount');
    return isAmountControl ? !!((_a = control === null || control === void 0 ? void 0 : control.value) === null || _a === void 0 ? void 0 : _a.amount) : !!(control === null || control === void 0 ? void 0 : control.value);
}
export function isClosedPaymentValidator(control) {
    var _a, _b, _c, _d;
    const form = getParentForm(control);
    const counterPartyDetails = (_a = (form.get(PaymentBaseFields.counterparty))) === null || _a === void 0 ? void 0 : _a.getRawValue();
    const selectedBeneficiary = (_b = form.get(HiddenFields.selectedBeneficiary)) === null || _b === void 0 ? void 0 : _b.value;
    const isBeneficairyUpdatedManually = isSelectedBeneficiaryModified(counterPartyDetails, selectedBeneficiary) ||
        (((_c = form === null || form === void 0 ? void 0 : form.get(HiddenFields.isManualEdit)) === null || _c === void 0 ? void 0 : _c.value) &&
            isCounterPartyDetailsTruthy(counterPartyDetails));
    return isBeneficairyUpdatedManually &&
        ((_d = form === null || form === void 0 ? void 0 : form.get(HiddenFields.isClosedPayment)) === null || _d === void 0 ? void 0 : _d.value)
        ? { hasOnlyClosedPaymentPermission: true }
        : null;
}
export function getCounterpartyFormGroupDetails(form) {
    var _a, _b, _c;
    const counterparty = (_a = (form.get(PaymentBaseFields.counterparty))) === null || _a === void 0 ? void 0 : _a.getRawValue();
    return {
        name: counterparty === null || counterparty === void 0 ? void 0 : counterparty.name,
        accountNumber: counterparty === null || counterparty === void 0 ? void 0 : counterparty.accountNumber,
        bankBranchCode: (_b = counterparty === null || counterparty === void 0 ? void 0 : counterparty.creditorBank) === null || _b === void 0 ? void 0 : _b.bankBranchCode,
        BIC: (_c = counterparty === null || counterparty === void 0 ? void 0 : counterparty.creditorBank) === null || _c === void 0 ? void 0 : _c.bic,
    };
}
export function resetValidators(formControl, validators, asyncValidators, config) {
    var _a;
    const computedValidators = validators ? [...validators] : [];
    if (!(config === null || config === void 0 ? void 0 : config.hidden) && ((_a = config === null || config === void 0 ? void 0 : config.options) === null || _a === void 0 ? void 0 : _a.isConditionalMandatory)) {
        computedValidators.push(Validators.required);
    }
    formControl.markAsUntouched();
    formControl.clearValidators();
    formControl.clearAsyncValidators();
    formControl.setAsyncValidators(asyncValidators || []);
    formControl.setValidators(computedValidators);
}
export function addAddressFields(formGroup) {
    const addressFields = {
        addressLine1: [''],
        addressLine2: [''],
        streetName: [''],
        postCode: [''],
        town: [''],
        countrySubDivision: [''],
        country: [''],
    };
    for (const key in addressFields) {
        if (addressFields.hasOwnProperty(key) && !formGroup.get(key)) {
            registerFormControl(formGroup, key);
        }
    }
}
export function registerFormArray(group, formArrayName, validators, asyncValidators) {
    const array = group.get(formArrayName) ||
        new FormArray([], validators || [], asyncValidators || []);
    group.addControl(formArrayName, array);
    return group.get(formArrayName);
}
export function addControlToFormArray(array, formGroupConfig, validators, asyncValidators, initialValue = null) {
    const subGroup = new FormGroup({}, validators || [], asyncValidators || []);
    formGroupConfig.forEach((formConfig) => {
        if (formConfig.name) {
            subGroup.registerControl(formConfig.name, new FormControl(initialValue, formConfig.validators || []));
        }
    });
    array.push(subGroup);
    return array;
}
export function isEditFormDirty(formValue, initialFormValue) {
    var _a, _b;
    if (!initialFormValue)
        return true;
    const schedule = getScheduleDatePart(formValue.schedule);
    const initialSchedule = getScheduleDatePart(initialFormValue.schedule);
    return (((_a = formValue.initiator) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = initialFormValue.initiator) === null || _b === void 0 ? void 0 : _b.id) ||
        !isCounterpartyObjectEquals(formValue.counterparty, initialFormValue.counterparty) ||
        !objectEquals(schedule, initialSchedule) ||
        isRemittanceInfoDirty(formValue[PaymentBaseFields.remittanceInfo], initialFormValue[PaymentBaseFields.remittanceInfo]) ||
        formValue.chargeBearer !== initialFormValue.chargeBearer);
}
export function isTemplateFormDirty(formValue, initialFormValue) {
    return (formValue[PaymentBaseFields.initiator].id !==
        initialFormValue[PaymentBaseFields.initiator].id ||
        !objectEquals(formValue[PaymentBaseFields.counterparty], initialFormValue[PaymentBaseFields.counterparty]) ||
        isRemittanceInfoDirty(formValue[PaymentBaseFields.remittanceInfo], initialFormValue[PaymentBaseFields.remittanceInfo]) ||
        formValue[PaymentTemplateFields.templateName] !==
            initialFormValue[PaymentTemplateFields.templateName]);
}
function getScheduleDatePart(schedule) {
    return Object.assign(Object.assign({}, schedule), { startDate: datePart(schedule === null || schedule === void 0 ? void 0 : schedule.startDate), endDate: datePart(schedule === null || schedule === void 0 ? void 0 : schedule.endDate) });
}
function isRemittanceInfoDirty(remittanceInfo, initialRemittanceInfo) {
    if (!remittanceInfo)
        return false;
    const amountGroup = remittanceInfo[RemittanceInfoFields.amountCurrencyGroup];
    const initialAmountGroup = initialRemittanceInfo[RemittanceInfoFields.amountCurrencyGroup];
    return ((amountGroup === null || amountGroup === void 0 ? void 0 : amountGroup.amount) !== (initialAmountGroup === null || initialAmountGroup === void 0 ? void 0 : initialAmountGroup.amount) ||
        (amountGroup === null || amountGroup === void 0 ? void 0 : amountGroup.currency) !== (initialAmountGroup === null || initialAmountGroup === void 0 ? void 0 : initialAmountGroup.currency) ||
        remittanceInfo[RemittanceInfoFields.urgent] !==
            initialRemittanceInfo[RemittanceInfoFields.urgent] ||
        remittanceInfo[RemittanceInfoFields.paymentReference] !==
            initialRemittanceInfo[RemittanceInfoFields.paymentReference] ||
        remittanceInfo[RemittanceInfoFields.description] !==
            initialRemittanceInfo[RemittanceInfoFields.description]);
}
export function applyPurposeOfPaymentSettings({ form, config, }) {
    var _a;
    const country = (_a = form.value) === null || _a === void 0 ? void 0 : _a.inputFormFromSettings;
    const remittanceGroup = form.get(PaymentBaseFields.remittanceInfo);
    if (!remittanceGroup) {
        return;
    }
    const purposeControl = remittanceGroup.get(RemittanceInfoFields.purposeOfPayment) ||
        registerFormControl(remittanceGroup, RemittanceInfoFields.purposeOfPayment);
    const info = getPurposeOfPaymentInfo(country);
    const fieldConfig = getConfig(RemittanceInfoFields.purposeOfPayment, config);
    const options = fieldConfig === null || fieldConfig === void 0 ? void 0 : fieldConfig.options;
    if (purposeControl && options) {
        options.isOptional = info.isOptional;
        options.purposes = info.purposes;
        options.isCollapsed = info.isOptional;
        if (options.isOptional) {
            purposeControl.setValidators(null);
            purposeControl.setAsyncValidators(null);
            purposeControl.updateValueAndValidity();
        }
        else {
            purposeControl.setValidators([
                Validators.required,
                ...(options.validators || []),
            ]);
            purposeControl.setAsyncValidators([...(options.asyncValidators || [])]);
            purposeControl.updateValueAndValidity();
        }
    }
}
function isCounterPartyDetailsTruthy(counterpartyDetails) {
    var _a;
    return isObjectTruthy({
        name: counterpartyDetails === null || counterpartyDetails === void 0 ? void 0 : counterpartyDetails.name,
        accountNumber: counterpartyDetails.accountNumber,
        bankBranchCode: (_a = counterpartyDetails.creditorBank) === null || _a === void 0 ? void 0 : _a.bankBranchCode,
    });
}
export function getBeneficiaryDetails(beneficiary) {
    var _a, _b;
    const contactAccount = (_b = (_a = beneficiary) === null || _a === void 0 ? void 0 : _a.accounts) === null || _b === void 0 ? void 0 : _b[0];
    const beneficiaryItem = beneficiary;
    return {
        bankBranchCode: (contactAccount === null || contactAccount === void 0 ? void 0 : contactAccount.bankCode) || (beneficiaryItem === null || beneficiaryItem === void 0 ? void 0 : beneficiaryItem.bankBranchCode),
        accountNumber: (contactAccount === null || contactAccount === void 0 ? void 0 : contactAccount.accountNumber) || (beneficiaryItem === null || beneficiaryItem === void 0 ? void 0 : beneficiaryItem.accountNumber),
        name: beneficiary === null || beneficiary === void 0 ? void 0 : beneficiary.name,
        BIC: (contactAccount === null || contactAccount === void 0 ? void 0 : contactAccount.BIC) || (beneficiaryItem === null || beneficiaryItem === void 0 ? void 0 : beneficiaryItem.BIC),
        address: getAccountHolderAddress(contactAccount),
        bankAddress: getContactBankAddress(contactAccount),
    };
}
export function revertBeneficiaryChanges(form) {
    var _a, _b, _c;
    const counterPartyGroup = form.get(PaymentBaseFields.counterparty);
    const selectedBeneficiary = (_a = form.get(HiddenFields.selectedBeneficiary)) === null || _a === void 0 ? void 0 : _a.value;
    const addressGroup = counterPartyGroup.get(CounterPartyFields.postalAddress);
    const bankAddressGroup = counterPartyGroup.get([
        CounterPartyFields.creditorBank,
        CounterPartyFields.postalAddress,
    ]);
    const isManualEditControl = form.get(HiddenFields.isManualEdit);
    if (selectedBeneficiary) {
        const beneficiaryDetails = getBeneficiaryDetails(selectedBeneficiary);
        isManualEditControl === null || isManualEditControl === void 0 ? void 0 : isManualEditControl.reset();
        counterPartyGroup.patchValue({
            [CounterPartyFields.name]: beneficiaryDetails.name,
            [CounterPartyFields.accountNumber]: beneficiaryDetails.accountNumber,
            [CounterPartyFields.creditorBank]: {
                [CounterPartyFields.bankBranchCode]: beneficiaryDetails.bankBranchCode,
                [CounterPartyFields.bic]: beneficiaryDetails.BIC,
            },
        });
        addressGroup === null || addressGroup === void 0 ? void 0 : addressGroup.setValue(Object.assign({}, beneficiaryDetails.address));
        bankAddressGroup === null || bankAddressGroup === void 0 ? void 0 : bankAddressGroup.setValue(Object.assign(Object.assign({}, beneficiaryDetails.bankAddress), { country: ((_b = beneficiaryDetails.bankAddress) === null || _b === void 0 ? void 0 : _b.country) ||
                ((_c = form.get(HiddenFields.defaultCountry)) === null || _c === void 0 ? void 0 : _c.value) }));
    }
    else {
        resetBeneficiaryDetails(counterPartyGroup);
    }
}
//# sourceMappingURL=form-helpers.js.map