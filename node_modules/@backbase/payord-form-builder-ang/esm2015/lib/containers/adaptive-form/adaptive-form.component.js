import { Component, ElementRef, EventEmitter, Input, Output, } from '@angular/core';
import { FormGroup } from '@angular/forms';
import { CounterPartyFields, focusErrorElement, getConfig, HiddenFields, InitiatorFields, isFormGroupConfig, PaymentBaseFields, PaymentComponents, PaymentOptionFields, PaymentState, RemittanceInfoFields, } from '@backbase/payment-orders-ang';
import { BehaviorSubject, Observable, pipe, Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, filter, skipWhile, startWith, takeUntil, tap, } from 'rxjs/operators';
import { filterPaymentConfigs, getChargeBearerFieldConfig, getPaymentCostFieldConfig, getSelectPaymentOptionFieldConfig, hasSameFields, tagFormGroupToFormFields, } from '../../helpers/payment-config-helpers';
import { addAddressFields, applyInputFormSettingForCountry, applyPurposeOfPaymentSettings, createControlsMap, registerFormControl, setAdditionalBankDetails, } from '../../helpers/form-helpers';
import * as i0 from "@angular/core";
import * as i1 from "@backbase/ui-ang/loading-indicator";
import * as i2 from "../../components/group/payord-group.component";
import * as i3 from "@angular/forms";
import * as i4 from "@angular/common";
import * as i5 from "../../directives/form-field.directive";
export class AdaptiveFormComponent {
    constructor(formEl) {
        this.formEl = formEl;
        /**
         * The initial set of fields rendered on the form.
         * These fields are static for all payment types.
         */
        this.baseFields = [];
        /**
         * Array of payment configs that are needs to be supported by the wizard.
         */
        this.paymentTypes = [];
        /**
         * The current state of the payment. Defaults to INITIAL
         */
        this.paymentState = PaymentState.INITIAL;
        /**
         * The flag to denote if it is a debit payment.
         */
        this.isDebitPayment = false;
        /**
         * Flag to display when not payment option is avaialble
         */
        this.paymentOptionsError = false;
        /**
         * Flag to check closed payment access
         */
        this.checkClosedPaymentsAccess = false;
        /**
         * Apply a payment template event emitter
         */
        this.applyPaymentTemplate = new EventEmitter();
        /**
         * Flag that indicates wether should apply a template
         * Default value is `false`
         */
        this.shouldApplyTemplate = false;
        /**
         * The flag to denote if the widget is rendered inside a modal.
         */
        this.isModalView = false;
        /**
         * Event emitted when the form is submitted.
         */
        this.submitted = new EventEmitter();
        /**
         *  Event emitted when a payment option is selected
         */
        this.selectPaymentOption = new EventEmitter();
        /**
         * Event emitted when the form is reset.
         */
        this.clear = new EventEmitter();
        /**
         * Event emitted when a payment config is selected based on the form details.
         */
        this.selectConfig = new EventEmitter();
        this.isSubmitting$ = new BehaviorSubject(false);
        this.fetchingOptions$ = new BehaviorSubject(false);
        this.gc$ = new Subject();
        this.currentControls = [];
        this.shouldResetPaymentOptions = false;
        this.debounceInput = pipe(takeUntil(this.gc$), debounceTime(500), distinctUntilChanged());
        this.controls$ = new BehaviorSubject([]);
        this.paymentOptionControls$ = new BehaviorSubject(undefined);
        this.paymentOptionsSubject$ = new BehaviorSubject(undefined);
        this.baseControls$ = new BehaviorSubject([]);
        this.taggedBaseFields = [];
        this.retainableFields = [
            `${PaymentBaseFields.counterparty}.${CounterPartyFields.postalAddress}`,
            `${PaymentBaseFields.counterparty}.${CounterPartyFields.creditorBank}.${CounterPartyFields.postalAddress}`,
            `${PaymentBaseFields.counterparty}.${CounterPartyFields.creditorBank}.${CounterPartyFields.bic}`,
            `${PaymentBaseFields.counterparty}.${CounterPartyFields.creditorBank}.${CounterPartyFields.bankName}`,
        ];
    }
    /**
     * A subject that emit s a flag to denote if we are in the process of fetching the payment options
     */
    set fetchingOptions(isFetchingOptions) {
        this.fetchingOptions$.next(!!isFetchingOptions);
    }
    /**
     * Flag that denotes if form is being submitted
     */
    set submitting(isSubmitting) {
        this.isSubmitting$.next(isSubmitting);
    }
    ngOnInit() {
        this.form = this.formItem || new FormGroup({});
        this.paymentTypeControl = registerFormControl(this.form, 'paymentType');
        this.registerPaymentOptionControls();
        this.listenPaymentOptionsChange();
        this.listenFormSettingChange();
        // tagging the base fields is required to find the delta between the base fields and others
        tagFormGroupToFormFields(this.baseFields, this.form, this.taggedBaseFields, this.form);
        this.baseControls$.next(this.taggedBaseFields);
        this.currentControls = this.baseFields;
        this.listenChanges =
            this.fetchPaymentOptionsListener || this.listenCriticalFieldChanges;
        this.registerPostalAddressFormGroups();
        registerFormControl(this.form, 'isEditMode', [], [], this.paymentState === PaymentState.EDIT);
        if (this.paymentState === PaymentState.EDIT && this.selectedPaymentConfig) {
            this.listenPaymentType(this.selectedPaymentConfig.paymentType);
        }
        if (this.isDebitPayment) {
            registerFormControl(this.form, HiddenFields.isDebitPayment, [], [], true);
        }
        this.buttonGroupConfig = this.getButtonGroupConfig();
        this.renderPaymentOptionControls();
    }
    ngAfterViewInit() {
        this.listenChanges(this.form, this.fetchOptions$);
        this.listenPaymentTypeChanges();
        if (this.shouldApplyTemplate) {
            this.applyPaymentTemplate.emit(this.form);
        }
    }
    ngOnDestroy() {
        this.gc$.next();
        this.gc$.complete();
        this.controls$.complete();
        this.paymentOptionControls$.next([]);
        this.paymentOptionControls$.complete();
    }
    getButtonGroupConfig() {
        return {
            type: PaymentComponents.buttonGroup,
            name: PaymentComponents.buttonGroup,
            options: {
                submitting$: this.isSubmitting$,
                isLoading$: this.fetchingOptions$,
                submit: this.onSubmit.bind(this),
                reset: this.resetForm.bind(this),
                isModalView: this.isModalView,
            },
        };
    }
    registerPaymentOptionControls() {
        this.chargeBearerControl = registerFormControl(this.form, PaymentOptionFields.chargeBearer);
        this.chargeBearerOptionsControl = registerFormControl(this.form, PaymentOptionFields.chargeBearerOptions);
        this.transferFeeControl = registerFormControl(this.form, PaymentOptionFields.transferFee);
        this.selectPaymentOptionControl = registerFormControl(this.form, PaymentOptionFields.selectPaymentOption);
        this.inputFormSettingControl = registerFormControl(this.form, PaymentOptionFields.inputFormFromSettings);
    }
    registerPostalAddressFormGroups() {
        const counterpartyGroup = (this.form.get(PaymentBaseFields.counterparty));
        let creditorBankGroup = (counterpartyGroup.get(CounterPartyFields.creditorBank));
        if (!creditorBankGroup) {
            creditorBankGroup = new FormGroup({});
            counterpartyGroup.addControl(CounterPartyFields.creditorBank, creditorBankGroup);
        }
        let creditorAddressGroup = (creditorBankGroup.get(CounterPartyFields.postalAddress));
        let creditorBankAddressGroup = (creditorBankGroup.get(CounterPartyFields.postalAddress));
        if (!creditorAddressGroup) {
            creditorAddressGroup = new FormGroup({});
            counterpartyGroup.addControl(CounterPartyFields.postalAddress, creditorAddressGroup);
        }
        if (!creditorBankAddressGroup) {
            creditorBankAddressGroup = new FormGroup({});
            creditorBankGroup.addControl(CounterPartyFields.postalAddress, creditorBankAddressGroup);
        }
        addAddressFields(creditorAddressGroup);
        addAddressFields(creditorBankAddressGroup);
    }
    /**
     * Renders the provided payment config
     */
    renderPaymentConfig(paymentConfig) {
        const newControls = [];
        let deltaFields = [];
        tagFormGroupToFormFields(paymentConfig.fields, this.form, newControls, this.form);
        setAdditionalBankDetails(this.form, paymentConfig);
        if (this.currentControls.length) {
            deltaFields = this.deleteControls(this.currentControls, newControls);
        }
        const groupedDelta = this.groupDeltaFields(newControls, deltaFields);
        this.currentControls = newControls;
        this.controls$.next(groupedDelta);
        if (this.paymentTypeControl) {
            this.paymentTypeControl.patchValue(paymentConfig.paymentType);
        }
    }
    /**
     * The activate depandants feature is based on groups so we need to group delta fields in order to toggle dependatants.
     * This function is used to group sibling delta fields into groups, so that the toggle dependatants feature is retained.
     */
    groupDeltaFields(currentControls, delta) {
        const groupedFields = [];
        for (const deltaField of delta) {
            if (Array.isArray(groupedFields[groupedFields.length - 1])) {
                const prevParent = groupedFields[groupedFields.length - 1][0].parent;
                if (deltaField.parent !== PaymentBaseFields.counterparty &&
                    prevParent === deltaField.parent) {
                    groupedFields[groupedFields.length - 1].push(deltaField);
                }
                else {
                    groupedFields.push(deltaField);
                }
            }
            else if (deltaField.parent !== PaymentBaseFields.counterparty &&
                groupedFields.length &&
                groupedFields[groupedFields.length - 1].parent === deltaField.parent) {
                const prevElem = groupedFields.pop();
                groupedFields.push([prevElem, deltaField]);
            }
            else {
                groupedFields.push(deltaField);
            }
        }
        return this.mapGroupedFields(groupedFields, currentControls);
    }
    /**
     * This function is fetches the grouped delta fields and encloses them with their appropriate parent group config.
     * Doing so ensures the toggle dependants feature works as expected
     */
    mapGroupedFields(groupedFields, currentControls) {
        const configs = groupedFields.map((groupedField) => {
            if (Array.isArray(groupedField)) {
                const anccestorArray = groupedField[0].parent.split('.');
                const parent = anccestorArray.pop();
                const ancestor = anccestorArray.length
                    ? anccestorArray.length === 1
                        ? anccestorArray[0]
                        : anccestorArray.join('.')
                    : '';
                const ancestorConfig = getConfig(ancestor, currentControls);
                const parentConfig = getConfig(parent, ancestorConfig || currentControls);
                return Object.assign(Object.assign({}, parentConfig), { fields: groupedField, 
                    //reset the group title since it will be added in payment information group
                    title: '' });
            }
            else
                return groupedField;
        });
        return this.organiseConfigs(configs);
    }
    /**
     * This function encloses the non counterparty and non schedule delta fields inside payment information group.
     */
    organiseConfigs(configs) {
        const counterPartyConfigs = [];
        const paymentInfoConfigs = [];
        const scheduleConfigs = [];
        for (const config of configs) {
            config.parent = config.parent || '';
            if (config.name === CounterPartyFields.remittanceInformation ||
                config.name === CounterPartyFields.messageToBank) {
                paymentInfoConfigs.push(config);
            }
            else if (config.parent === PaymentBaseFields.counterparty ||
                config.parent.indexOf(`${PaymentBaseFields.counterparty}`) === 0) {
                counterPartyConfigs.push(config);
            }
            else if (config.name === PaymentBaseFields.schedule ||
                config.parent === PaymentBaseFields.schedule) {
                if (isFormGroupConfig(config)) {
                    scheduleConfigs.push(...config.fields);
                }
                else {
                    scheduleConfigs.push(config);
                }
            }
            else {
                paymentInfoConfigs.push(config);
            }
        }
        const paymentInfo = {
            name: 'paymentInfo',
            title: 'Payment Infomation',
            fields: [...paymentInfoConfigs],
        };
        const schedule = {
            name: PaymentBaseFields.schedule,
            fields: [...scheduleConfigs],
        };
        return [...counterPartyConfigs, paymentInfo, schedule];
    }
    /**
     * Renders the provided array of fields in the form
     */
    renderFields(fields, flatArray) {
        tagFormGroupToFormFields(fields, this.form, flatArray, this.form);
        this.controls$.next([...flatArray]);
    }
    /**
     * Deletes form controls in current array that are absent in the new array and returns the delta fields
     */
    deleteControls(currentControls, newControls) {
        const baseControlsMap = createControlsMap(this.taggedBaseFields);
        const currentControlsMap = createControlsMap(currentControls);
        const newControlsMap = createControlsMap(newControls);
        const deltaControls = [];
        // Get new configs that are not rendered in the form
        for (const key in newControlsMap) {
            if (!baseControlsMap.hasOwnProperty(key) &&
                !PaymentOptionFields[key] &&
                key !==
                    `${PaymentBaseFields.counterparty}.${CounterPartyFields.counterPartyAccountGroup}`) {
                deltaControls.push(newControlsMap[key]);
            }
        }
        // Remove existing controls from the form that are not present in the newe config
        for (const key in currentControlsMap) {
            if (currentControlsMap.hasOwnProperty(key)) {
                const controlName = key.split('.').pop();
                const control = this.form.get(key) || this.form.get(controlName);
                if (!baseControlsMap.hasOwnProperty(key) &&
                    !PaymentOptionFields[key] &&
                    !newControlsMap.hasOwnProperty(key) &&
                    this.retainableFields.indexOf(key) === -1 &&
                    control &&
                    control.parent) {
                    control.parent.removeControl(controlName);
                }
                // reset validators from retainable controls
                else if (this.retainableFields.indexOf(key) !== -1) {
                    control === null || control === void 0 ? void 0 : control.setValidators(null);
                    control === null || control === void 0 ? void 0 : control.updateValueAndValidity();
                }
            }
        }
        return deltaControls;
    }
    /**
     * Listens to the form for changes in debit account number, credit account number, amount and currency
     */
    listenCriticalFieldChanges(form, fetchOptions$) {
        // Cache the critical form controls
        const debitAccount = (form.get([PaymentBaseFields.initiator, InitiatorFields.accountNumber]));
        const creditAccount = (form.get([
            PaymentBaseFields.counterparty,
            CounterPartyFields.accountNumber,
        ]));
        const counterpartyCountry = (form.get([
            PaymentBaseFields.counterparty,
            CounterPartyFields.creditorBank,
            CounterPartyFields.postalAddress,
            CounterPartyFields.country,
        ]));
        const amountInfo = (form.get([
            PaymentBaseFields.remittanceInfo,
            RemittanceInfoFields.amountCurrencyGroup,
        ]));
        this.currentDebitAccount = debitAccount.value;
        // subscribe for value changes in the critical form controls and trigger payment options endpoint
        if (debitAccount && creditAccount && amountInfo) {
            this.debounceInput(debitAccount.valueChanges)
                .pipe(skipWhile((val) => this.currentDebitAccount === val), tap(() => {
                this.currentDebitAccount = debitAccount.value;
            }))
                .subscribe(this.fetchPaymentOptions.bind(this, form, fetchOptions$));
            this.debounceInput(creditAccount.valueChanges).subscribe(this.fetchPaymentOptions.bind(this, form, fetchOptions$));
            this.debounceInput(amountInfo.valueChanges).subscribe(this.fetchPaymentOptions.bind(this, form, fetchOptions$));
            if (counterpartyCountry) {
                this.debounceInput(counterpartyCountry.valueChanges).subscribe(this.fetchPaymentOptions.bind(this, form, fetchOptions$));
            }
        }
    }
    /**
     * Listen to the select payment option component and render the fields fo the selected payment type.
     */
    listenPaymentTypeChanges() {
        this.paymentTypeControl.valueChanges
            .pipe(distinctUntilChanged(), takeUntil(this.gc$))
            .subscribe(() => {
            this.listenPaymentType(this.paymentTypeControl.value);
        });
    }
    /**
     * Listens to changes to the payment type in the form
     */
    listenPaymentType(paymentType) {
        if (paymentType) {
            const selectedPaymentTypeConfig = this.paymentTypes.filter((paymentConfig) => paymentType === paymentConfig.paymentType)[0];
            this.selectConfig.next(selectedPaymentTypeConfig);
            this.renderPaymentConfig(selectedPaymentTypeConfig);
        }
    }
    getPaymentConfigByType(paymentType, paymentConfigs) {
        return paymentConfigs.filter((paymentConfig) => paymentType === paymentConfig.paymentType)[0];
    }
    listenPaymentOptionsChange() {
        if (this.paymentOptions$) {
            this.paymentOptions$
                .pipe(takeUntil(this.gc$), tap((options) => {
                this.onPaymentOptionsChange(options);
                this.applyCountrySpecificSettings(this.inputFormSettingControl.value);
            }))
                .subscribe();
        }
    }
    listenFormSettingChange() {
        this.inputFormSettingControl.valueChanges
            .pipe(startWith(this.inputFormSettingControl.value), takeUntil(this.gc$), distinctUntilChanged(), filter((value) => !!value))
            .subscribe((value) => this.applyCountrySpecificSettings(value));
    }
    applyCountrySpecificSettings(value) {
        const currentConfig = this.getPaymentConfigByType(this.paymentTypeControl.value, this.paymentTypes);
        if (value) {
            for (const inputFormSetting of value.inputFormSettings || []) {
                applyInputFormSettingForCountry({
                    inputFormSetting,
                    form: this.form,
                    config: { fields: this.baseFields, name: '', paymentType: '' },
                });
                if (currentConfig) {
                    applyInputFormSettingForCountry({
                        inputFormSetting,
                        form: this.form,
                        config: currentConfig,
                    });
                }
            }
            if (currentConfig) {
                applyPurposeOfPaymentSettings({
                    form: this.form,
                    config: currentConfig,
                });
            }
        }
    }
    renderPaymentOptionControls() {
        const paymentOptionControls = [];
        paymentOptionControls.push(getSelectPaymentOptionFieldConfig(this.paymentOptions$, this.paymentTypes, this.checkClosedPaymentsAccess));
        paymentOptionControls.push(getChargeBearerFieldConfig());
        paymentOptionControls.push(getPaymentCostFieldConfig());
        this.paymentOptionControls$.next(paymentOptionControls);
    }
    /**
     * Resets the existing payment options
     */
    resetPaymentOptions(paymentOptions) {
        if (this.shouldResetPaymentOptions) {
            if (this.shouldResetSelectedPaymentOption(paymentOptions)) {
                this.selectPaymentOptionControl.reset();
            }
            this.chargeBearerOptionsControl.reset();
            this.transferFeeControl.reset();
        }
    }
    shouldResetSelectedPaymentOption(paymentOptions) {
        const selectedPaymentType = (this.selectPaymentOptionControl.value || '').split('::')[0];
        if (selectedPaymentType) {
            return !paymentOptions.some((option) => option.paymentType === selectedPaymentType);
        }
        return false;
    }
    /**
     * Callback triggered when the payment type changes
     */
    onPaymentOptionsChange(paymentOptions = []) {
        this.resetPaymentOptions(paymentOptions);
        this.shouldResetPaymentOptions = true;
        if (!paymentOptions || !paymentOptions.length) {
            return;
        }
        const paymentConfigs = filterPaymentConfigs(paymentOptions, this.paymentTypes);
        if (paymentOptions.length === 1 || hasSameFields(paymentConfigs)) {
            this.renderPaymentConfig(paymentConfigs[0]);
            this.selectConfig.next(paymentConfigs[0]);
        }
        else if (this.shouldResetSelectedPaymentOption(paymentOptions)) {
            this.controls$.next([]);
        }
    }
    /**
     * Fetches the payment options for provided payment details
     */
    fetchPaymentOptions(form, fetchOptions$) {
        const debitAccount = (form.get(`${PaymentBaseFields.initiator}.${InitiatorFields.accountNumber}`));
        const creditAccount = (form.get(`${PaymentBaseFields.counterparty}.${CounterPartyFields.accountNumber}`));
        const amountInfo = (form.get(`${PaymentBaseFields.remittanceInfo}.${RemittanceInfoFields.amountCurrencyGroup}`));
        const bankCountry = (form.get([
            PaymentBaseFields.counterparty,
            CounterPartyFields.creditorBank,
            CounterPartyFields.postalAddress,
            CounterPartyFields.country,
        ]));
        const closedPayment = form.get(HiddenFields.isClosedPayment);
        const arrangementId = form.get([
            PaymentBaseFields.counterparty,
            CounterPartyFields.id,
        ]);
        const skipCreditAccountValidityCheck = (closedPayment === null || closedPayment === void 0 ? void 0 : closedPayment.value) || (arrangementId === null || arrangementId === void 0 ? void 0 : arrangementId.value);
        if (debitAccount &&
            creditAccount &&
            amountInfo &&
            bankCountry &&
            bankCountry.valid &&
            debitAccount.value &&
            (creditAccount.valid || skipCreditAccountValidityCheck) &&
            amountInfo.valid) {
            fetchOptions$.next(form);
        }
    }
    /**
     * Returns the form group for the provided form field config
     */
    getFormGroup(field) {
        return this.form.get(field.parent) || this.form;
    }
    /**
     * Submits the payment form
     */
    onSubmit() {
        var _a;
        this.form.markAsDirty();
        this.form.markAllAsTouched();
        if (!this.form.valid) {
            focusErrorElement((_a = this.formEl) === null || _a === void 0 ? void 0 : _a.nativeElement);
        }
        else if (this.form.valid && !this.submitting) {
            this.submitted.next(this.form);
            this.selectPaymentOption.next(this.selectedPaymentOption);
        }
    }
    /**
     * Resets the payment form
     */
    resetForm() {
        this.selectConfig.next(undefined);
        this.selectPaymentOption.next(undefined);
        this.gc$.next(); // Clear listeners
        this.clear.next();
    }
}
/** @nocollapse */ AdaptiveFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AdaptiveFormComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ AdaptiveFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: AdaptiveFormComponent, selector: "bb-adaptive-form", inputs: { formItem: "formItem", baseFields: "baseFields", paymentTypes: "paymentTypes", paymentState: "paymentState", isDebitPayment: "isDebitPayment", selectedPaymentConfig: "selectedPaymentConfig", selectedPaymentOption: "selectedPaymentOption", paymentOptionsError: "paymentOptionsError", checkClosedPaymentsAccess: "checkClosedPaymentsAccess", paymentOptions$: "paymentOptions$", fetchingOptions: "fetchingOptions", fetchPaymentOptionsListener: "fetchPaymentOptionsListener", submitting: "submitting", fetchOptions$: "fetchOptions$", shouldApplyTemplate: "shouldApplyTemplate", isModalView: "isModalView" }, outputs: { applyPaymentTemplate: "applyPaymentTemplate", submitted: "submitted", selectPaymentOption: "selectPaymentOption", clear: "clear", selectConfig: "selectConfig" }, ngImport: i0, template: "<form class=\"payment-wizard-form\" [formGroup]=\"form\" (ngSubmit)=\"onSubmit()\">\n  <ng-container *ngFor=\"let field of baseControls$ | async\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        field.fields ? formGroupTmpl : formControlTmpl;\n        context: { $implicit: field }\n      \"\n    >\n    </ng-container>\n  </ng-container>\n\n  <div class=\"position-relative\">\n    <div class=\"delta-container\">\n      <ng-container *ngFor=\"let field of controls$ | async\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            field.fields ? formGroupTmpl : formControlTmpl;\n            context: { $implicit: field }\n          \"\n        >\n        </ng-container>\n      </ng-container>\n    </div>\n\n    <ng-container *ngFor=\"let controlConfig of paymentOptionControls$ | async\">\n      <ng-container\n        *ngTemplateOutlet=\"\n          controlConfig.fields ? formGroupTmpl : formControlTmpl;\n          context: { $implicit: controlConfig }\n        \"\n      >\n      </ng-container>\n    </ng-container>\n\n    <div\n      *ngIf=\"fetchingOptions$ | async\"\n      class=\"wizard-loader-container position-absolute w-100 h-100 top-0 fixed-top bg-white\"\n      [style.opacity]=\"0.8\"\n    >\n      <bb-loading-indicator-ui\n        loaderSize=\"lg\"\n        class=\"absolute-center\"\n      ></bb-loading-indicator-ui>\n    </div>\n  </div>\n\n  <ng-template let-config #formGroupTmpl>\n    <bb-payord-group [config]=\"config\" [group]=\"getFormGroup(config)\">\n      <ng-container *ngFor=\"let control of config.fields\">\n        <ng-container\n          *ngTemplateOutlet=\"\n            control.fields ? formGroupTmpl : formControlTmpl;\n            context: { $implicit: control }\n          \"\n        >\n        </ng-container>\n      </ng-container>\n    </bb-payord-group>\n  </ng-template>\n\n  <ng-template let-config #formControlTmpl>\n    <ng-container\n      bbPaymentFormField\n      [config]=\"config\"\n      [options]=\"config.options\"\n      [group]=\"getFormGroup(config)\"\n    ></ng-container>\n  </ng-template>\n\n  <div\n    class=\"text-danger bb-block--md col-12\"\n    *ngIf=\"paymentOptionsError\"\n    i18n=\"@@adaptive-form-no-payment-option-error\"\n  >\n    A Payment transfer is not possible with provided details. Please update the\n    details and try again.\n  </div>\n\n  <!--Render button group -->\n  <ng-container\n    *ngTemplateOutlet=\"\n      formControlTmpl;\n      context: { $implicit: buttonGroupConfig }\n    \"\n  ></ng-container>\n\n  <ng-template #fetchingOptions>\n    <bb-loading-indicator-ui\n      loaderSize=\"sm\"\n      class=\"bb-load-button__loading-indicator\"\n    ></bb-loading-indicator-ui>\n  </ng-template>\n</form>\n", components: [{ type: i1.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i2.PayordGroupComponent, selector: "bb-payord-group", inputs: ["config", "group"] }], directives: [{ type: i3.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i3.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i3.FormGroupDirective, selector: "[formGroup]", inputs: ["formGroup"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.PaymentFormFieldDirective, selector: "[bbPaymentFormField]", inputs: ["options", "config", "group"] }], pipes: { "async": i4.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: AdaptiveFormComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-adaptive-form',
                    templateUrl: './adaptive-form.component.html',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { formItem: [{
                type: Input
            }], baseFields: [{
                type: Input
            }], paymentTypes: [{
                type: Input
            }], paymentState: [{
                type: Input
            }], isDebitPayment: [{
                type: Input
            }], selectedPaymentConfig: [{
                type: Input
            }], selectedPaymentOption: [{
                type: Input
            }], paymentOptionsError: [{
                type: Input
            }], checkClosedPaymentsAccess: [{
                type: Input
            }], paymentOptions$: [{
                type: Input
            }], applyPaymentTemplate: [{
                type: Output
            }], fetchingOptions: [{
                type: Input
            }], fetchPaymentOptionsListener: [{
                type: Input
            }], submitting: [{
                type: Input
            }], fetchOptions$: [{
                type: Input
            }], shouldApplyTemplate: [{
                type: Input
            }], isModalView: [{
                type: Input
            }], submitted: [{
                type: Output
            }], selectPaymentOption: [{
                type: Output
            }], clear: [{
                type: Output
            }], selectConfig: [{
                type: Output
            }] } });
//# sourceMappingURL=adaptive-form.component.js.map