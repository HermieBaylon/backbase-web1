
declare type AddConditionResolver = (
  kind: string,
  resolver: Resolver,
) => void;

/**
 * AuthConfigs Union type.
 * It can only be one of these types.
 */
export declare type AuthConfigs = BasConfig | HybridConfig | CustomConfig;

/**
 * AuthKind Enumeration
 *
 * This enumeration is used to choose what kind of authentication
 * we want to use.
 */
export declare enum AuthKind {
  /** Basic Authentication */
  Basic = 'bas',
  /** Hybrid Authentication */
  Hybrid = 'hybrid',
  /** Custom Authentication */
  Custom = 'custom',
}

export declare interface AuthSession {
  getSession: () => BackbaseSession | null;
  create: (
    sessionInfo: Base64Jwt | number,
    options?: SessionOptions,
  ) => BackbaseSession;
  getTtl: () => Seconds;
  destroy: () => void;
}

export declare interface AuthStrategy {
  /**
   * Optional method that will login the user if the username and password are correct
   */
  login?: Login;
  /**
   * Optional method that will logout the user
   */
  logout?: Logout;
  /**
   * Optional method
   */
  refresh?: RefreshSession;
  /**
   * Optional method that will return time to live
   */
  timeToLive?: TimeToLive;
  /**
   * Optional method that will redirect to login page
   */
  goToLoginPage?: GoToLoginPage;
  /**
   * Optional method that allows to intercept any call done to the server to modify it before being sent.
   */
  interceptor?: HttpInterceptor;
  /**
   * Optional method that will reauthenticate a user
   */
  reauthenticate?: Reauthenticate;
  /**
   * Optional method that determines whether the user is being impersonated
   */
  isImpersonated?: () => boolean;
}

export declare interface AuthUtils {
  request: HttpRequest;
  encode: (hash: { [key: string]: string | undefined }) => string;
  getQueryStringValue: (key: string) => string;
  setLocale: SetLocale_2;
  cookie: Cookie;
  redirect: Redirect;
  isExternal: IsExternal;
  resolveRedirectUri: ResolveRedirectPageUrl;
}

/**
 * BackbaseAuth interface
 */
export declare interface BackbaseAuth {
  /**
   * Authorization config
   */
  config: AuthConfigs;
  /**
   * Optional method that will login the user if the username and password are correct
   */
  login?: Login;
  /**
   * Optional method that will logout the user
   */
  logout?: Logout;
  /**
   * Optional method that will force session refresh
   */
  refresh?: RefreshSession;
  /**
   * Optional method that will return time to live
   */
  timeToLive?: TimeToLive;
  /**
   * Optional method that will redirect to login page
   */
  goToLoginPage?: GoToLoginPage;
  /**
   * Optional method to allow registering a session countdown
   */
  register?: (countdown: Countdown) => () => void;
  /**
   * Optional method that will reauthenticate a user
   */
  reauthenticate?: Reauthenticate;
  /**
   * Optional method that determines whether the user is being impersonated
   */
  isImpersonated?: () => boolean;
}

export declare type BackbaseSession = StoredSession & { token?: Base64Jwt };

/**
 * BAS Authentication Config Interface
 */
export declare interface BasConfig {
  /** Basic Authentication is set */
  kind: AuthKind.Basic;
  /** Url used for the landing page */
  landingPageUrl?: string;
  /** Url used for the login page */
  loginPageUrl?: string;
  /** Url to authenticate the user */
  authUrl?: string;
  /** On getting authenticated this is the url to refresh */
  refreshUrl?: string;
  /** Url to logout */
  logoutUrl?: string;
  /** Url to check the status */
  statusUrl?: string;
  /** Time in seconds before session expiry that countdown will start */
  countdownDuration?: Seconds;
  /** Time in seconds of maximum user inactivity before session is terminated */
  maxInactivityDuration?: Seconds;
  /** Time in seconds of keeping alive session in CX5 */
  sessionTTL?: Seconds;
}

export declare type Base64Jwt = string;

export declare function bootstrap(cdnPageConfig: CdnPageConfig, pageModel: Container): Promise<void[]>;

/**
 * BootstrapItem function type.
 *
 * This function receives an item and the item location where it should be rendered and
 * returns a Promise<void> that resolves when item has been rendered.
 */
declare type BootstrapItem = (item: Item, itemLocation: ItemLocation) => Promise<void>;

/**
 * Breadcrumb navigation interface
 */
export declare interface Breadcrumb {
  /**
   * One of the values you can find in LinkType
   * - LinkType.Page
   * - LinkType.External
   * - LinkType.Divider
   * - LinkType.Header
   */
  type: LinkType;
  /** Title becomes the label of this item in breadcrumb */
  title: string;
  /** This is the url that points to this item in breadcrumb */
  url: string;
  /**
   * If the current url matches the url of this item it will return true
   * this can be used to highlight the item in breacrumb.
   */
  isCurrent: boolean;
  /** Other properties for this breadcrumb item. */
  properties: Properties;
}

/**
 * CanRender function type.
 *
 * This function receives a possible container and an item and returns if item can be rendered or not
 */
declare type CanRender = (container: Item, item: Item) => boolean;

export declare interface CdnPageConfig {
    apiRoot: string;
    staticResourcesRoot: string;
    locale: string;
    auth: HybridConfig;
    locales?: string;
    features?: any;
}

/**
 * Error response for a reauthentication or challenge request.
 * Implies the reauthentication process has failed.
 */
export declare interface ChallengeError {
  /**
   * A code identifying the error type to the user.
   */
  errorCode: string;
  /**
   * A code identifying the error description to the user.
   */
  errorDescription?: string;
}

/**
 * Data object for a reauthentication request.
 * A response containing an attribute implies that reauthentication did not immediately succeed.
 */
export declare interface ChallengeResponse {
  /**
   * The challenge type received after reauthentication.
   */
  challengeType?: string;
  /**
   * The challenge data used to identify what the user is signing.
   */
  challengeData?: object;
  /**
   * A function to post a response to the challenge.
   */
  postChallengeResponse?: ChallengeResponseFunction;
  /**
   * An error object describing how reauthentication failed.
   */
  error?: ChallengeError;
}

/**
 * The type for the post function to the auth server for a challenge.
 */
export declare type ChallengeResponseFunction = (data: object) => Promise<void | ChallengeResponse>;

export declare const checkPageItem: PageItemCheck;

declare interface Condition {
  kind: string;
  logic: LogicalOperator;
  [key: string]: any;
}

declare interface ConditionalValue {
  value: Property;
  condition: Array<Condition | ConditionGroup>;
}

declare interface ConditionGroup {
  logic: LogicalOperator;
  conditions: Condition[];
}

export declare interface Conditions {
  resolveConditions: ResolveConditions;
  resolveValue: ResolveValue;
  addResolver: AddConditionResolver;
}

/**
 * The interface declares a container entity.
 * A container item (as of it extends the widget interface)
 * contains a name, properties and an array of children.
 */
export declare interface Container extends Widget {
  /** Array of children items */
  children: Item[];
}

/**
 * Simplified ContentItem of a Content Services' content item
 */
export declare interface ContentItem<T = any> {
  /** Type of content item */
  type: ContentTypes;
  /** Type definition for structured content item */
  typeDefinitionName?: string;
  /** Content of content item */
  content: T;
  /** Map of content item properties */
  properties: { [key: string]: string | number };
}

/**
 * Options when resolving content
 */
export declare interface ContentOptions {
  /** Loads renditions for image content items, defaults to false */
  loadRenditions?: boolean;
}

/**
 * Common types of content items
 */
export declare enum ContentType {
  DOCUMENT = 'cmis:document',
  FOLDER = 'cmis:folder',
  IMAGE = 'bb:image',
  STRUCTURED_CONTENT = 'bb:structuredcontent',
  THUMBNAIL = 'cmis:thumbnail',
}

/**
 * ContentType
 *
 * Possible content types
 * @deprecated used only for the deprecated PortalContent.get method
 */
export declare type ContentTypeLegacy = ContentType.IMAGE | ContentType.STRUCTURED_CONTENT;

/**
 * ContentTypes of RawContentItem
 */
export declare enum ContentTypes {
  DOCUMENT = ContentType.DOCUMENT,
  IMAGE = ContentType.IMAGE,
  STRUCTURED_CONTENT = ContentType.STRUCTURED_CONTENT,
}

export declare type ContentUpdateUnsubscribe = () => void;

export declare interface Cookie {
  set: (name: string, token: Base64Jwt, options?: CookieOptions) => void;
  remove: (name: string, options?: CookieOptions) => void;
  get: (name: string) => string | undefined;
}

export declare interface CookieOptions {
  path: string;
  expires?: Date;
  secure: boolean;
}

export declare interface Countdown {
  start: () => void;
  reset: () => void;
  end: () => void;
  tick?: (remaining: Seconds) => void;
  duration?: Seconds;
}

/**
 * Custom Authentication Config Interface
 */
export declare interface CustomConfig {
  /** Custom Authentication is set */
  kind: AuthKind.Custom;
  /** Time in seconds before session expiry that countdown will start */
  countdownDuration?: Seconds;
  /** Time in seconds of maximum user inactivity before session is terminated */
  maxInactivityDuration?: Seconds;
  [key: string]: any;
}

/** CXResponse interface */
export declare interface CXResponse extends HttpResponse {
  body: string | Blob;
}

/**
 * Simplified represenation of a document content item
 */
export declare interface DocumentItem {
  /** Url of the content steam id including apiRoot */
  url: string;
  /** Mime type of the content item */
  mimeType: string;
  /** Size of the content item, not available in CX5 */
  bytes?: number;
}

declare interface DynamicValueConfig {
  defaultValue: Property;
  conditionalValues: ConditionalValue[];
}

/**
 * EventName alias type
 *
 * Used to be sure that event name is a string
 */
export declare type EventName = string;

/**
 * Maps ContentItem type to its content field type, or uses generic
 */
export declare type FlattenContentItem<T> = T extends ContentItem<any> ? T['content'] : T;

/**
 * GetBreadcrumbs function type that returns the path of the breadcrumb.
 */
export declare type GetBreadcrumbs = () => Promise<Breadcrumb[]>;

/**
 * GetTree function type that gets a uuid and depth and it returns a promise with the LinkTreeItem object.
 */
export declare type GetTree = (uuid: string, depth: number) => Promise<LinkTreeItem>;

/**
 * Redirects to login page
 */
export declare type GoToLoginPage = (redirectUri?: string) => void;

/**
 * Object Headers type.
 * It can have any member if the key and the value are of type string
 */
declare interface Headers_2 {
  [key: string]: string;
}

export declare type HttpHandler = (httpConfig: HttpRequestConfig) => Promise<HttpResponse>;

export declare type HttpInterceptor = (httpConfig: HttpRequestConfig, next: HttpHandler) => Promise<HttpResponse>;

/**
 * HttpInterceptors interface
 */
export declare interface HttpInterceptors {
  /** Function called to add a new interceptor */
  add: (interceptor: HttpInterceptor) => void;
  /** Function called to run the interceptors */
  run: (httpConfig: HttpRequestConfig, lastHandler: HttpHandler) => Promise<HttpResponse>;
}

/**
 * HttpMethod union type
 * Accepts as value only these values.
 */
declare type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'HEAD' | 'CONNECT' | 'OPTIONS' | 'TRACE' | 'PATCH';

/**
 * Generic HttpRequest type.
 */
export declare type HttpRequest<T = any> = (config: HttpRequestConfig, log?: Log) => Promise<HttpResponse<T>>;

/**
 * HttpRequestConfig interface
 */
export declare interface HttpRequestConfig {
  /**
   * Method used to communicate to the server
   *
   * @see HttpMethod
   */
  method: HttpMethod;
  /**
   * Url to send the request
   */
  url: string;
  /**
   * Query Data if it's a GET request
   * @see Query
   */
  query?: Query;
  /**
   * Headers to be sent with our request
   *
   * @see Headers
   */
  headers?: Headers_2;
  /**
   * This is the expected response type
   * @see XMLHttpRequestResponseType
   */
  responseType?: XMLHttpRequestResponseType;
  /**
   * Data to be sent to the server if method is different from GET
   */
  data?: Document | BodyInit;
  /**
   * Whether to include credentials in a cross origin request.
   */
  withCredentials?: boolean;
}

/**
 * Generic HttpResponse
 */
export declare interface HttpResponse<T = any> {
  /**
   * Response status number
   */
  status: number;
  /**
   * Response status text is the data fetched from server
   */
  statusText: string;
  /**
   * Headers sent by server
   */
  headers: Headers_2;
  /**
   * Body of the response.
   */
  body: T;
}

/**
 * Hybrid Authentication Config Interface
 */
export declare interface HybridConfig {
  /** Hybrid Authentication is set */
  kind: AuthKind.Hybrid;
  /** Url used for the landing page */
  landingPageUrl: string;
  /** Url used for the login page */
  loginPageUrl: string;
  /** Url to authenticate the user */
  authUrl: string;
  /** ClientId hash for the app we want to get authenticated*/
  clientId: string;
  /** App Scope */
  scope: string;
  /** App Realm */
  realm: string;
  /** Time in seconds before session expiry that countdown will start */
  countdownDuration?: Seconds;
  /** Time in seconds of maximum user inactivity before session is terminated */
  maxInactivityDuration?: Seconds;
}

/**
 * ImageContentItem interface
 *
 * When a content is an image
 * @deprecated used only for the deprecated PortalContent.get method
 */
export declare interface ImageContentItem {
  /** Id of content item */
  id: string;
  /** Type of content type */
  type: ContentTypeLegacy;
  /** Image url without apiRoot */
  contentRef: string;
  /** Alt text of content item resolved from bb:altText property */
  altText?: string;
}

/**
 * Simplified represenation of a image content item
 */
export declare interface ImageItem extends DocumentItem {
  /** Title of the content item */
  title: string;
  /** Width of the image */
  width: number;
  /** Height of the image */
  height: number;
  /** Alt text of the image */
  altText?: string;
  /** Renditions when loadRenditions is enabled */
  renditions?: ImageItem[];
}

export declare function initialise(cdnPageConfig: CdnPageConfig): {
    propertyResolver: PropertyResolver;
    pageRender: PageRender;
    pageConfig: PageConfig;
    pubsub: Pubsub;
    navigation: Navigation;
    portalContent: PortalContent;
    auth: BackbaseAuth;
    httpInterceptors: HttpInterceptors;
    itemRefresher: ItemRefresher;
    setLocale: SetLocale;
    conditions: Pick<PropertyResolver, "resolveEntitlements">;
};

export declare type IsExternal = (url: string) => boolean;

/**
 * Item interface is an abstraction on top of
 * the Widget and the Container (a union) interfaces.
 */
export declare type Item = Widget | Container;

/**
 * ItemLocation Union Type
 */
export declare type ItemLocation = { parentName: string, index: number } | undefined;

/**
 * ItemRefresher interface
 */
declare interface ItemRefresher {
  /** Function that is executed to refresh the item */
  refresh: Refresh;
}

/** LinkTreeItem interface */
export declare interface LinkTreeItem extends Breadcrumb {
  /** Is true if link is in path */
  isInPath: boolean;
  /** Set of link children */
  children: LinkTreeItem[];
}

/** LinkType */
declare type LinkType = 'page' | 'externalLink' | 'divider' | 'menuHeader';

/**
 * Log function type
 */
declare type Log = (label: string, obj: any) => void;

/**
 * @module lib-bb-conditions
 * @description Library to resolve conditional properties
 */

declare enum LogicalOperator {
  AND = 'AND',
  OR = 'OR',
  NOT = 'NOT',
}

/**
 * Login function type
 */
export declare type Login = (username: string, password: string) => Promise<void>;

/**
 * Logout function type
 */
export declare type Logout = (redirectUri?: string) => Promise<void>;

export declare type ModuleLoader = (name: string) => { [key: string]: any };

/** Navigation Interface */
export declare interface Navigation {
  /** Function to return the breadcrumb */
  getBreadcrumbs: GetBreadcrumbs;
  /** Function to get the tree */
  getTree: GetTree;
}

/**
 * PageConfig interface
 */
export declare interface PageConfig {
  /**
   * Major version of CXP (5 or 6)
   */
  version: string;
  /**
   * Portal gateway API path
   */
  apiRoot: string;
  /**
   * URI where the resources of imported catalog items are located
   */
  staticResourcesRoot: string;
  /**
   * Name of the portal that current page belongs to
   */
  portalName: string;
  /**
   * Name of the current page item
   */
  pageName: string;
  /**
   * True if page is rendered inside CXP Manager
   */
  designmode: boolean;
  /**
   * Uuid of the current link
   */
  currentLinkUUID: string;
  /**
   * Uuid of the current link
   */
  currentLink: string;
  /**
   * Current page locale
   */
  locale: string;
  /**
   * Array of available locale ISO values
   */
  locales: string[];
  /**
   * Portal link path
   */
  linkRoot: string;
  /**
   * CSP nonce
   */
  cspNonce: string;
  /**
   * web-sdk version
   */
  webSdkVersion: string;
  /**
   * Flag to detect if user is manager
   */
  isManager?: boolean;
  /**
   * Flag to detect if user is admin
   */
  isAdmin?: boolean;
  /**
   * Current user id
   */
  userId: string;
}

export declare type PageItemCheck = (pageItem: Container, propertyResolver: PropertyResolver) => Promise<boolean>;

/**
 * PageRender interface
 */
declare interface PageRender extends RenderApi {
  /** Function that checks if a container rendering strategy can render an item being dropped on it */
  canRender: CanRender;
  /** Function called to refresh a widget or container (remove and bootstrap) */
  refresh: BootstrapItem;
}

/**
 * PortalContent service interface
 */
export declare interface PortalContent {
  /**
   * Takes content ref property value and returns content item.
   * @param contentRef value of content ref property, e.g. cs:@portalRepository:id
   * @returns Promise of ImageContentItem or StructuredContentItem (only for rich text and plain text content types)
   * @deprecated Should use getContent and getRawContent which have support for any structured content
   */
  get(contentRef: string): Promise<StructuredContentItem | ImageContentItem>;

  /**
   * Takes content ref property and returns resolved image, document, or structured content item.
   * Structured content gets resolved with relations up to 3 levels deep.
   * @param contentRef value of content ref property, e.g. cs:@portalRepository:id
   * @param options options to resolve content
   * @returns Promise of flatten ContentItem object
   */
  getContent<T extends ContentItem<any>>(contentRef: string, options?: ContentOptions): Promise<FlattenContentItem<T>>;
  getContent<T>(contentRef: string, options?: ContentOptions): Promise<T>;

  /**
   * Takes content ref property and returns resolved image, document, or structured content item.
   * Structured content gets resolved with relations up to 3 levels deep.
   * The content item is in a detailed format which contains the fields:
   * - type: content item type
   * - content: content item's content (same result as getContent)
   * - properties: key-value-pair map of content item properties
   * @param contentRef value of content ref property, e.g. cs:@portalRepository:id
   * @param options options to resolve content
   * @returns Promise of ContentItem
   */
  getContentItem<T extends ContentItem<any>>(contentRef: string, options?: ContentOptions): Promise<T>;

  /**
   * Subscribes to dynamic content updates for content ref properties on an item.
   * This method is used by internal code to get live content updates from manager tooling.
   * @param itemName name of the item
   * @param propertyName name of the (contentRef) property
   * @param update callback function with the updated content
   * @returns unsubscribe method
   */
  subscribeContentUpdate<T extends ContentItem<any>>(itemName: string, propertyName: string, update: (content?: FlattenContentItem<T>) => void): ContentUpdateUnsubscribe;
  subscribeContentUpdate<T>(itemName: string, propertyName: string, update: (content?: T) => void): ContentUpdateUnsubscribe;

  /**
   * Subscribes to dynamic content item updates for content ref properties on an item.
   * This method is used by internal code to get live content updates from manager tooling.
   * @param itemName name of the item
   * @param propertyName name of the (contentRef) property
   * @param update callback function with the updated content item
   * @returns unsubscribe method
   */
  subscribeContentItemUpdate<T extends ContentItem<any>>(itemName: string, propertyName: string, update: (contentItem?: T) => void): ContentUpdateUnsubscribe;
}

/**
 * Backbase Item Properties
 * It defines a property as a hashMap (key-value pairs),
 * where a key is a unique (per item) string and a
 * value is an actual property value.
 */
export declare interface Properties {
  [key: string]: Property;
}

/**
 * Property union type that can be one of these only.
 */
export declare type Property = number | boolean | string | string[] | null;

export declare interface PropertyResolver {
  resolveItem: ResolveItem;
  resolveEntitlements: ResolveEntitlements;
}

/**
 * Pubsub interface
 */
export declare interface Pubsub {
  /**
   * Function used to publish/trigger any event
   * @param eventName Event name to publish
   * @param payload Data to pass to all the event listeners
   * @returns void
   */
  publish<T>(eventName: EventName, payload: T): void;
  /**
   * Function used to start listening to events.
   * @param eventName Event name to get subscribed to
   * @param listener Function to execute every time this event is triggered/published.
   * @returns Unsubscribe function
   */
  subscribe<T>(eventName: EventName, listener: PubsubListener<T>): Unsubscribe;
  /**
   * Function to get unsubscribed only from a specific event name and listener
   * @param eventName Event name to get unsubscribed to
   * @param listener Function to remove.
   */
  unsubscribe(eventName: EventName, listener: PubsubListener<any>): void;
  /**
   * Function to unsubscribe for every single eventName and listener
   */
  unsubscribeAll(): void;
}

/**
 * @module lib-bb-pubsub
 * @description Pubsub Backbase event system
 */

/**
 * PubsubListener interface
 *
 * This is a generic function type and it requires to configured
 * the listener setting what type of value it will receive.
 */
export declare type PubsubListener<T> = (eventPayload: T) => void;

/**
 * Object Query type.
 * It can have any member if the key and the value are of type string
 */
declare interface Query {
  [key: string]: string;
}

/**
 * RawPageConfig interface
 */
export declare interface RawPageConfig {
  /**
   * Major version of CXP (5 or 6)
   */
  version: string;
  /**
   * Portal gateway API path
   */
  apiRoot: string;
  /**
   * URI where the resources of imported catalog items are located
   */
  staticResourcesRoot: string;
  /**
   * Name of the portal that current page belongs to
   */
  portalName: string;
  /**
   * Name of the current page item
   */
  pageName: string;
  /**
   * 'true' if page is rendered inside CXP Manager
   */
  designmode: string;
  /**
   * Uuid of the current link
   */
  currentLinkUUID: string;
  /**
   * Uuid of the current link
   */
  currentLink: string;
  /**
   * Current page locale
   */
  locale: string;
  /**
   * Comma separated string of available locale ISO values
   */
  locales: string;
  /**
   * Portal link path
   */
  linkRoot: string;
  /**
   * CSP nonce
   */
  cspNonce: string;
  /**
   * Module loader
   */
  loadModule?: ModuleLoader;
  /**
   * Experience configuration
   */
  cx?: any;
  /**
  * Authentication configuration
  */
  auth?: any;
  /**
   * Flag to detect if user is manager
   */
  isManager?: string;
  /**
   * Flag to detect if user is admin
   */
  isAdmin?: string;
  /**
   * Current user id
   */
  userId: string;
}

/**
 * A configuration to determine how reauthentication should proceed.
 */
export declare interface ReauthConfig {
  /**
   * The location to return to following reauthentication redirect.
   */
  redirectUri?: string;
  /**
   * Whether to redirect the user or perform a request.
   */
  redirect?: boolean;
}

/**
 * Re-authenticates a user
 */
export declare type Reauthenticate = (scope: string, acrValues: string, reauthConfig?: ReauthConfig) => Promise<void>;

/**
 * A set of error codes generated within the reauthentication flow
 */
export declare enum ReauthErrorCodes {
  UNAVAILABLE = 'reauth_unavailable',
  UNKNOWN = 'unknown_error',
  CHALLENGE_ERROR = 'challenge_error',
  TOKEN_ERROR = 'token_error',
}

export declare type Redirect = (url: string, onInfiniteLoop?: () => void) => void;

/**
 * Refresh function type
 */
export declare type Refresh = (itemName: string, reloadModel?: boolean) => Promise<void>;

/**
 * RefreshSession function type
 */
export declare type RefreshSession = () => Promise<void>;

/**
 * RemoveItem function type.
 *
 * This function receives an item and the item location where it should be removed from and
 * returns a Promise<void> that resolves when item has been removed.
 */
declare type RemoveItem = (item: Item, itemLocation: ItemLocation) => Promise<void>;

/** RenderApi interface
 * Object returned from a rendering strategy that contains methods for rendering items and containers
*/
declare interface RenderApi {
  /** Function to run to bootstrap the widget / container */
  bootstrap: BootstrapItem;
  /** Function to run to update the widget / container */
  update: UpdateItem;
  /** Function to run to remove the widget / container */
  remove: RemoveItem;
}

/**
 * RenderingStrategy interface
 *
 * Abstraction of the rendering strategy so it can be redefined because of developer needs.
 */
export declare interface RenderingStrategy {
  /** Function executed to render an item */
  bootstrap(item: Item, itemLocation: ItemLocation): Promise<boolean | void>;
  /** Function executed to update properties of an item and perform the changes in view*/
  update(item: Item, itemLocation: ItemLocation, changes: Partial<Properties>): Promise<void>;
  /** Function executed to remove an item of the view */
  remove(item: Item, itemLocation: ItemLocation): Promise<void>;
}

declare interface ResolvableItem {
  properties: Properties;
  children?: ResolvableItem[];
}

declare type ResolveConditions = (conditions: Array<Condition | ConditionGroup>) => Promise<boolean>;

export declare type ResolveEntitlements = (entitlementDefinition: string) => Promise<boolean>;

declare type ResolveItem = <T extends ResolvableItem = ResolvableItem>(item: T) => Promise<T | undefined>;

declare type Resolver = (conditionConfig?: any) => Promise<boolean>;

declare type ResolveRedirectPageUrl = (loginPageUrl: string, redirectPageUrl: string) => string | undefined;

declare type ResolveValue = (dynamicValue: DynamicValueConfig) => Promise<Property>;

export declare type Seconds = number;

declare interface SessionOptions {
  timeSkew?: number;
  refreshToken?: Base64Jwt;
  forceSessionCookie?: true;
  isImpersonated?: true;
}

export declare type SetLocale = (locale: string) => Promise<CXResponse>;

declare type SetLocale_2 = (locale: string) => Promise<CXResponse>;

export declare interface StoredSession {
  accessExpiry: UnixTimeSeconds;
  timeSkew: Seconds;
  refreshToken?: Base64Jwt;
  isImpersonated: boolean;
}

/**
 * StructuredContentItem interface
 *
 * When a content is a structured content
 * @deprecated used only for the deprecated PortalContent.get method
 */
export declare interface StructuredContentItem {
  /** Id of content item */
  id: string;
  /** Type of content item */
  type: ContentTypeLegacy;
  /** Current content value */
  content: any;
  [key: string]: any;
}

/**
 * Common types of structured content items
 */
export declare enum StructuredContentType {
  PLAIN_TEXT = 'SC_Unit_PlainText',
  RICH_TEXT = 'SC_Unit_RichText',
}

/**
 * Returns time to live in seconds
 */
export declare type TimeToLive = () => Seconds;

export declare type UnixTimeSeconds = number;

/**
 * Unsubscribe function type
 *
 * Used to get unsubscribed to any event.
 */
export declare type Unsubscribe = () => void;

/**
 * UpdateItem function type
 *
 * This function updates an item properties and or ItemLocation
 * and returns a Promise<void> that gets resolved when the item
 * has been updated.
 */
declare type UpdateItem = (item: Item, itemLocation: ItemLocation, properties: Partial<Properties>) => Promise<void>;

/**
 * Widget item definition. It specifies widget as
 * an entity, which has aname and a set of properties
 */
export declare interface Widget {
  /** Widget Name */
  name: string;
  /** Widget properties */
  properties: Properties;
}

export { }
