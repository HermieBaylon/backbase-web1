import { Component, ChangeDetectionStrategy, ViewChild, } from '@angular/core';
import { combineLatest, of, Subject } from 'rxjs';
import { filter, map, switchMap, catchError } from 'rxjs/operators';
import { defaultPlaceTypeMarkerURI, defaultPlaceType, } from '../model/constants';
import { parseError } from '../model/place-error-model';
import { MapAPILoaderService, } from '../components/bb-map-ui/map-api-loader.service';
import { PlacesMeasurementSystem, } from '../services/places-journey-config.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/places-journey-config.service";
import * as i2 from "../services/places.service";
import * as i3 from "@backbase/foundation-ang/core";
import * as i4 from "../components/bb-map-ui/map-api-loader.service";
import * as i5 from "@backbase/ui-ang/header";
import * as i6 from "../components/bb-map-ui/map-search.component";
import * as i7 from "@backbase/ui-ang/icon";
import * as i8 from "@backbase/ui-ang/input-checkbox";
import * as i9 from "../components/places-list/places-list.component";
import * as i10 from "../components/map-wrapper/map-wrapper.component";
import * as i11 from "@backbase/ui-ang/empty-state";
import * as i12 from "@backbase/ui-ang/loading-indicator";
import * as i13 from "@backbase/ui-ang/common-error-state";
import * as i14 from "@angular/common";
import * as i15 from "@angular/forms";
export class PlacesViewComponent {
    constructor(config, service, assetsService, cd, loader) {
        this.config = config;
        this.service = service;
        this.assetsService = assetsService;
        this.cd = cd;
        this.loader = loader;
        this.mapParamsSubject = new Subject();
        this.mapParams = this.mapParamsSubject.asObservable();
        this.selectedPlaceId = new Subject();
        this.resolveAsset = this.assetsService.createAssetsResolver({
            widgetName: 'bb-places-journey-ang',
            getURIFromAssetID: (placeType) => {
                const found = this.placeTypes.find((type) => type === placeType);
                return found
                    ? this.config.placeTypes[found].markerUrl || defaultPlaceTypeMarkerURI
                    : defaultPlaceTypeMarkerURI;
            },
        });
        this.mapConfigObject = {};
        this.locations = this.mapParams.pipe(filter((params) => params !== undefined), switchMap((params) => this.service.getPlaces(params)), map((data) => this.config.limitList ? data.slice(0, this.config.limitList) : data), catchError((error) => {
            this.handleError(error);
            return of([]);
        }));
        this.selectedView = 'list';
        this.latitude = 0;
        this.longitude = 0;
        this.radius = 1;
        this.types = [];
        this.latitude = this.config.latitude;
        this.longitude = this.config.longitude;
        this.radius = this.config.radius;
        this.limitList = this.config.limitList;
    }
    // This is required to show info window only on mobile screen
    set groupBtns(elRef) {
        this.groupBtnRef = elRef;
        setTimeout(() => {
            if (!this.groupBtnRef) {
                return;
            }
            this.smallScreen =
                window.getComputedStyle(this.groupBtnRef.nativeElement).display !==
                    'none';
        }, 0);
    }
    loadApi(mapConfig = {}) {
        this.loader.config = mapConfig;
        return this.loader.load().then(() => {
            this.geocoder = new google.maps.Geocoder();
            return;
        });
    }
    getCurrentLocation() {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition((location) => {
                this.currentPosition = {
                    lat: location.coords.latitude,
                    lng: location.coords.longitude,
                };
                if (!this.geocoder) {
                    return;
                }
                this.geocoder.geocode({ location: this.currentPosition }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const route = results[0].address_components.filter((item) => item.types.find((type) => type === 'route'));
                        this.currentLocation =
                            route[0].long_name || results[0].formatted_address;
                    }
                });
            });
        }
    }
    handleError(error) {
        this.error = parseError(error);
    }
    get groupBtns() {
        return this.groupBtnRef;
    }
    get mapConfig() {
        return this.mapConfigObject;
    }
    get placeTypes() {
        return Object.keys(this.config.placeTypes);
    }
    get icons() {
        const types = [defaultPlaceType].concat(this.placeTypes);
        return combineLatest(types.map((type) => this.resolveAsset(type))).pipe(map((assets) => {
            const icons = {};
            for (let i = 0; i < assets.length; i++) {
                icons[types[i]] = assets[i];
            }
            return icons;
        }));
    }
    get isMetric() {
        return this.config.measurementSystem !== PlacesMeasurementSystem.METRIC;
    }
    filterTypes(values) {
        const types = [];
        Object.keys(values).forEach((key) => {
            if (values[key]) {
                types.push(key);
            }
        });
        return types;
    }
    locationUpdate(params) {
        this.latitude = params.latitude;
        this.longitude = params.longitude;
        this.radius = params.radius || this.config.radius;
        this.types = params.types || this.types;
        this.cd.detectChanges();
        this.mapParamsSubject.next(Object.assign(Object.assign({}, params), { radius: this.config.radius, types: this.types }));
    }
    handleTypeSearch(types) {
        this.locationUpdate({
            latitude: this.latitude,
            longitude: this.longitude,
            radius: this.radius,
            types,
        });
    }
    handleMapSearch(place) {
        if (!place.geometry) {
            return;
        }
        this.locationUpdate({
            latitude: place.geometry.location.lat(),
            longitude: place.geometry.location.lng(),
            radius: this.config.radius,
            types: this.types,
        });
    }
    updatePlaceSelection(place) {
        this.selectedPlaceId.next(place.id);
    }
    onMapReady() {
        // Map is there, so we don't use list limit property to determine list size. Map's zoom and radius parameter are driving it from now on
        this.limitList = undefined;
        this.locationUpdate({
            latitude: this.latitude,
            longitude: this.longitude,
            radius: this.radius,
            types: this.types,
        });
    }
    ngOnInit() {
        this.mapConfigObject = {
            apiKey: this.config.apiKey,
            libraries: ['geometry'],
        };
        this.loadApi(this.mapConfigObject).then(() => {
            this.getCurrentLocation();
        });
        this.locationUpdate({
            latitude: this.config.latitude,
            longitude: this.config.longitude,
            radius: this.config.radius,
        });
    }
}
PlacesViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesViewComponent, deps: [{ token: i1.PlacesJourneyConfigService }, { token: i2.PlacesService }, { token: i3.AssetsService }, { token: i0.ChangeDetectorRef }, { token: i4.MapAPILoaderService }], target: i0.ɵɵFactoryTarget.Component });
PlacesViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PlacesViewComponent, selector: "bb-places-view", providers: [MapAPILoaderService], viewQueries: [{ propertyName: "groupBtns", first: true, predicate: ["groupBtns"], descendants: true }], ngImport: i0, template: "<div\n  [ngClass]=\"{\n    'bb-heading-widget bb-heading-widget--de-elevated': config.deElevatedHeader\n  }\"\n>\n  <bb-header-ui\n    headingType=\"h1\"\n    [headingClasses]=\"\n      config.deElevatedHeader\n        ? 'bb-heading-widget__heading'\n        : 'bb-heading-widget__heading px-0 pb-5'\n    \"\n    heading=\"Find Branches and ATMs\"\n    i18n-heading=\"\n      Find Branches and ATMs|Heading for the Places\n      journey@@places.journey.heading.text\"\n  ></bb-header-ui>\n  <ng-content></ng-content>\n</div>\n\n<div\n  [ngClass]=\"{ 'container--drag-up container-fluid': config.deElevatedHeader }\"\n>\n  <ng-container\n    *ngTemplateOutlet=\"placesContainer; context: { places: locations | async }\"\n  ></ng-container>\n</div>\n\n<ng-template #placesContainer let-places=\"places\">\n  <div class=\"card\">\n    <div class=\"card-body\">\n      <div class=\"row\" [class.bb-stack--center]=\"this.error\">\n        <ng-container *ngIf=\"!this.error; else errorState\">\n          <div class=\"col-md-6\">\n            <bb-map-search-ui\n              [config]=\"this.mapConfig\"\n              (mapSearch)=\"this.handleMapSearch($event)\"\n            ></bb-map-search-ui>\n\n            <div\n              class=\"bb-inline-stack bb-text-support bb-block bb-block--md\"\n              *ngIf=\"this.currentLocation\"\n            >\n              <bb-icon-ui\n                name=\"my-location\"\n                class=\"bb-inline-stack__item\"\n              ></bb-icon-ui>\n              <span\n                class=\"bb-inline-stack__item\"\n                i18n=\"\n                  Current Location|current location message for\n                  places@@places.state.currentLocation\"\n                >Current Location - {{ this.currentLocation }}</span\n              >\n            </div>\n\n            <form\n              #placeTypeFilterForm=\"ngForm\"\n              class=\"bb-block bb-block--md bb-stack bb-stack--density-xl\"\n              *ngIf=\"places && places.length\"\n            >\n              <bb-input-checkbox-ui\n                *ngFor=\"let type of this.placeTypes; let i = index\"\n                ngModel\n                [name]=\"type\"\n                class=\"bb-stack__item\"\n                (change)=\"\n                  this.handleTypeSearch(\n                    this.filterTypes(placeTypeFilterForm.value)\n                  )\n                \"\n              >\n                <span i18n=\"filters|filters for types@@places.filter.types\"\n                  >{type, select, atm {ATM's} branch {Branches}}</span\n                >\n              </bb-input-checkbox-ui>\n            </form>\n\n            <div\n              class=\"bb-text-align-center bb-block bb-block--md d-md-none\"\n              #groupBtns\n            >\n              <div\n                class=\"btn-group btn-group-toggle bb-block bb-block--full-width\"\n              >\n                <button\n                  class=\"btn btn-secondary\"\n                  [ngClass]=\"{ active: this.selectedView === 'list' }\"\n                  name=\"list\"\n                  (click)=\"this.selectedView = 'list'\"\n                  i18n=\"List view button|List view @@places.toggle.view.list\"\n                >\n                  List\n                </button>\n                <button\n                  class=\"btn btn-secondary\"\n                  [ngClass]=\"{ active: this.selectedView === 'map' }\"\n                  (click)=\"this.selectedView = 'map'\"\n                  i18n=\"Map view Button|Map view @@places.toggle.view.map\"\n                >\n                  Map\n                </button>\n              </div>\n            </div>\n\n            <div [hidden]=\"this.selectedView === 'map'\" class=\"d-md-block\">\n              <div\n                class=\"bb-places-list\"\n                [ngClass]=\"\n                  places && places.length ? '' : 'bb-places-list--empty'\n                \"\n              >\n                <ng-container *ngIf=\"places; else loadingState\">\n                  <ng-container *ngIf=\"places.length; else emptyState\">\n                    <bb-places-list\n                      [radius]=\"this.config.radius\"\n                      [locations]=\"places\"\n                      [selectedPlaceId]=\"\n                        (this.selectedPlaceId | async) || undefined\n                      \"\n                      [currentPosition]=\"this.currentPosition\"\n                      [isMetric]=\"this.isMetric\"\n                      [placeTypes]=\"this.config.placeTypes\"\n                      (selected)=\"this.updatePlaceSelection($event)\"\n                    ></bb-places-list>\n                  </ng-container>\n                </ng-container>\n              </div>\n            </div>\n          </div>\n          <div\n            class=\"col-md-6 d-md-block\"\n            [hidden]=\"this.selectedView === 'list'\"\n          >\n            <bb-map-wrapper\n              [apiKey]=\"this.config.apiKey\"\n              [config]=\"this.mapConfig\"\n              [mapZoom]=\"this.config.mapZoom\"\n              [latitude]=\"this.latitude\"\n              [longitude]=\"this.longitude\"\n              [icons]=\"this.icons | async\"\n              [locations]=\"places\"\n              [enableInfoWindow]=\"!!this.smallScreen\"\n              [selectedPlaceId]=\"(this.selectedPlaceId | async) || undefined\"\n              (update)=\"this.locationUpdate($event)\"\n              (selected)=\"this.updatePlaceSelection($event)\"\n              (mapReady)=\"this.onMapReady()\"\n            ></bb-map-wrapper>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </div>\n</ng-template>\n\n<!-- Empty List -->\n<ng-template #emptyState>\n  <bb-empty-state-ui\n    class=\"bb-text-align-center\"\n    i18n-title=\"\n      No locations found|Title of a message that is shown when there are no\n      places@@places.state.noResultsFound.title\"\n    i18n-subtitle=\"\n      We could not find any items in this area. Try moving the map or searching\n      for a city or branch|Subtitle of a message that is shown when there are no\n      places@@places.state.noResultsFound.subtitle\"\n    title=\"No Locations Found\"\n    subtitle=\"We couldn\u2019t find any branches or ATMs in this region. Try moving the map or searching for a city or branch.\"\n    iconSize=\"xxl\"\n    iconModifier=\"place\"\n  ></bb-empty-state-ui>\n</ng-template>\n\n<!-- Loading State -->\n<ng-template #loadingState>\n  <bb-loading-indicator-ui\n    i18n-text=\"\n      Loading places data|Text to display while loading\n      places@@places.state.loadingPlaces\"\n  ></bb-loading-indicator-ui>\n</ng-template>\n\n<!-- Error State -->\n<ng-template #errorState>\n  <bb-common-error-state-ui [error]=\"errorCustomTemplate\">\n    <ng-template #errorCustomTemplate>\n      <bb-empty-state-ui\n        class=\"bb-text-align-center\"\n        i18n-title=\"\n          Page couldn\u2019t load|Title of a message that is shown when page couldn't\n          load@@places.state.pageCouldnotLoad.title\"\n        i18n-subtitle=\"\n          Try to reload the page or contact the system administrator.|Subtitle\n          of a message that is shown when page could not\n          load@@places.state.pageCouldnotLoad.subtitle\"\n        title=\"Page couldn\u2019t load\"\n        subtitle=\"Try to reload the page or contact the system administrator.\"\n        iconSize=\"xxl\"\n        iconModifier=\"error\"\n      ></bb-empty-state-ui>\n    </ng-template>\n  </bb-common-error-state-ui>\n</ng-template>\n", components: [{ type: i5.HeaderComponent, selector: "bb-header-ui", inputs: ["headingClasses", "headingType", "heading"] }, { type: i6.MapSearchComponent, selector: "bb-map-search-ui", inputs: ["options", "config"], outputs: ["mapSearch"] }, { type: i7.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i8.InputCheckboxComponent, selector: "bb-input-checkbox-ui", inputs: ["indeterminate"], outputs: ["indeterminateChange"] }, { type: i9.PlacesListComponent, selector: "bb-places-list", inputs: ["radius", "locations", "selectedPlaceId", "currentPosition", "isMetric", "placeTypes"], outputs: ["selected"] }, { type: i10.MapWrapperComponent, selector: "bb-map-wrapper", inputs: ["apiKey", "config", "mapZoom", "latitude", "longitude", "enableInfoWindow", "icons", "locations", "selectedPlaceId"], outputs: ["update", "selected", "locate", "mapReady"] }, { type: i11.EmptyStateComponent, selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }, { type: i12.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i13.ErrorCommonStateComponent, selector: "bb-common-error-state-ui", inputs: ["error"] }], directives: [{ type: i14.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i14.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i14.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i15.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i15.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i15.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i14.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i15.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i15.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i14.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-places-view',
                    templateUrl: './places-view.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [MapAPILoaderService],
                }]
        }], ctorParameters: function () { return [{ type: i1.PlacesJourneyConfigService }, { type: i2.PlacesService }, { type: i3.AssetsService }, { type: i0.ChangeDetectorRef }, { type: i4.MapAPILoaderService }]; }, propDecorators: { groupBtns: [{
                type: ViewChild,
                args: ['groupBtns']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxhY2VzLXZpZXcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9wbGFjZXMtam91cm5leS9zcmMvbGliL3ZpZXdzL3BsYWNlcy12aWV3LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvcGxhY2VzLWpvdXJuZXkvc3JjL2xpYi92aWV3cy9wbGFjZXMtdmlldy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUVULHVCQUF1QixFQUd2QixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFjLGFBQWEsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlELE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUlwRSxPQUFPLEVBQ0wseUJBQXlCLEVBQ3pCLGdCQUFnQixHQUNqQixNQUFNLG9CQUFvQixDQUFDO0FBRzVCLE9BQU8sRUFBRSxVQUFVLEVBQWUsTUFBTSw0QkFBNEIsQ0FBQztBQUVyRSxPQUFPLEVBRUwsbUJBQW1CLEdBQ3BCLE1BQU0sZ0RBQWdELENBQUM7QUFFeEQsT0FBTyxFQUVMLHVCQUF1QixHQUN4QixNQUFNLDJDQUEyQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQVFuRCxNQUFNLE9BQU8sbUJBQW1CO0lBdUQ5QixZQUNXLE1BQWtDLEVBQzFCLE9BQXNCLEVBQ3RCLGFBQTRCLEVBQzVCLEVBQXFCLEVBQ3JCLE1BQTJCO1FBSm5DLFdBQU0sR0FBTixNQUFNLENBQTRCO1FBQzFCLFlBQU8sR0FBUCxPQUFPLENBQWU7UUFDdEIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsT0FBRSxHQUFGLEVBQUUsQ0FBbUI7UUFDckIsV0FBTSxHQUFOLE1BQU0sQ0FBcUI7UUE1QzdCLHFCQUFnQixHQUFHLElBQUksT0FBTyxFQUFtQixDQUFDO1FBQ2xELGNBQVMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDekQsb0JBQWUsR0FBRyxJQUFJLE9BQU8sRUFBVSxDQUFDO1FBQ2hDLGlCQUFZLEdBQzNCLElBQUksQ0FBQyxhQUFhLENBQUMsb0JBQW9CLENBQUM7WUFDdEMsVUFBVSxFQUFFLHVCQUF1QjtZQUNuQyxpQkFBaUIsRUFBRSxDQUFDLFNBQWlCLEVBQUUsRUFBRTtnQkFDdkMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksS0FBSyxTQUFTLENBQUMsQ0FBQztnQkFDakUsT0FBTyxLQUFLO29CQUNWLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLElBQUkseUJBQXlCO29CQUN0RSxDQUFDLENBQUMseUJBQXlCLENBQUM7WUFDaEMsQ0FBQztTQUNGLENBQUMsQ0FBQztRQUNHLG9CQUFlLEdBQWtCLEVBQUUsQ0FBQztRQUduQyxjQUFTLEdBQXdCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUMzRCxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sS0FBSyxTQUFTLENBQUMsRUFDeEMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUNyRCxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ3BFLEVBQ0QsVUFBVSxDQUFDLENBQUMsS0FBd0IsRUFBRSxFQUFFO1lBQ3RDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDeEIsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDaEIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUdGLGlCQUFZLEdBQW1CLE1BQU0sQ0FBQztRQUl0QyxhQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2IsY0FBUyxHQUFHLENBQUMsQ0FBQztRQUNkLFdBQU0sR0FBRyxDQUFDLENBQUM7UUFFWCxVQUFLLEdBQWEsRUFBRSxDQUFDO1FBU25CLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUM7UUFDckMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUN2QyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7SUFDekMsQ0FBQztJQWpFRCw2REFBNkQ7SUFDN0QsSUFDSSxTQUFTLENBQUMsS0FBNkI7UUFDekMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7UUFDekIsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO2dCQUNyQixPQUFPO2FBQ1I7WUFDRCxJQUFJLENBQUMsV0FBVztnQkFDZCxNQUFNLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPO29CQUMvRCxNQUFNLENBQUM7UUFDWCxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDUixDQUFDO0lBdURPLE9BQU8sQ0FBQyxZQUEyQixFQUFFO1FBQzNDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztRQUMvQixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNsQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUMzQyxPQUFPO1FBQ1QsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sa0JBQWtCO1FBQ3hCLElBQUksYUFBYSxJQUFJLFNBQVMsRUFBRTtZQUM5QixTQUFTLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUU7Z0JBQ3BELElBQUksQ0FBQyxlQUFlLEdBQUc7b0JBQ3JCLEdBQUcsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVE7b0JBQzdCLEdBQUcsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLFNBQVM7aUJBQy9CLENBQUM7Z0JBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ2xCLE9BQU87aUJBQ1I7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQ25CLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsRUFDbEMsQ0FDRSxPQUFxQyxFQUNyQyxNQUFrQyxFQUNsQyxFQUFFO29CQUNGLElBQUksTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUUsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7d0JBQzFELE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUMxRCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxDQUM1QyxDQUFDO3dCQUNGLElBQUksQ0FBQyxlQUFlOzRCQUNsQixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQztxQkFDdEQ7Z0JBQ0gsQ0FBQyxDQUNGLENBQUM7WUFDSixDQUFDLENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQztJQUVPLFdBQVcsQ0FBQyxLQUF3QjtRQUMxQyxJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQsSUFBSSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFCLENBQUM7SUFFRCxJQUFJLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDOUIsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFRCxJQUFJLEtBQUs7UUFDUCxNQUFNLEtBQUssR0FBYSxDQUFDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNuRSxPQUFPLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ3JFLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2IsTUFBTSxLQUFLLEdBQWdCLEVBQUUsQ0FBQztZQUM5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDdEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM3QjtZQUNELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFJLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEtBQUssdUJBQXVCLENBQUMsTUFBTSxDQUFDO0lBQzFFLENBQUM7SUFFRCxXQUFXLENBQUMsTUFBbUM7UUFDN0MsTUFBTSxLQUFLLEdBQWEsRUFBRSxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBVyxFQUFFLEVBQUU7WUFDMUMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2YsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNqQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsY0FBYyxDQUFDLE1BQXVCO1FBQ3BDLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ2xELElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksaUNBQ3JCLE1BQU0sS0FDVCxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQzFCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxJQUNqQixDQUFDO0lBQ0wsQ0FBQztJQUVELGdCQUFnQixDQUFDLEtBQWU7UUFDOUIsSUFBSSxDQUFDLGNBQWMsQ0FBQztZQUNsQixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixLQUFLO1NBQ04sQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELGVBQWUsQ0FBQyxLQUFxQztRQUNuRCxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtZQUNuQixPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsY0FBYyxDQUFDO1lBQ2xCLFFBQVEsRUFBRSxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUU7WUFDdkMsU0FBUyxFQUFFLEtBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRTtZQUN4QyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNO1lBQzFCLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztTQUNsQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsb0JBQW9CLENBQUMsS0FBZ0I7UUFDbkMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxVQUFVO1FBQ1IsdUlBQXVJO1FBQ3ZJLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBRTNCLElBQUksQ0FBQyxjQUFjLENBQUM7WUFDbEIsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztZQUN6QixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLO1NBQ2xCLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLGVBQWUsR0FBRztZQUNyQixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNO1lBQzFCLFNBQVMsRUFBRSxDQUFDLFVBQVUsQ0FBQztTQUN4QixDQUFDO1FBRUYsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUMzQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUM1QixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxjQUFjLENBQUM7WUFDbEIsUUFBUSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUTtZQUM5QixTQUFTLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTO1lBQ2hDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU07U0FDM0IsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7aUhBdk5VLG1CQUFtQjtxR0FBbkIsbUJBQW1CLHlDQUZuQixDQUFDLG1CQUFtQixDQUFDLGtJQ3JDbEMsaThPQTJNQTs0RkRwS2EsbUJBQW1CO2tCQU4vQixTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxnQkFBZ0I7b0JBQzFCLFdBQVcsRUFBRSw4QkFBOEI7b0JBQzNDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO29CQUMvQyxTQUFTLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQztpQkFDakM7Mk9BSUssU0FBUztzQkFEWixTQUFTO3VCQUFDLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIE9uSW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBFbGVtZW50UmVmLFxuICBWaWV3Q2hpbGQsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBIdHRwRXJyb3JSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGNvbWJpbmVMYXRlc3QsIG9mLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgc3dpdGNoTWFwLCBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBBc3NldHNSZXNvbHZlciwgQXNzZXRzU2VydmljZSB9IGZyb20gJ0BiYWNrYmFzZS9mb3VuZGF0aW9uLWFuZy9jb3JlJztcblxuaW1wb3J0IHtcbiAgZGVmYXVsdFBsYWNlVHlwZU1hcmtlclVSSSxcbiAgZGVmYXVsdFBsYWNlVHlwZSxcbn0gZnJvbSAnLi4vbW9kZWwvY29uc3RhbnRzJztcbmltcG9ydCB7IFBsYWNlLCBNYXJrZXJJY29ucywgUGxhY2VJdGVtIH0gZnJvbSAnLi4vbW9kZWwvcGxhY2UtbW9kZWwnO1xuaW1wb3J0IHsgUGxhY2VzR2V0UGFyYW1zIH0gZnJvbSAnLi4vbW9kZWwvcGxhY2UtcGFyYW0tbW9kZWwnO1xuaW1wb3J0IHsgcGFyc2VFcnJvciwgUGxhY2VzRXJyb3IgfSBmcm9tICcuLi9tb2RlbC9wbGFjZS1lcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBQbGFjZXNTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvcGxhY2VzLnNlcnZpY2UnO1xuaW1wb3J0IHtcbiAgTWFwc0FQSUNvbmZpZyxcbiAgTWFwQVBJTG9hZGVyU2VydmljZSxcbn0gZnJvbSAnLi4vY29tcG9uZW50cy9iYi1tYXAtdWkvbWFwLWFwaS1sb2FkZXIuc2VydmljZSc7XG5cbmltcG9ydCB7XG4gIFBsYWNlc0pvdXJuZXlDb25maWdTZXJ2aWNlLFxuICBQbGFjZXNNZWFzdXJlbWVudFN5c3RlbSxcbn0gZnJvbSAnLi4vc2VydmljZXMvcGxhY2VzLWpvdXJuZXktY29uZmlnLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdiYi1wbGFjZXMtdmlldycsXG4gIHRlbXBsYXRlVXJsOiAnLi9wbGFjZXMtdmlldy5jb21wb25lbnQuaHRtbCcsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtNYXBBUElMb2FkZXJTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgUGxhY2VzVmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8vIFRoaXMgaXMgcmVxdWlyZWQgdG8gc2hvdyBpbmZvIHdpbmRvdyBvbmx5IG9uIG1vYmlsZSBzY3JlZW5cbiAgQFZpZXdDaGlsZCgnZ3JvdXBCdG5zJylcbiAgc2V0IGdyb3VwQnRucyhlbFJlZjogRWxlbWVudFJlZiB8IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuZ3JvdXBCdG5SZWYgPSBlbFJlZjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5ncm91cEJ0blJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNtYWxsU2NyZWVuID1cbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5ncm91cEJ0blJlZi5uYXRpdmVFbGVtZW50KS5kaXNwbGF5ICE9PVxuICAgICAgICAnbm9uZSc7XG4gICAgfSwgMCk7XG4gIH1cblxuICBwcml2YXRlIGdyb3VwQnRuUmVmOiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHJlYWRvbmx5IG1hcFBhcmFtc1N1YmplY3QgPSBuZXcgU3ViamVjdDxQbGFjZXNHZXRQYXJhbXM+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgbWFwUGFyYW1zID0gdGhpcy5tYXBQYXJhbXNTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICByZWFkb25seSBzZWxlY3RlZFBsYWNlSWQgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVzb2x2ZUFzc2V0OiBBc3NldHNSZXNvbHZlciA9XG4gICAgdGhpcy5hc3NldHNTZXJ2aWNlLmNyZWF0ZUFzc2V0c1Jlc29sdmVyKHtcbiAgICAgIHdpZGdldE5hbWU6ICdiYi1wbGFjZXMtam91cm5leS1hbmcnLFxuICAgICAgZ2V0VVJJRnJvbUFzc2V0SUQ6IChwbGFjZVR5cGU6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBmb3VuZCA9IHRoaXMucGxhY2VUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlID09PSBwbGFjZVR5cGUpO1xuICAgICAgICByZXR1cm4gZm91bmRcbiAgICAgICAgICA/IHRoaXMuY29uZmlnLnBsYWNlVHlwZXNbZm91bmRdLm1hcmtlclVybCB8fCBkZWZhdWx0UGxhY2VUeXBlTWFya2VyVVJJXG4gICAgICAgICAgOiBkZWZhdWx0UGxhY2VUeXBlTWFya2VyVVJJO1xuICAgICAgfSxcbiAgICB9KTtcbiAgcHJpdmF0ZSBtYXBDb25maWdPYmplY3Q6IE1hcHNBUElDb25maWcgPSB7fTtcbiAgcHJpdmF0ZSBnZW9jb2RlcjogZ29vZ2xlLm1hcHMuR2VvY29kZXIgfCB1bmRlZmluZWQ7XG5cbiAgcmVhZG9ubHkgbG9jYXRpb25zOiBPYnNlcnZhYmxlPFBsYWNlW10+ID0gdGhpcy5tYXBQYXJhbXMucGlwZShcbiAgICBmaWx0ZXIoKHBhcmFtcykgPT4gcGFyYW1zICE9PSB1bmRlZmluZWQpLFxuICAgIHN3aXRjaE1hcCgocGFyYW1zKSA9PiB0aGlzLnNlcnZpY2UuZ2V0UGxhY2VzKHBhcmFtcykpLFxuICAgIG1hcCgoZGF0YSkgPT5cbiAgICAgIHRoaXMuY29uZmlnLmxpbWl0TGlzdCA/IGRhdGEuc2xpY2UoMCwgdGhpcy5jb25maWcubGltaXRMaXN0KSA6IGRhdGFcbiAgICApLFxuICAgIGNhdGNoRXJyb3IoKGVycm9yOiBIdHRwRXJyb3JSZXNwb25zZSkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICByZXR1cm4gb2YoW10pO1xuICAgIH0pXG4gICk7XG5cbiAgZXJyb3I6IFBsYWNlc0Vycm9yIHwgdW5kZWZpbmVkO1xuICBzZWxlY3RlZFZpZXc6ICdsaXN0JyB8ICdtYXAnID0gJ2xpc3QnO1xuICBzbWFsbFNjcmVlbjogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgY3VycmVudExvY2F0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGN1cnJlbnRQb3NpdGlvbjogZ29vZ2xlLm1hcHMuTGF0TG5nTGl0ZXJhbCB8IHVuZGVmaW5lZDtcbiAgbGF0aXR1ZGUgPSAwO1xuICBsb25naXR1ZGUgPSAwO1xuICByYWRpdXMgPSAxO1xuICBsaW1pdExpc3Q6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgdHlwZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgY29uZmlnOiBQbGFjZXNKb3VybmV5Q29uZmlnU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNlcnZpY2U6IFBsYWNlc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBhc3NldHNTZXJ2aWNlOiBBc3NldHNTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbG9hZGVyOiBNYXBBUElMb2FkZXJTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMubGF0aXR1ZGUgPSB0aGlzLmNvbmZpZy5sYXRpdHVkZTtcbiAgICB0aGlzLmxvbmdpdHVkZSA9IHRoaXMuY29uZmlnLmxvbmdpdHVkZTtcbiAgICB0aGlzLnJhZGl1cyA9IHRoaXMuY29uZmlnLnJhZGl1cztcbiAgICB0aGlzLmxpbWl0TGlzdCA9IHRoaXMuY29uZmlnLmxpbWl0TGlzdDtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZEFwaShtYXBDb25maWc6IE1hcHNBUElDb25maWcgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMubG9hZGVyLmNvbmZpZyA9IG1hcENvbmZpZztcbiAgICByZXR1cm4gdGhpcy5sb2FkZXIubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5nZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDdXJyZW50TG9jYXRpb24oKSB7XG4gICAgaWYgKCdnZW9sb2NhdGlvbicgaW4gbmF2aWdhdG9yKSB7XG4gICAgICBuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKChsb2NhdGlvbikgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICBsYXQ6IGxvY2F0aW9uLmNvb3Jkcy5sYXRpdHVkZSxcbiAgICAgICAgICBsbmc6IGxvY2F0aW9uLmNvb3Jkcy5sb25naXR1ZGUsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5nZW9jb2Rlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdlb2NvZGVyLmdlb2NvZGUoXG4gICAgICAgICAgeyBsb2NhdGlvbjogdGhpcy5jdXJyZW50UG9zaXRpb24gfSxcbiAgICAgICAgICAoXG4gICAgICAgICAgICByZXN1bHRzOiBnb29nbGUubWFwcy5HZW9jb2RlclJlc3VsdFtdLFxuICAgICAgICAgICAgc3RhdHVzOiBnb29nbGUubWFwcy5HZW9jb2RlclN0YXR1c1xuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gZ29vZ2xlLm1hcHMuR2VvY29kZXJTdGF0dXMuT0sgJiYgcmVzdWx0c1swXSkge1xuICAgICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJlc3VsdHNbMF0uYWRkcmVzc19jb21wb25lbnRzLmZpbHRlcigoaXRlbSkgPT5cbiAgICAgICAgICAgICAgICBpdGVtLnR5cGVzLmZpbmQoKHR5cGUpID0+IHR5cGUgPT09ICdyb3V0ZScpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID1cbiAgICAgICAgICAgICAgICByb3V0ZVswXS5sb25nX25hbWUgfHwgcmVzdWx0c1swXS5mb3JtYXR0ZWRfYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgIHRoaXMuZXJyb3IgPSBwYXJzZUVycm9yKGVycm9yKTtcbiAgfVxuXG4gIGdldCBncm91cEJ0bnMoKTogRWxlbWVudFJlZjxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cEJ0blJlZjtcbiAgfVxuXG4gIGdldCBtYXBDb25maWcoKTogTWFwc0FQSUNvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMubWFwQ29uZmlnT2JqZWN0O1xuICB9XG5cbiAgZ2V0IHBsYWNlVHlwZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbmZpZy5wbGFjZVR5cGVzKTtcbiAgfVxuXG4gIGdldCBpY29ucygpOiBPYnNlcnZhYmxlPE1hcmtlckljb25zPiB7XG4gICAgY29uc3QgdHlwZXM6IHN0cmluZ1tdID0gW2RlZmF1bHRQbGFjZVR5cGVdLmNvbmNhdCh0aGlzLnBsYWNlVHlwZXMpO1xuICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy5yZXNvbHZlQXNzZXQodHlwZSkpKS5waXBlKFxuICAgICAgbWFwKChhc3NldHMpID0+IHtcbiAgICAgICAgY29uc3QgaWNvbnM6IE1hcmtlckljb25zID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNzZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWNvbnNbdHlwZXNbaV1dID0gYXNzZXRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpY29ucztcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGdldCBpc01ldHJpYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubWVhc3VyZW1lbnRTeXN0ZW0gIT09IFBsYWNlc01lYXN1cmVtZW50U3lzdGVtLk1FVFJJQztcbiAgfVxuXG4gIGZpbHRlclR5cGVzKHZhbHVlczogeyBbdHlwZTogc3RyaW5nXTogYm9vbGVhbiB9KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHR5cGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaCgoa2V5OiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICh2YWx1ZXNba2V5XSkge1xuICAgICAgICB0eXBlcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHlwZXM7XG4gIH1cblxuICBsb2NhdGlvblVwZGF0ZShwYXJhbXM6IFBsYWNlc0dldFBhcmFtcykge1xuICAgIHRoaXMubGF0aXR1ZGUgPSBwYXJhbXMubGF0aXR1ZGU7XG4gICAgdGhpcy5sb25naXR1ZGUgPSBwYXJhbXMubG9uZ2l0dWRlO1xuICAgIHRoaXMucmFkaXVzID0gcGFyYW1zLnJhZGl1cyB8fCB0aGlzLmNvbmZpZy5yYWRpdXM7XG4gICAgdGhpcy50eXBlcyA9IHBhcmFtcy50eXBlcyB8fCB0aGlzLnR5cGVzO1xuICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIHRoaXMubWFwUGFyYW1zU3ViamVjdC5uZXh0KHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIHJhZGl1czogdGhpcy5jb25maWcucmFkaXVzLFxuICAgICAgdHlwZXM6IHRoaXMudHlwZXMsXG4gICAgfSk7XG4gIH1cblxuICBoYW5kbGVUeXBlU2VhcmNoKHR5cGVzOiBzdHJpbmdbXSkge1xuICAgIHRoaXMubG9jYXRpb25VcGRhdGUoe1xuICAgICAgbGF0aXR1ZGU6IHRoaXMubGF0aXR1ZGUsXG4gICAgICBsb25naXR1ZGU6IHRoaXMubG9uZ2l0dWRlLFxuICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1cyxcbiAgICAgIHR5cGVzLFxuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlTWFwU2VhcmNoKHBsYWNlOiBnb29nbGUubWFwcy5wbGFjZXMuUGxhY2VSZXN1bHQpIHtcbiAgICBpZiAoIXBsYWNlLmdlb21ldHJ5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2NhdGlvblVwZGF0ZSh7XG4gICAgICBsYXRpdHVkZTogcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24ubGF0KCksXG4gICAgICBsb25naXR1ZGU6IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpLFxuICAgICAgcmFkaXVzOiB0aGlzLmNvbmZpZy5yYWRpdXMsXG4gICAgICB0eXBlczogdGhpcy50eXBlcyxcbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVBsYWNlU2VsZWN0aW9uKHBsYWNlOiBQbGFjZUl0ZW0pIHtcbiAgICB0aGlzLnNlbGVjdGVkUGxhY2VJZC5uZXh0KHBsYWNlLmlkKTtcbiAgfVxuXG4gIG9uTWFwUmVhZHkoKSB7XG4gICAgLy8gTWFwIGlzIHRoZXJlLCBzbyB3ZSBkb24ndCB1c2UgbGlzdCBsaW1pdCBwcm9wZXJ0eSB0byBkZXRlcm1pbmUgbGlzdCBzaXplLiBNYXAncyB6b29tIGFuZCByYWRpdXMgcGFyYW1ldGVyIGFyZSBkcml2aW5nIGl0IGZyb20gbm93IG9uXG4gICAgdGhpcy5saW1pdExpc3QgPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLmxvY2F0aW9uVXBkYXRlKHtcbiAgICAgIGxhdGl0dWRlOiB0aGlzLmxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlOiB0aGlzLmxvbmdpdHVkZSxcbiAgICAgIHJhZGl1czogdGhpcy5yYWRpdXMsXG4gICAgICB0eXBlczogdGhpcy50eXBlcyxcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMubWFwQ29uZmlnT2JqZWN0ID0ge1xuICAgICAgYXBpS2V5OiB0aGlzLmNvbmZpZy5hcGlLZXksXG4gICAgICBsaWJyYXJpZXM6IFsnZ2VvbWV0cnknXSxcbiAgICB9O1xuXG4gICAgdGhpcy5sb2FkQXBpKHRoaXMubWFwQ29uZmlnT2JqZWN0KS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxvY2F0aW9uVXBkYXRlKHtcbiAgICAgIGxhdGl0dWRlOiB0aGlzLmNvbmZpZy5sYXRpdHVkZSxcbiAgICAgIGxvbmdpdHVkZTogdGhpcy5jb25maWcubG9uZ2l0dWRlLFxuICAgICAgcmFkaXVzOiB0aGlzLmNvbmZpZy5yYWRpdXMsXG4gICAgfSk7XG4gIH1cbn1cbiIsIjxkaXZcbiAgW25nQ2xhc3NdPVwie1xuICAgICdiYi1oZWFkaW5nLXdpZGdldCBiYi1oZWFkaW5nLXdpZGdldC0tZGUtZWxldmF0ZWQnOiBjb25maWcuZGVFbGV2YXRlZEhlYWRlclxuICB9XCJcbj5cbiAgPGJiLWhlYWRlci11aVxuICAgIGhlYWRpbmdUeXBlPVwiaDFcIlxuICAgIFtoZWFkaW5nQ2xhc3Nlc109XCJcbiAgICAgIGNvbmZpZy5kZUVsZXZhdGVkSGVhZGVyXG4gICAgICAgID8gJ2JiLWhlYWRpbmctd2lkZ2V0X19oZWFkaW5nJ1xuICAgICAgICA6ICdiYi1oZWFkaW5nLXdpZGdldF9faGVhZGluZyBweC0wIHBiLTUnXG4gICAgXCJcbiAgICBoZWFkaW5nPVwiRmluZCBCcmFuY2hlcyBhbmQgQVRNc1wiXG4gICAgaTE4bi1oZWFkaW5nPVwiXG4gICAgICBGaW5kIEJyYW5jaGVzIGFuZCBBVE1zfEhlYWRpbmcgZm9yIHRoZSBQbGFjZXNcbiAgICAgIGpvdXJuZXlAQHBsYWNlcy5qb3VybmV5LmhlYWRpbmcudGV4dFwiXG4gID48L2JiLWhlYWRlci11aT5cbiAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cbjxkaXZcbiAgW25nQ2xhc3NdPVwieyAnY29udGFpbmVyLS1kcmFnLXVwIGNvbnRhaW5lci1mbHVpZCc6IGNvbmZpZy5kZUVsZXZhdGVkSGVhZGVyIH1cIlxuPlxuICA8bmctY29udGFpbmVyXG4gICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJwbGFjZXNDb250YWluZXI7IGNvbnRleHQ6IHsgcGxhY2VzOiBsb2NhdGlvbnMgfCBhc3luYyB9XCJcbiAgPjwvbmctY29udGFpbmVyPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjcGxhY2VzQ29udGFpbmVyIGxldC1wbGFjZXM9XCJwbGFjZXNcIj5cbiAgPGRpdiBjbGFzcz1cImNhcmRcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwicm93XCIgW2NsYXNzLmJiLXN0YWNrLS1jZW50ZXJdPVwidGhpcy5lcnJvclwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXRoaXMuZXJyb3I7IGVsc2UgZXJyb3JTdGF0ZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2wtbWQtNlwiPlxuICAgICAgICAgICAgPGJiLW1hcC1zZWFyY2gtdWlcbiAgICAgICAgICAgICAgW2NvbmZpZ109XCJ0aGlzLm1hcENvbmZpZ1wiXG4gICAgICAgICAgICAgIChtYXBTZWFyY2gpPVwidGhpcy5oYW5kbGVNYXBTZWFyY2goJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC9iYi1tYXAtc2VhcmNoLXVpPlxuXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzPVwiYmItaW5saW5lLXN0YWNrIGJiLXRleHQtc3VwcG9ydCBiYi1ibG9jayBiYi1ibG9jay0tbWRcIlxuICAgICAgICAgICAgICAqbmdJZj1cInRoaXMuY3VycmVudExvY2F0aW9uXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGJiLWljb24tdWlcbiAgICAgICAgICAgICAgICBuYW1lPVwibXktbG9jYXRpb25cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYmItaW5saW5lLXN0YWNrX19pdGVtXCJcbiAgICAgICAgICAgICAgPjwvYmItaWNvbi11aT5cbiAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICBjbGFzcz1cImJiLWlubGluZS1zdGFja19faXRlbVwiXG4gICAgICAgICAgICAgICAgaTE4bj1cIlxuICAgICAgICAgICAgICAgICAgQ3VycmVudCBMb2NhdGlvbnxjdXJyZW50IGxvY2F0aW9uIG1lc3NhZ2UgZm9yXG4gICAgICAgICAgICAgICAgICBwbGFjZXNAQHBsYWNlcy5zdGF0ZS5jdXJyZW50TG9jYXRpb25cIlxuICAgICAgICAgICAgICAgID5DdXJyZW50IExvY2F0aW9uIC0ge3sgdGhpcy5jdXJyZW50TG9jYXRpb24gfX08L3NwYW5cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxmb3JtXG4gICAgICAgICAgICAgICNwbGFjZVR5cGVGaWx0ZXJGb3JtPVwibmdGb3JtXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJiYi1ibG9jayBiYi1ibG9jay0tbWQgYmItc3RhY2sgYmItc3RhY2stLWRlbnNpdHkteGxcIlxuICAgICAgICAgICAgICAqbmdJZj1cInBsYWNlcyAmJiBwbGFjZXMubGVuZ3RoXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGJiLWlucHV0LWNoZWNrYm94LXVpXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IHR5cGUgb2YgdGhpcy5wbGFjZVR5cGVzOyBsZXQgaSA9IGluZGV4XCJcbiAgICAgICAgICAgICAgICBuZ01vZGVsXG4gICAgICAgICAgICAgICAgW25hbWVdPVwidHlwZVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJiYi1zdGFja19faXRlbVwiXG4gICAgICAgICAgICAgICAgKGNoYW5nZSk9XCJcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHlwZVNlYXJjaChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJUeXBlcyhwbGFjZVR5cGVGaWx0ZXJGb3JtLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhbiBpMThuPVwiZmlsdGVyc3xmaWx0ZXJzIGZvciB0eXBlc0BAcGxhY2VzLmZpbHRlci50eXBlc1wiXG4gICAgICAgICAgICAgICAgICA+e3R5cGUsIHNlbGVjdCwgYXRtIHtBVE0nc30gYnJhbmNoIHtCcmFuY2hlc319PC9zcGFuXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8L2JiLWlucHV0LWNoZWNrYm94LXVpPlxuICAgICAgICAgICAgPC9mb3JtPlxuXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzPVwiYmItdGV4dC1hbGlnbi1jZW50ZXIgYmItYmxvY2sgYmItYmxvY2stLW1kIGQtbWQtbm9uZVwiXG4gICAgICAgICAgICAgICNncm91cEJ0bnNcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuLWdyb3VwIGJ0bi1ncm91cC10b2dnbGUgYmItYmxvY2sgYmItYmxvY2stLWZ1bGwtd2lkdGhcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiXG4gICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7IGFjdGl2ZTogdGhpcy5zZWxlY3RlZFZpZXcgPT09ICdsaXN0JyB9XCJcbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJsaXN0XCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0aGlzLnNlbGVjdGVkVmlldyA9ICdsaXN0J1wiXG4gICAgICAgICAgICAgICAgICBpMThuPVwiTGlzdCB2aWV3IGJ1dHRvbnxMaXN0IHZpZXcgQEBwbGFjZXMudG9nZ2xlLnZpZXcubGlzdFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgTGlzdFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zZWNvbmRhcnlcIlxuICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieyBhY3RpdmU6IHRoaXMuc2VsZWN0ZWRWaWV3ID09PSAnbWFwJyB9XCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0aGlzLnNlbGVjdGVkVmlldyA9ICdtYXAnXCJcbiAgICAgICAgICAgICAgICAgIGkxOG49XCJNYXAgdmlldyBCdXR0b258TWFwIHZpZXcgQEBwbGFjZXMudG9nZ2xlLnZpZXcubWFwXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBNYXBcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBbaGlkZGVuXT1cInRoaXMuc2VsZWN0ZWRWaWV3ID09PSAnbWFwJ1wiIGNsYXNzPVwiZC1tZC1ibG9ja1wiPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3M9XCJiYi1wbGFjZXMtbGlzdFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiXG4gICAgICAgICAgICAgICAgICBwbGFjZXMgJiYgcGxhY2VzLmxlbmd0aCA/ICcnIDogJ2JiLXBsYWNlcy1saXN0LS1lbXB0eSdcbiAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBsYWNlczsgZWxzZSBsb2FkaW5nU3RhdGVcIj5cbiAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwbGFjZXMubGVuZ3RoOyBlbHNlIGVtcHR5U3RhdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJiLXBsYWNlcy1saXN0XG4gICAgICAgICAgICAgICAgICAgICAgW3JhZGl1c109XCJ0aGlzLmNvbmZpZy5yYWRpdXNcIlxuICAgICAgICAgICAgICAgICAgICAgIFtsb2NhdGlvbnNdPVwicGxhY2VzXCJcbiAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRQbGFjZUlkXT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2VsZWN0ZWRQbGFjZUlkIHwgYXN5bmMpIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRQb3NpdGlvbl09XCJ0aGlzLmN1cnJlbnRQb3NpdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgW2lzTWV0cmljXT1cInRoaXMuaXNNZXRyaWNcIlxuICAgICAgICAgICAgICAgICAgICAgIFtwbGFjZVR5cGVzXT1cInRoaXMuY29uZmlnLnBsYWNlVHlwZXNcIlxuICAgICAgICAgICAgICAgICAgICAgIChzZWxlY3RlZCk9XCJ0aGlzLnVwZGF0ZVBsYWNlU2VsZWN0aW9uKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICA+PC9iYi1wbGFjZXMtbGlzdD5cbiAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiY29sLW1kLTYgZC1tZC1ibG9ja1wiXG4gICAgICAgICAgICBbaGlkZGVuXT1cInRoaXMuc2VsZWN0ZWRWaWV3ID09PSAnbGlzdCdcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxiYi1tYXAtd3JhcHBlclxuICAgICAgICAgICAgICBbYXBpS2V5XT1cInRoaXMuY29uZmlnLmFwaUtleVwiXG4gICAgICAgICAgICAgIFtjb25maWddPVwidGhpcy5tYXBDb25maWdcIlxuICAgICAgICAgICAgICBbbWFwWm9vbV09XCJ0aGlzLmNvbmZpZy5tYXBab29tXCJcbiAgICAgICAgICAgICAgW2xhdGl0dWRlXT1cInRoaXMubGF0aXR1ZGVcIlxuICAgICAgICAgICAgICBbbG9uZ2l0dWRlXT1cInRoaXMubG9uZ2l0dWRlXCJcbiAgICAgICAgICAgICAgW2ljb25zXT1cInRoaXMuaWNvbnMgfCBhc3luY1wiXG4gICAgICAgICAgICAgIFtsb2NhdGlvbnNdPVwicGxhY2VzXCJcbiAgICAgICAgICAgICAgW2VuYWJsZUluZm9XaW5kb3ddPVwiISF0aGlzLnNtYWxsU2NyZWVuXCJcbiAgICAgICAgICAgICAgW3NlbGVjdGVkUGxhY2VJZF09XCIodGhpcy5zZWxlY3RlZFBsYWNlSWQgfCBhc3luYykgfHwgdW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgKHVwZGF0ZSk9XCJ0aGlzLmxvY2F0aW9uVXBkYXRlKCRldmVudClcIlxuICAgICAgICAgICAgICAoc2VsZWN0ZWQpPVwidGhpcy51cGRhdGVQbGFjZVNlbGVjdGlvbigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgKG1hcFJlYWR5KT1cInRoaXMub25NYXBSZWFkeSgpXCJcbiAgICAgICAgICAgID48L2JiLW1hcC13cmFwcGVyPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gRW1wdHkgTGlzdCAtLT5cbjxuZy10ZW1wbGF0ZSAjZW1wdHlTdGF0ZT5cbiAgPGJiLWVtcHR5LXN0YXRlLXVpXG4gICAgY2xhc3M9XCJiYi10ZXh0LWFsaWduLWNlbnRlclwiXG4gICAgaTE4bi10aXRsZT1cIlxuICAgICAgTm8gbG9jYXRpb25zIGZvdW5kfFRpdGxlIG9mIGEgbWVzc2FnZSB0aGF0IGlzIHNob3duIHdoZW4gdGhlcmUgYXJlIG5vXG4gICAgICBwbGFjZXNAQHBsYWNlcy5zdGF0ZS5ub1Jlc3VsdHNGb3VuZC50aXRsZVwiXG4gICAgaTE4bi1zdWJ0aXRsZT1cIlxuICAgICAgV2UgY291bGQgbm90IGZpbmQgYW55IGl0ZW1zIGluIHRoaXMgYXJlYS4gVHJ5IG1vdmluZyB0aGUgbWFwIG9yIHNlYXJjaGluZ1xuICAgICAgZm9yIGEgY2l0eSBvciBicmFuY2h8U3VidGl0bGUgb2YgYSBtZXNzYWdlIHRoYXQgaXMgc2hvd24gd2hlbiB0aGVyZSBhcmUgbm9cbiAgICAgIHBsYWNlc0BAcGxhY2VzLnN0YXRlLm5vUmVzdWx0c0ZvdW5kLnN1YnRpdGxlXCJcbiAgICB0aXRsZT1cIk5vIExvY2F0aW9ucyBGb3VuZFwiXG4gICAgc3VidGl0bGU9XCJXZSBjb3VsZG7igJl0IGZpbmQgYW55IGJyYW5jaGVzIG9yIEFUTXMgaW4gdGhpcyByZWdpb24uIFRyeSBtb3ZpbmcgdGhlIG1hcCBvciBzZWFyY2hpbmcgZm9yIGEgY2l0eSBvciBicmFuY2guXCJcbiAgICBpY29uU2l6ZT1cInh4bFwiXG4gICAgaWNvbk1vZGlmaWVyPVwicGxhY2VcIlxuICA+PC9iYi1lbXB0eS1zdGF0ZS11aT5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gTG9hZGluZyBTdGF0ZSAtLT5cbjxuZy10ZW1wbGF0ZSAjbG9hZGluZ1N0YXRlPlxuICA8YmItbG9hZGluZy1pbmRpY2F0b3ItdWlcbiAgICBpMThuLXRleHQ9XCJcbiAgICAgIExvYWRpbmcgcGxhY2VzIGRhdGF8VGV4dCB0byBkaXNwbGF5IHdoaWxlIGxvYWRpbmdcbiAgICAgIHBsYWNlc0BAcGxhY2VzLnN0YXRlLmxvYWRpbmdQbGFjZXNcIlxuICA+PC9iYi1sb2FkaW5nLWluZGljYXRvci11aT5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gRXJyb3IgU3RhdGUgLS0+XG48bmctdGVtcGxhdGUgI2Vycm9yU3RhdGU+XG4gIDxiYi1jb21tb24tZXJyb3Itc3RhdGUtdWkgW2Vycm9yXT1cImVycm9yQ3VzdG9tVGVtcGxhdGVcIj5cbiAgICA8bmctdGVtcGxhdGUgI2Vycm9yQ3VzdG9tVGVtcGxhdGU+XG4gICAgICA8YmItZW1wdHktc3RhdGUtdWlcbiAgICAgICAgY2xhc3M9XCJiYi10ZXh0LWFsaWduLWNlbnRlclwiXG4gICAgICAgIGkxOG4tdGl0bGU9XCJcbiAgICAgICAgICBQYWdlIGNvdWxkbuKAmXQgbG9hZHxUaXRsZSBvZiBhIG1lc3NhZ2UgdGhhdCBpcyBzaG93biB3aGVuIHBhZ2UgY291bGRuJ3RcbiAgICAgICAgICBsb2FkQEBwbGFjZXMuc3RhdGUucGFnZUNvdWxkbm90TG9hZC50aXRsZVwiXG4gICAgICAgIGkxOG4tc3VidGl0bGU9XCJcbiAgICAgICAgICBUcnkgdG8gcmVsb2FkIHRoZSBwYWdlIG9yIGNvbnRhY3QgdGhlIHN5c3RlbSBhZG1pbmlzdHJhdG9yLnxTdWJ0aXRsZVxuICAgICAgICAgIG9mIGEgbWVzc2FnZSB0aGF0IGlzIHNob3duIHdoZW4gcGFnZSBjb3VsZCBub3RcbiAgICAgICAgICBsb2FkQEBwbGFjZXMuc3RhdGUucGFnZUNvdWxkbm90TG9hZC5zdWJ0aXRsZVwiXG4gICAgICAgIHRpdGxlPVwiUGFnZSBjb3VsZG7igJl0IGxvYWRcIlxuICAgICAgICBzdWJ0aXRsZT1cIlRyeSB0byByZWxvYWQgdGhlIHBhZ2Ugb3IgY29udGFjdCB0aGUgc3lzdGVtIGFkbWluaXN0cmF0b3IuXCJcbiAgICAgICAgaWNvblNpemU9XCJ4eGxcIlxuICAgICAgICBpY29uTW9kaWZpZXI9XCJlcnJvclwiXG4gICAgICA+PC9iYi1lbXB0eS1zdGF0ZS11aT5cbiAgICA8L25nLXRlbXBsYXRlPlxuICA8L2JiLWNvbW1vbi1lcnJvci1zdGF0ZS11aT5cbjwvbmctdGVtcGxhdGU+XG4iXX0=