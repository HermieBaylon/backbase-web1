import { Component, Input, ChangeDetectionStrategy, Output, EventEmitter, ViewChild, } from '@angular/core';
import { DatePipe } from '@angular/common';
import { defaultPlaceTypeIcon, footInMeter, meterInKM, footInMile, } from '../../model/constants';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@backbase/ui-ang/collapsible-accordion";
import * as i3 from "@backbase/ui-ang/collapsible";
import * as i4 from "@backbase/ui-ang/icon";
import * as i5 from "../place-details/place-details.component";
import * as i6 from "../../directives/keyboard-accessibility.directive";
export class PlacesListComponent {
    constructor(datePipe) {
        this.datePipe = datePipe;
        /**
         * Map radius.
         */
        this.radius = 1;
        /**
         * Use metric system for displaying distances.
         */
        this.isMetric = true;
        /**
         * Provide Place Types
         */
        this.placeTypes = {};
        /**
         * EventEmitter for triggering a place selection update event.
         */
        this.selected = new EventEmitter();
        this.places = [];
    }
    /**
     * List of locations to be rendered.
     */
    set locations(locations) {
        this.places = locations
            .map((place) => (Object.assign(Object.assign({}, place), { distance: this.calculateDistance(place) })))
            .sort((a, b) => (a.distance || 0) - (b.distance || 0));
    }
    /**
     * Uses Google geometry library to calculate distance between two points
     * Returns undefined if google library or current position is undefined
     * Returns distance in meters or feet, depending on measurment system property in the widget
     */
    calculateDistance(place) {
        if (typeof google === 'undefined' || this.currentPosition === undefined) {
            return undefined;
        }
        const centerCoords = new google.maps.LatLng(this.currentPosition.lat, this.currentPosition.lng);
        const itemCoords = new google.maps.LatLng(place.latitude, place.longitude);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(centerCoords, itemCoords);
        return this.isMetric ? distance : distance * footInMeter;
    }
    isStillOpen(hour, currentDate = new Date()) {
        const [closeHour, closeMinute] = hour
            .split(':')
            .map((timePart) => +timePart);
        const currentHour = currentDate.getHours();
        const currentMinute = currentDate.getMinutes();
        return (currentHour < closeHour ||
            (currentHour === closeHour && currentMinute < closeMinute));
    }
    getDistanceUnits() {
        if (this.isMetric) {
            return [
                this.transM.nativeElement.textContent,
                this.transKm.nativeElement.textContent,
            ];
        }
        return [
            this.transFt.nativeElement.textContent,
            this.transMi.nativeElement.textContent,
        ];
    }
    onListItemClick(isOpen, place) {
        this.selected.emit(!isOpen
            ? place
            : {
                id: '',
                latitude: 0,
                longitude: 0,
            });
        return;
    }
    getClosingHour(hours, currentDate = new Date()) {
        if (!hours) {
            return;
        }
        // in specs, Sunday is 7 and in JS it is 0, rest of the days match
        const currentDay = currentDate.getDay() || 7;
        const todayHours = hours.find((time) => time.day === currentDay);
        if (!todayHours) {
            return;
        }
        return ((this.isStillOpen(todayHours.close, currentDate) &&
            this.datePipe.transform(new Date('2000-01-01T' + todayHours.close), 'shortTime')) ||
            undefined);
    }
    getPlaceTypeIcon(type) {
        return type && this.placeTypes[type] && this.placeTypes[type].iconName
            ? this.placeTypes[type].iconName
            : defaultPlaceTypeIcon;
    }
    formatDistance(distance) {
        const distanceUnit = this.getDistanceUnits();
        const distanceUnitRatio = this.isMetric ? meterInKM : footInMile;
        let convertedDistance = Math.round(distance);
        let unit = distanceUnit[0];
        if (distance >= distanceUnitRatio) {
            unit = distanceUnit[1];
            convertedDistance /= distanceUnitRatio;
            if (convertedDistance >= 10) {
                // for distance over 10 km/mi show only integers
                convertedDistance = Math.round(convertedDistance);
            }
            else {
                // for distance more than 1 km/mi but smaller than 10 km/mi use one decimal point
                convertedDistance = Math.round(convertedDistance * 10) / 10;
            }
        }
        return `${convertedDistance} ${unit}`;
    }
}
PlacesListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesListComponent, deps: [{ token: i1.DatePipe }], target: i0.ɵɵFactoryTarget.Component });
PlacesListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PlacesListComponent, selector: "bb-places-list", inputs: { radius: "radius", locations: "locations", selectedPlaceId: "selectedPlaceId", currentPosition: "currentPosition", isMetric: "isMetric", placeTypes: "placeTypes" }, outputs: { selected: "selected" }, providers: [DatePipe], viewQueries: [{ propertyName: "transM", first: true, predicate: ["transM"], descendants: true, static: true }, { propertyName: "transKm", first: true, predicate: ["transKm"], descendants: true, static: true }, { propertyName: "transFt", first: true, predicate: ["transFt"], descendants: true, static: true }, { propertyName: "transMi", first: true, predicate: ["transMi"], descendants: true, static: true }], ngImport: i0, template: "<!-- Places List -->\n<bb-collapsible-accordion-ui\n  [closeOthers]=\"true\"\n  class=\"bb-list bb-list--density-md\"\n>\n  <bb-collapsible-ui\n    [isOpen]=\"place.id === selectedPlaceId\"\n    class=\"bb-list__item d-block\"\n    role=\"tree\"\n    *ngFor=\"let place of places; let i = index\"\n  >\n    <ng-template bbCollapsibleHeader let-isOpen=\"isOpen\">\n      <div\n        role=\"treeitem\"\n        bbKeyboardAccessibility\n        [attr.aria-expanded]=\"isOpen\"\n        (click)=\"this.onListItemClick(isOpen, place)\"\n        class=\"bb-block\"\n        [class.bb-block--md]=\"isOpen\"\n      >\n        <div class=\"bb-stack bb-place-info\">\n          <div class=\"bb-inline-stack bb-inline-stack--density-sm\">\n            <bb-icon-ui\n              [name]=\"this.getPlaceTypeIcon(place.placeType)\"\n              size=\"md\"\n              class=\"bb-inline-stack__item\"\n            ></bb-icon-ui>\n            <span class=\"bb-text-semi-bold\">{{ place.name }}</span>\n          </div>\n          <bb-icon-ui\n            class=\"bb-stack__item bb-stack__item--push-right\"\n            [name]=\"isOpen ? 'toggle-up' : 'toggle-down'\"\n            size=\"md\"\n          >\n          </bb-icon-ui>\n        </div>\n        <div class=\"bb-place-info__subtitle bb-subtitle\">\n          <div *ngIf=\"place.address\">\n            <span>{{ place.address.addressLine1 }}</span>\n            <span *ngIf=\"place.address.addressLine2\"\n              >,\n              <span>{{ place.address.addressLine2 }}</span>\n            </span>\n            <div *ngIf=\"place.address.postalCode\">\n              {{ place.address.postalCode }}\n            </div>\n          </div>\n          <div\n            class=\"bb-text-support bb-inline-stack\"\n            *ngIf=\"place.distance !== undefined\"\n          >\n            <bb-icon-ui\n              name=\"near-me\"\n              size=\"sm\"\n              class=\"bb-inline-stack__item\"\n            ></bb-icon-ui>\n            <span>{{ this.formatDistance(place.distance) }}</span>\n          </div>\n          <div\n            class=\"bb-text-support\"\n            *ngIf=\"this.getClosingHour(place.hours) as hour\"\n          >\n            <span\n              i18n=\"\n                Open Today until|label for open today\n                until@@places.openToday.until\"\n              >Open Today until\n            </span>\n            <span>{{ hour }}</span>\n          </div>\n        </div>\n      </div>\n    </ng-template>\n\n    <ng-template bbCollapsibleBody>\n      <bb-place-details [place]=\"place\"></bb-place-details>\n    </ng-template>\n  </bb-collapsible-ui>\n</bb-collapsible-accordion-ui>\n\n<span #transM class=\"ng-cloak\" i18n=\"m|Label for meters@@places.distance.meter\"\n  >m</span\n>\n<span\n  #transKm\n  class=\"ng-cloak\"\n  i18n=\"km|Label for kilometers@@places.distance.kilometer\"\n  >km</span\n>\n<span #transFt class=\"ng-cloak\" i18n=\"ft|Label for feet@@places.distance.foot\"\n  >ft</span\n>\n<span #transMi class=\"ng-cloak\" i18n=\"mi|Label for miles@@places.distance.mile\"\n  >mi</span\n>\n", components: [{ type: i2.CollapsibleAccordionComponent, selector: "bb-collapsible-accordion-ui", inputs: ["closeOthers", "openFirst", "obeyParentAccordion"] }, { type: i3.CollapsibleComponent, selector: "bb-collapsible-ui", inputs: ["recreateBodyContent", "hasChevron", "isOpen"], outputs: ["isOpenChange"] }, { type: i4.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i5.PlaceDetailsComponent, selector: "bb-place-details", inputs: ["place"] }], directives: [{ type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.CollapsibleHeaderDirective, selector: "ng-template[bbCollapsibleHeader]" }, { type: i6.KeyboardAccessibilityDirective, selector: "[bbKeyboardAccessibility]" }, { type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.CollapsibleBodyDirective, selector: "ng-template[bbCollapsibleBody]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-places-list',
                    templateUrl: './places-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [DatePipe],
                }]
        }], ctorParameters: function () { return [{ type: i1.DatePipe }]; }, propDecorators: { radius: [{
                type: Input
            }], locations: [{
                type: Input
            }], selectedPlaceId: [{
                type: Input
            }], currentPosition: [{
                type: Input
            }], isMetric: [{
                type: Input
            }], placeTypes: [{
                type: Input
            }], selected: [{
                type: Output
            }], transM: [{
                type: ViewChild,
                args: ['transM', { static: true }]
            }], transKm: [{
                type: ViewChild,
                args: ['transKm', { static: true }]
            }], transFt: [{
                type: ViewChild,
                args: ['transFt', { static: true }]
            }], transMi: [{
                type: ViewChild,
                args: ['transMi', { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxhY2VzLWxpc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9wbGFjZXMtam91cm5leS9zcmMvbGliL2NvbXBvbmVudHMvcGxhY2VzLWxpc3QvcGxhY2VzLWxpc3QuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9wbGFjZXMtam91cm5leS9zcmMvbGliL2NvbXBvbmVudHMvcGxhY2VzLWxpc3QvcGxhY2VzLWxpc3QuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxLQUFLLEVBQ0wsdUJBQXVCLEVBQ3ZCLE1BQU0sRUFDTixZQUFZLEVBQ1osU0FBUyxHQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUkzQyxPQUFPLEVBQ0wsb0JBQW9CLEVBQ3BCLFdBQVcsRUFDWCxTQUFTLEVBQ1QsVUFBVSxHQUNYLE1BQU0sdUJBQXVCLENBQUM7Ozs7Ozs7O0FBVS9CLE1BQU0sT0FBTyxtQkFBbUI7SUE4QzlCLFlBQTZCLFFBQWtCO1FBQWxCLGFBQVEsR0FBUixRQUFRLENBQVU7UUE3Qy9DOztXQUVHO1FBQ00sV0FBTSxHQUFHLENBQUMsQ0FBQztRQXFCcEI7O1dBRUc7UUFDTSxhQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3pCOztXQUVHO1FBQ00sZUFBVSxHQUFlLEVBQUUsQ0FBQztRQUNyQzs7V0FFRztRQUNnQixhQUFRLEdBQ3pCLElBQUksWUFBWSxFQUFhLENBQUM7UUFPaEMsV0FBTSxHQUFnQixFQUFFLENBQUM7SUFFeUIsQ0FBQztJQXpDbkQ7O09BRUc7SUFDSCxJQUNJLFNBQVMsQ0FBQyxTQUFrQjtRQUM5QixJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVM7YUFDcEIsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxpQ0FD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WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIElucHV0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgT3V0cHV0LFxuICBFdmVudEVtaXR0ZXIsXG4gIFZpZXdDaGlsZCxcbiAgRWxlbWVudFJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlUGlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IEhvdXIgfSBmcm9tICdAYmFja2Jhc2UvZGF0YS1hbmcvcGxhY2VzJztcblxuaW1wb3J0IHtcbiAgZGVmYXVsdFBsYWNlVHlwZUljb24sXG4gIGZvb3RJbk1ldGVyLFxuICBtZXRlckluS00sXG4gIGZvb3RJbk1pbGUsXG59IGZyb20gJy4uLy4uL21vZGVsL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBQbGFjZSwgUGxhY2VJdGVtIH0gZnJvbSAnLi4vLi4vbW9kZWwvcGxhY2UtbW9kZWwnO1xuaW1wb3J0IHsgUGxhY2VUeXBlcyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3BsYWNlcy1qb3VybmV5LWNvbmZpZy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYmItcGxhY2VzLWxpc3QnLFxuICB0ZW1wbGF0ZVVybDogJy4vcGxhY2VzLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJvdmlkZXJzOiBbRGF0ZVBpcGVdLFxufSlcbmV4cG9ydCBjbGFzcyBQbGFjZXNMaXN0Q29tcG9uZW50IHtcbiAgLyoqXG4gICAqIE1hcCByYWRpdXMuXG4gICAqL1xuICBASW5wdXQoKSByYWRpdXMgPSAxO1xuICAvKipcbiAgICogTGlzdCBvZiBsb2NhdGlvbnMgdG8gYmUgcmVuZGVyZWQuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgbG9jYXRpb25zKGxvY2F0aW9uczogUGxhY2VbXSkge1xuICAgIHRoaXMucGxhY2VzID0gbG9jYXRpb25zXG4gICAgICAubWFwKChwbGFjZSkgPT4gKHtcbiAgICAgICAgLi4ucGxhY2UsXG4gICAgICAgIGRpc3RhbmNlOiB0aGlzLmNhbGN1bGF0ZURpc3RhbmNlKHBsYWNlKSxcbiAgICAgIH0pKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IChhLmRpc3RhbmNlIHx8IDApIC0gKGIuZGlzdGFuY2UgfHwgMCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgUGxhY2Ugc2VsZWN0ZWQgYnkgdXNlclxuICAgKi9cbiAgQElucHV0KCkgc2VsZWN0ZWRQbGFjZUlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiByZXRyaWV2ZWQgYnkgZ2VvbG9jYXRpb24gaHRtbDUgYXBpXG4gICAqL1xuICBASW5wdXQoKSBjdXJyZW50UG9zaXRpb246IGdvb2dsZS5tYXBzLkxhdExuZ0xpdGVyYWwgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBVc2UgbWV0cmljIHN5c3RlbSBmb3IgZGlzcGxheWluZyBkaXN0YW5jZXMuXG4gICAqL1xuICBASW5wdXQoKSBpc01ldHJpYyA9IHRydWU7XG4gIC8qKlxuICAgKiBQcm92aWRlIFBsYWNlIFR5cGVzXG4gICAqL1xuICBASW5wdXQoKSBwbGFjZVR5cGVzOiBQbGFjZVR5cGVzID0ge307XG4gIC8qKlxuICAgKiBFdmVudEVtaXR0ZXIgZm9yIHRyaWdnZXJpbmcgYSBwbGFjZSBzZWxlY3Rpb24gdXBkYXRlIGV2ZW50LlxuICAgKi9cbiAgQE91dHB1dCgpIHJlYWRvbmx5IHNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8UGxhY2VJdGVtPiA9XG4gICAgbmV3IEV2ZW50RW1pdHRlcjxQbGFjZUl0ZW0+KCk7XG5cbiAgQFZpZXdDaGlsZCgndHJhbnNNJywgeyBzdGF0aWM6IHRydWUgfSkgdHJhbnNNOiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuICBAVmlld0NoaWxkKCd0cmFuc0ttJywgeyBzdGF0aWM6IHRydWUgfSkgdHJhbnNLbTogRWxlbWVudFJlZiB8IHVuZGVmaW5lZDtcbiAgQFZpZXdDaGlsZCgndHJhbnNGdCcsIHsgc3RhdGljOiB0cnVlIH0pIHRyYW5zRnQ6IEVsZW1lbnRSZWYgfCB1bmRlZmluZWQ7XG4gIEBWaWV3Q2hpbGQoJ3RyYW5zTWknLCB7IHN0YXRpYzogdHJ1ZSB9KSB0cmFuc01pOiBFbGVtZW50UmVmIHwgdW5kZWZpbmVkO1xuXG4gIHBsYWNlczogUGxhY2VJdGVtW10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGRhdGVQaXBlOiBEYXRlUGlwZSkge31cblxuICAvKipcbiAgICogVXNlcyBHb29nbGUgZ2VvbWV0cnkgbGlicmFyeSB0byBjYWxjdWxhdGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIGdvb2dsZSBsaWJyYXJ5IG9yIGN1cnJlbnQgcG9zaXRpb24gaXMgdW5kZWZpbmVkXG4gICAqIFJldHVybnMgZGlzdGFuY2UgaW4gbWV0ZXJzIG9yIGZlZXQsIGRlcGVuZGluZyBvbiBtZWFzdXJtZW50IHN5c3RlbSBwcm9wZXJ0eSBpbiB0aGUgd2lkZ2V0XG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZURpc3RhbmNlKHBsYWNlOiBQbGFjZUl0ZW0pOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGlmICh0eXBlb2YgZ29vZ2xlID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmN1cnJlbnRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlckNvb3JkcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoXG4gICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5sYXQsXG4gICAgICB0aGlzLmN1cnJlbnRQb3NpdGlvbi5sbmdcbiAgICApO1xuICAgIGNvbnN0IGl0ZW1Db29yZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBsYWNlLmxhdGl0dWRlLCBwbGFjZS5sb25naXR1ZGUpO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gZ29vZ2xlLm1hcHMuZ2VvbWV0cnkuc3BoZXJpY2FsLmNvbXB1dGVEaXN0YW5jZUJldHdlZW4oXG4gICAgICBjZW50ZXJDb29yZHMsXG4gICAgICBpdGVtQ29vcmRzXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5pc01ldHJpYyA/IGRpc3RhbmNlIDogZGlzdGFuY2UgKiBmb290SW5NZXRlcjtcbiAgfVxuXG4gIHByaXZhdGUgaXNTdGlsbE9wZW4oaG91cjogc3RyaW5nLCBjdXJyZW50RGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCkpOiBib29sZWFuIHtcbiAgICBjb25zdCBbY2xvc2VIb3VyLCBjbG9zZU1pbnV0ZV0gPSBob3VyXG4gICAgICAuc3BsaXQoJzonKVxuICAgICAgLm1hcCgodGltZVBhcnQpID0+ICt0aW1lUGFydCk7XG4gICAgY29uc3QgY3VycmVudEhvdXIgPSBjdXJyZW50RGF0ZS5nZXRIb3VycygpO1xuICAgIGNvbnN0IGN1cnJlbnRNaW51dGUgPSBjdXJyZW50RGF0ZS5nZXRNaW51dGVzKCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgY3VycmVudEhvdXIgPCBjbG9zZUhvdXIgfHxcbiAgICAgIChjdXJyZW50SG91ciA9PT0gY2xvc2VIb3VyICYmIGN1cnJlbnRNaW51dGUgPCBjbG9zZU1pbnV0ZSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREaXN0YW5jZVVuaXRzKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5pc01ldHJpYykge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgKDxFbGVtZW50UmVmPnRoaXMudHJhbnNNKS5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50LFxuICAgICAgICAoPEVsZW1lbnRSZWY+dGhpcy50cmFuc0ttKS5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50LFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICg8RWxlbWVudFJlZj50aGlzLnRyYW5zRnQpLm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQsXG4gICAgICAoPEVsZW1lbnRSZWY+dGhpcy50cmFuc01pKS5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50LFxuICAgIF07XG4gIH1cblxuICBvbkxpc3RJdGVtQ2xpY2soaXNPcGVuOiBib29sZWFuLCBwbGFjZTogUGxhY2VJdGVtKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZC5lbWl0KFxuICAgICAgIWlzT3BlblxuICAgICAgICA/IHBsYWNlXG4gICAgICAgIDoge1xuICAgICAgICAgICAgaWQ6ICcnLFxuICAgICAgICAgICAgbGF0aXR1ZGU6IDAsXG4gICAgICAgICAgICBsb25naXR1ZGU6IDAsXG4gICAgICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZ2V0Q2xvc2luZ0hvdXIoXG4gICAgaG91cnM6IEhvdXJbXSB8IHVuZGVmaW5lZCxcbiAgICBjdXJyZW50RGF0ZTogRGF0ZSA9IG5ldyBEYXRlKClcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIWhvdXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW4gc3BlY3MsIFN1bmRheSBpcyA3IGFuZCBpbiBKUyBpdCBpcyAwLCByZXN0IG9mIHRoZSBkYXlzIG1hdGNoXG4gICAgY29uc3QgY3VycmVudERheSA9IGN1cnJlbnREYXRlLmdldERheSgpIHx8IDc7XG5cbiAgICBjb25zdCB0b2RheUhvdXJzID0gaG91cnMuZmluZCgodGltZTogSG91cikgPT4gdGltZS5kYXkgPT09IGN1cnJlbnREYXkpO1xuICAgIGlmICghdG9kYXlIb3Vycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAodGhpcy5pc1N0aWxsT3Blbih0b2RheUhvdXJzLmNsb3NlLCBjdXJyZW50RGF0ZSkgJiZcbiAgICAgICAgdGhpcy5kYXRlUGlwZS50cmFuc2Zvcm0oXG4gICAgICAgICAgbmV3IERhdGUoJzIwMDAtMDEtMDFUJyArIHRvZGF5SG91cnMuY2xvc2UpLFxuICAgICAgICAgICdzaG9ydFRpbWUnXG4gICAgICAgICkpIHx8XG4gICAgICB1bmRlZmluZWRcbiAgICApO1xuICB9XG5cbiAgZ2V0UGxhY2VUeXBlSWNvbih0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIHJldHVybiB0eXBlICYmIHRoaXMucGxhY2VUeXBlc1t0eXBlXSAmJiB0aGlzLnBsYWNlVHlwZXNbdHlwZV0uaWNvbk5hbWVcbiAgICAgID8gPHN0cmluZz50aGlzLnBsYWNlVHlwZXNbdHlwZV0uaWNvbk5hbWVcbiAgICAgIDogZGVmYXVsdFBsYWNlVHlwZUljb247XG4gIH1cblxuICBmb3JtYXREaXN0YW5jZShkaXN0YW5jZTogbnVtYmVyKSB7XG4gICAgY29uc3QgZGlzdGFuY2VVbml0ID0gdGhpcy5nZXREaXN0YW5jZVVuaXRzKCk7XG4gICAgY29uc3QgZGlzdGFuY2VVbml0UmF0aW8gPSB0aGlzLmlzTWV0cmljID8gbWV0ZXJJbktNIDogZm9vdEluTWlsZTtcbiAgICBsZXQgY29udmVydGVkRGlzdGFuY2UgPSBNYXRoLnJvdW5kKGRpc3RhbmNlKTtcbiAgICBsZXQgdW5pdCA9IGRpc3RhbmNlVW5pdFswXTtcbiAgICBpZiAoZGlzdGFuY2UgPj0gZGlzdGFuY2VVbml0UmF0aW8pIHtcbiAgICAgIHVuaXQgPSBkaXN0YW5jZVVuaXRbMV07XG4gICAgICBjb252ZXJ0ZWREaXN0YW5jZSAvPSBkaXN0YW5jZVVuaXRSYXRpbztcbiAgICAgIGlmIChjb252ZXJ0ZWREaXN0YW5jZSA+PSAxMCkge1xuICAgICAgICAvLyBmb3IgZGlzdGFuY2Ugb3ZlciAxMCBrbS9taSBzaG93IG9ubHkgaW50ZWdlcnNcbiAgICAgICAgY29udmVydGVkRGlzdGFuY2UgPSBNYXRoLnJvdW5kKGNvbnZlcnRlZERpc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZvciBkaXN0YW5jZSBtb3JlIHRoYW4gMSBrbS9taSBidXQgc21hbGxlciB0aGFuIDEwIGttL21pIHVzZSBvbmUgZGVjaW1hbCBwb2ludFxuICAgICAgICBjb252ZXJ0ZWREaXN0YW5jZSA9IE1hdGgucm91bmQoY29udmVydGVkRGlzdGFuY2UgKiAxMCkgLyAxMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke2NvbnZlcnRlZERpc3RhbmNlfSAke3VuaXR9YDtcbiAgfVxufVxuIiwiPCEtLSBQbGFjZXMgTGlzdCAtLT5cbjxiYi1jb2xsYXBzaWJsZS1hY2NvcmRpb24tdWlcbiAgW2Nsb3NlT3RoZXJzXT1cInRydWVcIlxuICBjbGFzcz1cImJiLWxpc3QgYmItbGlzdC0tZGVuc2l0eS1tZFwiXG4+XG4gIDxiYi1jb2xsYXBzaWJsZS11aVxuICAgIFtpc09wZW5dPVwicGxhY2UuaWQgPT09IHNlbGVjdGVkUGxhY2VJZFwiXG4gICAgY2xhc3M9XCJiYi1saXN0X19pdGVtIGQtYmxvY2tcIlxuICAgIHJvbGU9XCJ0cmVlXCJcbiAgICAqbmdGb3I9XCJsZXQgcGxhY2Ugb2YgcGxhY2VzOyBsZXQgaSA9IGluZGV4XCJcbiAgPlxuICAgIDxuZy10ZW1wbGF0ZSBiYkNvbGxhcHNpYmxlSGVhZGVyIGxldC1pc09wZW49XCJpc09wZW5cIj5cbiAgICAgIDxkaXZcbiAgICAgICAgcm9sZT1cInRyZWVpdGVtXCJcbiAgICAgICAgYmJLZXlib2FyZEFjY2Vzc2liaWxpdHlcbiAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJpc09wZW5cIlxuICAgICAgICAoY2xpY2spPVwidGhpcy5vbkxpc3RJdGVtQ2xpY2soaXNPcGVuLCBwbGFjZSlcIlxuICAgICAgICBjbGFzcz1cImJiLWJsb2NrXCJcbiAgICAgICAgW2NsYXNzLmJiLWJsb2NrLS1tZF09XCJpc09wZW5cIlxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmItc3RhY2sgYmItcGxhY2UtaW5mb1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJiYi1pbmxpbmUtc3RhY2sgYmItaW5saW5lLXN0YWNrLS1kZW5zaXR5LXNtXCI+XG4gICAgICAgICAgICA8YmItaWNvbi11aVxuICAgICAgICAgICAgICBbbmFtZV09XCJ0aGlzLmdldFBsYWNlVHlwZUljb24ocGxhY2UucGxhY2VUeXBlKVwiXG4gICAgICAgICAgICAgIHNpemU9XCJtZFwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiYmItaW5saW5lLXN0YWNrX19pdGVtXCJcbiAgICAgICAgICAgID48L2JiLWljb24tdWk+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJiLXRleHQtc2VtaS1ib2xkXCI+e3sgcGxhY2UubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8YmItaWNvbi11aVxuICAgICAgICAgICAgY2xhc3M9XCJiYi1zdGFja19faXRlbSBiYi1zdGFja19faXRlbS0tcHVzaC1yaWdodFwiXG4gICAgICAgICAgICBbbmFtZV09XCJpc09wZW4gPyAndG9nZ2xlLXVwJyA6ICd0b2dnbGUtZG93bidcIlxuICAgICAgICAgICAgc2l6ZT1cIm1kXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgPC9iYi1pY29uLXVpPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJiLXBsYWNlLWluZm9fX3N1YnRpdGxlIGJiLXN1YnRpdGxlXCI+XG4gICAgICAgICAgPGRpdiAqbmdJZj1cInBsYWNlLmFkZHJlc3NcIj5cbiAgICAgICAgICAgIDxzcGFuPnt7IHBsYWNlLmFkZHJlc3MuYWRkcmVzc0xpbmUxIH19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJwbGFjZS5hZGRyZXNzLmFkZHJlc3NMaW5lMlwiXG4gICAgICAgICAgICAgID4sXG4gICAgICAgICAgICAgIDxzcGFuPnt7IHBsYWNlLmFkZHJlc3MuYWRkcmVzc0xpbmUyIH19PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cInBsYWNlLmFkZHJlc3MucG9zdGFsQ29kZVwiPlxuICAgICAgICAgICAgICB7eyBwbGFjZS5hZGRyZXNzLnBvc3RhbENvZGUgfX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiYmItdGV4dC1zdXBwb3J0IGJiLWlubGluZS1zdGFja1wiXG4gICAgICAgICAgICAqbmdJZj1cInBsYWNlLmRpc3RhbmNlICE9PSB1bmRlZmluZWRcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxiYi1pY29uLXVpXG4gICAgICAgICAgICAgIG5hbWU9XCJuZWFyLW1lXCJcbiAgICAgICAgICAgICAgc2l6ZT1cInNtXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJiYi1pbmxpbmUtc3RhY2tfX2l0ZW1cIlxuICAgICAgICAgICAgPjwvYmItaWNvbi11aT5cbiAgICAgICAgICAgIDxzcGFuPnt7IHRoaXMuZm9ybWF0RGlzdGFuY2UocGxhY2UuZGlzdGFuY2UpIH19PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzPVwiYmItdGV4dC1zdXBwb3J0XCJcbiAgICAgICAgICAgICpuZ0lmPVwidGhpcy5nZXRDbG9zaW5nSG91cihwbGFjZS5ob3VycykgYXMgaG91clwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgaTE4bj1cIlxuICAgICAgICAgICAgICAgIE9wZW4gVG9kYXkgdW50aWx8bGFiZWwgZm9yIG9wZW4gdG9kYXlcbiAgICAgICAgICAgICAgICB1bnRpbEBAcGxhY2VzLm9wZW5Ub2RheS51bnRpbFwiXG4gICAgICAgICAgICAgID5PcGVuIFRvZGF5IHVudGlsXG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3Bhbj57eyBob3VyIH19PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgYmJDb2xsYXBzaWJsZUJvZHk+XG4gICAgICA8YmItcGxhY2UtZGV0YWlscyBbcGxhY2VdPVwicGxhY2VcIj48L2JiLXBsYWNlLWRldGFpbHM+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgPC9iYi1jb2xsYXBzaWJsZS11aT5cbjwvYmItY29sbGFwc2libGUtYWNjb3JkaW9uLXVpPlxuXG48c3BhbiAjdHJhbnNNIGNsYXNzPVwibmctY2xvYWtcIiBpMThuPVwibXxMYWJlbCBmb3IgbWV0ZXJzQEBwbGFjZXMuZGlzdGFuY2UubWV0ZXJcIlxuICA+bTwvc3BhblxuPlxuPHNwYW5cbiAgI3RyYW5zS21cbiAgY2xhc3M9XCJuZy1jbG9ha1wiXG4gIGkxOG49XCJrbXxMYWJlbCBmb3Iga2lsb21ldGVyc0BAcGxhY2VzLmRpc3RhbmNlLmtpbG9tZXRlclwiXG4gID5rbTwvc3BhblxuPlxuPHNwYW4gI3RyYW5zRnQgY2xhc3M9XCJuZy1jbG9ha1wiIGkxOG49XCJmdHxMYWJlbCBmb3IgZmVldEBAcGxhY2VzLmRpc3RhbmNlLmZvb3RcIlxuICA+ZnQ8L3NwYW5cbj5cbjxzcGFuICN0cmFuc01pIGNsYXNzPVwibmctY2xvYWtcIiBpMThuPVwibWl8TGFiZWwgZm9yIG1pbGVzQEBwbGFjZXMuZGlzdGFuY2UubWlsZVwiXG4gID5taTwvc3BhblxuPlxuIl19