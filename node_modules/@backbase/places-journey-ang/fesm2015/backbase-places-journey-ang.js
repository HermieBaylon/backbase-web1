import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, Component, EventEmitter, ChangeDetectionStrategy, Input, Output, ViewChild, Directive, HostListener, NgModule } from '@angular/core';
import * as i1$3 from '@angular/common';
import { DatePipe, CommonModule } from '@angular/common';
import * as i1$1 from '@angular/router';
import { provideRoutes, RouterModule } from '@angular/router';
import * as i1 from '@backbase/foundation-ang/core';
import { BackbaseCoreModule } from '@backbase/foundation-ang/core';
import { Subject, of, combineLatest } from 'rxjs';
import { map, filter, switchMap, catchError } from 'rxjs/operators';
import * as i1$2 from '@backbase/data-ang/places';
import * as i5 from '@backbase/ui-ang/header';
import { HeaderModule } from '@backbase/ui-ang/header';
import * as i2 from '@backbase/ui-ang/search-box';
import { SearchBoxModule } from '@backbase/ui-ang/search-box';
import * as i1$4 from '@backbase/ui-ang/icon';
import { IconModule } from '@backbase/ui-ang/icon';
import * as i8 from '@backbase/ui-ang/input-checkbox';
import { InputCheckboxModule } from '@backbase/ui-ang/input-checkbox';
import * as i2$1 from '@backbase/ui-ang/collapsible-accordion';
import { CollapsibleAccordionModule } from '@backbase/ui-ang/collapsible-accordion';
import * as i3 from '@backbase/ui-ang/collapsible';
import { CollapsibleModule } from '@backbase/ui-ang/collapsible';
import * as i11 from '@backbase/ui-ang/empty-state';
import { EmptyStateModule } from '@backbase/ui-ang/empty-state';
import * as i12 from '@backbase/ui-ang/loading-indicator';
import { LoadingIndicatorModule } from '@backbase/ui-ang/loading-indicator';
import * as i13 from '@backbase/ui-ang/common-error-state';
import { ErrorCommonStateModule } from '@backbase/ui-ang/common-error-state';
import * as i15 from '@angular/forms';
import { FormsModule } from '@angular/forms';
import { ButtonModule } from '@backbase/ui-ang/button';

const PlacesJourneyConfigurationToken = new InjectionToken('PlacesJourneyConfiguration injection token');
var PlacesMeasurementSystem;
(function (PlacesMeasurementSystem) {
    PlacesMeasurementSystem["METRIC"] = "metric";
    PlacesMeasurementSystem["US_IMPERIAL"] = "imperial";
})(PlacesMeasurementSystem || (PlacesMeasurementSystem = {}));
const configDefaults = {
    apiKey: '',
    placeTypes: {},
    mapZoom: 15,
    latitude: 52.3760992,
    longitude: 4.900779,
    radius: 2,
    limitList: 100,
    measurementSystem: PlacesMeasurementSystem.METRIC,
    deElevatedHeader: false,
};
class PlacesJourneyConfigService {
    constructor(config, itemModel) {
        this.itemModel = itemModel;
        config = config || {};
        this._config = Object.assign(Object.assign({}, configDefaults), config);
        // update the API key from ItemModel if it was not provided from a static config
        if (this.itemModel && config.apiKey === undefined) {
            this.itemModel
                .property('apiKey', this._config.apiKey)
                .subscribe({
                next: (key) => {
                    this._config.apiKey = key;
                },
            })
                .unsubscribe();
        }
    }
    get defaults() {
        return configDefaults;
    }
    /**
     * API key for Google Maps
     */
    get apiKey() {
        return this._config.apiKey;
    }
    /**
     * Place types configuration. Used to set up marker image and the filter label for any place type available in the service
     */
    get placeTypes() {
        return this._config.placeTypes;
    }
    /**
     * Default zoom value for a map
     */
    get mapZoom() {
        return this._config.mapZoom;
    }
    /**
     * Default map latitude
     */
    get latitude() {
        return this._config.latitude;
    }
    /**
     * Default map longitude
     */
    get longitude() {
        return this._config.longitude;
    }
    /**
     * Default radius in which the locations are being searched while map is not loaded
     */
    get radius() {
        return this._config.radius;
    }
    /**
     * Maximum amount of locations to display
     */
    get limitList() {
        return this._config.limitList;
    }
    /**
     * Measurement system
     */
    get measurementSystem() {
        return this._config.measurementSystem;
    }
    /**
     * Dev config to enable de-elevated header
     */
    get deElevatedHeader() {
        return this._config.deElevatedHeader;
    }
}
PlacesJourneyConfigService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyConfigService, deps: [{ token: PlacesJourneyConfigurationToken, optional: true }, { token: i1.ItemModel, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
PlacesJourneyConfigService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyConfigService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyConfigService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [PlacesJourneyConfigurationToken]
                }] }, { type: i1.ItemModel, decorators: [{
                    type: Optional
                }] }]; } });

class PlacesJourneyComponent {
}
PlacesJourneyComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PlacesJourneyComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PlacesJourneyComponent, selector: "bb-places-journey", providers: [PlacesJourneyConfigService], ngImport: i0, template: '<router-outlet></router-outlet>', isInline: true, directives: [{ type: i1$1.RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate"], exportAs: ["outlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-places-journey',
                    template: '<router-outlet></router-outlet>',
                    providers: [PlacesJourneyConfigService],
                }]
        }] });

/**
 * Default place type that will be used as fallback in case types are not configured in the app
 */
const defaultPlaceType = 'bbDefaultPlaceType';
/**
 * Marker icon for default place type
 */
const defaultPlaceTypeMarkerURI = 'bb-default-marker.svg';
/**
 * List icon name for default place type
 */
const defaultPlaceTypeIcon = 'map';
/**
 * Ratio between foot and meter
 */
const footInMeter = 3.28084;
/**
 * Ratio between meter and kilometer
 */
const meterInKM = 1000;
/**
 * Ratio between foot and mile
 */
const footInMile = 5280;

const getMessageFromResponse = (error) => {
    const responseBody = error.error;
    if (responseBody &&
        responseBody.errors &&
        responseBody.errors[0] &&
        responseBody.errors[0].message) {
        return responseBody.errors[0].message;
    }
    else {
        return undefined;
    }
};
const parseError = (error) => {
    // TODO: should have more user-friendly messages
    if (error.error instanceof ErrorEvent) {
        // Client-side or network error.
        return {
            message: 'An unexpected error occurred',
        };
    }
    else if (error.status && `${error.status}`.startsWith('4')) {
        // Backend returns unsuccessful response code.  In case of 400, try to get a message from the
        // response.
        return {
            message: getMessageFromResponse(error) || `Error ${error.status}`,
        };
    }
    else {
        // Backend returns 5xx
        return {
            message: 'An unexpected server error occurred',
        };
    }
};

var GoogleMapsScriptProtocol;
(function (GoogleMapsScriptProtocol) {
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTP"] = 1] = "HTTP";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["HTTPS"] = 2] = "HTTPS";
    GoogleMapsScriptProtocol[GoogleMapsScriptProtocol["AUTO"] = 3] = "AUTO";
})(GoogleMapsScriptProtocol || (GoogleMapsScriptProtocol = {}));
class MapAPILoaderService {
    constructor() {
        this.scriptID = 'bbGoogleMapsApiScript';
        this.callbackName = 'bbMapsAPILoader';
        this.apiLoadPromiseName = 'bbMapsAPILoaderPromise';
        this.windowRef = window;
        this.documentRef = document;
        this.configValue = {};
    }
    get config() {
        return this.configValue;
    }
    set config(config) {
        this.configValue = config;
    }
    get loadAPIPromise() {
        return this.windowRef[this.apiLoadPromiseName];
    }
    assignScriptLoadingPromise(scriptElem) {
        this.windowRef[this.apiLoadPromiseName] = new Promise((resolve, reject) => {
            this.windowRef[this.callbackName] = () => {
                resolve();
            };
            scriptElem.onerror = (error) => {
                reject(error);
            };
        });
    }
    getScriptSrc(callbackName) {
        const protocolType = (this.configValue && this.configValue.protocol) ||
            GoogleMapsScriptProtocol.HTTPS;
        let protocol = '';
        switch (protocolType) {
            case GoogleMapsScriptProtocol.HTTP:
                protocol = 'http:';
                break;
            case GoogleMapsScriptProtocol.HTTPS:
                protocol = 'https:';
                break;
        }
        const hostAndPath = this.configValue.hostAndPath || 'maps.googleapis.com/maps/api/js';
        // make sure we have places library for search component
        const libraries = this.configValue.libraries || [];
        if (libraries.indexOf('places') === -1) {
            this.configValue.libraries = [...libraries, 'places'];
        }
        const queryParams = {
            v: this.configValue.apiVersion || 'quarterly',
            callback: callbackName,
            key: this.configValue.apiKey,
            client: this.configValue.clientId,
            channel: this.configValue.channel,
            libraries: this.configValue.libraries,
            region: this.configValue.region,
            language: this.configValue.language,
        };
        const params = Object.keys(queryParams)
            .filter((key) => queryParams[key] !== undefined)
            .filter((key) => {
            // remove empty arrays
            return (!Array.isArray(queryParams[key]) ||
                (Array.isArray(queryParams[key]) &&
                    queryParams[key].length > 0));
        })
            .map((key) => {
            let value = queryParams[key];
            if (Array.isArray(value)) {
                // join arrays as comma seperated strings
                value = value.join(',');
            }
            return `${key}=${value}`;
        })
            .join('&');
        return `${protocol}//${hostAndPath}?${params}`;
    }
    load() {
        const window = this.windowRef;
        if (window.google && window.google.maps) {
            // Google maps already loaded on the page.
            return Promise.resolve();
        }
        if (this.loadAPIPromise) {
            return this.loadAPIPromise;
        }
        const script = this.documentRef.createElement('script');
        script.type = 'text/javascript';
        script.async = true;
        script.defer = true;
        script.id = this.scriptID;
        script.src = this.getScriptSrc(this.callbackName);
        this.assignScriptLoadingPromise(script);
        this.documentRef.body.appendChild(script);
        return this.loadAPIPromise;
    }
}
MapAPILoaderService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
MapAPILoaderService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapAPILoaderService, decorators: [{
            type: Injectable
        }] });

class PlacesService {
    constructor(placesDataHttpService) {
        this.placesDataHttpService = placesDataHttpService;
    }
    getPlaces(params) {
        return this.placesDataHttpService
            .getPlaces(params)
            .pipe(map((data) => data || []));
    }
}
PlacesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesService, deps: [{ token: i1$2.PlacesHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
PlacesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$2.PlacesHttpService }]; } });

class MapSearchComponent {
    constructor(loader) {
        this.loader = loader;
        /**
         * Map autocomplete options object.
         */
        this.options = {};
        /**
         * Map API configuration.
         */
        this.config = {};
        /**
         * EventEmitter for triggering a mapSearch event.
         */
        this.mapSearch = new EventEmitter();
    }
    onSearchButtonClick() {
        const input = this.searchBox.inputField;
        if (!input) {
            return;
        }
        // select first result and do the search
        google.maps.event.trigger(input.nativeElement, 'focus', {});
        google.maps.event.trigger(input.nativeElement, 'keydown', {
            keyCode: 40,
            stopPropagation: () => undefined,
            preventDefault: () => undefined,
        });
        google.maps.event.trigger(input.nativeElement, 'keydown', { keyCode: 13 }); // enter
    }
    ngOnInit() {
        this.loader.config = this.config;
        this.loader.load().then(() => {
            const input = this.searchBox.inputField;
            if (!input) {
                return;
            }
            const autocomplete = new google.maps.places.Autocomplete(input.nativeElement, this.options);
            autocomplete.addListener('place_changed', () => {
                const place = autocomplete.getPlace();
                if (place.geometry) {
                    this.mapSearch.emit(place);
                }
            });
        });
    }
}
MapSearchComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapSearchComponent, deps: [{ token: MapAPILoaderService }], target: i0.ɵɵFactoryTarget.Component });
MapSearchComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MapSearchComponent, selector: "bb-map-search-ui", inputs: { options: "options", config: "config" }, outputs: { mapSearch: "mapSearch" }, viewQueries: [{ propertyName: "searchBox", first: true, predicate: ["bbMapsearch"], descendants: true, static: true }], ngImport: i0, template: "<div class=\"bb-block bb-block--md\">\n  <bb-search-box-ui\n    placeholder=\"Search Branch and Street Names\"\n    i18n-placeholder=\"Search for Location@@map-ui.search.placeholder\"\n    aria-label=\"Search Branch and Street Name\"\n    i18n-aria-label=\"\n      Search Branch and Street Name aria-label@@map.search.ui.aria-label\"\n    [showSearch]=\"true\"\n    (submit)=\"onSearchButtonClick()\"\n    #bbMapsearch\n  >\n  </bb-search-box-ui>\n</div>\n", components: [{ type: i2.SearchBoxComponent, selector: "bb-search-box-ui", inputs: ["placeholder", "maxLength", "squareBorder", "typeaheadOptions", "showSearch", "showClear", "searchLabel", "clearLabel", "autocomplete"], outputs: ["submit", "clear", "valueChange"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapSearchComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-map-search-ui',
                    templateUrl: './map-search.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: MapAPILoaderService }]; }, propDecorators: { options: [{
                type: Input
            }], config: [{
                type: Input
            }], mapSearch: [{
                type: Output
            }], searchBox: [{
                type: ViewChild,
                args: ['bbMapsearch', { static: true }]
            }] } });

var WeekDay;
(function (WeekDay) {
    WeekDay[WeekDay["Monday"] = 1] = "Monday";
    WeekDay[WeekDay["Tuesday"] = 2] = "Tuesday";
    WeekDay[WeekDay["Wednesday"] = 3] = "Wednesday";
    WeekDay[WeekDay["Thursday"] = 4] = "Thursday";
    WeekDay[WeekDay["Friday"] = 5] = "Friday";
    WeekDay[WeekDay["Saturday"] = 6] = "Saturday";
    WeekDay[WeekDay["Sunday"] = 7] = "Sunday";
})(WeekDay || (WeekDay = {}));

class WorkTimesComponent {
    constructor(datePipe) {
        this.datePipe = datePipe;
        /**
         * The day number based on WeekDay enum
         */
        this.day = 0;
        /**
         * Hours related to this day
         */
        this.hours = [];
    }
    toLocaleTime(hour) {
        return (this.datePipe.transform(new Date('2000-01-01T' + hour), 'shortTime') ||
            hour);
    }
    isToday(day, today = new Date().getDay()) {
        today = today || 7;
        return day === today;
    }
}
WorkTimesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WorkTimesComponent, deps: [{ token: i1$3.DatePipe }], target: i0.ɵɵFactoryTarget.Component });
WorkTimesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: WorkTimesComponent, selector: "bb-work-times", inputs: { day: "day", hours: "hours" }, providers: [DatePipe], ngImport: i0, template: "<div\n  class=\"row bb-place-timetable\"\n  [ngClass]=\"{\n    'bb-text-semi-bold': this.isToday(day),\n    'bb-text-support': !this.isToday(day)\n  }\"\n>\n  <span\n    class=\"col-md-5\"\n    i18n=\"\n      Week day name|label for week day name based on work\n      times@@places.workTimes.dayName\"\n  >\n    { day, select, 1 {Monday} 2 {Tuesday} 3 {Wednesday} 4 {Thursday} 5 {Friday}\n    6 {Saturday} 7 {Sunday} }\n  </span>\n  <span class=\"col-md-7\">\n    <ng-container *ngIf=\"this.hours.length; else closed\">\n      <ng-container *ngFor=\"let workHour of this.hours; let i = index\"\n        >{{ this.toLocaleTime(workHour.open) }} -\n        {{ this.toLocaleTime(workHour.close) }}<br\n      /></ng-container>\n    </ng-container>\n  </span>\n</div>\n\n<ng-template #closed>\n  <span i18n=\"Closed|label for closed day@@places.workTimes.closed\"\n    >Closed</span\n  >\n</ng-template>\n", directives: [{ type: i1$3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: WorkTimesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-work-times',
                    templateUrl: './work-times.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [DatePipe],
                }]
        }], ctorParameters: function () { return [{ type: i1$3.DatePipe }]; }, propDecorators: { day: [{
                type: Input
            }], hours: [{
                type: Input
            }] } });

class PlaceDetailsComponent {
    // This returns array of weekDay numbers based on the WeekDay enum
    get weekDay() {
        const days = Object.keys(WeekDay);
        return days.slice(0, days.length / 2).map((day) => +day);
    }
    getWorkTimes(day, hours) {
        return hours.filter((time) => time.day === day);
    }
    getFullAddress(address) {
        return address
            ? encodeURI(`${address.postalCode} ${address.addressLine1}`)
            : '';
    }
}
PlaceDetailsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlaceDetailsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
PlaceDetailsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PlaceDetailsComponent, selector: "bb-place-details", inputs: { place: "place" }, providers: [DatePipe], ngImport: i0, template: "<div class=\"bb-place-details\">\n  <div\n    class=\"bb-block bb-block--md\"\n    aria-label=\"Get Directions on google maps\"\n    i18n-aria-label=\"\n      Get Directions button\n      aria-label@@place.details.get.direction.button.aria-label\"\n  >\n    <a\n      class=\"btn btn-sm btn-outline-primary\"\n      [href]=\"\n        'https://www.google.com/maps/dir//' +\n        this.getFullAddress(place && place.address)\n      \"\n      target=\"_blank\"\n      i18n=\"Get Directions|Get Directions redirect link@@places.directions.get\"\n      rel=\"noopener\"\n    >\n      <bb-icon-ui name=\"navigation\" size=\"md\"></bb-icon-ui>\n      Get Directions\n    </a>\n  </div>\n\n  <div class=\"bb-block bb-block--md\" *ngIf=\"place?.hours\">\n    <div class=\"bb-stack bb-stack--density-sm\">\n      <bb-icon-ui name=\"access-time\" class=\"bb-stack__item\"></bb-icon-ui>\n      <span\n        class=\"bb-stack__item bb-text-semi-bold\"\n        i18n=\"Opening Hours|label for Opening Hours@@places.label.openingHours\"\n      >\n        Opening Hours\n      </span>\n    </div>\n    <ul\n      class=\"bb-list bb-list--density-none\"\n      aria-label=\"Opening Hours\"\n      i18n-aria-label=\"\n        Opening Hours list\n        aria-label@@place.details.opening.hours.list.aria-label\"\n      tabindex=\"0\"\n    >\n      <li *ngFor=\"let day of weekDay\">\n        <bb-work-times\n          [day]=\"day\"\n          [hours]=\"this.getWorkTimes(day, place?.hours || [])\"\n        ></bb-work-times>\n      </li>\n    </ul>\n  </div>\n  <div *ngIf=\"place?.services?.length\">\n    <div class=\"bb-stack bb-stack--density-sm\">\n      <bb-icon-ui name=\"supervisor-account\" class=\"bb-stack__item\"></bb-icon-ui>\n      <span\n        class=\"bb-stack__item bb-text-semi-bold\"\n        i18n=\"\n          Available Services|label for Available\n          Services@@places.label.availableServices\"\n      >\n        Available Services\n      </span>\n    </div>\n    <div\n      aria-label=\"Available Services\"\n      i18n-aria-label=\"\n        Available Services list\n        aria-label@@place.details.available.services.list.aria-label\"\n      tabindex=\"0\"\n    >\n      <div\n        class=\"bb-place-services bb-text-support\"\n        *ngFor=\"let service of place?.services\"\n      >\n        {{ service | titlecase }}\n      </div>\n    </div>\n  </div>\n</div>\n", components: [{ type: i1$4.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: WorkTimesComponent, selector: "bb-work-times", inputs: ["day", "hours"] }], directives: [{ type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i1$3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], pipes: { "titlecase": i1$3.TitleCasePipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlaceDetailsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-place-details',
                    templateUrl: './place-details.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [DatePipe],
                }]
        }], propDecorators: { place: [{
                type: Input
            }] } });

class KeyboardAccessibilityDirective {
    constructor(element) {
        this.element = element;
        element.nativeElement.tabIndex = 0;
    }
    // eslint-disable-next-line
    eventListener(event) {
        this.element.nativeElement.click(event);
    }
}
KeyboardAccessibilityDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardAccessibilityDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
KeyboardAccessibilityDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: KeyboardAccessibilityDirective, selector: "[bbKeyboardAccessibility]", host: { listeners: { "keydown.enter": "eventListener($event)", "keydown.space": "eventListener($event)" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: KeyboardAccessibilityDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[bbKeyboardAccessibility]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { eventListener: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

class PlacesListComponent {
    constructor(datePipe) {
        this.datePipe = datePipe;
        /**
         * Map radius.
         */
        this.radius = 1;
        /**
         * Use metric system for displaying distances.
         */
        this.isMetric = true;
        /**
         * Provide Place Types
         */
        this.placeTypes = {};
        /**
         * EventEmitter for triggering a place selection update event.
         */
        this.selected = new EventEmitter();
        this.places = [];
    }
    /**
     * List of locations to be rendered.
     */
    set locations(locations) {
        this.places = locations
            .map((place) => (Object.assign(Object.assign({}, place), { distance: this.calculateDistance(place) })))
            .sort((a, b) => (a.distance || 0) - (b.distance || 0));
    }
    /**
     * Uses Google geometry library to calculate distance between two points
     * Returns undefined if google library or current position is undefined
     * Returns distance in meters or feet, depending on measurment system property in the widget
     */
    calculateDistance(place) {
        if (typeof google === 'undefined' || this.currentPosition === undefined) {
            return undefined;
        }
        const centerCoords = new google.maps.LatLng(this.currentPosition.lat, this.currentPosition.lng);
        const itemCoords = new google.maps.LatLng(place.latitude, place.longitude);
        const distance = google.maps.geometry.spherical.computeDistanceBetween(centerCoords, itemCoords);
        return this.isMetric ? distance : distance * footInMeter;
    }
    isStillOpen(hour, currentDate = new Date()) {
        const [closeHour, closeMinute] = hour
            .split(':')
            .map((timePart) => +timePart);
        const currentHour = currentDate.getHours();
        const currentMinute = currentDate.getMinutes();
        return (currentHour < closeHour ||
            (currentHour === closeHour && currentMinute < closeMinute));
    }
    getDistanceUnits() {
        if (this.isMetric) {
            return [
                this.transM.nativeElement.textContent,
                this.transKm.nativeElement.textContent,
            ];
        }
        return [
            this.transFt.nativeElement.textContent,
            this.transMi.nativeElement.textContent,
        ];
    }
    onListItemClick(isOpen, place) {
        this.selected.emit(!isOpen
            ? place
            : {
                id: '',
                latitude: 0,
                longitude: 0,
            });
        return;
    }
    getClosingHour(hours, currentDate = new Date()) {
        if (!hours) {
            return;
        }
        // in specs, Sunday is 7 and in JS it is 0, rest of the days match
        const currentDay = currentDate.getDay() || 7;
        const todayHours = hours.find((time) => time.day === currentDay);
        if (!todayHours) {
            return;
        }
        return ((this.isStillOpen(todayHours.close, currentDate) &&
            this.datePipe.transform(new Date('2000-01-01T' + todayHours.close), 'shortTime')) ||
            undefined);
    }
    getPlaceTypeIcon(type) {
        return type && this.placeTypes[type] && this.placeTypes[type].iconName
            ? this.placeTypes[type].iconName
            : defaultPlaceTypeIcon;
    }
    formatDistance(distance) {
        const distanceUnit = this.getDistanceUnits();
        const distanceUnitRatio = this.isMetric ? meterInKM : footInMile;
        let convertedDistance = Math.round(distance);
        let unit = distanceUnit[0];
        if (distance >= distanceUnitRatio) {
            unit = distanceUnit[1];
            convertedDistance /= distanceUnitRatio;
            if (convertedDistance >= 10) {
                // for distance over 10 km/mi show only integers
                convertedDistance = Math.round(convertedDistance);
            }
            else {
                // for distance more than 1 km/mi but smaller than 10 km/mi use one decimal point
                convertedDistance = Math.round(convertedDistance * 10) / 10;
            }
        }
        return `${convertedDistance} ${unit}`;
    }
}
PlacesListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesListComponent, deps: [{ token: i1$3.DatePipe }], target: i0.ɵɵFactoryTarget.Component });
PlacesListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PlacesListComponent, selector: "bb-places-list", inputs: { radius: "radius", locations: "locations", selectedPlaceId: "selectedPlaceId", currentPosition: "currentPosition", isMetric: "isMetric", placeTypes: "placeTypes" }, outputs: { selected: "selected" }, providers: [DatePipe], viewQueries: [{ propertyName: "transM", first: true, predicate: ["transM"], descendants: true, static: true }, { propertyName: "transKm", first: true, predicate: ["transKm"], descendants: true, static: true }, { propertyName: "transFt", first: true, predicate: ["transFt"], descendants: true, static: true }, { propertyName: "transMi", first: true, predicate: ["transMi"], descendants: true, static: true }], ngImport: i0, template: "<!-- Places List -->\n<bb-collapsible-accordion-ui\n  [closeOthers]=\"true\"\n  class=\"bb-list bb-list--density-md\"\n>\n  <bb-collapsible-ui\n    [isOpen]=\"place.id === selectedPlaceId\"\n    class=\"bb-list__item d-block\"\n    role=\"tree\"\n    *ngFor=\"let place of places; let i = index\"\n  >\n    <ng-template bbCollapsibleHeader let-isOpen=\"isOpen\">\n      <div\n        role=\"treeitem\"\n        bbKeyboardAccessibility\n        [attr.aria-expanded]=\"isOpen\"\n        (click)=\"this.onListItemClick(isOpen, place)\"\n        class=\"bb-block\"\n        [class.bb-block--md]=\"isOpen\"\n      >\n        <div class=\"bb-stack bb-place-info\">\n          <div class=\"bb-inline-stack bb-inline-stack--density-sm\">\n            <bb-icon-ui\n              [name]=\"this.getPlaceTypeIcon(place.placeType)\"\n              size=\"md\"\n              class=\"bb-inline-stack__item\"\n            ></bb-icon-ui>\n            <span class=\"bb-text-semi-bold\">{{ place.name }}</span>\n          </div>\n          <bb-icon-ui\n            class=\"bb-stack__item bb-stack__item--push-right\"\n            [name]=\"isOpen ? 'toggle-up' : 'toggle-down'\"\n            size=\"md\"\n          >\n          </bb-icon-ui>\n        </div>\n        <div class=\"bb-place-info__subtitle bb-subtitle\">\n          <div *ngIf=\"place.address\">\n            <span>{{ place.address.addressLine1 }}</span>\n            <span *ngIf=\"place.address.addressLine2\"\n              >,\n              <span>{{ place.address.addressLine2 }}</span>\n            </span>\n            <div *ngIf=\"place.address.postalCode\">\n              {{ place.address.postalCode }}\n            </div>\n          </div>\n          <div\n            class=\"bb-text-support bb-inline-stack\"\n            *ngIf=\"place.distance !== undefined\"\n          >\n            <bb-icon-ui\n              name=\"near-me\"\n              size=\"sm\"\n              class=\"bb-inline-stack__item\"\n            ></bb-icon-ui>\n            <span>{{ this.formatDistance(place.distance) }}</span>\n          </div>\n          <div\n            class=\"bb-text-support\"\n            *ngIf=\"this.getClosingHour(place.hours) as hour\"\n          >\n            <span\n              i18n=\"\n                Open Today until|label for open today\n                until@@places.openToday.until\"\n              >Open Today until\n            </span>\n            <span>{{ hour }}</span>\n          </div>\n        </div>\n      </div>\n    </ng-template>\n\n    <ng-template bbCollapsibleBody>\n      <bb-place-details [place]=\"place\"></bb-place-details>\n    </ng-template>\n  </bb-collapsible-ui>\n</bb-collapsible-accordion-ui>\n\n<span #transM class=\"ng-cloak\" i18n=\"m|Label for meters@@places.distance.meter\"\n  >m</span\n>\n<span\n  #transKm\n  class=\"ng-cloak\"\n  i18n=\"km|Label for kilometers@@places.distance.kilometer\"\n  >km</span\n>\n<span #transFt class=\"ng-cloak\" i18n=\"ft|Label for feet@@places.distance.foot\"\n  >ft</span\n>\n<span #transMi class=\"ng-cloak\" i18n=\"mi|Label for miles@@places.distance.mile\"\n  >mi</span\n>\n", components: [{ type: i2$1.CollapsibleAccordionComponent, selector: "bb-collapsible-accordion-ui", inputs: ["closeOthers", "openFirst", "obeyParentAccordion"] }, { type: i3.CollapsibleComponent, selector: "bb-collapsible-ui", inputs: ["recreateBodyContent", "hasChevron", "isOpen"], outputs: ["isOpenChange"] }, { type: i1$4.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: PlaceDetailsComponent, selector: "bb-place-details", inputs: ["place"] }], directives: [{ type: i1$3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.CollapsibleHeaderDirective, selector: "ng-template[bbCollapsibleHeader]" }, { type: KeyboardAccessibilityDirective, selector: "[bbKeyboardAccessibility]" }, { type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.CollapsibleBodyDirective, selector: "ng-template[bbCollapsibleBody]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-places-list',
                    templateUrl: './places-list.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [DatePipe],
                }]
        }], ctorParameters: function () { return [{ type: i1$3.DatePipe }]; }, propDecorators: { radius: [{
                type: Input
            }], locations: [{
                type: Input
            }], selectedPlaceId: [{
                type: Input
            }], currentPosition: [{
                type: Input
            }], isMetric: [{
                type: Input
            }], placeTypes: [{
                type: Input
            }], selected: [{
                type: Output
            }], transM: [{
                type: ViewChild,
                args: ['transM', { static: true }]
            }], transKm: [{
                type: ViewChild,
                args: ['transKm', { static: true }]
            }], transFt: [{
                type: ViewChild,
                args: ['transFt', { static: true }]
            }], transMi: [{
                type: ViewChild,
                args: ['transMi', { static: true }]
            }] } });

/**
 * Handles the communication with the Google Maps Javascript
 * API v3
 */
class MapHelpersService {
    constructor(loader) {
        this.loader = loader;
    }
    createMap(el, mapOptions, mapConfig = {}) {
        this.loader.config = mapConfig;
        return this.loader.load().then(() => {
            this.map = new google.maps.Map(el, mapOptions);
        });
    }
    setMapOptions(options) {
        this.map.setOptions(options);
    }
    /**
     * Creates a google map marker with the map context
     */
    createMarker(options = {}, addToMap = true) {
        if (addToMap) {
            options.map = this.map;
        }
        return new google.maps.Marker(options);
    }
    createInfoWindow(options) {
        return new google.maps.InfoWindow(options);
    }
    openInfoWindow(infoWindow, marker) {
        return infoWindow.open(this.map, marker);
    }
    onMapEvent(eventName, callback) {
        this.map.addListener(eventName, (arg) => callback(arg));
    }
    setCenter(latLng) {
        return this.map.setCenter(latLng);
    }
    getZoom() {
        return this.map.getZoom();
    }
    getBounds() {
        return this.map.getBounds();
    }
    getMapTypeId() {
        return this.map.getMapTypeId();
    }
    setZoom(zoom) {
        return this.map.setZoom(zoom);
    }
    getCenter() {
        return this.map.getCenter();
    }
    panTo(latLng) {
        return this.map.panTo(latLng);
    }
    panBy(x, y) {
        return this.map.panBy(x, y);
    }
    fitBounds(latLng) {
        return this.map.fitBounds(latLng);
    }
    panToBounds(latLng) {
        return this.map.panToBounds(latLng);
    }
    /**
     * Triggers the given event name on the map instance.
     */
    triggerMapEvent(eventName) {
        return google.maps.event.trigger(this.map, eventName);
    }
}
MapHelpersService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapHelpersService, deps: [{ token: MapAPILoaderService }], target: i0.ɵɵFactoryTarget.Injectable });
MapHelpersService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapHelpersService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapHelpersService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: MapAPILoaderService }]; } });

class MapComponent {
    constructor(helpers) {
        this.helpers = helpers;
        /**
         * Map options object.
         */
        this.options = {};
        /**
         * Map API configuration.
         */
        this.config = {};
        /**
         * EventEmitter for triggering a mapReady event.
         */
        this.mapReady = new EventEmitter();
    }
    get mapHelpers() {
        return this.helpers;
    }
    ngOnInit() {
        this.helpers
            .createMap(this.mapContainer.nativeElement, this.options, this.config)
            .then(() => this.mapReady.emit(this));
    }
}
MapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapComponent, deps: [{ token: MapHelpersService }], target: i0.ɵɵFactoryTarget.Component });
MapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MapComponent, selector: "bb-map-ui", inputs: { options: "options", config: "config" }, outputs: { mapReady: "mapReady" }, viewQueries: [{ propertyName: "mapContainer", first: true, predicate: ["bbMapContainer"], descendants: true, static: true }], ngImport: i0, template: "<ng-content select=\"[bbMapHeader]\"></ng-content>\n<div #bbMapContainer class=\"bb-map\"></div>\n<ng-content select=\"[bbMapFooter]\"></ng-content>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-map-ui',
                    templateUrl: './map.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: MapHelpersService }]; }, propDecorators: { options: [{
                type: Input
            }], config: [{
                type: Input
            }], mapReady: [{
                type: Output
            }], mapContainer: [{
                type: ViewChild,
                args: ['bbMapContainer', { static: true }]
            }] } });

class MapWrapperComponent {
    constructor() {
        /**
         * API key need for the google maps to work.
         */
        this.apiKey = '';
        /**
         * Map config.
         */
        this.config = {};
        /**
         * Map zoom.
         */
        this.mapZoom = 0;
        /**
         * Latitude for the coordinates.
         */
        this.latitude = 0;
        /**
         * Longitude for the coordinates.
         */
        this.longitude = 0;
        /**
         * Info window should be displayed after clicking on marker.
         */
        this.enableInfoWindow = false;
        /**
         * Object to describe the map marker icon.
         */
        this.icons = {};
        /**
         * EventEmitter for triggering a update event.
         */
        this.update = new EventEmitter();
        /**
         * EventEmitter for place selection update event.
         */
        this.selected = new EventEmitter();
        /**
         * EventEmitter for triggering a locate event.
         */
        this.locate = new EventEmitter();
        /**
         * EventEmitter for triggering a mapReady event.
         */
        this.mapReady = new EventEmitter();
        this.markers = [];
    }
    set locations(locations) {
        this.places = locations;
        if (this.mapHelpers) {
            this.drawMarkers();
        }
    }
    set selectedPlaceId(id) {
        this.selectedId = id;
        if (this.mapHelpers) {
            this.drawMarkers();
        }
    }
    getInfoWindowContent(placeId) {
        const wrapperElement = this.template
            .nativeElement;
        const template = wrapperElement.querySelector(`div[data-place-id='${placeId}']`);
        return template ? template.innerHTML : '';
    }
    getDistance(bounds) {
        if (!bounds) {
            return 0;
        }
        return (google.maps.geometry.spherical.computeDistanceBetween(bounds.getNorthEast(), bounds.getSouthWest()) / 1000);
    }
    emitMapUpdate() {
        if (!this.mapHelpers) {
            return;
        }
        const center = this.mapHelpers.getCenter();
        this.update.emit({
            latitude: center.lat(),
            longitude: center.lng(),
            radius: Math.ceil(this.getDistance(this.mapHelpers.getBounds()) / 2),
        });
    }
    setCurrentLocationMarker(location) {
        if (!this.mapHelpers) {
            return;
        }
        this.mapHelpers.createMarker({
            position: location,
            clickable: false,
            icon: this.currentLocationIconOptions,
            locationId: '',
        });
    }
    markerClicklistener(marker, place) {
        const helpers = this.mapHelpers;
        if (this.enableInfoWindow) {
            if (this.infoWindow) {
                this.infoWindow.close();
            }
            const content = this.getInfoWindowContent(place.id);
            this.infoWindow = helpers.createInfoWindow({ content });
            helpers.openInfoWindow(this.infoWindow, marker);
        }
        if (this.mapHelpers) {
            if (marker.locationId === this.selectedId) {
                this.selected.emit({
                    id: '',
                    latitude: 0,
                    longitude: 0,
                });
            }
            else {
                this.selected.emit(this.places.find((location) => location.id === marker.locationId));
            }
        }
    }
    drawMarkers() {
        if (!Array.isArray(this.places)) {
            return;
        }
        // markers that are not needed anymore, should be cleared
        const placeIds = this.places.map((place) => place.id);
        const newMarkerList = [];
        this.markers.forEach((marker) => {
            if (placeIds.includes(marker.locationId)) {
                newMarkerList.push(marker);
            }
            else {
                // eslint-disable-next-line
                marker.setMap(null);
            }
        });
        this.markers = newMarkerList;
        // places markers on map
        this.places.forEach((place) => {
            let marker = this.markers.find((item) => item.locationId === place.id);
            if (marker === undefined) {
                marker = this.createMarker(place);
                this.markers.push(marker);
                marker.addListener('click', () => this.markerClicklistener(marker, place));
            }
            if (this.selectedId && placeIds.includes(this.selectedId)) {
                if (place.id === this.selectedId) {
                    marker.setOpacity(1);
                    marker.setIcon({
                        url: marker.getIcon().url,
                        scaledSize: new google.maps.Size(60, 60),
                    });
                }
                else {
                    marker.setOpacity(0.5);
                    marker.setIcon({
                        url: marker.getIcon().url,
                    });
                }
            }
            else {
                marker.setOpacity(1);
                marker.setIcon({
                    url: marker.getIcon().url,
                });
            }
        });
    }
    createMarker(place) {
        const helpers = this.mapHelpers;
        const position = {
            lat: place.latitude,
            lng: place.longitude,
        };
        // try to find place type icon or try to use fallback icon
        const defaultIcon = this.icons && Object.keys(this.icons).length
            ? this.icons[Object.keys(this.icons)[0]]
            : undefined;
        const iconUrl = place.placeType && this.icons && this.icons[place.placeType]
            ? this.icons[place.placeType]
            : defaultIcon;
        let marker = {
            position,
            locationId: place.id,
            title: $localize `:@@places.map.marker.title:map marker`,
        };
        // if there is no icon at all, use maps default pin
        if (iconUrl) {
            marker = Object.assign(Object.assign({}, marker), {
                icon: {
                    url: iconUrl,
                },
            });
        }
        return helpers.createMarker(marker);
    }
    /**
     * List of locations to be rendered.
     */
    get locations() {
        return this.places || [];
    }
    /**
     * Selected place id.
     */
    get selectedPlaceId() {
        return this.selectedId;
    }
    get options() {
        return {
            center: {
                lat: this.latitude,
                lng: this.longitude,
            },
            zoom: this.mapZoom,
            disableDefaultUI: true,
            zoomControl: true,
            styles: [
                {
                    featureType: 'poi',
                    stylers: [{ visibility: 'off' }],
                },
            ],
        };
    }
    setMapOptions(component) {
        this.mapHelpers = component.mapHelpers;
        this.mapHelpers.setMapOptions({
            mapTypeControlOptions: {
                mapTypeIds: [google.maps.MapTypeId.ROADMAP],
            },
        });
        this.mapHelpers.onMapEvent('idle', () => this.emitMapUpdate());
        this.currentLocationIconOptions = {
            path: google.maps.SymbolPath.CIRCLE,
            fillColor: '#4285F4',
            fillOpacity: 1,
            scale: 6,
            strokeColor: 'white',
            strokeWeight: 2,
        };
        if ('geolocation' in navigator) {
            const helpers = this.mapHelpers;
            navigator.geolocation.getCurrentPosition((location) => {
                const position = {
                    lat: location.coords.latitude,
                    lng: location.coords.longitude,
                };
                helpers.setCenter(position);
                this.setCurrentLocationMarker(position);
                this.locate.emit(position);
            });
        }
        // Everything set, emit that map is ready
        this.mapReady.emit();
    }
    ngOnChanges(changes) {
        if (!this.mapHelpers) {
            return;
        }
        if (changes.latitude || changes.longitude) {
            this.mapHelpers.setCenter({
                lat: changes.latitude ? changes.latitude.currentValue : this.latitude,
                lng: changes.longitude
                    ? changes.longitude.currentValue
                    : this.longitude,
            });
        }
    }
}
MapWrapperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapWrapperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
MapWrapperComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: MapWrapperComponent, selector: "bb-map-wrapper", inputs: { apiKey: "apiKey", config: "config", mapZoom: "mapZoom", latitude: "latitude", longitude: "longitude", enableInfoWindow: "enableInfoWindow", icons: "icons", locations: "locations", selectedPlaceId: "selectedPlaceId" }, outputs: { update: "update", selected: "selected", locate: "locate", mapReady: "mapReady" }, viewQueries: [{ propertyName: "template", first: true, predicate: ["bbMapInfoWindowContent"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<bb-map-ui\n  [options]=\"this.options\"\n  [config]=\"this.config\"\n  (mapReady)=\"this.setMapOptions($event)\"\n></bb-map-ui>\n\n<div hidden #bbMapInfoWindowContent>\n  <div [attr.data-place-id]=\"place.id\" *ngFor=\"let place of this.places\">\n    <p class=\"bb-text-semi-bold\">{{ place.name }}</p>\n    <div>\n      {{ place.address?.addressLine1 }}, {{ place.address?.postalCode }}\n      {{ place.address?.addressLine2 }}\n    </div>\n  </div>\n</div>\n", components: [{ type: MapComponent, selector: "bb-map-ui", inputs: ["options", "config"], outputs: ["mapReady"] }], directives: [{ type: i1$3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapWrapperComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-map-wrapper',
                    templateUrl: './map-wrapper.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], propDecorators: { apiKey: [{
                type: Input
            }], config: [{
                type: Input
            }], mapZoom: [{
                type: Input
            }], latitude: [{
                type: Input
            }], longitude: [{
                type: Input
            }], enableInfoWindow: [{
                type: Input
            }], icons: [{
                type: Input
            }], locations: [{
                type: Input
            }], selectedPlaceId: [{
                type: Input
            }], update: [{
                type: Output
            }], selected: [{
                type: Output
            }], locate: [{
                type: Output
            }], mapReady: [{
                type: Output
            }], template: [{
                type: ViewChild,
                args: ['bbMapInfoWindowContent']
            }] } });

class PlacesViewComponent {
    constructor(config, service, assetsService, cd, loader) {
        this.config = config;
        this.service = service;
        this.assetsService = assetsService;
        this.cd = cd;
        this.loader = loader;
        this.mapParamsSubject = new Subject();
        this.mapParams = this.mapParamsSubject.asObservable();
        this.selectedPlaceId = new Subject();
        this.resolveAsset = this.assetsService.createAssetsResolver({
            widgetName: 'bb-places-journey-ang',
            getURIFromAssetID: (placeType) => {
                const found = this.placeTypes.find((type) => type === placeType);
                return found
                    ? this.config.placeTypes[found].markerUrl || defaultPlaceTypeMarkerURI
                    : defaultPlaceTypeMarkerURI;
            },
        });
        this.mapConfigObject = {};
        this.locations = this.mapParams.pipe(filter((params) => params !== undefined), switchMap((params) => this.service.getPlaces(params)), map((data) => this.config.limitList ? data.slice(0, this.config.limitList) : data), catchError((error) => {
            this.handleError(error);
            return of([]);
        }));
        this.selectedView = 'list';
        this.latitude = 0;
        this.longitude = 0;
        this.radius = 1;
        this.types = [];
        this.latitude = this.config.latitude;
        this.longitude = this.config.longitude;
        this.radius = this.config.radius;
        this.limitList = this.config.limitList;
    }
    // This is required to show info window only on mobile screen
    set groupBtns(elRef) {
        this.groupBtnRef = elRef;
        setTimeout(() => {
            if (!this.groupBtnRef) {
                return;
            }
            this.smallScreen =
                window.getComputedStyle(this.groupBtnRef.nativeElement).display !==
                    'none';
        }, 0);
    }
    loadApi(mapConfig = {}) {
        this.loader.config = mapConfig;
        return this.loader.load().then(() => {
            this.geocoder = new google.maps.Geocoder();
            return;
        });
    }
    getCurrentLocation() {
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition((location) => {
                this.currentPosition = {
                    lat: location.coords.latitude,
                    lng: location.coords.longitude,
                };
                if (!this.geocoder) {
                    return;
                }
                this.geocoder.geocode({ location: this.currentPosition }, (results, status) => {
                    if (status === google.maps.GeocoderStatus.OK && results[0]) {
                        const route = results[0].address_components.filter((item) => item.types.find((type) => type === 'route'));
                        this.currentLocation =
                            route[0].long_name || results[0].formatted_address;
                    }
                });
            });
        }
    }
    handleError(error) {
        this.error = parseError(error);
    }
    get groupBtns() {
        return this.groupBtnRef;
    }
    get mapConfig() {
        return this.mapConfigObject;
    }
    get placeTypes() {
        return Object.keys(this.config.placeTypes);
    }
    get icons() {
        const types = [defaultPlaceType].concat(this.placeTypes);
        return combineLatest(types.map((type) => this.resolveAsset(type))).pipe(map((assets) => {
            const icons = {};
            for (let i = 0; i < assets.length; i++) {
                icons[types[i]] = assets[i];
            }
            return icons;
        }));
    }
    get isMetric() {
        return this.config.measurementSystem !== PlacesMeasurementSystem.METRIC;
    }
    filterTypes(values) {
        const types = [];
        Object.keys(values).forEach((key) => {
            if (values[key]) {
                types.push(key);
            }
        });
        return types;
    }
    locationUpdate(params) {
        this.latitude = params.latitude;
        this.longitude = params.longitude;
        this.radius = params.radius || this.config.radius;
        this.types = params.types || this.types;
        this.cd.detectChanges();
        this.mapParamsSubject.next(Object.assign(Object.assign({}, params), { radius: this.config.radius, types: this.types }));
    }
    handleTypeSearch(types) {
        this.locationUpdate({
            latitude: this.latitude,
            longitude: this.longitude,
            radius: this.radius,
            types,
        });
    }
    handleMapSearch(place) {
        if (!place.geometry) {
            return;
        }
        this.locationUpdate({
            latitude: place.geometry.location.lat(),
            longitude: place.geometry.location.lng(),
            radius: this.config.radius,
            types: this.types,
        });
    }
    updatePlaceSelection(place) {
        this.selectedPlaceId.next(place.id);
    }
    onMapReady() {
        // Map is there, so we don't use list limit property to determine list size. Map's zoom and radius parameter are driving it from now on
        this.limitList = undefined;
        this.locationUpdate({
            latitude: this.latitude,
            longitude: this.longitude,
            radius: this.radius,
            types: this.types,
        });
    }
    ngOnInit() {
        this.mapConfigObject = {
            apiKey: this.config.apiKey,
            libraries: ['geometry'],
        };
        this.loadApi(this.mapConfigObject).then(() => {
            this.getCurrentLocation();
        });
        this.locationUpdate({
            latitude: this.config.latitude,
            longitude: this.config.longitude,
            radius: this.config.radius,
        });
    }
}
PlacesViewComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesViewComponent, deps: [{ token: PlacesJourneyConfigService }, { token: PlacesService }, { token: i1.AssetsService }, { token: i0.ChangeDetectorRef }, { token: MapAPILoaderService }], target: i0.ɵɵFactoryTarget.Component });
PlacesViewComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: PlacesViewComponent, selector: "bb-places-view", providers: [MapAPILoaderService], viewQueries: [{ propertyName: "groupBtns", first: true, predicate: ["groupBtns"], descendants: true }], ngImport: i0, template: "<div\n  [ngClass]=\"{\n    'bb-heading-widget bb-heading-widget--de-elevated': config.deElevatedHeader\n  }\"\n>\n  <bb-header-ui\n    headingType=\"h1\"\n    [headingClasses]=\"\n      config.deElevatedHeader\n        ? 'bb-heading-widget__heading'\n        : 'bb-heading-widget__heading px-0 pb-5'\n    \"\n    heading=\"Find Branches and ATMs\"\n    i18n-heading=\"\n      Find Branches and ATMs|Heading for the Places\n      journey@@places.journey.heading.text\"\n  ></bb-header-ui>\n  <ng-content></ng-content>\n</div>\n\n<div\n  [ngClass]=\"{ 'container--drag-up container-fluid': config.deElevatedHeader }\"\n>\n  <ng-container\n    *ngTemplateOutlet=\"placesContainer; context: { places: locations | async }\"\n  ></ng-container>\n</div>\n\n<ng-template #placesContainer let-places=\"places\">\n  <div class=\"card\">\n    <div class=\"card-body\">\n      <div class=\"row\" [class.bb-stack--center]=\"this.error\">\n        <ng-container *ngIf=\"!this.error; else errorState\">\n          <div class=\"col-md-6\">\n            <bb-map-search-ui\n              [config]=\"this.mapConfig\"\n              (mapSearch)=\"this.handleMapSearch($event)\"\n            ></bb-map-search-ui>\n\n            <div\n              class=\"bb-inline-stack bb-text-support bb-block bb-block--md\"\n              *ngIf=\"this.currentLocation\"\n            >\n              <bb-icon-ui\n                name=\"my-location\"\n                class=\"bb-inline-stack__item\"\n              ></bb-icon-ui>\n              <span\n                class=\"bb-inline-stack__item\"\n                i18n=\"\n                  Current Location|current location message for\n                  places@@places.state.currentLocation\"\n                >Current Location - {{ this.currentLocation }}</span\n              >\n            </div>\n\n            <form\n              #placeTypeFilterForm=\"ngForm\"\n              class=\"bb-block bb-block--md bb-stack bb-stack--density-xl\"\n              *ngIf=\"places && places.length\"\n            >\n              <bb-input-checkbox-ui\n                *ngFor=\"let type of this.placeTypes; let i = index\"\n                ngModel\n                [name]=\"type\"\n                class=\"bb-stack__item\"\n                (change)=\"\n                  this.handleTypeSearch(\n                    this.filterTypes(placeTypeFilterForm.value)\n                  )\n                \"\n              >\n                <span i18n=\"filters|filters for types@@places.filter.types\"\n                  >{type, select, atm {ATM's} branch {Branches}}</span\n                >\n              </bb-input-checkbox-ui>\n            </form>\n\n            <div\n              class=\"bb-text-align-center bb-block bb-block--md d-md-none\"\n              #groupBtns\n            >\n              <div\n                class=\"btn-group btn-group-toggle bb-block bb-block--full-width\"\n              >\n                <button\n                  class=\"btn btn-secondary\"\n                  [ngClass]=\"{ active: this.selectedView === 'list' }\"\n                  name=\"list\"\n                  (click)=\"this.selectedView = 'list'\"\n                  i18n=\"List view button|List view @@places.toggle.view.list\"\n                >\n                  List\n                </button>\n                <button\n                  class=\"btn btn-secondary\"\n                  [ngClass]=\"{ active: this.selectedView === 'map' }\"\n                  (click)=\"this.selectedView = 'map'\"\n                  i18n=\"Map view Button|Map view @@places.toggle.view.map\"\n                >\n                  Map\n                </button>\n              </div>\n            </div>\n\n            <div [hidden]=\"this.selectedView === 'map'\" class=\"d-md-block\">\n              <div\n                class=\"bb-places-list\"\n                [ngClass]=\"\n                  places && places.length ? '' : 'bb-places-list--empty'\n                \"\n              >\n                <ng-container *ngIf=\"places; else loadingState\">\n                  <ng-container *ngIf=\"places.length; else emptyState\">\n                    <bb-places-list\n                      [radius]=\"this.config.radius\"\n                      [locations]=\"places\"\n                      [selectedPlaceId]=\"\n                        (this.selectedPlaceId | async) || undefined\n                      \"\n                      [currentPosition]=\"this.currentPosition\"\n                      [isMetric]=\"this.isMetric\"\n                      [placeTypes]=\"this.config.placeTypes\"\n                      (selected)=\"this.updatePlaceSelection($event)\"\n                    ></bb-places-list>\n                  </ng-container>\n                </ng-container>\n              </div>\n            </div>\n          </div>\n          <div\n            class=\"col-md-6 d-md-block\"\n            [hidden]=\"this.selectedView === 'list'\"\n          >\n            <bb-map-wrapper\n              [apiKey]=\"this.config.apiKey\"\n              [config]=\"this.mapConfig\"\n              [mapZoom]=\"this.config.mapZoom\"\n              [latitude]=\"this.latitude\"\n              [longitude]=\"this.longitude\"\n              [icons]=\"this.icons | async\"\n              [locations]=\"places\"\n              [enableInfoWindow]=\"!!this.smallScreen\"\n              [selectedPlaceId]=\"(this.selectedPlaceId | async) || undefined\"\n              (update)=\"this.locationUpdate($event)\"\n              (selected)=\"this.updatePlaceSelection($event)\"\n              (mapReady)=\"this.onMapReady()\"\n            ></bb-map-wrapper>\n          </div>\n        </ng-container>\n      </div>\n    </div>\n  </div>\n</ng-template>\n\n<!-- Empty List -->\n<ng-template #emptyState>\n  <bb-empty-state-ui\n    class=\"bb-text-align-center\"\n    i18n-title=\"\n      No locations found|Title of a message that is shown when there are no\n      places@@places.state.noResultsFound.title\"\n    i18n-subtitle=\"\n      We could not find any items in this area. Try moving the map or searching\n      for a city or branch|Subtitle of a message that is shown when there are no\n      places@@places.state.noResultsFound.subtitle\"\n    title=\"No Locations Found\"\n    subtitle=\"We couldn\u2019t find any branches or ATMs in this region. Try moving the map or searching for a city or branch.\"\n    iconSize=\"xxl\"\n    iconModifier=\"place\"\n  ></bb-empty-state-ui>\n</ng-template>\n\n<!-- Loading State -->\n<ng-template #loadingState>\n  <bb-loading-indicator-ui\n    i18n-text=\"\n      Loading places data|Text to display while loading\n      places@@places.state.loadingPlaces\"\n  ></bb-loading-indicator-ui>\n</ng-template>\n\n<!-- Error State -->\n<ng-template #errorState>\n  <bb-common-error-state-ui [error]=\"errorCustomTemplate\">\n    <ng-template #errorCustomTemplate>\n      <bb-empty-state-ui\n        class=\"bb-text-align-center\"\n        i18n-title=\"\n          Page couldn\u2019t load|Title of a message that is shown when page couldn't\n          load@@places.state.pageCouldnotLoad.title\"\n        i18n-subtitle=\"\n          Try to reload the page or contact the system administrator.|Subtitle\n          of a message that is shown when page could not\n          load@@places.state.pageCouldnotLoad.subtitle\"\n        title=\"Page couldn\u2019t load\"\n        subtitle=\"Try to reload the page or contact the system administrator.\"\n        iconSize=\"xxl\"\n        iconModifier=\"error\"\n      ></bb-empty-state-ui>\n    </ng-template>\n  </bb-common-error-state-ui>\n</ng-template>\n", components: [{ type: i5.HeaderComponent, selector: "bb-header-ui", inputs: ["headingClasses", "headingType", "heading"] }, { type: MapSearchComponent, selector: "bb-map-search-ui", inputs: ["options", "config"], outputs: ["mapSearch"] }, { type: i1$4.IconComponent, selector: "bb-icon-ui", inputs: ["name", "inverse", "size", "color", "animate", "aria-label", "cropped", "backgroundType"] }, { type: i8.InputCheckboxComponent, selector: "bb-input-checkbox-ui", inputs: ["indeterminate"], outputs: ["indeterminateChange"] }, { type: PlacesListComponent, selector: "bb-places-list", inputs: ["radius", "locations", "selectedPlaceId", "currentPosition", "isMetric", "placeTypes"], outputs: ["selected"] }, { type: MapWrapperComponent, selector: "bb-map-wrapper", inputs: ["apiKey", "config", "mapZoom", "latitude", "longitude", "enableInfoWindow", "icons", "locations", "selectedPlaceId"], outputs: ["update", "selected", "locate", "mapReady"] }, { type: i11.EmptyStateComponent, selector: "bb-empty-state-ui", inputs: ["title", "subtitle", "showIcon", "iconClasses", "iconModifier", "iconSize", "iconColor"] }, { type: i12.LoadingIndicatorComponent, selector: "bb-loading-indicator-ui", inputs: ["text", "loaderSize", "showDelay", "hasBackground", "inline"] }, { type: i13.ErrorCommonStateComponent, selector: "bb-common-error-state-ui", inputs: ["error"] }], directives: [{ type: i1$3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i1$3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i1$3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i15.ɵNgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])" }, { type: i15.NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]" }, { type: i15.NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: ["ngFormOptions"], outputs: ["ngSubmit"], exportAs: ["ngForm"] }, { type: i1$3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i15.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i15.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }], pipes: { "async": i1$3.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesViewComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'bb-places-view',
                    templateUrl: './places-view.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [MapAPILoaderService],
                }]
        }], ctorParameters: function () { return [{ type: PlacesJourneyConfigService }, { type: PlacesService }, { type: i1.AssetsService }, { type: i0.ChangeDetectorRef }, { type: MapAPILoaderService }]; }, propDecorators: { groupBtns: [{
                type: ViewChild,
                args: ['groupBtns']
            }] } });

class MapModule {
}
MapModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
MapModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapModule, declarations: [MapComponent, MapSearchComponent], imports: [CommonModule, SearchBoxModule, ButtonModule, IconModule], exports: [MapComponent, MapSearchComponent] });
MapModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapModule, providers: [MapAPILoaderService, MapHelpersService], imports: [[CommonModule, SearchBoxModule, ButtonModule, IconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: MapModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, SearchBoxModule, ButtonModule, IconModule],
                    declarations: [MapComponent, MapSearchComponent],
                    exports: [MapComponent, MapSearchComponent],
                    providers: [MapAPILoaderService, MapHelpersService],
                }]
        }] });

const defaultRoute = {
    path: '',
    component: PlacesJourneyComponent,
    children: [
        {
            path: '',
            component: PlacesViewComponent,
            data: { title: 'Places' },
        },
    ],
};
const components = [
    PlacesListComponent,
    MapWrapperComponent,
    PlaceDetailsComponent,
    WorkTimesComponent,
    KeyboardAccessibilityDirective,
];
const modules = [
    HeaderModule,
    EmptyStateModule,
    ErrorCommonStateModule,
    LoadingIndicatorModule,
    IconModule,
    ButtonModule,
    MapModule,
    CollapsibleModule,
    CollapsibleAccordionModule,
    InputCheckboxModule,
];
class PlacesJourneyModule {
    static forRoot(data = { route: defaultRoute }) {
        return {
            ngModule: PlacesJourneyModule,
            providers: [provideRoutes([data.route])],
        };
    }
}
PlacesJourneyModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
PlacesJourneyModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyModule, declarations: [PlacesJourneyComponent, PlacesViewComponent, PlacesListComponent,
        MapWrapperComponent,
        PlaceDetailsComponent,
        WorkTimesComponent,
        KeyboardAccessibilityDirective], imports: [CommonModule,
        FormsModule, i1.BackbaseCoreModule, RouterModule, HeaderModule,
        EmptyStateModule,
        ErrorCommonStateModule,
        LoadingIndicatorModule,
        IconModule,
        ButtonModule,
        MapModule,
        CollapsibleModule,
        CollapsibleAccordionModule,
        InputCheckboxModule] });
PlacesJourneyModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyModule, providers: [PlacesService], imports: [[
            CommonModule,
            FormsModule,
            BackbaseCoreModule.withConfig({
                classMap: { PlacesJourneyComponent },
            }),
            RouterModule,
            ...modules,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: PlacesJourneyModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [PlacesJourneyComponent, PlacesViewComponent, ...components],
                    imports: [
                        CommonModule,
                        FormsModule,
                        BackbaseCoreModule.withConfig({
                            classMap: { PlacesJourneyComponent },
                        }),
                        RouterModule,
                        ...modules,
                    ],
                    providers: [PlacesService],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { PlacesJourneyComponent, PlacesJourneyConfigService, PlacesJourneyConfigurationToken, PlacesJourneyModule, PlacesMeasurementSystem, PlacesService, PlacesViewComponent };
//# sourceMappingURL=backbase-places-journey-ang.js.map
