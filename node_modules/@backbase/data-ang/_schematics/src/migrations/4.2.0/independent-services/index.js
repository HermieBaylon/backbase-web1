"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const ts_morph_1 = require("ts-morph");
const http_client_services_map_1 = require("./http-client-services-map");
const find_module_1 = require("@schematics/angular/utility/find-module");
const path_1 = require("path");
const utils_1 = require("../../../utils");
const base_paths_map_1 = require("./base-paths-map");
/**
 * - add http clients to the dependencies of the package and remove from peer dependencies
 */
function default_1() {
    return (tree, _context) => __awaiter(this, void 0, void 0, function* () {
        const projects = utils_1.getLibInfo(tree);
        const astProject = new ts_morph_1.Project({
            manipulationSettings: {
                indentationText: ts_morph_1.IndentationText.TwoSpaces,
                quoteKind: ts_morph_1.QuoteKind.Single,
            },
        });
        const projectPackageJson = utils_1.parseJsonFile(tree, 'package.json');
        // Populate libraries information with an NPM package name
        projects.forEach((project) => {
            if (!project.sourceRoot)
                return;
            const libPath = path_1.normalize(project.root);
            try {
                project.packageName = utils_1.parseJsonFile(tree, path_1.join(libPath, 'package.json')).name;
            }
            catch (e) {
                console.warn(`Couldn't find package.json in ${libPath}. Skipping the project...`);
            }
        });
        const journeys = [];
        // Make list of journeys and their dependencies
        projects.forEach((project) => {
            if (!project.sourceRoot || !project.isLibrary || !project.packageName)
                return;
            if (isJourney(tree, astProject, project)) {
                const journeyImports = collectAllImports(tree, astProject, project).map(([libName, _imports]) => libName);
                const importedProjects = projects.filter((proj) => proj.packageName && journeyImports.includes(proj.packageName));
                journeys.push({
                    project,
                    // We want to be scanning not only journey dependencies, but also journey itself
                    librariesToScan: [project, ...importedProjects],
                });
            }
        });
        journeys.forEach((journey) => {
            console.log(`Processing ${journey.project.packageName} journey...`);
            // Collect all imported HTTP-client services from all local deps and the journey itself
            const importedServices = new Map();
            journey.librariesToScan.forEach((project) => {
                const rawImports = collectAllImports(tree, astProject, project)
                    .filter(isHttpClientImport)
                    .map(toServicesOnlyImport)
                    .filter(([_library, imports]) => imports && imports.length);
                rawImports.forEach(([libName, imports]) => {
                    if (importedServices.has(libName)) {
                        const uniqueImports = new Set([...importedServices.get(libName), ...imports]);
                        importedServices.set(libName, [...uniqueImports]);
                    }
                    else {
                        importedServices.set(libName, imports);
                    }
                });
            });
            if (importedServices.size > 0) {
                // Add all imported HTTP-client services to the journey providers
                updateJourneyModuleProviders(tree, astProject, journey.project, importedServices);
                // Add reexporting BASE_PATHS from the journey (to prevent lazy loading issues)
                reExportBasePathFromJourney(tree, astProject, journey.project, importedServices);
                const requiredLibs = Array.from(importedServices.keys());
                // Make sure required HTTP-clients are included in the journey dependencies
                console.log(`Making sure ${requiredLibs.join(', ')} are in the dependencies of the ${journey.project.packageName}`);
                updateLibPackageJson(tree, requiredLibs, journey.project, projectPackageJson);
                // Make sure allowedDependencies of a package are updated, so build will pass
                updateLibNgPackageJson(tree, requiredLibs, journey.project.root);
            }
        });
    });
}
exports.default = default_1;
function reExportBasePathFromJourney(tree, astProject, project, importsMap) {
    var _a;
    try {
        const publicAPIFilePath = path_1.join(path_1.normalize(project.sourceRoot), project.isNx ? 'index.ts' : 'public_api.ts');
        const publicAPIFIle = astProject.createSourceFile(publicAPIFilePath, ((_a = tree.read(publicAPIFilePath)) === null || _a === void 0 ? void 0 : _a.toString('utf-8')) || '', { overwrite: true });
        importsMap.forEach((_imports, moduleSpecifier) => {
            if (base_paths_map_1.BASE_PATH_MAP.has(moduleSpecifier)) {
                const basePath = base_paths_map_1.BASE_PATH_MAP.get(moduleSpecifier);
                console.log(`Adding ${basePath} export to ${publicAPIFilePath}`);
                publicAPIFIle.addExportDeclaration({
                    namedExports: [`${basePath} as ${createBasePathPrefix(basePath, project.packageName)}`],
                    moduleSpecifier,
                });
            }
        });
        tree.overwrite(publicAPIFilePath, publicAPIFIle.getText());
    }
    catch (e) {
        console.error(`Unable to find public API declarations file in ${project.sourceRoot}...`, 'Skipping...');
        console.error(e);
    }
}
function isJourney(tree, astProject, project) {
    var _a;
    const rootModulePath = findJourneyModule(tree, project);
    try {
        const moduleFile = astProject.createSourceFile(rootModulePath, ((_a = tree.read(rootModulePath)) === null || _a === void 0 ? void 0 : _a.toString('utf-8')) || '', {
            overwrite: true,
        });
        // assuming each journey has to have a static forRoot function in it
        const forRootFunction = moduleFile.getClasses().pop().getStaticMemberOrThrow('forRoot');
        return !!forRootFunction;
    }
    catch (e) {
        return false;
    }
}
function updateJourneyModuleProviders(tree, astProject, project, importsMap) {
    var _a;
    const rootModulePath = findJourneyModule(tree, project);
    try {
        const moduleFile = astProject.createSourceFile(rootModulePath, ((_a = tree.read(rootModulePath)) === null || _a === void 0 ? void 0 : _a.toString('utf-8')) || '', {
            overwrite: true,
        });
        const moduleName = moduleFile
            .getClasses()
            .map((classDecl) => classDecl.getName())
            .filter((name) => name.toLowerCase().endsWith('module'))
            .pop();
        addImportAliaces(importsMap).forEach((imports, libName) => {
            console.log(`Adding providers from ${libName} to the ${moduleName}.`);
            addNamedImportDeclaration(moduleFile, imports, libName);
            addProvider(moduleFile, imports, moduleName);
        });
        tree.overwrite(rootModulePath, moduleFile.getText());
    }
    catch (e) {
        console.error(`Unable to handle angular module in ${project.sourceRoot}...`, 'Skipping...');
        console.error(e);
    }
}
function findJourneyModule(tree, project) {
    // Assuming there is a root level module
    let rootModulePath;
    const rootPath = path_1.normalize(project.sourceRoot);
    const moduleFilePath = path_1.join(rootPath, 'lib');
    try {
        rootModulePath = find_module_1.findModule(tree, moduleFilePath, find_module_1.MODULE_EXT);
    }
    catch (_a) { }
    if (rootModulePath) {
        return rootModulePath;
    }
    try {
        rootModulePath = find_module_1.findModule(tree, moduleFilePath, find_module_1.MODULE_EXT);
    }
    catch (_b) {
        console.warn(`Unable to find the main library module for ${project.packageName} in ${moduleFilePath} or ${rootPath}. Skipping...`);
    }
    return rootModulePath;
}
function addImportAliaces(rawImports) {
    const aliacedImports = new Map();
    const allImports = [];
    for (const libName of rawImports.keys()) {
        const libraryImports = rawImports.get(libName);
        const libraryImportsWithAliaces = libraryImports.map((importedItem) => allImports.includes(importedItem)
            ? { importedItem: importedItem, alias: createServicePrefix(importedItem, libName) }
            : { importedItem });
        allImports.push(...libraryImports);
        aliacedImports.set(libName, libraryImportsWithAliaces);
    }
    return aliacedImports;
}
function createServicePrefix(namedImport, specifier) {
    const prefix = specifier.replace('@backbase/', '').replace('http-ang', '').replace('-ang', '');
    return core_1.strings.classify(`${prefix} ${namedImport}`);
}
function createBasePathPrefix(namedImport, specifier) {
    const prefix = specifier.replace('@backbase/', '').replace('-journey-ang', '-journey').replace('-ang', '');
    return core_1.strings.underscore(`${prefix}-${namedImport}`).toUpperCase();
}
function addProvider(moduleFile, importStatements, moduleName) {
    const existingProviders = getModuleProviders(moduleFile, moduleName);
    importStatements.forEach((namedImport) => existingProviders.addElement(namedImport.alias ? namedImport.alias : namedImport.importedItem));
}
function getModuleProviders(moduleFile, moduleName) {
    const decoratorArguments = moduleFile
        .getClassOrThrow(moduleName)
        .getDecoratorOrThrow('NgModule')
        .getArguments()
        .pop();
    if (!ts_morph_1.Node.isObjectLiteralExpression(decoratorArguments)) {
        throw new Error(`Arguments of the ${moduleName} NgModule Decorator should be an object literal`);
    }
    let providers = decoratorArguments.getProperty('providers');
    if (!providers || !ts_morph_1.Node.isPropertyAssignment(providers)) {
        decoratorArguments.addProperty('providers: [],');
        providers = decoratorArguments.getProperty('providers');
    }
    return providers.getInitializerIfKindOrThrow(ts_morph_1.SyntaxKind.ArrayLiteralExpression);
}
function addNamedImportDeclaration(sourceFile, importStatements, libName) {
    const declaration = sourceFile.getImportDeclaration((i) => i.getModuleSpecifierValue() === libName);
    const imports = importStatements.map((statement) => statement.alias ? `${statement.importedItem} as ${statement.alias}` : statement.importedItem);
    if (declaration) {
        declaration.addNamedImports(imports);
    }
    else {
        sourceFile.addImportDeclaration({
            namedImports: imports,
            moduleSpecifier: libName,
        });
    }
}
function isHttpClientImport([moduleSpecifier, _imports]) {
    return http_client_services_map_1.HTTP_CLIENT_SERVICES_MAP.has(moduleSpecifier);
}
function toServicesOnlyImport([moduleSpecifier, imports]) {
    return [
        moduleSpecifier,
        imports.filter((importedItem) => http_client_services_map_1.HTTP_CLIENT_SERVICES_MAP.get(moduleSpecifier).includes(importedItem)),
    ];
}
function collectAllImports(tree, astProject, project) {
    let libraryImports = [];
    tree.getDir(project.sourceRoot).visit((path) => {
        var _a;
        if (!path.endsWith('.ts'))
            return;
        const file = astProject.createSourceFile(path, ((_a = tree.read(path)) === null || _a === void 0 ? void 0 : _a.toString('utf-8')) || '', { overwrite: true });
        const fileImports = file.getImportDeclarations().map(toImportDeclaration);
        libraryImports = [...libraryImports, ...fileImports];
    });
    return libraryImports;
}
function toImportDeclaration(importStatement) {
    return [
        importStatement.getModuleSpecifier().getText().split("'").join(''),
        importStatement.getNamedImports().map((importSpecifier) => importSpecifier.getName()),
    ];
}
function updateLibPackageJson(tree, requiredLibs, project, packageJsonContent) {
    if (!project.root) {
        return;
    }
    const packageJsonPath = path_1.join(path_1.normalize(project.root), 'package.json');
    if (!tree.exists(packageJsonPath)) {
        return;
    }
    const packageJson = utils_1.parseJsonFile(tree, packageJsonPath);
    const peerDependencies = (packageJson.peerDependencies || (packageJson.peerDependencies = {}));
    const dependencies = (packageJson.dependencies || (packageJson.dependencies = {}));
    const requiredDependencies = requiredLibs.reduce((acc, libraryName) => {
        acc = Object.assign(Object.assign({}, acc), { [libraryName]: utils_1.getDataModuleVersion(libraryName, packageJsonContent) });
        delete peerDependencies[libraryName];
        return acc;
    }, {});
    if (!requiredDependencies || !Object.keys(requiredDependencies).length) {
        return;
    }
    packageJson.dependencies = Object.assign(Object.assign({}, dependencies), requiredDependencies);
    packageJson.peerDependencies = Object.assign({}, peerDependencies);
    tree.overwrite(packageJsonPath, JSON.stringify(packageJson, undefined, 2));
}
function updateLibNgPackageJson(tree, requiredLibs, libRoot) {
    if (!libRoot) {
        return;
    }
    const ngPackageJsonPath = path_1.join(path_1.normalize(libRoot), 'ng-package.json');
    if (!tree.exists(ngPackageJsonPath)) {
        return;
    }
    const ngPackageJson = utils_1.parseJsonFile(tree, ngPackageJsonPath);
    ngPackageJson.allowedNonPeerDependencies = [...(ngPackageJson.allowedNonPeerDependencies || []), ...requiredLibs];
    tree.overwrite(ngPackageJsonPath, JSON.stringify(ngPackageJson, undefined, 2));
}
