import { __rest } from "tslib";
import { Injectable } from '@angular/core';
import { ContactHttpService } from './contact-http.service';
import { BehaviorSubject, merge, of, ReplaySubject, Subject } from 'rxjs';
import { filter, finalize, map, mapTo, mergeMap, scan, shareReplay, switchMap, takeUntil } from 'rxjs/operators';
import { ContactActions, LoadMoreMethod, } from '../models/types';
import * as i0 from "@angular/core";
import * as i1 from "./contact-http.service";
export const ContactsServiceConfigDefaults = {
    pageSize: 50,
};
/**
 * Service calls the APIs for all the actions done by the user.
 * This service Injects ContactHttpService
 *
 * @see ContactHttpService
 * @usageNotes
 *
 *
 * ```ts
 * @NgModule({
 *   ...
 *   providers: [
 *     ...
 *     ContactService,
 *   ],
 * })
 * export class MyContactCommonAngModule {}
 * ```
 *
 * ### Inject this service into your component
 *
 * ```ts
 * @Component({
 *   ...
 *   providers: [ContactService],
 * })
 *  export class ContactCommonAngComponent {
 * ```
 */
export class ContactService {
    constructor(contactHttpService) {
        this.contactHttpService = contactHttpService;
        this.destroy$ = new Subject();
        this.changePage$ = new Subject();
        this.loadMore$ = new Subject();
        this.load$ = new Subject();
        this.refresh$ = new Subject();
        this.search$ = new Subject();
        this.sort$ = new Subject();
        this.config$ = new BehaviorSubject(ContactsServiceConfigDefaults);
        this.id$$ = new ReplaySubject(1);
        this.subscriptions = [];
        this.contact$ = this.id$$.pipe(switchMap((id) => {
            if (!id) {
                return of(undefined);
            }
            return this.contactHttpService.getContact(id);
        }));
        this.loading$$ = new ReplaySubject(1);
        this.loading$ = this.loading$$.asObservable();
        this.acting$$ = new ReplaySubject(1);
        this.acting$ = this.acting$$.asObservable();
        this.pageSize$ = this.config$.pipe(map((config) => config.pageSize));
        this.actions$ = merge(this.load$.pipe(mapTo({ action: ContactActions.Load })), this.search$.pipe(map(({ query, from }) => ({ action: ContactActions.Search, query, from }))), this.refresh$.pipe(map((loadMoreMethod) => ({ action: ContactActions.Refresh, loadMoreMethod }))), this.changePage$.pipe(map((from) => ({ action: ContactActions.ChangePage, from }))), this.loadMore$.pipe(map((from) => ({ action: ContactActions.LoadMore, from }))), this.pageSize$.pipe(map((pageSize) => ({ pageSize }))), this.sort$.pipe(map(({ sort, direction }) => ({ action: ContactActions.Sort, sort, direction }))));
        this.state$ = this.actions$.pipe(scan((state, action) => (Object.assign(Object.assign({}, state), action))), map((_a) => {
            var { pageSize, loadMoreMethod, query } = _a, state = __rest(_a, ["pageSize", "loadMoreMethod", "query"]);
            const isRefresh = state.action === ContactActions.Refresh;
            const size = pageSize || ContactsServiceConfigDefaults.pageSize;
            const from = state.from || 0;
            return Object.assign(Object.assign({}, state), { query: query || '', size: isRefresh && loadMoreMethod === LoadMoreMethod.LOAD_MORE ? size * (from + 1) : size, from: isRefresh && loadMoreMethod === LoadMoreMethod.LOAD_MORE ? 0 : from });
        }), filter((state) => state.action !== undefined), shareReplay(1));
        this.effects$ = this.state$.pipe(mergeMap((_a) => {
            var { action } = _a, parameters = __rest(_a, ["action"]);
            this.loading = true;
            const isLoadMore = action === ContactActions.LoadMore;
            return this.contactHttpService.getContacts(this.removeEmptyParameters(parameters)).pipe(map((response) => (Object.assign(Object.assign({}, response), { isLoadMore }))), finalize(() => (this.loading = false)));
        }), takeUntil(this.destroy$), shareReplay(1));
        this.contactsSource$ = new BehaviorSubject(undefined);
    }
    set loading(val) {
        this.loading$$.next(val);
    }
    set acting(val) {
        this.acting$$.next(val);
    }
    get contacts$() {
        return this.contactsSource$.asObservable();
    }
    removeEmptyParameters(parameters) {
        return Object.entries(parameters)
            .filter(([key, value]) => value !== '')
            .reduce((prev, curr) => (Object.assign(Object.assign({}, prev), { [curr[0]]: curr[1] })), {});
    }
    /**
     * Sets the Subject with updated contactService config.
     *
     * @param {ContactsServiceConfig} config - new config for Contact Service
     */
    init(config) {
        this.config$.next(config);
    }
    /**
     *  Updates the subject with value
     */
    load() {
        this.load$.next();
    }
    /**
     * Updates the loadMore Subject with pageFrom value.
     *
     * @param {number} from - page From the data has to be fetched.
     */
    loadMore(from) {
        this.loadMore$.next(from);
    }
    /**
     * Updates the changePage subject to updated page.
     *
     * @param {number} from - page From the data has to be fetched.
     */
    changePage(from) {
        this.changePage$.next(from);
    }
    /**
     * Triggers the refresh listener with current load more.
     *
     * @param {LoadMoreMethod} loadMoreMethod - Current LoadMore method can be pagination / load-more
     */
    refresh(loadMoreMethod) {
        this.refresh$.next(loadMoreMethod);
    }
    /**
     * Triggers search Listner with search query.
     *
     * @param {string} query - search text entered by the user.
     */
    searchContacts(query) {
        this.search$.next({ query, from: 0 });
    }
    /**
     * Triggers sort Listner with mapped event.
     *
     * @param {string} sortEvent - table sort event.
     */
    sortApprovals(sortEvent) {
        const castedDirection = sortEvent.direction.toUpperCase();
        const mappedEvent = { sort: sortEvent.column, direction: castedDirection };
        this.sort$.next(mappedEvent);
    }
    /**
     * Subscribes to the contact of a given contact ID.
     *
     * @param {Observable<string | null>} id Observable of Contact ID.
     * @returns {Observable<ContactItem | undefined>} of contact Details with that ID.
     */
    getContactFrom(id) {
        this.subscriptions.push(id.subscribe(this.id$$));
        return this.contact$;
    }
    /**
     * Returns the details for a given ID.
     *
     * @param {string} id contact ID
     * @returns {Observable<ContactItem | undefined>} Observable of contact Details for given ID.
     */
    getContactById(id) {
        return this.contactHttpService.getContact(id);
    }
    /**
     * Calls the delete API for specific ID
     *
     * @param {string} contactId Contact ID
     * @returns {Observable<ApprovalRequired>} observable of a result
     */
    deleteContact(contactId) {
        this.acting = true;
        return this.contactHttpService.deleteContact(contactId).pipe(finalize(() => (this.acting = false)));
    }
    /**
     *
     * @param {ContactItem} contact contact item object
     * @returns {Observable<ApprovalRequired>} response of a contact update
     */
    updateContact(contact) {
        this.acting = true;
        return this.contactHttpService.updateContact(contact).pipe(finalize(() => (this.acting = false)));
    }
    /**
     * Calls the API for approval
     *
     * @param {string} approvalId - approval ID
     * @param {string?} comment explanation of request approval
     * @returns {Observable<string>} response of a contact edit approval
     */
    approveContact(approvalId, comment) {
        this.acting = true;
        return this.contactHttpService.approveContact(approvalId, comment).pipe(finalize(() => (this.acting = false)));
    }
    /**
     * Calls the API for rejction
     *
     * @param {string} approvalId approval ID
     * @param {string?} comment explanation of request rejection
     * @returns {Observable<string>} response of an approval rejection
     */
    rejectContact(approvalId, comment) {
        this.acting = true;
        return this.contactHttpService.rejectContact(approvalId, comment).pipe(finalize(() => (this.acting = false)));
    }
    ngOnDestroy() {
        this.subscriptions.forEach((subscription) => subscription.unsubscribe());
        this.destroy$.complete();
        this.loadMore$.complete();
        this.changePage$.complete();
        this.refresh$.complete();
    }
}
/** @nocollapse */ ContactService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ContactService, deps: [{ token: i1.ContactHttpService }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ ContactService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ContactService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: ContactService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.ContactHttpService }]; } });
//# sourceMappingURL=contact.service.js.map